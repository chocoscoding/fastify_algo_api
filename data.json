[
  {
    "name": "1-two-sum",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n * @param {number} target\r\n * @return {number[]}\r\n */\r\nconst twoSum = function(nums, target) {\r\n  const myObject = {};\r\n  for (let i = 0; i < nums.length; i++) {\r\n    const complement = target - nums[i];\r\n    if (myObject.hasOwnProperty(complement)) {\r\n      return [myObject[complement], i];\r\n    }\r\n    myObject[nums[i]] = i;\r\n  }\r\n};\r\n"
    }
  },
  {
    "name": "10-regular-expression-matching",
    "code": {
      "JS": "/**\r\n * @param {string} s\r\n * @param {string} p\r\n * @return {boolean}\r\n */\r\nconst isMatch = function(s, p) {\r\n  let memory = new Array(s.length + 1)\r\n    .fill(0)\r\n    .map(e => new Array(p.length + 1).fill(-1));\r\n  return memorySearch(s, 0, p, 0, memory);\r\n};\r\n\r\nconst memorySearch = (s, i, p, k, memory) => {\r\n  if (memory[i][k] != -1) return memory[i][k];\r\n  if (k == p.length) return i == s.length;\r\n\r\n  let firstMatch = i < s.length && (s[i] == p[k] || p[k] == \".\");\r\n  if (k + 1 < p.length && p[k + 1] == \"*\") {\r\n    memory[i][k] =\r\n      (firstMatch && memorySearch(s, i + 1, p, k, memory)) ||\r\n      memorySearch(s, i, p, k + 2, memory);\r\n  } else {\r\n    memory[i][k] = firstMatch && memorySearch(s, i + 1, p, k + 1, memory);\r\n  }\r\n  return memory[i][k];\r\n};\r\n"
    }
  },
  {
    "name": "100-same-tree",
    "code": {
      "JS": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {boolean}\r\n */\r\nconst isSameTree = function(p, q) {\r\n  if(p == null && q == null) return true\r\n  if(p == null || q == null || p.val !== q.val) return false\r\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {boolean}\r\n */\r\nconst isSameTree = function(p, q) {\r\n  if(p == null || q == null) return p === q\r\n  if(p.val !== q.val) return false\r\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\r\n};\r\n"
    }
  },
  {
    "name": "1000-minimum-cost-to-merge-stones",
    "code": {
      "JS": "/**\n * @param {number[]} stones\n * @param {number} K\n * @return {number}\n */\nconst mergeStones = function(stones, K) {\n  const KMO = K - 1\n  const N = stones.length\n  if ((N - 1) % KMO !== 0) return -1\n  const sum = [0]\n  const dp = stones.map(s => stones.map(s1 => 0))\n  stones.forEach(s => {\n    sum.push(sum[sum.length - 1] + s)\n  })\n  for (let e = KMO; e < N; e++) {\n    for (let b = e - KMO; b >= 0; b--) {\n      for (let split = e - 1; split >= b; split -= KMO) {\n        let cost = dp[b][split] + dp[split + 1][e]\n        dp[b][e] = dp[b][e] === 0 ? cost : Math.min(dp[b][e], cost)\n      }\n      if ((e - b) % KMO === 0) {\n        dp[b][e] += sum[e + 1] - sum[b]\n      }\n    }\n  }\n  return dp[0][N - 1]\n}\n"
    }
  },
  {
    "name": "1001-grid-illumination",
    "code": {
      "JS": "/**\n * @param {number} N\n * @param {number[][]} lamps\n * @param {number[][]} queries\n * @return {number[]}\n */\nconst gridIllumination = function (N, lamps, queries) {\n  const rowMap = new Map()\n  const colMap = new Map()\n  const hillMap = new Map()\n  const daleMap = new Map()\n  const litMap = new Map()\n  const direction = [\n    [0, 0],\n    [0, 1],\n    [1, 0],\n    [-1, 0],\n    [0, -1],\n    [-1, -1],\n    [1, 1],\n  ]\n  //map what areas are lit\n  for (let [x, y] of lamps) {\n    insert(rowMap, x)\n    insert(colMap, y)\n    insert(hillMap, x + y)\n    insert(daleMap, x - y)\n    litMap.set(N * x + y, true)\n  }\n  const result = new Array(queries.length).fill(0)\n  let count = 0\n  for (let [x, y] of queries) {\n    if (\n      rowMap.get(x) > 0 ||\n      colMap.get(y) > 0 ||\n      hillMap.get(x + y) > 0 ||\n      daleMap.get(x - y) > 0\n    ) {\n      result[count] = 1\n    }\n    for (let [i, j] of direction) {\n      let newX = x + i\n      let newY = y + j\n      if (litMap.has(N * newX + newY)) {\n        decrease(rowMap, newX)\n        decrease(colMap, newY)\n        decrease(hillMap, newX + newY)\n        decrease(daleMap, N * newX + newY)\n        litMap.delete(N * newX + newY)\n      }\n    }\n    count++\n  }\n  return result\n}\nconst insert = (map, value) => {\n  if (map.has(value)) {\n    map.set(value, map.get(value) + 1)\n  } else {\n    map.set(value, 1)\n  }\n}\nconst decrease = (map, value) => {\n  if (map.has(value)) {\n    map.set(value, map.get(value) - 1)\n  }\n}\n"
    }
  },
  {
    "name": "1002-find-common-characters",
    "code": {
      "JS": "/**\n * @param {string[]} A\n * @return {string[]}\n */\nconst commonChars = function(A) {\n    const minArr = minEl(A)\n    const res = []\n    for(let i = 0; i < minArr[1]; i++) {\n      let target = A[minArr[0]][i]\n      let all = true\n      for(let j = 0; j < A.length; j++) {\n        if(j === minArr[0]) continue\n        if(all === false) continue\n        let idx\n        if( (idx = A[j].indexOf(target)) === -1) {\n           all = false\n        } else {\n          A[j] = A[j].slice(0, idx) + A[j].slice(idx + 1)\n        }\n      }\n      if(all) res.push(target)\n    }\n        \n    return res\n};\n\nfunction minEl(arr) {\n  const res = [0, Number.MAX_SAFE_INTEGER] // [idx, len]\n  for(let i = 0; i < arr.length; i++) {\n    if(arr[i].length < res[1]) {\n       res[0] = i\n       res[1] = arr[i].length\n    }\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "1004-max-consecutive-ones-iii",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @param {number} K\n * @return {number}\n */\nconst longestOnes = function (A, K) {\n  let i = 0\n  let j = 0\n  const len = A.length\n  while (j < len) {\n    if (A[j] === 0) K--\n    if (K < 0) {\n      if (A[i] === 0) K++\n      i++\n    }\n    j++\n  }\n  return j - i\n}\n"
    }
  },
  {
    "name": "1005-maximize-sum-of-array-after-k-negations",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @param {number} K\n * @return {number}\n */\nconst largestSumAfterKNegations = function(A, K) {\n  if (A.length === 0) return 0;\n  A.sort((a, b) => a - b);\n  let res = 0;\n  let posIdx;\n  for (let i = 0, num = 0; i < A.length; i++) {\n    if (num < K) {\n      if (A[i] < 0) {\n        A[i] = -A[i];\n      } else {\n        if (posIdx == null) {\n          posIdx = Math.abs(A[i]) - Math.abs(A[i - 1]) > 0 ? i - 1 : i;\n        }\n        A[posIdx] = -A[posIdx];\n      }\n      num++;\n    }\n  }\n  res = A.reduce((ac, el) => ac + el, 0);\n  return res;\n};\n"
    }
  },
  {
    "name": "1006-clumsy-factorial",
    "code": {
      "JS": "/**\n * @param {number} N\n * @return {number}\n */\nconst clumsy = function(N) {\n  const ops = [\"*\", \"/\", \"+\", \"-\"];\n  const arr = [];\n  arr.push(N);\n  for (let i = N - 1, idx = 0; i > 0; i--, idx++) {\n    let op = ops[idx % 4];\n    let arrIdx = arr.length - 1 < 0 ? 0 : arr.length - 1;\n    switch (op) {\n      case \"*\":\n        arr[arrIdx] *= i;\n        break;\n      case \"/\":\n        arr[arrIdx] = Math.floor(arr[arrIdx] / i);\n        break;\n      case \"+\":\n        arr[0] += i;\n        break;\n      case \"-\":\n        arr.push(i);\n        break;\n    }\n  }\n\n  let res = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    res -= arr[i];\n  }\n  return res;\n};\n"
    }
  },
  {
    "name": "1008-construct-binary-search-tree-from-preorder-traversal",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {number[]} preorder\n * @return {TreeNode}\n */\nconst bstFromPreorder = function(preorder) {\n  let i = 0;\n  return bstFromPreorder(preorder, Number.MAX_VALUE);\n  function bstFromPreorder(A, bound) {\n    if (i === A.length || A[i] > bound) return null;\n    let root = new TreeNode(A[i++]);\n    root.left = bstFromPreorder(A, root.val);\n    root.right = bstFromPreorder(A, bound);\n    return root;\n  }\n};\n"
    }
  },
  {
    "name": "1009-complement-of-base-10-integer",
    "code": {
      "JS": "/**\n * @param {number} N\n * @return {number}\n */\nconst bitwiseComplement = function (N) {\n  if (N === 0) return 1\n  // bitmask has the same length as N and contains only ones 1...1\n  let bitmask = N\n  bitmask |= bitmask >> 1\n  bitmask |= bitmask >> 2\n  bitmask |= bitmask >> 4\n  bitmask |= bitmask >> 8\n  bitmask |= bitmask >> 16\n  // flip all bits\n  return bitmask ^ N\n}\n\n// another\n\n/**\n * @param {number} N\n * @return {number}\n */\nconst bitwiseComplement = function (N) {\n  let X = 1;\n  while (N > X) X = X * 2 + 1;\n  return N ^ X;\n}\n\n// another\n\n/**\n * @param {number} N\n * @return {number}\n */\nconst bitwiseComplement = function (N) {\n  if (N === 0) return 1\n  // l is a length of N in binary representation\n  const l = Math.floor(Math.log(N) / Math.log(2)) + 1\n  // bitmask has the same length as num and contains only ones 1...1\n  const bitmask = (1 << l) - 1\n  // flip all bits\n  return bitmask ^ N\n}\n"
    }
  },
  {
    "name": "101-symmetric-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nconst isSymmetric = function(root) {\n    if(root == null) return true\n    return compare(root.left, root.right)\n};\n\nfunction compare(l, r) {\n    if(l == null && r == null) return true\n    if( (l == null && r != null) || (l != null && r == null) ) return false\n    \n    if(l.val === r.val) {\n        if(compare(l.left, r.right) !== false && compare(l.right, r.left) !== false) {\n           return true\n         } else {\n             return false\n         }\n        \n    } else {\n        return false\n    }\n}\n"
    }
  },
  {
    "name": "1011-capacity-to-ship-packages-within-d-days",
    "code": {
      "JS": "/**\n * @param {number[]} weights\n * @param {number} days\n * @return {number}\n */\nconst shipWithinDays = function(weights, days) {\n  let l = Math.max(...weights)\n  let r = weights.reduce((ac, e) => ac + e, 0)\n  while(l < r) {\n     const mid = Math.floor((l + r) / 2)\n     if(valid(mid)) {\n       r = mid\n     } else l = mid + 1\n  }\n  \n  return l\n  \n  function valid(mid) {\n    let res = 1, cur = 0\n    for(let w of weights) {\n      if(cur + w > mid) {\n        cur = 0\n        res++\n      }\n      cur += w\n    }\n    return res <= days\n  }\n};\n"
    }
  },
  {
    "name": "1012-complement-of-base-10-integer",
    "code": {
      "JS": "/**\n * @param {number} N\n * @return {number}\n */\nconst bitwiseComplement = function(N) {\n    let binStr = bin(N)\n    let str = ''\n    for(let i = 0; i < binStr.length; i++) {\n      str += binStr[i] === '0' ? '1' : '0'\n    }\n    return parseInt(str, 2)\n};\n\nfunction bin(N) {\n  return (N >>> 0).toString(2)\n}\n"
    }
  },
  {
    "name": "1013-pairs-of-songs-with-total-durations-divisible-by-60",
    "code": {
      "JS": "/**\n * @param {number[]} time\n * @return {number}\n */\nconst numPairsDivisibleBy60 = function(time) {\n  const count = new Map();\n  let n = 0;\n  for (let t of time) {\n    // two sum like method\n    let d = (60 - t % 60) % 60;\n    if (count.has(d)) { n += count.get(d); }\n    count.set(t % 60, 1 + (count.get(t % 60) || 0));\n  }\n  return n;\n};\n"
    }
  },
  {
    "name": "1014-capacity-to-ship-packages-within-d-days",
    "code": {
      "JS": "/**\n * @param {number[]} weights\n * @param {number} D\n * @return {number}\n */\nconst shipWithinDays = function(weights, D) {\n  let left = 0, right = 0;\n  for (let w of weights) {\n    left = Math.max(left, w);\n    right += w;\n  }\n  while (left < right) {\n    let mid = Math.floor((left + right) / 2), need = 1, cur = 0;\n    for (let w of weights) {\n      if (cur + w > mid) {\n        need += 1;\n        cur = 0;\n      }\n      cur += w;\n    }\n    if (need > D) left = mid + 1;\n    else right = mid;\n  }\n  return left;\n}\n"
    }
  },
  {
    "name": "1015-numbers-with-repeated-digits",
    "code": {
      "JS": "/**\n * @param {number} N\n * @return {number}\n */\nconst numDupDigitsAtMostN = function(N) {\n  const L = [];\n  for (let x = N + 1; x > 0; x = Math.floor(x / 10)) L.unshift(x % 10);\n\n  // Count the number with digits < N\n  let res = 0,\n    n = L.length;\n  for (let i = 1; i < n; ++i) res += 9 * A(9, i - 1);\n\n  const seen = new Set();\n  for (let i = 0; i < n; ++i) {\n    for (let j = i > 0 ? 0 : 1; j < L[i]; ++j)\n      if (!seen.has(j)) res += A(9 - i, n - i - 1);\n    if (seen.has(L[i])) break;\n    seen.add(L[i]);\n  }\n  return N - res;\n};\n\nfunction A(m, n) {\n  return n === 0 ? 1 : A(m, n - 1) * (m - n + 1);\n}\n"
    }
  },
  {
    "name": "1017-convert-to-base-2",
    "code": {
      "JS": "/**\n * @param {number} N\n * @return {string}\n */\nconst baseNeg2 = function(N) {\n  return negBase(N, -2)\n};\n\nfunction negBase(val, base) {\n  if(val === 0) return '0'\n\tlet result = '';\n\twhile (val !== 0) {\n\t\tlet remainder = val % base;\n\t\tval = Math.trunc(val / base);\n\t\tif (remainder < 0) {\n\t\t\tremainder += -base;\n\t\t\tval += 1;\n\t\t}\n\t\tresult = remainder + result;\n\t}\n\treturn result;\n}\n\n// another\n\n/**\n * @param {number} N\n * @return {string}\n */\nconst baseNeg2 = function(N) {\n  if (N === 0) return \"0\"; \n  let res = ''\n  while(N !== 0) {\n    res = (N & 1) + res\n    N = -(N >> 1)\n  }\n  return res; \n};\n"
    }
  },
  {
    "name": "1018-binary-prefix-divisible-by-5",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @return {boolean[]}\n */\nconst prefixesDivBy5 = function(A) {\n    const res = []\n    let pre = 0\n    const len = A.length\n    for(let i = 0; i < len; i++) {\n      pre = (pre % 100) * 2 + A[i]\n      res.push(pre % 5 === 0 ? true : false)\n    }\n    return res\n};\n"
    }
  },
  {
    "name": "102-binary-tree-level-order-traversal",
    "code": {
      "JS": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number[][]}\r\n */\r\nconst levelOrder = function(root) {\r\n  const res = [];\r\n  if (root == null) return res;\r\n  let next = [root];\r\n  while (next.length > 0) {\r\n    next = tr(res, next);\r\n  }\r\n  return res;\r\n};\r\n\r\nfunction tr(res, nodeArr) {\r\n  const arr = [];\r\n  const nextLevelNodes = [];\r\n  for (let i = 0; i < nodeArr.length; i++) {\r\n    arr.push(nodeArr[i].val);\r\n    if (nodeArr[i].left) {\r\n      nextLevelNodes.push(nodeArr[i].left);\r\n    }\r\n    if (nodeArr[i].right) {\r\n      nextLevelNodes.push(nodeArr[i].right);\r\n    }\r\n  }\r\n  if (arr.length) res.push(arr);\r\n  return nextLevelNodes;\r\n}\r\n"
    }
  },
  {
    "name": "1020-partition-array-into-three-parts-with-equal-sum",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @return {boolean}\n */\nconst canThreePartsEqualSum = function(A) {\n  let lo = 0\n  let hi = A.length - 1\n  let lsum = 0\n  let hsum = 0\n  const sum = A.reduce((ac, el) => ac + el, 0)\n  if(sum % 3 !== 0) return false\n  const target = sum / 3\n\n  while(lo < hi && lsum !== target) {\n    lsum += A[lo]\n    lo++\n  }\n  if(lsum !== target) return false\n  while(lo < hi && hsum !== target) {\n    hsum += A[hi]\n    hi--\n  }\n  if(hsum !== target) return false\n\n  let msum = 0\n  for(let i = lo; i <= hi; i++) {\n    msum += A[i]\n  }\n  if(msum !== target) return false\n  return true\n};\n"
    }
  },
  {
    "name": "1021-best-sightseeing-pair",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @return {number}\n */\nconst maxScoreSightseeingPair = function(A) {\n    let res = 0, cur = 0;\n    for (let a of A) {\n        res = Math.max(res, cur + a);\n        cur = Math.max(cur, a) - 1;\n    }\n    return res;\n};\n\n\n// another\n\n/**\n * @param {number[]} A\n * @return {number}\n */\nconst maxScoreSightseeingPair = function(A) {\n    let ans =A[0];\n    let prevBestIdx =0;\n    for(let j=1;j<A.length;j++){\n        ans = Math.max(ans, A[prevBestIdx]+prevBestIdx+A[j]-j);\n        if(A[prevBestIdx ]+prevBestIdx <A[j]+j){\n            prevBestIdx =j;\n        }\n    }\n    return ans;\n};\n"
    }
  },
  {
    "name": "1021-remove-outermost-parentheses",
    "code": {
      "JS": "/**\n * @param {string} S\n * @return {string}\n */\nconst removeOuterParentheses = function(S) {\n    let onum = 0\n    let oidx = 0\n    let cnum = 0\n    let cidx = 0\n    let res = ''\n    const arr = S.split('')\n    for(let i = 0, len = S.length; i < len; i++) {\n      if(S[i] === '(') onum++\n      if(S[i] === ')') cnum++\n      if(onum === cnum) {\n        res += arr.slice(oidx + 1, oidx + cnum * 2 - 1).join('')\n        onum = 0\n        cnum = 0\n        oidx = i+1\n      }\n    }\n    return res\n};\n"
    }
  },
  {
    "name": "1022-smallest-integer-divisible-by-k",
    "code": {
      "JS": "/**\n * @param {number} K\n * @return {number}\n */\nconst smallestRepunitDivByK = function(K) {\n    if (K % 2 === 0 || K % 5 === 0) return -1;\n    let r = 0;\n    for (let N = 1; N <= K; ++N) {\n        r = (r * 10 + 1) % K;\n        if (r == 0) return N;\n    }\n    return -1;\n};\n"
    }
  },
  {
    "name": "1022-sum-of-root-to-leaf-binary-numbers",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nconst sumRootToLeaf = function(root) {\n  if(root == null) return 0\n  const res = []\n  dfs(root, 0, res)\n  const mod = Math.pow(10, 9) + 7\n  return res.reduce((ac, el) => (ac + el) % mod ,0)  \n};\n\nfunction dfs(node, val, res) {\n  const mod = Math.pow(10, 9) + 7\n  if(node == null) return\n  val = (val * 2 + node.val) % mod\n  if(node.left === null && node.right === null) {\n    res.push(val)\n  }\n  dfs(node.left, val, res)\n  dfs(node.right, val, res)\n}\n"
    }
  },
  {
    "name": "1023-binary-string-with-substrings-representing-1-to-n",
    "code": {
      "JS": "/**\n * @param {string} S\n * @param {number} N\n * @return {boolean}\n */\nconst queryString = function(S, N) {\n  for(let i = 1; i <= N; i++) {\n    let tmp = bin(i)\n    if(S.indexOf(tmp) === -1) return false\n  }\n  return true\n};\n\nfunction bin(num) {\n  return (num >>> 0).toString(2)\n}\n"
    }
  },
  {
    "name": "1023-camelcase-matching",
    "code": {
      "JS": "/**\n * @param {string[]} queries\n * @param {string} pattern\n * @return {boolean[]}\n */\nconst camelMatch = function(queries, pattern) {\n    const res = []\n\n    queries.forEach(el => {\n      let tmp = chk(el, pattern)\n      if(tmp) res.push(true)\n      else res.push(false)\n    })\n    \n    return res\n};\n\nfunction chk(str, p) {\n  let pIdx = 0\n  let sIdx = 0\n  const sLen = str.length\n  const pLen = p.length\n  const Acode = ('A').charCodeAt(0)\n  const Zcode = ('Z').charCodeAt(0)\n  let pEnd = false\n\n  for(let i = 0; i < pLen; i++) {\n    let target = p.charAt(i)\n    \n    while(sIdx < sLen && !pEnd) {\n      if(str.charCodeAt(sIdx) >= Acode && str.charCodeAt(sIdx) <= Zcode && str.charAt(sIdx) !== target) return false\n      if(str.charAt(sIdx) === target) {\n        if(i !== pLen - 1) {\n          sIdx++\n        } else {\n          pEnd = true\n        }\n        break\n      } else {\n        sIdx++        \n      }\n    }\n    if(sIdx >= sLen) return false\n  }\n\n  for(let i = sIdx + 1; pEnd && i < sLen; i++) {\n    if(str.charCodeAt(i) >= Acode && str.charCodeAt(i) <= Zcode) return false\n  }\n  return true\n}\n"
    }
  },
  {
    "name": "1024-video-stitching",
    "code": {
      "JS": "/**\n * @param {number[][]} clips\n * @param {number} T\n * @return {number}\n */\nconst videoStitching = function (clips, T) {\n  clips.sort((a, b) => a[0] - b[0])\n  if(T === 0) return 0\n  let laststart = -1,\n    curend = 0,\n    count = 0\n  for (let i = 0; i < clips.length; ) {\n    if (clips[i][0] > curend) return -1\n    let maxend = curend\n    // while one clip's start is before or equal to current end\n    while (i < clips.length && clips[i][0] <= curend) {\n      maxend = Math.max(maxend, clips[i][1])\n      i++\n    }\n    count++\n    curend = maxend\n    if (curend >= T) return count\n  }\n  return -1\n}\n\n// another\n\n/**\n * @param {number[][]} clips\n * @param {number} T\n * @return {number}\n */\nconst videoStitching = function (clips, T) {\n  clips.sort((a, b) => a[0] - b[0])\n  let res = 0\n  for(let i = 0, start = 0, end = 0, len = clips.length; start < T; start = end, res++) {\n    for(; i < len && clips[i][0] <= start; i++) {\n      end = Math.max(end, clips[i][1])\n    }\n    if(start === end) return -1\n  }\n  return res\n}\n\n\n// another\n\n/**\n * @param {number[][]} clips\n * @param {number} T\n * @return {number}\n */\nconst videoStitching = function (clips, T) {\n  const dp = Array(T + 1).fill( T + 1 )\n  dp[0] = 0\n  for(let i = 0; i <= T; i++) {\n    for(let c of clips) {\n      if(i >= c[0] && i <= c[1]) dp[i] = Math.min(dp[i], dp[c[0]] + 1)\n    }\n    if(dp[i] === T + 1) return -1\n  }\n  return dp[T]\n}\n\n\n"
    }
  },
  {
    "name": "1025-divisor-game",
    "code": {
      "JS": "/**\n *  * @param {number} N\n *   * @return {boolean}\n *    */\nconst divisorGame = function(N) {\n   let idx = 0  \n   let x\n   while(x = chk(N)) {\n     idx++\n     N = N - x\n   }\n   if(idx === 0) return false\n   return idx % 2 === 1 ? true : false\n};\n\nfunction chk(num) {\n   for(let i = 1; i < num; i++) {\n      if(num % i === 0) return i\n   }\n   return false\n}\n"
    }
  },
  {
    "name": "1026-maximum-difference-between-node-and-ancestor",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nconst maxAncestorDiff = function(root) {\n    const arr = []\n    dfs(root, [], arr)\n    let res = Number.MIN_VALUE\n    for(let i = 0; i < arr.length; i++) {\n      let el = arr[i]\n      let max = Number.MIN_VALUE\n      let min = Number.MAX_VALUE \n      for(let j = 0; j < el.length; j++) {\n        if(el[j] < min) min = el[j]\n        if(el[j] > max) max = el[j]\n      }\n      if(Math.abs(max - min) > res) res = Math.abs(max - min)\n    }\n    return res\n};\n\nfunction dfs(node, arr, res) {\n  if(node == null) return\n  arr.push(node.val)\n  if(node.left === null && node.right === null) {\n    res.push(arr.slice(0))\n    return\n  }\n  \n  dfs(node.left, arr.slice(0), res)\n  dfs(node.right, arr.slice(0), res)\n  \n  \n}\n"
    }
  },
  {
    "name": "1027-longest-arithmetic-sequence",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @return {number}\n */\nconst longestArithSeqLength = function(A) {\n  let a = A\n  let n = A.length\n  if (n <= 2) return n;\n\n  let i, j, k, d;\n  let mxl = 2;\n  let current;\n  let last;\n\n  //i will be the index of first element of the ap\n  for (i = 0; i < n - mxl; i++) {\n    //j will be the index of second element of the ap\n    for (j = i + 1; j < n - mxl + 1; j++) {\n      //common difference\n      d = a[j] - a[i];\n      last = a[j];\n      current = 2;\n\n      for (k = j + 1; k < n; k++) {\n        if (a[k] - last == d) {\n          //here is our element\n          current++;\n          last = a[k];\n        }\n      }\n\n      mxl = Math.max(mxl, current);\n    }\n  }\n\n  return mxl;\n};\n"
    }
  },
  {
    "name": "1028-recover-a-tree-from-preorder-traversal",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {string} S\n * @return {TreeNode}\n */\nconst recoverFromPreorder = function(S) {\n  const arr = []\n  let tmp = S[0]\n  for(let i = 1; i < S.length; i++) {\n    if(S[i] === '-') {\n      if(S[i-1] === '-') {\n         tmp += '-'\n       } else {\n         arr.push(tmp)\n         tmp = '-'\n       }\n    } else {\n      if(S[i-1] === '-') {\n        arr.push(tmp)\n        tmp = S[i]\n      } else {\n        tmp += S[i]\n      }\n    }\n  }\n  arr.push(tmp)\n  const resArr = []\n  helper(resArr, arr, 0)\n  return resArr[0]\n};\n\n\nfunction helper(nodeArr, strArr, idx) {\n  if(idx >= strArr.length) return\n  if(idx > 0) {\n    \n    if(strArr[idx].startsWith('-')) {\n      helper(nodeArr, strArr, idx + 1)\n    } else {\n      nodeArr[idx] = new TreeNode(+strArr[idx])\n      let d = strArr[idx - 1].length\n\n      let tIdx\n\n      for(let i = idx - 1; ; i = i - 2) {\n        if(i>= 1) {\n          if(strArr[i].length < d) {\n            tIdx = i+1\n            break\n          }\n        } else {\n\n          tIdx = 0\n          break\n        }\n      }\n      \n      if(nodeArr[tIdx].left) {\n        nodeArr[tIdx].right = nodeArr[idx]\n      } else {\n        nodeArr[tIdx].left = nodeArr[idx]\n      }\n      helper(nodeArr, strArr, idx + 1)\n    }\n\n  } else {\n    nodeArr[idx] = new TreeNode(+strArr[idx])\n    helper(nodeArr, strArr, idx + 1)\n  }\n  \n}\n\n"
    }
  },
  {
    "name": "1029-two-city-scheduling",
    "code": {
      "JS": "/**\n * @param {number[][]} costs\n * @return {number}\n */\nconst twoCitySchedCost = function(costs) {\n  const N = costs.length / 2\n  const dp = Array.from({ length: N + 1 }, () => new Array(N + 1).fill(0))\n  for (let i = 1; i <= N; i++) {\n    dp[i][0] = dp[i - 1][0] + costs[i - 1][0]\n  }\n  for (let j = 1; j <= N; j++) {\n    dp[0][j] = dp[0][j - 1] + costs[j - 1][1]\n  }\n  for (let i = 1; i <= N; i++) {\n    for (let j = 1; j <= N; j++) {\n      dp[i][j] = Math.min(\n        dp[i - 1][j] + costs[i + j - 1][0],\n        dp[i][j - 1] + costs[i + j - 1][1]\n      )\n    }\n  }\n  return dp[N][N]\n}\n\n// another\n\n/**\n * @param {number[][]} costs\n * @return {number}\n */\nconst twoCitySchedCost = function(costs) {\n  const N = costs.length\n  let res = 0\n  const refund = []\n  for(let i = 0; i < N; i++) {\n    refund[i] = costs[i][1] - costs[i][0]\n    res += costs[i][0]\n  }\n  refund.sort((a, b) => a - b)\n  for(let i = 0; i < N / 2; i++) {\n    res += refund[i]\n  }\n  return res\n};\n\n// another\n\n/**\n * @param {number[][]} costs\n * @return {number}\n */\nconst twoCitySchedCost = function(costs) {\n  const len = costs.length\n  if(len === 0) return 0\n  const N = len / 2\n  costs.sort((a, b) => (a[0] - a[1]) - (b[0] - b[1]))\n  let res = 0\n  for(let i = 0; i < costs.length; i++) {\n    if(i < N) {\n      res += costs[i][0]\n    } else {\n      res += costs[i][1]\n    }\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "103-binary-tree-zigzag-level-order-traversal",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nconst zigzagLevelOrder = function(root) {\n  if(root == null) return []\n  const row = [root]\n  const res = []\n  bfs(row, res)\n  for(let i = 0; i < res.length; i++) {\n    res[i] = i % 2 === 0 ? res[i] : res[i].reverse()\n  }\n  return res\n};\n\nfunction bfs(row, res) {\n  if(row.length === 0) return\n  let tmp = []\n  let next = []\n  for(let i = 0; i< row.length; i++) {\n    tmp.push(row[i].val)\n    if(row[i].left) {\n       next.push(row[i].left)\n    }\n    if(row[i].right) {\n       next.push(row[i].right)\n    }\n  }\n  if(tmp.length) {\n    res.push(tmp)\n  }\n  bfs(next, res)\n}\n\n// another\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nconst zigzagLevelOrder = function (root) {\n  if (!root) return [];\n  const queue = [root];\n  const zigzag = [];\n  let numLevels = 1;\n  while (queue.length > 0) {\n    const width = queue.length;\n    const levelTraversal = [];\n    for (let i = 0; i < width; i++) {\n      const currentNode = queue.shift();\n      if (currentNode.right) queue.push(currentNode.right);\n      if (currentNode.left) queue.push(currentNode.left);\n      numLevels % 2 === 0\n        ? levelTraversal.push(currentNode.val)\n        : levelTraversal.unshift(currentNode.val);\n    }\n    zigzag.push(levelTraversal);\n    numLevels++;\n  }\n\n  return zigzag;\n};\n\n// another\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nconst zigzagLevelOrder = function (root) {\n  const res = []\n  dfs(root, res, 0)\n  return res\n  \n  function dfs(node, res, level) {\n    if(node == null) return\n    if(res.length <= level) res.push([])\n    const tmp = res[level]\n    if(level % 2 === 0) tmp.push(node.val)\n    else tmp.unshift(node.val)\n    \n    dfs(node.left, res, level + 1)\n    dfs(node.right, res, level + 1)\n  }\n};\n"
    }
  },
  {
    "name": "1030-matrix-cells-in-distance-order",
    "code": {
      "JS": "/**\n * @param {number} R\n * @param {number} C\n * @param {number} r0\n * @param {number} c0\n * @return {number[][]}\n */\nconst allCellsDistOrder = function(R, C, r0, c0) {\n  const matrix = Array.from({ length: R }, () => new Array(C))\n  const arr = []\n  for (let i = 0; i < R; i++) {\n    for (let j = 0; j < C; j++) {\n      arr.push([i, j])\n    }\n  }\n\n  return arr.sort(\n    (a, b) =>\n      Math.abs(a[0] - r0) +\n      Math.abs(a[1] - c0) -\n      (Math.abs(b[0] - r0) + Math.abs(b[1] - c0))\n  )\n}\n"
    }
  },
  {
    "name": "1030-next-greater-node-in-linked-list",
    "code": {
      "JS": "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number[]}\n */\nconst nextLargerNodes = function(head) {\n  const A = []\n  while (head != null) A.push(head.val), (head = head.next)\n  const res = new Array(A.length).fill(0)\n  const stack = []\n  for (let i = 0; i < A.length; i++) {\n    while (stack.length && A[stack[stack.length - 1]] < A[i])\n      res[stack.pop()] = A[i]\n    stack.push(i)\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "1031-maximum-sum-of-two-non-overlapping-subarrays",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @param {number} L\n * @param {number} M\n * @return {number}\n */\nconst maxSumTwoNoOverlap = function(A, L, M) {\n  for(let i = 1, len = A.length; i < len; i++) {\n    A[i] += A[i - 1]\n  }\n  let LMax = A[L - 1], MMax = A[M - 1], res = A[L + M - 1]\n  for(let i = L + M, len = A.length; i < len; i++) {\n    LMax = Math.max(LMax, A[i - M] - A[i - M - L])\n    MMax = Math.max(MMax, A[i - L] - A[i - M - L])\n    res = Math.max(res, Math.max(LMax + A[i] - A[i - M], MMax + A[i] - A[i - L]))\n  }\n  return res\n}\n\n// another\n\nconst maxSumTwoNoOverlap = function(A, L, M) {\n  let n = A.length\n  let sum = []\n  sum[0] = 0\n  for (let i = 0; i < n; i++) sum[i + 1] = sum[i] + A[i]\n\n  let ans = 0\n  for (let i = L - 1; i + M < n; ++i) {\n    for (let j = i + 1; j + M - 1 < n; ++j) {\n      ans = Math.max(ans, sum[i + 1] - sum[i - L + 1] + sum[j + M] - sum[j])\n    }\n  }\n  let tmp = L\n  L = M\n  M = tmp\n  for (let i = L - 1; i + M < n; ++i) {\n    for (let j = i + 1; j + M - 1 < n; ++j) {\n      ans = Math.max(ans, sum[i + 1] - sum[i - L + 1] + sum[j + M] - sum[j])\n    }\n  }\n  return ans\n}\n"
    }
  },
  {
    "name": "1031-number-of-enclaves",
    "code": {
      "JS": "/**\n * @param {number[][]} A\n * @return {number}\n */\nconst numEnclaves = function(A) {\n  let res = 0\n  const dirs = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n  const visited = Array.from({ length: A.length }, () =>\n    new Array(A[0].length).fill(false)\n  )\n  for (let row = 0; row < A.length; row++) {\n    for (let col = 0; A[0] && col < A[0].length; col++) {\n      if (\n        (row === 0 ||\n          col === 0 ||\n          row === A.length - 1 ||\n          col === A[0].length - 1) &&\n        A[row][col] === 1\n      ) {\n        dfs(A, row, col, visited, dirs)\n      }\n    }\n  }\n  for (let row = 0; row < A.length; row++) {\n    for (let col = 0; A[0] && col < A[0].length; col++) {\n      if (A[row][col] === 1) {\n        res += 1\n      }\n    }\n  }\n  return res\n}\n\nfunction dfs(A, row, col, v, dirs) {\n  if (\n    row < 0 ||\n    row >= A.length ||\n    col < 0 ||\n    col >= A[0].length ||\n    v[row][col] ||\n    A[row][col] === 0\n  )\n    return\n\n  v[row][col] = true\n  A[row][col] = 0\n\n  for (let dir of dirs) {\n    dfs(A, row + dir[0], col + dir[1], v, dirs)\n  }\n}\n"
    }
  },
  {
    "name": "1032-stream-of-characters",
    "code": {
      "JS": "/**\n * @param {string[]} words\n */\nconst StreamChecker = function(words) {\n  this.maxLen = 0\n  this.pos = -1\n  this.s = []\n  this.root = new Node()\n  for (let w of words) {\n    this.add(w)\n    this.maxLen = Math.max(this.maxLen, w.length)\n  }\n}\n\n/**\n * @param {character} letter\n * @return {boolean}\n */\nStreamChecker.prototype.query = function(letter) {\n  this.s[++this.pos] = letter\n  return this.find(this.s, this.pos, Math.min(this.pos + 1, this.maxLen))\n}\n\nStreamChecker.prototype.add = function(word) {\n  let len = word.length\n  let p = this.root\n  for (let i = len - 1; i >= 0; i--) {\n    let k = word.charCodeAt(i) - 'a'.charCodeAt(0)\n    if (p.child[k] == null) p.child[k] = new Node()\n    p = p.child[k]\n  }\n  p.valid = true\n}\n\nStreamChecker.prototype.find = function(s, pos, len) {\n  let p = this.root\n  for (let i = 0; i < len; i++) {\n    let k = s[pos - i].charCodeAt(0) - 'a'.charCodeAt(0)\n    if (p.child[k] == null) return false\n    p = p.child[k]\n    if (p.valid) return true\n  }\n  return false\n}\nclass Node {\n  constructor() {\n    this.child = []\n    this.valid = false\n  }\n}\n\n/**\n * Your StreamChecker object will be instantiated and called as such:\n * var obj = new StreamChecker(words)\n * var param_1 = obj.query(letter)\n */\n"
    }
  },
  {
    "name": "1033-moving-stones-until-consecutive",
    "code": {
      "JS": "/**\n * @param {number} a\n * @param {number} b\n * @param {number} c\n * @return {number[]}\n */\nconst numMovesStones = function(a, b, c) {\n    let min = 0\n    let min2 = 0\n    let max = 0\n    const arr= [a,b,c]\n    arr.sort((a,b) => a - b)\n    \n    max = arr[2]-arr[1]-1 + arr[1] - arr[0] - 1\n    min = (arr[2] - arr[1] > 1 ? 1 : 0) +(arr[1] - arr[0] > 1 ? 1 : 0)\n    min2 = arr[2] - arr[1] === 2 || arr[1] - arr[0] === 2 ? 1 : Number.MAX_VALUE\n  \n    return [Math.min(min, min2), max]\n};\n"
    }
  },
  {
    "name": "1034-coloring-a-border",
    "code": {
      "JS": "/**\n * @param {number[][]} grid\n * @param {number} r0\n * @param {number} c0\n * @param {number} color\n * @return {number[][]}\n */\nconst colorBorder = function(grid, r0, c0, color) {\n  const dirs = [[-1,0], [1,0], [0,1], [0,-1]]\n  const c = grid[r0][c0]\n  const rows = grid.length\n  const cols = grid[0].length\n  const visited = Array.from({length: rows}, () => new Array(cols).fill(0))\n  dfs(r0, c0, c, rows, cols, visited, grid, dirs)\n  for(let i = 0; i < rows; i++) {\n    for(let j = 0; j < cols; j++) {\n      if(visited[i][j] === -1) {\n         if(i === 0 || j === 0 || i === rows - 1 || j === cols - 1) {\n            visited[i][j] = -2\n         } else {\n            for(let dir of dirs) {\n              if(visited[i + dir[0]][j + dir[1]] === 0) {\n                 visited[i][j] = -2\n                 break\n              }\n            }    \n         }\n      }\n    }\n  }\n  for(let i = 0; i < rows; i++) {\n    for(let j = 0; j < cols; j++) {\n      if(visited[i][j] === -2) grid[i][j] = color\n    }\n  }\n  \n  return grid\n};\n\nfunction dfs(row, col, target, rows, cols, visited, grid, dirs) {\n  if(row >= rows || col >= cols || row < 0 || col < 0 || grid[row][col] !== target || visited[row][col] === -1) {\n    return   \n  }\n  visited[row][col] = -1\n  for(let dir of dirs) {\n    dfs(row + dir[0], col+dir[1], target, rows, cols, visited, grid, dirs)\n  }\n  \n}\n"
    }
  },
  {
    "name": "1035-uncrossed-lines",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @param {number[]} B\n * @return {number}\n */\nconst maxUncrossedLines = function(A, B) {\n  const lenA = A.length\n  const lenB = B.length\n  const dp = Array.from({length: lenA + 1}, () => new Array(lenB + 1).fill(0))\n  for(let i = 1; i <= lenA; i++) {\n    for(let j = 1; j <= lenB; j++) {\n      if(A[i - 1] === B[j - 1]) {\n        dp[i][j] = 1 + dp[i - 1][j - 1]\n      } else {\n        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])\n      }\n    }\n  }\n  return dp[lenA][lenB]\n};\n\n\n// another\n\nconst maxUncrossedLines = function(A, B) {\n  const m = A.length,\n    n = B.length\n  const dp = new Array(n + 1).fill(0)\n  let prev\n\n  for (let i = 1; i <= m; i++) {\n    prev = dp[0]\n    for (let j = 1; j <= n; j++) {\n      let backup = dp[j]\n      if (A[i - 1] == B[j - 1]) dp[j] = prev + 1\n      else dp[j] = Math.max(dp[j], dp[j - 1])\n      prev = backup\n    }\n  }\n\n  return dp[n]\n}\n"
    }
  },
  {
    "name": "1036-escape-a-large-maze",
    "code": {
      "JS": "/**\n * @param {number[][]} blocked\n * @param {number[]} source\n * @param {number[]} target\n * @return {boolean}\n */\nconst isEscapePossible = function(blocked, source, target) {\n  const blockedSet = new Set()\n  for (let el of blocked) {\n    let key = el[0] + \",\" + el[1]\n    blockedSet.add(key)\n  }\n  return canVisit(blockedSet, source, target) && canVisit(blockedSet, target, source)\n}\n\nfunction canVisit(blocked, start, end) {\n  const visited = new Set()\n  return dfs(blocked, start[0], start[1], end[0], end[1], visited)\n}\nfunction dfs(blocked, i, j, m, n, visited) {\n  visited.add(i + \",\" + j)\n  const dirs = [[i - 1, j], [i + 1, j], [i, j + 1], [i, j - 1]]\n  if ((i == m && j == n) || visited.size >= 20000) {\n    return true\n  }\n  for (let dir of dirs) {\n    let nextKey = dir[0] + \",\" + dir[1]\n    if (\n      dir[0] >= 0 &&\n      dir[1] >= 0 &&\n      dir[0] < 1e6 &&\n      dir[1] < 1e6 &&\n      !blocked.has(nextKey) &&\n      !visited.has(nextKey)\n    ) {\n      if (dfs(blocked, dir[0], dir[1], m, n, visited)) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n// another\n\n/**\n * @param {number[][]} blocked\n * @param {number[]} source\n * @param {number[]} target\n * @return {boolean}\n */\nconst isEscapePossible = function(blocked, source, target) {\n  if (blocked.length < 2) {\n    return true\n  }\n//   if (blocked[0][0] == 100025) {\n//     return false\n//   }\n  const blockSet = new Set(\n    blocked.map(el => {\n      return el[0] + \",\" + el[1]\n    })\n  )\n  let targetR, targetC, curR, curC\n  ;[targetR, targetC] = target\n  let visited = new Set([])\n  let DIRS = [[0, 1], [-1, 0], [0, -1], [1, 0]],\n    queue = [source]\n  const inBound = (r, c) => {\n    return r >= 0 && c >= 0 && r < 1000000 && c < 1000000\n  }\n  let count = 0\n  while (queue.length > 0) {\n    count++\n    ;[curR, curC] = queue.shift()\n\n    if (count > 20000) {\n      return true\n    }\n    for (let dir of DIRS) {\n      const newR = curR + dir[0],\n        newC = curC + dir[1]\n      if (\n        !inBound(newR, newC) ||\n        blockSet.has(newR + \",\" + newC) ||\n        visited.has(newR + \",\" + newC)\n      ) {\n        continue\n      }\n\n      if (newR == targetR && newC == targetC) {\n        return true\n      }\n      visited.add(newR + \",\" + newC)\n      queue.push([newR, newC])\n    }\n  }\n  return false\n}\n"
    }
  },
  {
    "name": "1037-valid-boomerang",
    "code": {
      "JS": "/**\n * @param {number[][]} points\n * @return {boolean}\n */\nconst isBoomerang = function(points) {\n  if(angle(points[0], points[1], points[2]) &&\n     angle(points[1], points[2], points[0]) &&\n     angle(points[1], points[0], points[2]) ) return false\n  return true\n};\n\n// distinct or in a line\nfunction angle(p1, p2, p3) {\n  if((p1[0] === p2[0] && p1[1] === p2[1]) ||\n     (p2[0] === p3[0] && p2[1] === p3[1]) ||\n     (p1[0] === p3[0] && p1[1] === p3[1]) ) return true\n  \n  return collinear(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1])\n}\nfunction collinear(x1, y1, x2, y2,  x3, y3)  { \n  return (y3 - y2) * (x2 - x1) === (y2 - y1) * (x3 - x2)\n} \n"
    }
  },
  {
    "name": "1038-binary-search-tree-to-greater-sum-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nconst bstToGst = function(root) {\n  const arr = []\n  dfs(root, arr)\n  let v = 0\n  for(let i = arr.length - 1; i >= 0; i--) {\n    arr[i].val = arr[i].val + v\n    v = arr[i].val\n  }\n  return root\n};\n\nfunction dfs(node, arr) {\n  if(node == null) return\n  dfs(node.left, arr)\n  arr.push(node)\n  dfs(node.right, arr)\n}\n"
    }
  },
  {
    "name": "1039-minimum-score-triangulation-of-polygon",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @return {number}\n */\nconst minScoreTriangulation = function(A) {\n  if(A.length <= 2) return 0\n  if(A.length === 3) return A[0] * A[1] * A[2]\n  return chk(A, A.length)\n};\n\nfunction cost(points, i, j, k) {\n  let p1 = points[i],\n    p2 = points[j],\n    p3 = points[k]\n  return p1 * p2 * p3\n}\n\nfunction chk(points, n) {\n  if (n < 3) return 0\n\n  const table = Array.from({ length: n }, () => new Array(n).fill(0))\n\n  for (let gap = 0; gap < n; gap++) {\n    for (let i = 0, j = gap; j < n; i++, j++) {\n      if (j < i + 2) table[i][j] = 0\n      else {\n        table[i][j] = Number.MAX_VALUE\n        for (let k = i + 1; k < j; k++) {\n          let val = table[i][k] + table[k][j] + cost(points, i, j, k)\n          if (table[i][j] > val) table[i][j] = val\n        }\n      }\n    }\n  }\n  return table[0][n - 1]\n}\n"
    }
  },
  {
    "name": "104-maximum-depth-of-binary-tree",
    "code": {
      "JS": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nconst maxDepth = function(root) {\r\n  if (!root) return 0;\r\n  const left = maxDepth(root.left);\r\n  const right = maxDepth(root.right);\r\n  let depth = left > right ? left : right;\r\n  return (depth += 1);\r\n};\r\n"
    }
  },
  {
    "name": "1040-moving-stones-until-consecutive-ii",
    "code": {
      "JS": "/**\n * @param {number[]} stones\n * @return {number[]}\n */\nconst numMovesStonesII = function(stones) {\nstones.sort((a, b) => a - b)\nlet n = stones.length;\nlet least = Number.MAX_VALUE, most = Number.MIN_VALUE;\n\nfor (let i = 0, j = 0; i < n; i++) {\n  while (j + 1 < n && stones[j + 1] - stones[i] < n) j++;\n  let now = n - (j - i + 1);\n  if (j - i == n - 2 && stones[j] - stones[i] == j - i) now++;\n  least = Math.min(least, now);\n}\n\nmost = Math.max(stones[n - 1] - stones[1], stones[n - 2] - stones[0]) - (n - 2);\nreturn [least, most];\n};\n"
    }
  },
  {
    "name": "1041-robot-bounded-in-circle",
    "code": {
      "JS": "/**\n * @param {string} instructions\n * @return {boolean}\n */\nconst isRobotBounded = function(instructions) {\n  let x = 0, y = 0, i = 0, d = [[0, 1], [1, 0], [0, -1], [ -1, 0]];\n  for (let j = 0; j < instructions.length; ++j)\n    if (instructions.charAt(j) === 'R') i = (i + 1) % 4;\n    else if (instructions .charAt(j) === 'L') i = (i + 3) % 4;\n    else {\n        x += d[i][0]; y += d[i][1];\n    }\n  return x == 0 && y == 0 || i > 0;\n};\n\n// another\n\n/**\n * @param {string} instructions\n * @return {boolean}\n */\nconst isRobotBounded = function(instructions) {\n  let x = 0, y = 0, i = 0\n  const dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]] // U, R, D, L\n  for(let e of instructions) {\n    if(e === 'R') {\n      i = (i + 1) % 4\n    } else if(e === 'L') {\n      i = (i + 3) % 4\n    } else {\n      x += dirs[i][0]\n      y += dirs[i][1]\n    }\n  }\n  return x === 0 && y === 0 || i > 0\n};\n\n// another\n\n/**\n * @param {string} instructions\n * @return {boolean}\n */\nconst isRobotBounded = function(instructions) {\n  const dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]\n  let x = 0, y = 0, i = 0\n  for(let ins of instructions) {\n    if(ins === 'G') {\n      const dir = dirs[i]\n      x += dir[0]\n      y += dir[1]\n    } else if(ins === 'L') {\n      i = i - 1 < 0 ? 3 : i - 1 \n    } else if(ins === 'R') {\n      i = i + 1 > 3 ? 0 : i + 1\n    }\n  }\n  return x === 0 && y === 0 || i !== 0\n};\n"
    }
  },
  {
    "name": "1042-flower-planting-with-no-adjacent",
    "code": {
      "JS": "/**\n * @param {number} N\n * @param {number[][]} paths\n * @return {number[]}\n */\nconst gardenNoAdj = function(N, paths) {\n  const map = {};\n  for (let i = 0; i < N; i++) {\n    map[i] = [];\n  }\n  for (let path of paths) {\n    let l = path[0] - 1;\n    let r = path[1] - 1;\n    map[l].push(r);\n    map[r].push(l);\n  }\n  const result = new Array(N).fill(-1);\n  for (let i = 0; i < N; i++) {\n    let colors = new Array(4).fill(false);\n    for (let neighbor of map[i]) {\n      if (result[neighbor] !== -1) {\n        colors[result[neighbor]] = true;\n      }\n    }\n    for (let j = 0; j < colors.length; j++) {\n      if (!colors[j]) {\n        result[i] = j;\n        break;\n      }\n    }\n  }\n  return result.map(i => ++i);\n};\n"
    }
  },
  {
    "name": "1043-partition-array-for-maximum-sum",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @param {number} K\n * @return {number}\n */\nconst maxSumAfterPartitioning = function(A, K) {\n  const N = A.length\n  const dp = new Array(N).fill(0);\n  for (let i = 0; i < N; ++i) {\n    let curMax = 0;\n    for (let j = 1; j <= K && i - j + 1 >= 0; j++) {\n      curMax = Math.max(curMax, A[i - j + 1]);\n      dp[i] = Math.max(dp[i], (i >= j ? dp[i - j] : 0) + curMax * j);\n    }\n  }\n  return dp[N - 1];\n};\n\n// another\n\n/**\n * @param {number[]} arr\n * @param {number} k\n * @return {number}\n */\nconst maxSumAfterPartitioning = function(arr, k) {\n  const n = arr.length, memo = Array(n + 1)\n  memo[0] = 0\n  return dp(n)\n  \n  function dp(i) {\n    if(i === 0) return 0\n    if(memo[i] != null) return memo[i]\n    \n    let sum = 0, max = 0, res = 0\n    for(let j = i; j > 0 && i - j < k; j--) {\n      max = Math.max(max, arr[j - 1])\n      sum = (i - j + 1) * max\n      res = Math.max(res, dp(j - 1) + sum)\n    }\n    return memo[i] = res\n  }\n};\n"
    }
  },
  {
    "name": "1044-longest-duplicate-substring",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {string}\n */\nconst longestDupSubstring = function(s) {\n  const n = s.length\n  let l = 0, r = n, res = ''\n  while(l < r) {\n    const mid = (l + r + 1) >> 1\n    const [chk, str] = valid(s, mid)\n    if(chk) {\n      l = mid\n      res = str\n    } else {\n      r = mid - 1\n    }\n  }\n  return res\n};\n\nfunction valid(s, len) {\n  const set = new Set()\n  for(let i = 0, n = s.length; i <= n - len; i++) {\n    const tmp = s.substr(i, len)\n    if(set.has(tmp)) return [true, tmp]\n    set.add(tmp)\n  }\n  \n  return [false, '']\n}\n\n// another\n\n/**\n * @param {string} S\n * @return {string}\n */\nconst longestDupSubstring = function(S) {\n  const R = 26,\n    MOD = 1e9 + 7\n  let lo = 0,\n    hi = S.length - 1,\n    res = ''\n  while (lo < hi) {\n    const len = Math.ceil((lo + hi) / 2)\n    const sub = rabinKarp(S, len)\n    if (sub !== '') {\n      lo = len\n      res = sub\n    } else {\n      hi = len - 1\n    }\n  }\n  return res\n\n  function rabinKarp(str, len) {\n    const aCode = ('a').charCodeAt(0)\n    let RM = 1\n    // 等价于RM=Math.pow(R,M-1) % MOD\n    // 由于JS精度问题拆解计算\n    for (let i = 1; i < len; i++) {\n      RM = (RM * R) % MOD\n    }\n    const map = new Map()\n    let num = 0\n    // 计算前len个字符串的散列值\n    for (let i = 0; i < len; i++) {\n      const code = str.charCodeAt(i) - aCode\n      num = (num * R + code) % MOD\n    }\n    map.set(num, 0)\n    // 后续计算散列值\n    for (let i = 0; i < str.length - len; i++) {\n      const preCode = str.charCodeAt(i) - aCode,\n        curCode = str.charCodeAt(i + len) - aCode\n      num = (num + MOD - ((preCode * RM) % MOD)) % MOD\n      num = (num * R + curCode) % MOD\n      if (map.has(num)) {\n        const sub = str.substring(i + 1, i + 1 + len)\n        const preId = map.get(num),\n          preSub = str.substring(preId, preId + len)\n        if (sub === preSub) return sub\n      }\n      map.set(num, i + 1)\n    }\n    return ''\n  }\n}\n"
    }
  },
  {
    "name": "1046-last-stone-weight",
    "code": {
      "JS": "/**\n * @param {number[]} stones\n * @return {number}\n */\nconst lastStoneWeight = function(stones) {\n  stones.sort((a, b) => a - b)\n  while (stones.length > 1) {\n    const num = Math.abs(stones.pop() - stones.pop())\n    stones.splice(stones.findIndex(item => item >= num), 0, num)\n  }\n  return stones[0] \n};\n"
    }
  },
  {
    "name": "1047-remove-all-adjacent-duplicates-in-string",
    "code": {
      "JS": "/**\n * @param {string} S\n * @return {string}\n */\nconst removeDuplicates = function(S) {\n  const queue = []\n  for(let i = 0; i < S.length; i++) {\n    if(queue.length > 0 && queue[queue.length - 1] === S[i]) {\n       queue.pop()\n    } else {\n      queue.push(S[i])\n    }\n  }\n  return queue.join('')\n};\n"
    }
  },
  {
    "name": "1048-longest-string-chain",
    "code": {
      "JS": "/**\n * @param {string[]} words\n * @return {number}\n */\nconst longestStrChain = function(words) {\n  words.sort((a, b) => a.length - b.length)\n  const dp = {}\n  for(let el of words) {\n    dp[el] = 1\n  }\n  \n  let res = Number.MIN_VALUE\n  for(let w of words) {\n    for(let i = 0; i < w.length; i++) {\n      let prev = w.slice(0, i) + w.slice(i + 1)\n      dp[w] = Math.max(dp[w], (dp[prev] || 0) + 1 )\n    }\n    if(dp[w] > res) res = dp[w]\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1049-last-stone-weight-ii",
    "code": {
      "JS": "/**\n * @param {number[]} stones\n * @return {number}\n */\nconst lastStoneWeightII = function(stones) {\n  let sum=stones.reduce((a,b)=>a+b)\n  let dp=Array(sum+1).fill(0)\n  dp[0]=1\n  for(let i=0;i<stones.length;i++){\n    let cur=stones[i]\n    for(let j=dp.length-1;j>=0;j--){\n      if(j-stones[i]<0)break\n      if(dp[j-stones[i]]){\n        dp[j]=1\n      }\n    }\n  }\n\n  let minLen=Infinity\n  for(let i=0;i<dp.length;i++){\n    if(dp[i]){\n      if(i*2-sum>=0)minLen=Math.min(minLen,i*2-sum)\n    }\n  }\n  return minLen\n};\n"
    }
  },
  {
    "name": "105-construct-binary-tree-from-preorder-and-inorder-traversal",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {number[]} preorder\n * @param {number[]} inorder\n * @return {TreeNode}\n */\nlet pre\nlet ins\nlet inmap = {}\nconst buildTree = function(preorder, inorder) {\n    pre = preorder\n    ins = inorder\n    for(let i = 0; i < inorder.length; i++) {\n      inmap[inorder[i]] = i\n    }\n    let root = helper(0,0,ins.length - 1)\n    return root\n};\n\nfunction helper(preStart, inStart, inEnd) {\n  if (preStart > pre.length -1 || inStart > inEnd) {\n    return null\n  }\n  let val = pre[preStart]\n  let root = new TreeNode(val)\n  let inIndex = inmap[val]\n  root.left = helper(preStart + 1, inStart, inIndex - 1)\n  root.right = helper(preStart+inIndex-inStart+1, inIndex+1, inEnd)\n  return root\n}\n"
    }
  },
  {
    "name": "1051-height-checker",
    "code": {
      "JS": "/**\n * @param {number[]} heights\n * @return {number}\n */\nconst heightChecker = function(heights) {\n  const arr = heights.slice(0).sort((a, b) => a - b)\n  let res = 0\n  for(let i = 0, len = heights.length; i < len; i++) {\n    if(arr[i] !== heights[i]) res++\n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "1052-grumpy-bookstore-owner",
    "code": {
      "JS": "/**\n * @param {number[]} customers\n * @param {number[]} grumpy\n * @param {number} X\n * @return {number}\n */\nconst maxSatisfied = function(customers, grumpy, X) {\n  if (customers.length === 1) return customers[0]\n  const totalSatisfiedCustomers = customers.reduce(\n    (ac, el, idx) => ac + (grumpy[idx] === 0 ? el : 0),\n    0\n  )\n  const arr = customers.map((el, idx) => (grumpy[idx] === 1 ? el : 0))\n  const acArr = []\n  let ac = 0\n  for (let i = 0, len = arr.length; i < len; i++) {\n    acArr[i] = ac = ac + arr[i]\n  }\n  let max = 0\n  for (let i = X - 1, len = grumpy.length; i < len; i++) {\n    let tmp = i - X < 0 ? 0 : acArr[i - X]\n    if (acArr[i] - tmp > max) max = acArr[i] - tmp\n  }\n\n  return totalSatisfiedCustomers + max\n}\n\n// another\n\n/**\n * @param {number[]} customers\n * @param {number[]} grumpy\n * @param {number} X\n * @return {number}\n */\nconst maxSatisfied = function (customers, grumpy, X) {\n  let satisfied = 0,\n    maxMakeSatisfied = 0\n  for (let i = 0, winOfMakeSatisfied = 0; i < grumpy.length; ++i) {\n    if (grumpy[i] === 0) {\n      satisfied += customers[i]\n    } else {\n      winOfMakeSatisfied += customers[i]\n    }\n    if (i >= X) {\n      winOfMakeSatisfied -= grumpy[i - X] * customers[i - X]\n    }\n    maxMakeSatisfied = Math.max(winOfMakeSatisfied, maxMakeSatisfied)\n  }\n  return satisfied + maxMakeSatisfied\n}\n"
    }
  },
  {
    "name": "1053-previous-permutation-with-one-swap",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @return {number[]}\n */\nconst prevPermOpt1 = function(A) {\n  let n = A.length, left = n - 2, right = n - 1;\n  while (left >= 0  && A[left] <= A[left + 1]) left--;\n  if (left < 0) return A;\n  while (A[left] <= A[right]) right--;\n  while (A[right - 1] == A[right]) right--;\n  swap(A,left,right)\n  return A;\n};\nfunction swap(a, i, j) {\n  let tmp = a[i]\n  a[i] = a[j]\n  a[j] = tmp\n}\n"
    }
  },
  {
    "name": "1054-distant-barcodes",
    "code": {
      "JS": "/**\n * @param {number[]} barcodes\n * @return {number[]}\n */\nconst rearrangeBarcodes = function(barcodes) {\n\tconst map = {};\n\tbarcodes.forEach(b => map[b] = (map[b] || 0) + 1);\n\tconst keys = Object.keys(map).sort((k1, k2) => map[k1] - map[k2]);\n\n\tlet idx = 1;\n\tfor (let k of keys) {\n\t\tlet t = map[k];\n\n\t\tfor (let i = 0; i < t; i++) {\n\t\t\tif (idx >= barcodes.length) idx = 0;\n\t\t\tbarcodes[idx] = k;\n\t\t\tidx += 2;\n\t\t}\n\t}\n\n\treturn barcodes;\n};\n\n// another\n\n/**\n * @param {number[]} barcodes\n * @return {number[]}\n */\nconst rearrangeBarcodes = function(barcodes) {\n  const hash = {}, n = barcodes.length\n  for(let e of barcodes) {\n    if(hash[e] == null) hash[e] = 0\n    hash[e]++\n  }\n  const res = Array(n)\n  let max = 0, idx = -1\n  for(let k in hash) {\n    if(hash[k] > max) {\n      max = hash[k]\n      idx = +k\n    }\n  }\n  let i = 0\n  // max freq first\n  while(max > 0) {\n    res[i] = idx\n    max--\n    i += 2\n  }\n  // the rest\n  const keys = Object.keys(hash).map(e => +e)\n  for(let j = 0, len = keys.length; j < len; j++) {\n    if(keys[j] !== idx) {\n      const k = keys[j]\n      let freq = hash[k]\n      while(freq > 0) {\n        if(i >= n) i = 1\n        res[i] = k\n        freq--\n        i += 2\n      }\n    }\n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "1056-confusing-number",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {boolean}\n */\nconst confusingNumber = function(n) {\n  //  0, 1, 6, 8, 9\n  const invalid = new Set(['2', '3', '4', '5', '7'])\n  const valid = new Set(['6', '9'])\n  const arr = ('' + n).split('')\n  let num = 0\n  for(let i = 0; i < arr.length; i++) {\n    const ch = arr[i]\n    if(invalid.has(ch)) return false\n    if(ch === '6') arr[i] = '9'\n    else if(ch  === '9') arr[i] = '6'\n  }\n  arr.reverse()\n  return arr.join('') !== '' + n\n};\n"
    }
  },
  {
    "name": "1059-all-paths-from-source-lead-to-destination",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @param {number} source\n * @param {number} destination\n * @return {boolean}\n */\nconst leadsToDestination = function(n, edges, source, destination) {\n  const inm = new Map(), outm = new Map()\n  for(let k = 0, len = edges.length; k < len; k++) {\n    const [o, i] = edges[k]\n    if(!inm.has(i)) inm.set(i, new Set())\n    if(!outm.has(o)) outm.set(o, new Set())\n    inm.get(i).add(o)\n    outm.get(o).add(i)\n  }\n  const visited = new Set()\n  const obj = { res: true }\n  dfs(source)\n  return obj.res\n  function dfs(node) {\n    if((outm.get(node) == null || outm.get(node).size === 0) && node !== destination) {\n      obj.res = false\n      return\n    }\n    if(visited.has(node)) {\n      obj.res = false\n      return\n    }\n    if(outm.get(node) == null) return\n    visited.add(node)\n    for(let e of outm.get(node)) {\n      if(obj.res) dfs(e)\n    }\n    visited.delete(node)\n  }\n};\n"
    }
  },
  {
    "name": "106-construct-binary-tree-from-inorder-and-postorder-traversal",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {number[]} inorder\n * @param {number[]} postorder\n * @return {TreeNode}\n */\n\nconst buildTree = function(inorder, postorder) {\n  const inmap = {};\n  const posts = postorder;\n  for (let i = 0; i < inorder.length; i++) {\n    inmap[inorder[i]] = i;\n  }\n  return helper(postorder.length - 1, 0, inorder.length - 1);\n\n  function helper(postEnd, inStart, inEnd) {\n    if (postEnd < 0 || inEnd < inStart) return null;\n    const val = posts[postEnd];\n    const idx = inmap[\"\" + val];\n    const root = new TreeNode(val);\n    root.left = helper(postEnd - (inEnd - idx) - 1, inStart, idx - 1);\n    root.right = helper(postEnd - 1, idx + 1, inEnd);\n\n    return root;\n  }\n};\n\n// another\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {number[]} inorder\n * @param {number[]} postorder\n * @return {TreeNode}\n */\n\nconst buildTree = function (inorder, postorder) {\n  let pInorder = inorder.length - 1\n  let pPostorder = postorder.length - 1\n  return helper(inorder, postorder, null)\n  function helper(inorder, postorder, end) {\n    if (pPostorder < 0) return null\n    // create root node\n    const n = new TreeNode(postorder[pPostorder--])\n    // if right node exist, create right subtree\n    if (inorder[pInorder] != n.val) {\n      n.right = helper(inorder, postorder, n)\n    }\n    pInorder--\n    // if left node exist, create left subtree\n    if (end === null || inorder[pInorder] !== end.val) {\n      n.left = helper(inorder, postorder, end)\n    }\n    return n\n  }\n}\n"
    }
  },
  {
    "name": "1060-missing-element-in-sorted-array",
    "code": {
      "JS": "/**\n\nGiven a sorted array A of unique numbers, find the K-th missing number\nstarting from the leftmost number of the array.\n\nExample 1:\n\nInput: A = [4,7,9,10], K = 1\nOutput: 5\nExplanation: \nThe first missing number is 5.\nExample 2:\n\nInput: A = [4,7,9,10], K = 3\nOutput: 8\nExplanation: \nThe missing numbers are [5,6,8,...], hence the third missing number is 8.\nExample 3:\n\nInput: A = [1,2,4], K = 3\nOutput: 6\nExplanation: \nThe missing numbers are [3,5,6,7,...], hence the third missing number is 6.\n \nNote:\n\n1 <= A.length <= 50000\n1 <= A[i] <= 1e7\n1 <= K <= 1e8\n\n*/\n\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nconst missingElement = function(nums, k) {\n  for (let i = 1, len = nums.length; i < len; i++) {\n    const dif = nums[i] - nums[i - 1] - 1\n    if (dif >= k) {\n      return nums[i - 1] + k\n    }\n    k -= dif\n  }\n  return nums[nums.length - 1] + k\n}\n\n// another\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nconst missingElement = function(nums, k) {\n  const n = nums.length\n  let l = 0\n  let h = n - 1\n  const missingNum = nums[n - 1] - nums[0] + 1 - n\n  if (missingNum < k) {\n    return nums[n - 1] + k - missingNum\n  }\n  while (l < h - 1) {\n    const m = l + ((h - l) >> 1)\n    const missing = nums[m] - nums[l] - (m - l)\n    if (missing >= k) {\n      h = m\n    } else {\n      k -= missing\n      l = m\n    }\n  }\n  return nums[l] + k\n}\n\n// another\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nconst missingElement = function(nums, k) {\n  const n = nums.length\n  if (k > missing(nums, n - 1)) return nums[n - 1] + k - missing(nums, n - 1)\n  let left = 0,\n    right = n - 1,\n    pivot\n  while (left < right) {\n    pivot = left + Math.floor((right - left) / 2)\n    if (missing(nums, pivot) < k) left = pivot + 1\n    else right = pivot\n  }\n  return nums[left - 1] + k - missing(nums, left - 1)\n}\nfunction missing(arr, idx) {\n  return arr[idx] - arr[0] - idx\n}\n\n"
    }
  },
  {
    "name": "1062-longest-repeating-substring",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst longestRepeatingSubstring = function(s) {\n  let left = 0;\n  let right = s.length - 1;\n  while(left < right) {\n    let pivot = Math.floor((left + right + 1) / 2);\n    if (hasRepeat(s, pivot)) {\n      left = pivot;\n    } else {\n      right = pivot - 1;\n    }\n  }\n  return left;\n};\n\nconst hasRepeat = (s, l) => {\n  const strings = new Set();\n  for (let i = 0; i < s.length - l + 1; i++) {\n    const sub = s.substr(i, l);\n    if (strings.has(sub)) {\n      return true;\n    }\n    strings.add(sub);\n  }\n  return false;\n}\n\n// another\n\n/**\n * @param {string} s\n * @return {number}\n */\nconst longestRepeatingSubstring = function(s) {\n    const n = s.length;\n    // dp[i][j] means # of repeated chars for substrings ending at i and j\n    const dp = Array.from({ length: n + 1 }, () => Array(n + 1).fill(0));\n    let res = 0;\n    for (let i = 1; i <= n; i++) {\n        for (let j = i + 1; j <= n; j++) {\n            if (s.charAt(i - 1) === s.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n                res = Math.max(res, dp[i][j]);\n            }\n        }\n    }\n    return res;\n};\n\n// non-overlap version\n// http://nriverwang.blogspot.com/2013/04/longest-repeated-substring.html\n\n/*\nYou are to find the longest repeated substring in a given text. \nRepeated substrings may not overlap. If more than one substring is \nrepeated with the same length, print the first one you find.(starting \nfrom the beginning of the text). NOTE: The substrings can't be all spaces.\n\nInput Sample:\nYour program should accept as its first argument a path to a filename. \nThe input file contains several lines. Each line is one test case.\nEach line contains a test string. eg.\n\nbanana\nabc\n\nOutput Sample:\nFor each set of input produce a single line of output which is the \nlongest repeated substring. If there is none, print out the string NONE. eg.\nan\nNONE\n\nstd::string repeated_substring(std::string &str) {\n    int len = str.length();\n\n    int **c = new int*[len + 1];\n    for (int i = 0; i <= len; ++i)\n        c[i] = new int[len + 1];\n    for (int i = 0; i <= len; ++i) {\n        c[i][0] = 0;\n        c[0][i] = 0;\n    }\n\n    int max_len = 0, index = len + 1;\n    for (int i = 1; i <= len; ++i) {\n        for (int j = 1; j <= len; ++j) {\n            if (str[i-1] == str[j-1] && abs(i-j) > c[i-1][j-1]) {\n                c[i][j] = c[i-1][j-1] + 1;\n                if (c[i][j] > max_len) {\n                    max_len = c[i][j];\n                    index = std::min(i, j);\n                }\n            } else {\n                c[i][j] = 0;\n            }\n        }\n    }\n    \n    for (int i = 0; i <= len; ++i)\n        delete[] c[i];\n    delete[] c;\n \n    if (max_len > 0) {\n        std::string ret = str.substr(index - max_len, max_len);\n        for (int i = 0; i < max_len; ++i)\n            if(ret[i] != ' ')\n                return ret;\n    }\n\n    return \"NONE\";\n}\n\n*/\n"
    }
  },
  {
    "name": "1064-fixed-point",
    "code": {
      "JS": "/**\n * @param {number[]} arr\n * @return {number}\n */\nconst fixedPoint = function(arr) {\n  const n = arr.length\n  let l = 0, r = n - 1\n  while(l < r) {\n    const mid = l + ((r - l) >> 1)\n    if(arr[mid] < mid) l =  mid + 1\n    else if(arr[mid] > mid) r = mid - 1\n    else r = mid\n  }\n  return arr[l] === l ? l : -1\n};\n"
    }
  },
  {
    "name": "1065-index-pairs-of-a-string",
    "code": {
      "JS": "/**\n * @param {string} text\n * @param {string[]} words\n * @return {number[][]}\n */\nconst indexPairs = function(text, words) {\n  const res = [], trie = buildTrie(words)\n  const n = text.length\n  for(let i = 0; i < n; i++) {\n    let node = trie\n    for(let j = i; j < n; j++) {\n      if(node.children[text[j]] == null) break\n      node = node.children[text[j]]\n      if(node.isWord) res.push([i, j])\n    }\n  }\n\n  return res\n};\n\nfunction buildTrie(words) {\n  const root = new Trie()\n  \n  for(let word of words) {\n    let node = root\n    for(let c of word) {\n      if(node.children[c] == null) node.children[c] = new Trie()\n      node = node.children[c]\n    }\n    node.isWord = true\n  }\n\n  return root\n}\n\nclass Trie {\n  constructor() {\n    this.children = {}\n    this.isWord = false\n  }\n}\n"
    }
  },
  {
    "name": "1066-campus-bikes-ii",
    "code": {
      "JS": "/**\n * @param {number[][]} workers\n * @param {number[][]} bikes\n * @return {number}\n */\nconst assignBikes = function(workers, bikes) {\n  const n = workers.length, m = bikes.length\n  let res = Infinity\n  dfs(0, 0, 0)\n  return res\n  function dfs(i, mask, cur) {\n    if(i === n) {\n      res = Math.min(res, cur)\n      return\n    }\n    for(let j = 0; j < m; j++) {\n      if((mask & (1 << j)) === 0) {\n        dfs(i + 1, mask | (1 << j), cur + calc(i, j))\n      }\n    }\n  }\n\n  function calc(i, j) {\n    const a = workers[i], b = bikes[j]\n    return Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1])\n  }\n\n};\n\n// another\n\n/**\n * @param {number[][]} workers\n * @param {number[][]} bikes\n * @return {number}\n */\nconst assignBikes = function(workers, bikes) {\n  const n = workers.length, m = bikes.length\n  const dp = Array(1 << m).fill(Infinity)\n  return dfs(0, 0)\n \n  function dfs(i, mask) {\n    if(i >= workers.length) return 0\n    if(dp[mask] !== Infinity) return dp[mask]\n    for(let j = 0; j < bikes.length; j++) {\n      if((mask & (1 << j)) === 0) {\n         dp[mask] = Math.min(dp[mask], dist(i, j) + dfs(i + 1, mask + (1 << j)))\n      }\n    }\n    \n    return dp[mask]\n  }\n  \n  function dist(j, i) {\n    return Math.abs(bikes[i][0] - workers[j][0]) + Math.abs(bikes[i][1] - workers[j][1])\n  }\n};\n\n// another\n\n/**\n * @param {number[][]} workers\n * @param {number[][]} bikes\n * @return {number}\n */\nconst assignBikes = function (workers, bikes) {\n  const n = workers.length\n  const m = bikes.length\n  const dp = Array.from({ length: n + 1 }, () =>\n    Array(1 << m).fill(Number.MAX_VALUE / 2)\n  )\n\n  dp[0][0] = 0\n  let min = Number.MAX_VALUE\n  for (let i = 1; i <= n; i++) {\n    for (let s = 1; s < 1 << m; s++) {\n      for (let j = 0; j < m; j++) {\n        if ((s & (1 << j)) === 0) continue\n        let prev = s ^ (1 << j)\n        dp[i][s] = Math.min(\n          dp[i - 1][prev] + dis(workers[i - 1], bikes[j]),\n          dp[i][s]\n        )\n        if (i === n) min = Math.min(min, dp[i][s])\n      }\n    }\n  }\n  return min\n}\n\nfunction dis(p1, p2) {\n  return Math.abs(p1[0] - p2[0]) + Math.abs(p1[1] - p2[1])\n}\n"
    }
  },
  {
    "name": "1067-digit-count-in-range",
    "code": {
      "JS": "/**\n * @param {number} d\n * @param {number} low\n * @param {number} high\n * @return {number}\n */\nconst digitsCount = function (d, low, high) {\n  return countDigit(high, d) - countDigit(low - 1, d)\n\n  function countDigit(n, d) {\n    if (n < 0 || n < d) {\n      return 0\n    }\n    let count = 0\n    for (let i = 1; i <= n; i *= 10) {\n      let divider = i * 10\n      count += ((n / divider) >> 0) * i\n      if (d > 0) {\n        // tailing number need to be large than d *  i to qualify.\n        count += Math.min(Math.max((n % divider) - d * i + 1, 0), i)\n      } else {\n        if (n / divider > 0) {\n          if (i > 1) {\n            // when d == 0, we need avoid to take numbers like 0xxxx into account.\n            count -= i\n            count += Math.min((n % divider) + 1, i)\n          }\n        }\n      }\n    }\n    return count\n  }\n}\n"
    }
  },
  {
    "name": "107-binary-tree-level-order-traversal-ii",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nconst levelOrderBottom = function(root) {\n  const levels = []\n  postOrderTraversal(root)\n  return levels.reverse()\n\n  function postOrderTraversal(node, level = 0) {\n    if (node) {\n      if (!levels[level]) levels.push([])\n      postOrderTraversal(node.left, level + 1)\n      postOrderTraversal(node.right, level + 1)\n      levels[level].push(node.val)\n    }\n  }\n}\n\n// another\n\nconst levelOrderBottom = function(root) {\n  if (!root) return []\n  const currentLevelNodes = [root]\n  const result = []\n  while (currentLevelNodes.length > 0) {\n    const count = currentLevelNodes.length\n    const currentLevelValues = []\n    for (let i = 0; i < count; i++) {\n      const node = currentLevelNodes.shift()\n      currentLevelValues.push(node.val)\n      if (node.left) currentLevelNodes.push(node.left)\n      if (node.right) currentLevelNodes.push(node.right)\n    }\n    result.unshift(currentLevelValues)\n  }\n  return result\n}\n"
    }
  },
  {
    "name": "1071-greatest-common-divisor-of-strings",
    "code": {
      "JS": "/**\n * @param {string} str1\n * @param {string} str2\n * @return {string}\n */\nconst gcdOfStrings = function(str1, str2) {\n  let res = \"\";\n\n  if (str1[0] !== str2[0]) return res;\n  if (str1[str1.length - 1] !== str2[str2.length - 1]) return res;\n  let s = str1[0];\n  let e = str1[str1.length - 1];\n\n  let loopStr = str1.length > str2.length ? str2 : str1;\n  for (let i = 1, len = loopStr.length; i < len; i++) {\n    if (loopStr[i] !== e) continue;\n    let tmp = loopStr.slice(0, i + 1);\n    let ok1 = false;\n    let ok2 = false;\n    let t1 = \"\";\n    let t2 = \"\";\n    while (t1.length < str1.length) {\n      t1 += tmp;\n      if (t1 === str1) {\n        ok1 = true;\n        break;\n      }\n    }\n    while (t2.length < str2.length) {\n      t2 += tmp;\n      if (t2 === str2) {\n        ok2 = true;\n        break;\n      }\n    }\n\n    if (ok1 && ok2 && tmp.length > res.length) res = tmp;\n  }\n\n  return res;\n};\n"
    }
  },
  {
    "name": "1072-flip-columns-for-maximum-number-of-equal-rows",
    "code": {
      "JS": "/**\n * @param {number[][]} matrix\n * @return {number}\n */\nconst maxEqualRowsAfterFlips = function(matrix) {\n  let n = matrix.length,\n    m = matrix[0].length;\n  let ret = 0;\n  for (let i = 0; i < n; i++) {\n    let ct = 0;\n    inner: for (let j = i; j < n; j++) {\n      if (ae(matrix[i], matrix[j])) {\n        ct++;\n      } else {\n        for (let k = 0; k < m; k++) {\n          if (matrix[i][k] + matrix[j][k] !== 1) continue inner;\n        }\n        ct++;\n      }\n    }\n    ret = Math.max(ret, ct);\n  }\n  return ret;\n};\n\nfunction ae(a1, a2) {\n  if (a1.length !== a2.length) return false;\n  for (let i = 0; i < a1.length; i++) {\n    if (a1[i] !== a2[i]) return false;\n  }\n  return true;\n}\n"
    }
  },
  {
    "name": "1073-adding-two-negabinary-numbers",
    "code": {
      "JS": "/**\n * @param {number[]} arr1\n * @param {number[]} arr2\n * @return {number[]}\n */\nconst addNegabinary = function(arr1, arr2) {\n  let ret = [];\n  arr1.reverse();\n  arr2.reverse();\n  let n = arr1.length,\n    m = arr2.length,\n    g = 0;\n  for (let i = 0; i < Math.max(n, m); i++) {\n    let s = g;\n    if (i < n) s += arr1[i];\n    if (i < m) s += arr2[i];\n    g = (s / -2) >> 0;\n    if (s + g * 2 < 0) g++;\n    ret.push(s + g * 2);\n  }\n  while (g) {\n    let s = g;\n    g = (s / -2) >> 0;\n    if (s + g * 2 < 0) g++;\n    ret.push(s + g * 2);\n  }\n  while (ret.length > 1 && ret[ret.length - 1] == 0) ret.pop();\n  ret.reverse();\n  return ret;\n};\n"
    }
  },
  {
    "name": "1074-number-of-submatrices-that-sum-to-target",
    "code": {
      "JS": "/**\n * @param {number[][]} matrix\n * @param {number} target\n * @return {number}\n */\nconst numSubmatrixSumTarget = function(matrix, target) {\n    let a = matrix\n    let n = a.length, m = a[0].length;\n    const cum = Array.from({length: n + 1}, () => new Array(m + 1).fill(0));\n    for(let i = 0;i < n;i++){\n      for(let j = 0;j < m;j++){\n        cum[i+1][j+1] = cum[i+1][j] + cum[i][j+1] - cum[i][j] + a[i][j];\n      }\n    }\n\n    let ans = 0;\n    for(let i = 0;i < n;i++){\n      for(let j = i;j < n;j++){\n        let map = new Map();\n        for(let k = 0;k <= m;k++){\n          let v = cum[j+1][k] - cum[i][k];\n          if(map.has(v - target)){\n            ans += map.get(v-target);\n          }\n          if(map.has(v)){\n            map.set(v, map.get(v)+1);\n          }else{\n            map.set(v, 1);\n          }\n        }\n      }\n    }\n    return ans;\n};\n"
    }
  },
  {
    "name": "1079-letter-tile-possibilities",
    "code": {
      "JS": "/**\n * @param {string} tiles\n * @return {number}\n */\nconst numTilePossibilities = function(tiles) {\n  const obj = { count: 0 };\n  dfs(tiles, new Array(tiles.length).fill(false), new Set(), \"\", obj);\n  return obj.count;\n};\n\nfunction dfs(tiles, used, visited, path, obj) {\n  if (path !== \"\" && !visited.has(path)) obj.count++;\n  visited.add(path)\n\n  for (let i = 0; i < tiles.length; i++) {\n    if (used[i]) continue;\n    used[i] = true;\n    dfs(tiles, used, visited, path + tiles.charAt(i), obj);\n    used[i] = false;\n  }\n}\n\n// another\n\n/**\n * @param {string} tiles\n * @return {number}\n */\nconst numTilePossibilities = function(tiles) {\n  let used = new Array(tiles.length).fill(false);\n  let visited = new Set();\n  let cnt = 0;\n  const dfs = (path) => {\n    if (path.length && !visited.has(path)) {\n      visited.add(path);\n      cnt++;\n    }\n    for (let i = 0; i < tiles.length; i++) {\n      if (used[i]) continue;\n      used[i] = true;\n      dfs(path + tiles[i]);\n      used[i] = false;\n    }\n  }\n  dfs('');\n  return cnt;\n};\n\n// another\n\n/**\n * @param {string} tiles\n * @return {number}\n */\nconst numTilePossibilities = function(tiles) {\n  const count = new Array(26).fill(0)\n  const ACode = 'A'.charCodeAt(0)\n  for (let i = 0, len = tiles.length; i < len; i++) {\n    count[tiles.charCodeAt(i) - ACode]++\n  }\n  return dfs(count)\n}\n\nfunction dfs(arr) {\n  let sum = 0\n  for (let i = 0; i < 26; i++) {\n    if (arr[i] === 0) continue\n    sum++\n    arr[i]--\n    sum += dfs(arr)\n    arr[i]++\n  }\n  return sum\n}\n"
    }
  },
  {
    "name": "108-convert-sorted-array-to-binary-search-tree",
    "code": {
      "JS": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n/**\r\n * @param {number[]} nums\r\n * @return {TreeNode}\r\n */\r\nconst sortedArrayToBST = function(nums) {\r\n  if (nums.length == 0) {\r\n    return null;\r\n  }\r\n  const head = helper(nums, 0, nums.length - 1);\r\n  return head;\r\n};\r\n\r\nfunction helper(num, low, high) {\r\n  if (low > high) {\r\n    // Done\r\n    return null;\r\n  }\r\n  let mid = Math.floor((low + high) / 2);\r\n  let node = new TreeNode(num[mid]);\r\n  node.left = helper(num, low, mid - 1);\r\n  node.right = helper(num, mid + 1, high);\r\n  return node;\r\n}\r\n"
    }
  },
  {
    "name": "1081-smallest-subsequence-of-distinct-characters",
    "code": {
      "JS": "/**\n * @param {string} text\n * @return {string}\n */\nconst smallestSubsequence = function(text) {\n  if (text === '') return ''\n  let counter = new Array(128).fill(0)\n  for (let i = 0; i < text.length; i++) counter[text.charCodeAt(i)]++\n  let minChar = 128\n  let minIndex = 0\n  for (let i = 0; i < text.length; i++) {\n    let c = text.charCodeAt(i)\n    if (c < minChar) {\n      minChar = c\n      minIndex = i\n    }\n    if (--counter[c] === 0) {\n      return (\n        String.fromCharCode(minChar) +\n        smallestSubsequence(\n          text\n            .slice(minIndex + 1)\n            .replace(new RegExp(String.fromCharCode(minChar), 'g'), '')\n        )\n      )\n    }\n  }\n  return ''\n}\n\n// another\n\n/**\n * @param {string} text\n * @return {string}\n */\nconst smallestSubsequence = function(s) {\n  let res = []\n  const count = new Array(26).fill(0)\n  const used = new Array(26).fill(0)\n  const aCode = 'a'.charCodeAt(0)\n  for (let el of s) count[el.charCodeAt(0) - aCode]++\n  for (let el of s) {\n    count[el.charCodeAt(0) - aCode]--\n    if (used[el.charCodeAt(0) - aCode]++ > 0) continue\n    while (\n      res.length &&\n      res[res.length - 1].charCodeAt(0) > el.charCodeAt(0) &&\n      count[res[res.length - 1].charCodeAt(0) - aCode] > 0\n    ) {\n      used[res[res.length - 1].charCodeAt(0) - aCode] = 0\n      res.pop()\n    }\n    res.push(el)\n  }\n  return res.join('') \n};\n\n// anoother\n\n\n/**\n * @param {string} text\n * @return {string}\n */\nconst smallestSubsequence = function(text) {\n  const n = text.length, stack = [], last = {}, visited = {}\n  for(let i = 0; i < n; i++) last[text[i]] = i\n  for(let i = 0; i < n; i++) {\n    const ch = text[i]\n    if (visited[ch]) continue\n    while(stack.length && stack[stack.length - 1] > ch && last[stack[stack.length - 1]] > i) {\n      visited[stack[stack.length - 1]] = 0\n      stack.pop()\n    }\n    visited[ch] = 1\n    stack.push(ch)\n  }\n\n  return stack.join('')\n};\n"
    }
  },
  {
    "name": "1085-sum-of-digits-in-the-minimum-number",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst sumOfDigits = function(nums) {\n  let min = Math.min(...nums);\n  let ans = 0;\n  while (min > 0) {\n      ans += min % 10;\n      min = ~~(min / 10);\n  }\n  return 1 - ans % 2;\n};\n"
    }
  },
  {
    "name": "1086-high-five",
    "code": {
      "JS": "/**\n\nGiven a list of scores of different students, return the average score\nof each student's top five scores in the order of each student's id.\n\nEach entry items[i] has items[i][0] the student's id, and items[i][1]\nthe student's score.  The average score is calculated using integer division.\n\nExample 1:\n\nInput: [[1,91],[1,92],[2,93],[2,97],[1,60],[2,77],[1,65],[1,87],[1,100],[2,100],[2,76]]\nOutput: [[1,87],[2,88]]\nExplanation: \nThe average of the student with id = 1 is 87.\nThe average of the student with id = 2 is 88.6. But with integer division\ntheir average converts to 88.\n\nNote:\n\n1 <= items.length <= 1000\nitems[i].length == 2\nThe IDs of the students is between 1 to 1000\nThe score of the students is between 1 to 100\nFor each student, there are at least 5 scores\n\n*/\n\n/**\n * @param {number[][]} items\n * @return {number[][]}\n */\nconst highFive = function(items) {\n  const m = {}\n  for(let el of items) {\n    const key = '' + el[0]\n    if(!m.hasOwnProperty(key)) m[key] = []\n    add(m[key], el[1])\n  }\n  const res = []\n  Object.entries(m).forEach(el => {\n    res.push([+el[0], div(el[1])])\n  })\n  return res.sort((a, b) => a[0] - b[0])\n};\n\nfunction div(arr) {\n  let sum = 0\n  arr.forEach(el => sum += el)\n  return sum / 5 >> 0\n}\n\nfunction add(arr, val) {\n  if(arr.length < 5) arr.push(val)\n  else {\n    let min = Number.MAX_VALUE\n    let idx = -1\n    for(let i = 0, len = arr.length; i < len; i++) {\n      if(arr[i] < min) {\n        min = arr[i]\n        idx = i\n      }\n    }\n    if(val > min && idx !== -1) {\n      arr.splice(idx, 1, val)\n    }\n  }\n}\n"
    }
  },
  {
    "name": "1087-brace-expansion",
    "code": {
      "JS": "/**\n * @param {string} S\n * @return {string[]}\n */\nconst expand = function(S) {\n  const arr = []\n  let cur = ''\n  for (let i = 0, len = S.length; i < len; i++) {\n    const ch = S.charAt(i)\n    if (ch === '{') {\n      if (cur) arr.push(cur)\n      cur = []\n    } else if (ch === '}') {\n      arr.push(cur.sort())\n      cur = ''\n    } else if (ch === ',') {\n    } else {\n      if (typeof cur === 'string' || cur === '') {\n        cur += ch\n      } else {\n        cur.push(ch)\n      }\n    }\n  }\n  arr.push(cur)\n  const res = []\n  bt(arr, 0, '', res)\n  return res\n}\nfunction bt(arr, i, cur, res) {\n  if (i === arr.length) {\n    res.push(cur)\n    return\n  }\n  if (typeof arr[i] === 'string') {\n    cur += arr[i]\n    bt(arr, i + 1, cur, res)\n  } else {\n    for (let j = 0, len = arr[i].length; j < len; j++) {\n      let bak = cur\n      cur += arr[i][j]\n      bt(arr, i + 1, cur, res)\n      cur = bak\n    }\n  }\n}\n"
    }
  },
  {
    "name": "1088-confusing-number-ii",
    "code": {
      "JS": "/**\n * @param {number} N\n * @return {number}\n */\nconst confusingNumberII = function (N) {\n  const valid = [\n    [0, 0],\n    [1, 1],\n    [6, 9],\n    [8, 8],\n    [9, 6],\n  ]\n  function dfs(num, rotated, order) {\n    let count = 0\n    if (num !== rotated) count++\n    for (const [dig, rot] of valid) {\n      if (num === 0 && dig === 0) continue\n      if (num * 10 + dig > N) break\n      count += dfs(num * 10 + dig, rot * order + rotated, order * 10)\n    }\n    return count\n  }\n  return dfs(0, 0, 1)\n}\n"
    }
  },
  {
    "name": "1089-duplicate-zeros",
    "code": {
      "JS": "/**\n * @param {number[]} arr\n * @return {void} Do not return anything, modify arr in-place instead.\n */\nconst duplicateZeros = function(arr) {\n  const len = arr.length\n  for (let i = len - 1; i >= 0; i--) {\n    if (arr[i] === 0) arr.splice(i, 0, 0)\n  }\n  while (arr.length > len) {\n    arr.pop()\n  }\n}\n"
    }
  },
  {
    "name": "109-convert-sorted-list-to-binary-search-tree",
    "code": {
      "JS": "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nconst sortedListToBST = function(head) {\n    if(head == null) return null\n    const arr = []\n    let cur = head\n    while(cur !== null) {\n        arr.push(cur)\n        cur = cur.next\n    }\n    return build(arr, null, '')\n};\n\nfunction build(arr, parent, type) {\n    if(arr.length === 0) return\n    let mid = Math.floor(arr.length / 2)\n    let left = arr.slice(0, mid)\n    let right = arr.slice(mid + 1)\n    const node = new TreeNode(arr[mid].val)\n    if(parent) parent[type] = node\n    build(left, node, 'left')\n    build(right, node, 'right')\n    return node\n}\n\n// another\n\nconst sortedListToBST = function(head, tail = null) {\n    if (head === tail) {\n        return null;\n    } else if (head.next === tail) {\n        return new TreeNode(head.val);\n    } else {\n        let slow = head; \n        let fast = head;\n        while (fast !== tail && fast.next !== tail) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        let node = new TreeNode(slow.val);\n        node.left = sortedListToBST(head, slow);\n        node.right = sortedListToBST(slow.next, tail);\n        return node;\n    }\n};\n"
    }
  },
  {
    "name": "1090-largest-values-from-labels",
    "code": {
      "JS": "/**\n * @param {number[]} values\n * @param {number[]} labels\n * @param {number} num_wanted\n * @param {number} use_limit\n * @return {number}\n */\nconst largestValsFromLabels = function(values, labels, num_wanted, use_limit) {\n  return Object.entries(\n    labels.reduce((ret, l, i) => {\n      ret[l] = (ret[l] || []).concat(values[i])\n      return ret\n    }, {})\n  )\n    .reduce(\n      (candi, [k, vals]) =>\n        candi.concat(vals.sort((a, b) => b - a).slice(0, use_limit)),\n      []\n    )\n    .sort((a, b) => b - a)\n    .slice(0, num_wanted)\n    .reduce((ret, n) => ret + n, 0)\n};\n"
    }
  },
  {
    "name": "1091-shortest-path-in-binary-matrix",
    "code": {
      "JS": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nconst shortestPathBinaryMatrix = function(grid) {\n  if(grid == null || grid.length === 0 || grid[0][0] === 1) return -1 \n  let res = 1\n  const n = grid.length\n  const dirs = [\n    [1, 0],\n    [-1, 0],\n    [0, 1],\n    [0, -1],\n    [-1, -1],\n    [-1, 1],\n    [1, 1],\n    [1, -1],\n  ]\n  let q = [[0, 0]]\n  while(q.length) {\n    const tmp = q\n    q = []\n    for(let [x, y] of tmp) {\n      if (x < 0 || x >= n || y < 0 || y >= n || grid[x][y] !== 0) continue\n      if(x === n - 1 && y === n - 1) return res\n      grid[x][y] = 1\n      for(let [dx, dy] of dirs) {    \n        q.push([x + dx, y + dy])\n      }\n    }\n    res++\n  }\n  return -1\n};\n\n// another\n\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nconst shortestPathBinaryMatrix = function(grid) {\n  if(grid == null || grid.length === 0 || grid[0][0] === 1) return -1 \n  let res = 1\n  const n = grid.length\n  const dirs = [\n    [1, 0],\n    [-1, 0],\n    [0, 1],\n    [0, -1],\n    [-1, -1],\n    [-1, 1],\n    [1, 1],\n    [1, -1],\n  ]\n  let q = [[0, 0]]\n  while(q.length) {\n    let ref = q\n    q = []\n    for(let [x, y] of ref) {\n      if(x === n - 1 && y === n - 1) return res\n      grid[x][y] = 1\n      for(let [dx, dy] of dirs) {\n        const nx = x + dx, ny = y + dy\n        if(helper(grid, nx, ny)) {\n          q.push([nx, ny])\n          grid[nx][ny] = 1 // very important\n        }\n      }\n    }\n    res++\n  }\n  return -1\n};\n\nfunction helper(grid, i, j) {\n  const n = grid.length\n  if(i < 0 || i >= n || j < 0 || j >= n || grid[i][j] !== 0) return false\n  return true\n}\n"
    }
  },
  {
    "name": "1092-shortest-common-supersequence",
    "code": {
      "JS": "/**\n * @param {string} str1\n * @param {string} str2\n * @return {string}\n */\nconst shortestCommonSupersequence = function(str1, str2) {\n  const len1 = str1.length\n  const len2 = str2.length\n  const mat = Array.from({ length: len1 + 1 }, () =>\n    new Array(len2 + 1).fill(0)\n  )\n  for (let i = 0; i <= len1; i++) {\n    for (let j = 0; j <= len2; j++) {\n      if (i == 0) {\n        mat[i][j] = str2.slice(0, j)\n        continue\n      }\n      if (j == 0) {\n        mat[i][j] = str1.slice(0, i)\n        continue\n      }\n      mat[i][j] = mat[i - 1][j] + str1[i - 1]\n      let cand1 = mat[i][j - 1] + str2[j - 1]\n      if (cand1.length < mat[i][j].length) mat[i][j] = cand1\n      if (str1[i - 1] === str2[j - 1]) {\n        let cand2 = mat[i - 1][j - 1] + str1[i - 1]\n        if (cand2.length < mat[i][j].length) mat[i][j] = cand2\n      }\n    }\n  }\n  return mat[len1][len2]\n}\n"
    }
  },
  {
    "name": "1093-statistics-from-a-large-sample",
    "code": {
      "JS": "/**\n * @param {number[]} count\n * @return {number[]}\n */\nconst sampleStats = function(count) {\n  const n = count.length\n  let numElems = 0\n  let sum = 0\n  let min = n - 1\n  let max = 0\n  let modVal = 0\n  let modIdx = 0\n  for (let i = 0; i < n; i++) {\n    if (count[i]) {\n      min = Math.min(i, min)\n      max = Math.max(i, max)\n      if (count[i] > modVal) {\n        modVal = count[i]\n        modIdx = i\n      }\n      sum += i * count[i]\n      numElems += count[i]\n    }\n  }\n  const half = Math.floor(numElems / 2)\n  let median\n  for (let i = 0, c = 0, last = 0; i < n; i++) {\n    if (count[i]) {\n      c += count[i]\n      if (c > half) {\n        if (numElems % 2 === 0 && c - count[i] === half) {\n          median = (i + last) / 2\n        } else {\n          median = i\n        }\n        break\n      }\n      last = i\n    }\n  }\n  return [min, max, sum / numElems, median, modIdx]\n}\n"
    }
  },
  {
    "name": "1094-car-pooling",
    "code": {
      "JS": "/**\n * @param {number[][]} trips\n * @param {number} capacity\n * @return {boolean}\n */\nconst carPooling = function(trips, capacity) {\n  let stops = new Array(1001).fill(0)\n  for (let t of trips) {\n    stops[t[1]] += t[0]\n    stops[t[2]] -= t[0]\n  }\n  for (let i = 0; capacity >= 0 && i < 1001; ++i) capacity -= stops[i]\n  return capacity >= 0\n}\n\n// another\n\n/**\n * @param {number[][]} trips\n * @param {number} capacity\n * @return {boolean}\n */\nconst carPooling = function(trips, capacity) {\n  const arr = Array(1001).fill(0)\n  for(let el of trips) {\n    const [num, s, e] = el\n    arr[s] += num\n    arr[e] -= num\n  }\n  for(let i = 1; i < 1001; i++) {\n    if(arr[i] !== 0) arr[i] += arr[i - 1]\n    else arr[i] = arr[i - 1]\n  }\n  for(let e of arr) {\n    if(e > capacity) return false\n  }\n  return true\n};\n"
    }
  },
  {
    "name": "1095-find-in-mountain-array",
    "code": {
      "JS": "/**\n * // This is the MountainArray's API interface.\n * // You should not implement it, or speculate about its implementation\n * function MountainArray() {\n *\n *     @param {integer} index\n *     @return {integer}\n *     this.get = function(index) {\n *         ...\n *     };\n *\n *     @return {integer}\n *     this.length = function() {\n *         ...\n *     };\n * };\n */\n/**\n * @param {number} target\n * @param {MountainArray} mountainArr\n * @return {number}\n */\nconst findInMountainArray = function(target, mountainArr) {\n  const p = findPeak(mountainArr)\n  if (mountainArr.get(p) === target) {\n    return p\n  }\n  const left = binarySeach(mountainArr, 0, p, target, 'asc')\n  if (left > -1) {\n    return left\n  }\n  return binarySeach(mountainArr, p + 1, mountainArr.length(), target, 'dsc')\n}\n\nfunction findPeak(arr) {\n  let left = 0\n  let right = arr.length()\n  while (left < right) {\n    const mid = Math.floor((left + right) / 2)\n    if (arr.get(mid) < arr.get(mid + 1)) {\n      left = mid + 1\n    } else {\n      right = mid\n    }\n  }\n  return left\n}\n\nfunction binarySeach(mountainArr, start, end, target, order) {\n  let left = start\n  let right = end\n  while (left < right) {\n    const mid = Math.floor((left + right) / 2)\n    if (target === mountainArr.get(mid)) {\n      return mid\n    } else if (\n      (target > mountainArr.get(mid) && order === 'asc') ||\n      (target < mountainArr.get(mid) && order === 'dsc')\n    ) {\n      left = mid + 1\n    } else {\n      right = mid\n    }\n  }\n  return -1\n}\n"
    }
  },
  {
    "name": "1096-brace-expansion-ii",
    "code": {
      "JS": "/**\n * @param {string} expression\n * @return {string[]}\n */\nconst braceExpansionII = function (expression) {\n  expression = expression.replace(/([a-z]){1}/g, '{$1}')\n  const stk = new Array()\n  for (let char of expression) {\n    if (char !== '}') {\n      stk.push(char)\n    } else {\n      let str = '',\n        prev = '',\n        temp = ''\n      while (stk[stk.length - 1] != '{') {\n        prev = temp\n        temp = stk.pop()\n        if (temp == ',' || prev == ',' || str == '') str = temp + str\n        else {\n          str = str\n            .split(',')\n            .map((item) => {\n              let ar = new Array()\n              for (let ch of temp.split(',')) ar.push(ch + item)\n              return ar.join(',')\n            })\n            .join(',')\n        }\n      }\n      stk.pop()\n      while (\n        stk.length > 0 &&\n        stk[stk.length - 1] != ',' &&\n        stk[stk.length - 1] != '{'\n      ) {\n        temp = stk.pop()\n        str = str\n          .split(',')\n          .map((item) => {\n            let ar = new Array()\n            for (let ch of temp.split(',')) ar.push(ch + item)\n            return ar.join(',')\n          })\n          .join(',')\n      }\n\n      if (str.length > 0) stk.push(str)\n    }\n  }\n\n  return [...new Set(stk[0].split(','))].sort()\n}\n"
    }
  },
  {
    "name": "1099-two-sum-less-than-k",
    "code": {
      "JS": "/**\n\nGiven an array A of integers and integer K,\nreturn the maximum S such that there exists i < j with A[i] + A[j] = S and S < K.\nIf no i, j exist satisfying this equation, return -1.\n\nExample 1:\n\nInput: A = [34,23,1,24,75,33,54,8], K = 60\nOutput: 58\nExplanation: \nWe can use 34 and 24 to sum 58 which is less than 60.\n\nExample 2:\n\nInput: A = [10,20,30], K = 15\nOutput: -1\nExplanation: \nIn this case it's not possible to get a pair sum less that 15.\n\nNote:\n\n1 <= A.length <= 100\n1 <= A[i] <= 1000\n1 <= K <= 2000\n\n*/\n\n/**\n * @param {number[]} A\n * @param {number} K\n * @return {number}\n */\nconst twoSumLessThanK = function(A, K) {\n  A.sort((a, b) => a - b)\n  let max = -1,\n    i = 0,\n    j = A.length - 1\n  while (i < j) {\n    const sum = A[i] + A[j]\n    if (sum < K) {\n      max = Math.max(max, sum)\n      i++\n    } else {\n      j--\n    }\n  }\n  return max\n}\n"
    }
  },
  {
    "name": "11-container-with-most-water",
    "code": {
      "JS": "/**\r\n * @param {number[]} height\r\n * @return {number}\r\n */\r\nconst maxArea = function(height) {\r\n  let res = 0, l = 0, r = height.length - 1\r\n  while(l < r) {\r\n    const tmp = (r - l) * Math.min(height[l], height[r])\r\n    if(tmp > res) res = tmp\r\n    if(height[l] < height[r]) l++\r\n    else r--\r\n  }\r\n  return res\r\n};\r\n"
    }
  },
  {
    "name": "110-balanced-binary-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nconst isBalanced = function(root) {\n    return check(root) >= 0 ? true : false\n};\n\nconst check = (root) => {\n    if(!root) return 1\n    \n    const left = check(root.left)\n    if( left === -1 ) return -1\n    \n    const right = check(root.right)\n    if( right === -1 ) return -1\n    \n    if(Math.abs(left - right) > 1)return -1\n    \n    return (1 + Math.max(left, right))\n}\n"
    }
  },
  {
    "name": "1103-distribute-candies-to-people",
    "code": {
      "JS": "/**\n * @param {number} candies\n * @param {number} num_people\n * @return {number[]}\n */\nconst distributeCandies = function(candies, num_people) {\n  const n = num_people\n  const res = Array(n).fill(0)\n  let idx = 0, cur = 0\n  while(candies > 0) {\n    cur++\n    res[idx] += Math.min(cur, candies)\n    idx++\n    candies -= cur\n    if(idx === n) idx = 0\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1105-filling-bookcase-shelves",
    "code": {
      "JS": "/**\n * @param {number[][]} books\n * @param {number} shelf_width\n * @return {number}\n */\nconst minHeightShelves = function(books, shelf_width) {\n  const dp = new Array(books.length + 1)\n  dp[0] = 0\n  for(let i = 1; i <= books.length; i++) {\n    let width = books[i - 1][0]\n    let height = books[i - 1][1]\n    dp[i] = dp[i - 1] + height\n    for(let j = i - 1; j > 0 && width + books[j - 1][0] <= shelf_width; j--) {\n      height = Math.max(height, books[j - 1][1])\n      width += books[j - 1][0]\n      dp[i] = Math.min(dp[i], dp[j - 1] + height)\n    }\n  }\n  return dp[books.length]\n};\n\n// another\n\n/**\n * @param {number[][]} books\n * @param {number} shelf_width\n * @return {number}\n */\nconst minHeightShelves = function(books, shelf_width) {\n  const n = books.length, dp = Array(1001).fill(Infinity)\n  dp[0] = 0\n  for(let i = 0; i < n; i++) {\n    let sum = 0, mx = 0\n    for(let j = i; j >= 0 && sum + books[j][0] <= shelf_width; j--) {\n      sum += books[j][0]\n      mx = Math.max(mx, books[j][1])\n      dp[i + 1] = Math.min(dp[i + 1], dp[j] + mx)\n    }\n  }\n  return dp[n]\n};\n\n// another\n\n/**\n * @param {number[][]} books\n * @param {number} shelf_width\n * @return {number}\n */\n const minHeightShelves = function(books, shelf_width) {\n  const n = books.length, dp = Array(1001)\n  dp[0] = 0\n\n  for(let i = 0; i < n; i++) {\n    let [w, h] = books[i]\n    dp[i + 1] = dp[i] + h\n    for(let j = i - 1; j >= 0 && w + books[j][0] <= shelf_width; j--) {\n      h = Math.max(h, books[j][1])\n      w += books[j][0]\n      dp[i + 1] = Math.min(dp[i + 1], dp[j] + h) \n    }\n  }\n\n  return dp[n]\n};\n"
    }
  },
  {
    "name": "1106-parsing-a-boolean-expression",
    "code": {
      "JS": "/**\n * @param {string} expression\n * @return {boolean}\n */\nconst parseBoolExpr = function(expression) {\n  const stack = []\n  for (let ch of expression) {\n    if (ch === '|' || ch === '&' || ch === '!') stack.push(ch)\n    if (ch === 't') stack.push(true)\n    if (ch === 'f') stack.push(false)\n    if (ch === ')') {\n      const tmp = []\n      while (stack.length) {\n        let t = stack.pop()\n        if (t === true || t === false) tmp.push(t)\n        else {\n          let res = tmp.pop()\n          if (t === '|') {\n            while (tmp.length) res = tmp.pop() || res\n          } else if (t === '&') {\n            while (tmp.length) res = tmp.pop() && res\n          } else if (t === '!') {\n            res = !res\n          }\n          stack.push(res)\n          break\n        }\n      }\n    }\n  }\n  return stack[0]\n}\n"
    }
  },
  {
    "name": "1108-defanging-an-ip-address",
    "code": {
      "JS": "/**\n * @param {string} address\n * @return {string}\n */\nconst defangIPaddr = function(address) {\n  return address.split('.').join('[.]')\n};\n"
    }
  },
  {
    "name": "1109-corporate-flight-bookings",
    "code": {
      "JS": "/**\n * @param {number[][]} bookings\n * @param {number} n\n * @return {number[]}\n */\nconst corpFlightBookings = function(bookings, n) {\n  let res = new Array(n).fill(0)\n  for (let v of bookings) {\n    res[v[0] - 1] += v[2]\n    if (v[1] < n) res[v[1]] -= v[2]\n  }\n  for (let i = 1; i < n; ++i) res[i] += res[i - 1]\n  return res\n}\n\n// another\n\n/**\n * @param {number[][]} bookings\n * @param {number} n\n * @return {number[]}\n */\nconst corpFlightBookings = function(bookings, n) {\n  const arr = Array(n + 2).fill(0)\n  for(let [s, e, num] of bookings) {\n    arr[s] += num\n    arr[e + 1] -= num\n  }\n  for(let i = 1; i <= n; i++) {\n    if(arr[i] !== 0) arr[i] += arr[i - 1]\n    else arr[i] = arr[i - 1]\n  }\n  return arr.slice(1, n + 1)\n};\n"
    }
  },
  {
    "name": "111-minimum-depth-of-binary-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nconst minDepth = function(root) {\n    if(root == null) return 0\n    if(root.left === null && root.right === null) return 1\n    const res = {\n      min:Number.MAX_VALUE\n    }\n    dfs(root, res, 1)\n    return res.min\n};\n\nfunction dfs(node, res, cur) {\n  if(node == null) return\n  if(node !== null && node.left === null && node.right === null) {\n    if(cur < res.min) {\n      res.min = cur   \n    }\n    return\n  }\n  dfs(node.left, res, cur + 1)\n  dfs(node.right, res, cur + 1)\n  \n} \n"
    }
  },
  {
    "name": "1110-delete-nodes-and-return-forest",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number[]} to_delete\n * @return {TreeNode[]}\n */\nconst delNodes = function(root, to_delete) {\n  let rst = []\n  let dfs = function(node, isRoot) {\n    if (!node) return\n    let isDel = to_delete.indexOf(node.val) !== -1\n    if (node.left) node.left = dfs(node.left, isDel)\n    if (node.right) node.right = dfs(node.right, isDel)\n    if (isRoot && !isDel) rst.push(node)\n    return isDel ? null : node\n  }\n  if (!root) return []\n  dfs(root, true)\n  return rst\n}\n"
    }
  },
  {
    "name": "1118-number-of-days-in-a-month",
    "code": {
      "JS": "/**\n\nGiven a year Y and a month M, return how many days there are in that month.\n\nExample 1:\n\nInput: Y = 1992, M = 7\nOutput: 31\nExample 2:\n\nInput: Y = 2000, M = 2\nOutput: 29\nExample 3:\n\nInput: Y = 1900, M = 2\nOutput: 28\n\nNote:\n\n1583 <= Y <= 2100\n1 <= M <= 12\n\n*/\n\n/**\n * @param {number} Y\n * @param {number} M\n * @return {number}\n */\nfunction numberOfDays(Y, M) {\n  switch (M) {\n    case 2:\n      return Y % 400 === 0 || (Y % 4 === 0 && Y % 100 !== 0) ? 29 : 28;\n    case 4:\n    case 6:\n    case 9:\n    case 11:\n      return 30;\n    default:\n      return 31;\n  }\n}\n\n// another\n\nconst numberOfDays = function(Y, M) {\n    return new Date(Y,M,0).getDate();\n};\n\n// another\n\n/**\n * @param {number} Y\n * @param {number} M\n * @return {number}\n */\nconst numberOfDays = function(Y, M) {\n  const d = new Date(Y, M - 1)\n  let num = 0\n  while(d.getMonth() === M - 1) {\n    num++\n    const n = d.getDate()\n    d.setDate(n + 1)\n  }\n  return num\n};\n"
    }
  },
  {
    "name": "1119-remove-vowels-from-a-string",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {string}\n */\nconst removeVowels = function(s) {\n  return s.replace(/[aeiou]/g, '')\n};\n"
    }
  },
  {
    "name": "112-path-sum",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} sum\n * @return {boolean}\n */\nconst hasPathSum = function(root, sum) {\n    if (root == null) {\n        return false\n    }\n    const obj = {\n        sum: 0\n    }\n    const res = []\n    dfs(root, obj, sum, res)\n    return res.indexOf(true) !== -1\n};\n\nfunction dfs(node, obj, target, res) {\n\n    if (node.left == null && node.right == null) {\n        obj.sum += node.val\n        if (obj.sum === target) {\n            res.push(true)\n        }\n    }\n    if (node.left) {\n        dfs(node.left, {sum: obj.sum + node.val}, target, res)\n    }\n    if (node.right) {\n        dfs(node.right, {sum: obj.sum + node.val}, target, res)\n    }\n}\n"
    }
  },
  {
    "name": "1120-maximum-average-subtree",
    "code": {
      "JS": "/**\n\nGiven the root of a binary tree, find the maximum average value of any subtree of that tree.\n(A subtree of a tree is any node of that tree plus all its descendants.\nThe average value of a tree is the sum of its values, divided by the number of nodes.)\n\nExample 1:\n\nInput: [5,6,1]\nOutput: 6.00000\nExplanation: \nFor the node with value = 5 we have an average of (5 + 6 + 1) / 3 = 4.\nFor the node with value = 6 we have an average of 6 / 1 = 6.\nFor the node with value = 1 we have an average of 1 / 1 = 1.\nSo the answer is 6 which is the maximum.\n\nNote:\n\nThe number of nodes in the tree is between 1 and 5000.\nEach node will have a value between 0 and 100000.\nAnswers will be accepted as correct if they are within 10^-5 of the correct answer.\n\n*/\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nconst maximumAverageSubtree = function(root) {\n  let max = -Number.MIN_VALUE;\n  function helper(root) {\n    if (!root) return [0, 0]; // [value, number of nodes]\n    const [lTotal, lNum] = helper(root.left);\n    const [rTotal, rNum] = helper(root.right);\n    max = Math.max(max, (rTotal + lTotal + root.val) / (rNum + lNum + 1));\n    return [lTotal + rTotal + root.val, lNum + rNum + 1];\n  }\n  helper(root);\n  return max;\n};\n"
    }
  },
  {
    "name": "1121-divide-array-into-increasing-sequences",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} K\n * @return {boolean}\n */\nconst canDivideIntoSubsequences = function (nums, K) {\n  let cur = 1,\n    groups = 1,\n    n = nums.length\n  for (let i = 1; i < n; ++i) {\n    cur = nums[i - 1] < nums[i] ? 1 : cur + 1\n    groups = Math.max(groups, cur)\n  }\n  return n >= K * groups\n}\n"
    }
  },
  {
    "name": "1122-relative-sort-array",
    "code": {
      "JS": "/**\n * @param {number[]} arr1\n * @param {number[]} arr2\n * @return {number[]}\n */\nconst relativeSortArray = function(arr1, arr2) {\n  const hash = {}\n  const res = []\n  arr1.forEach(el => {\n    if(hash.hasOwnProperty(el)) hash[el] += 1\n    else hash[el] = 1\n  })\n  for(let i = 0, len = arr2.length; i < len; i++) {\n    res.push(...makeArr(arr2[i], hash[arr2[i]]))\n    delete hash[arr2[i]]\n  }\n  const keys = Object.keys(hash).sort((a, b) => a - b)\n  for(let i = 0, len = keys.length; i < len; i++) {\n    res.push(...makeArr(keys[i], hash[keys[i]]))\n  }\n  return res\n};\n\nfunction makeArr(el, num) {\n  return new Array(num).fill(el)\n}\n"
    }
  },
  {
    "name": "1123-lowest-common-ancestor-of-deepest-leaves",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nconst lcaDeepestLeaves = function(root) {\n  let maxDepth = 0, lcaNode = null\n\n  function lca(node, depth) {\n    if(node == null) return depth - 1\n    maxDepth = Math.max(depth, maxDepth)\n    const left = lca(node.left, depth + 1)\n    const right = lca(node.right, depth + 1)\n    if(left === maxDepth && right === maxDepth) {\n      lcaNode = node\n    }\n    return Math.max(left, right)\n  }\n\n  lca(root, 0)\n  return lcaNode\n};\n\n\n// another\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nconst lcaDeepestLeaves = function(root) {\n  if (root === null) return null\n  const getHeight = root => {\n    if (root === null) return 0\n    const res = Math.max(getHeight(root.left), getHeight(root.right)) + 1\n    return res\n  }\n  if (getHeight(root.left) === getHeight(root.right)) {\n    return root\n  } else if (getHeight(root.left) > getHeight(root.right)) {\n    return lcaDeepestLeaves(root.left)\n  } else {\n    return lcaDeepestLeaves(root.right)\n  }\n}\n\n// BFS\n\nconst lcaDeepestLeaves = function(root) {\n  let current = [root];\n  let level = 0;\n  let last = [];\n  while(current.length) {\n    let next = [];\n    for (var i = 0; i < current.length; i++) {\n      if (current[i].left) {\n        current[i].left.parent = current[i];\n        next.push(current[i].left);\n      }\n      if (current[i].right) {\n        current[i].right.parent = current[i];\n        next.push(current[i].right);\n      }\n    }\n    last = current;\n    current = next;\n  }\n  let parent = last[0].parent;\n  if (!parent) {\n    return last[0];\n  }\n  while(last.length > 1) {\n    let next = [];\n    for (var i = 0; i < last.length; i++) {\n      newParent = last[i].parent;\n      if (!next.includes(newParent)) {\n        next.push(newParent);\n      }\n    }\n    last = next;\n  }\n  return last[0]; \n};\n"
    }
  },
  {
    "name": "1124-longest-well-performing-interval",
    "code": {
      "JS": "/**\n * @param {number[]} hours\n * @return {number}\n */\nconst longestWPI = function(hours) {\n  const N = hours.length;\n  const seen = new Map();\n  let res = 0;\n  let score = 0;\n  for (let i = 0; i < N; i++) {\n    score += hours[i] > 8 ? 1 : -1;\n    if (score > 0) {\n      res = i + 1;\n    } else {\n      if (!seen.has(score)) {\n        seen.set(score, i);\n      }\n      if (seen.has(score - 1)) {\n        res = Math.max(res, i - seen.get(score - 1));\n      }\n    }\n  }\n  return res;\n};\n"
    }
  },
  {
    "name": "1125-smallest-sufficient-team",
    "code": {
      "JS": "/**\n * @param {string[]} req_skills\n * @param {string[][]} people\n * @return {number[]}\n */\nconst smallestSufficientTeam = function(req_skills, people) {\n  const m = req_skills.length\n  const n = people.length\n  const skill2Bitmap = req_skills\n    .map((x, i) => [x, i])\n    .reduce((dict, cur) => {\n      dict[cur[0]] = 1 << cur[1]\n      return dict\n    }, {})\n  const newPeople = people.map(x => {\n    return x.reduce((acc, cur) => {\n      const y = skill2Bitmap[cur]\n      if (y !== undefined) {\n        acc |= y\n      }\n      return acc\n    }, 0)\n  })\n\n  const all = (1 << m) - 1\n  const dp = {}\n  for (let j = 0; j < n; j++) {\n    if (newPeople[j] > 0) {\n      dp[newPeople[j]] = new Set([j])\n    }\n  }\n  if (dp[all]) {\n    return Array.from(dp[all]).sort()\n  }\n\n  for (let k = 0; k < n; k++) {\n    for (let s in dp) {\n      for (let j = 0; j < n; j++) {\n        if (newPeople[j] === 0 || dp[s].has(j)) continue\n        const newIdx = s | newPeople[j]\n        if (dp[newIdx] === undefined) {\n          dp[newIdx] = new Set([...dp[s], j])\n          if (newIdx === all) {\n            return Array.from(dp[all]).sort()\n          }\n        }\n      }\n    }\n  }\n  return []\n}\n\n// another\n\n/**\n * @param {string[]} req_skills\n * @param {string[][]} people\n * @return {number[]}\n */\nconst smallestSufficientTeam = function(req_skills, people) {\n  let skill_len = req_skills.length\n\n  // 将people转换为id的模式\n  let id_people = []\n  let hash = {}\n  for (let i = 0; i < skill_len; i++) {\n    hash[req_skills[i]] = i\n  }\n  for (let i = 0; i < people.length; i++) {\n    id_people[i] = []\n    for (let j = 0; j < people[i].length; j++) {\n      id_people[i][j] = hash[people[i][j]]\n    }\n  }\n\n  // 过滤掉不可能的选取的人员\n  let skip = {}\n  for (let i = 0; i < id_people.length; i++) {\n    if (skip[i]) continue\n    let skills = Array(skill_len).fill(0)\n    for (let j = 0; j < id_people[i].length; j++) {\n      let curId = id_people[i][j]\n      skills[curId]++\n    }\n    for (let k = i + 1; k < id_people.length; k++) {\n      if (skip[k]) continue\n      let needSkip = true\n      for (let l = 0; l < id_people[k].length; l++) {\n        let id = id_people[k][l]\n        if (skills[id] === 0) {\n          needSkip = false\n          break\n        }\n      }\n      if (needSkip) {\n        skip[k] = true\n      }\n    }\n  }\n\n  // 构造精简后的人员，并且保存对应的index关系\n  let slim_people = []\n  let idHash = {}\n  for (let i = 0; i < id_people.length; i++) {\n    if (skip[i]) continue\n    idHash[slim_people.length] = i\n    slim_people.push(id_people[i])\n  }\n\n  // 执行回溯\n  let res = Infinity\n  let remain = {}\n  let ans = null\n  for (let i = 0; i < slim_people.length; i++) {\n    remain[i] = false\n  }\n  let init_select = Array(skill_len).fill(0)\n\n  backtrack(0, init_select, 0, remain)\n\n  return ans\n\n  function backtrack(id, select, count, remain) {\n    if (count >= res) return\n    let done = true\n    for (let i = 0; i < select.length; i++) {\n      if (select[i] === 0) {\n        done = false\n      }\n    }\n    if (done) {\n      res = count\n      let _res_ = []\n      for (let k in remain) {\n        if (remain[k]) _res_.push(idHash[k])\n      }\n      ans = _res_\n      return\n    }\n    for (let k = id; k < slim_people.length; k++) {\n      let arr = slim_people[k]\n      for (let i = 0; i < arr.length; i++) {\n        select[arr[i]]++\n      }\n      remain[k] = true\n      backtrack(k + 1, select, count + 1, remain)\n      remain[k] = false\n      for (let i = 0; i < arr.length; i++) {\n        select[arr[i]]--\n      }\n    }\n  }\n}\n\n"
    }
  },
  {
    "name": "1128-number-of-equivalent-domino-pairsnumber-of-equivalent-domino-pairs",
    "code": {
      "JS": "/**\n * @param {number[][]} dominoes\n * @return {number}\n */\nconst numEquivDominoPairs = function(dominoes) {\n  const hash = {}\n  for (let dom of dominoes) {\n    const [a, b] = dom\n    const key = `${a},${b}`, alterKey = `${b},${a}`\n    if (hash[key] == null && hash[alterKey] == null) {\n      hash[key] = 1\n    } else {\n      if(hash[key] != null) hash[key] += 1\n      else hash[alterKey] += 1\n    }\n  }\n\n  let res = 0\n\n  Object.keys(hash).forEach(k => {\n    if(hash[k] > 1) res += sum(hash[k])\n  })\n\n  return res\n};\n\nfunction sum(n) {\n  let res = 0\n  while(n > 1) {\n    res += n - 1\n    n--\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "1129-shortest-path-with-alternating-colors",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[][]} red_edges\n * @param {number[][]} blue_edges\n * @return {number[]}\n */\nconst shortestAlternatingPaths = function(n, red_edges, blue_edges) {\n  let d = new Array(n * 2).fill(Number.MAX_SAFE_INTEGER)\n  let queue = []\n  d[0] = d[n] = 0\n  queue.push(0)\n  queue.push(n)\n  while (queue.length) {\n    let cur = queue.shift()\n    if (cur < n) {\n      for (let r of red_edges) {\n        if (r[0] == cur && d[r[1] + n] > d[cur] + 1) {\n          d[r[1] + n] = d[cur] + 1\n          queue.push(r[1] + n)\n        }\n      }\n    } else {\n      for (let b of blue_edges) {\n        if (b[0] == cur - n && d[b[1]] > d[cur] + 1) {\n          d[b[1]] = d[cur] + 1\n          queue.push(b[1])\n        }\n      }\n    }\n  }\n  let res = new Array(n).fill(-1)\n  for (let i = 0; i < n; i++) {\n    res[i] =\n      Math.min(d[i], d[i + n]) == Number.MAX_SAFE_INTEGER\n        ? -1\n        : Math.min(d[i], d[i + n])\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "113-path-sum-ii",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} sum\n * @return {number[][]}\n */\n\nconst pathSum = function(root, sum) {\n    const result = [];\n    backtrack(root, sum, [], result);\n    return result;\n};\n\nconst backtrack = function(root, sum, temp, result) {\n    if (root == null) {\n        return;\n    }\n    temp.push(root.val);\n    let newSum = sum - root.val;\n    if (root.left == null && root.right == null) {\n        if (newSum === 0) {\n            result.push([...temp]);\n        }\n        temp.pop();\n        return;\n    }\n    backtrack(root.left, newSum, temp, result);\n    backtrack(root.right, newSum, temp, result);\n    temp.pop();\n}\n"
    }
  },
  {
    "name": "1130-minimum-cost-tree-from-leaf-values",
    "code": {
      "JS": "/**\n * @param {number[]} arr\n * @return {number}\n */\nconst mctFromLeafValues = function(arr) {\n  let res = 0, n = arr.length;\n  let stack = new Array();\n  stack.push(Number.MAX_VALUE);\n  for (let a of arr) {\n    while (stack[stack.length - 1] <= a) {\n      let mid = stack.pop();\n      res += mid * Math.min(stack[stack.length - 1], a);\n    }\n    stack.push(a);\n  }\n  while (stack.length > 2) {\n    res += stack.pop() * stack[stack.length - 1];\n  }\n  return res;   \n};\n"
    }
  },
  {
    "name": "1133-largest-unique-number",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst largestUniqueNumber = function(nums) {\n   const hash = {}\n   for(let e of nums) {\n     hash[e] = (hash[e] || 0) + 1\n   }\n   let res = -Infinity\n   Object.keys(hash).forEach(k => {\n     if(hash[k] === 1) {\n       if(+k > res) {\n         res = +k\n       }\n     }\n   })\n   return res === -Infinity ? -1 : res\n};\n"
    }
  },
  {
    "name": "1134-armstrong-number",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {boolean}\n */\nconst isArmstrong = function(n) {\n    //number of digits in N\n    let k = ~~(Math.log10(n) + 1);\n    //temporary variable (so we dont modify N)\n    let x = n;\n    //to hold sum\n    let sum = 0;\n    //get each digit\n    while (x !== 0) {\n        //add this digit^k to sum\n        sum += Math.pow(x % 10, k);\n        //get next digit\n        x = ~~(x/10);\n    }\n    return sum == n;\n};\n"
    }
  },
  {
    "name": "1136-parallel-courses",
    "code": {
      "JS": "/**\n * @param {number} N\n * @param {number[][]} relations\n * @return {number}\n */\nconst minimumSemesters = function (N, relations) {\n  const g = new Map() // key: prerequisite, value: course list.\n  const inDegree = new Array(N + 1).fill(0) // inDegree[i]: number of prerequisites for i.\n  for (let r of relations) {\n    if (!g.has(r[0])) g.set(r[0], [])\n    g.get(r[0]).push(r[1]) // construct graph.\n    ++inDegree[r[1]] // count prerequisites for r[1].\n  }\n  const q = [] // save current 0 in-degree vertices.\n  for (let i = 1; i <= N; ++i) if (inDegree[i] === 0) q.push(i)\n  let semester = 0\n  while (q.length) {\n    // BFS traverse all currently 0 in degree vertices.\n    for (let sz = q.length; sz > 0; --sz) {\n      // sz is the search breadth.\n      const c = q.shift()\n      --N\n      // c's in-degree is currently 0, but it is not a prerequisite of anyone else.\n      if (!g.has(c)) continue\n      const tmp = g.get(c)\n      g.delete(c)\n      for (let course of tmp)\n        if (--inDegree[course] === 0)\n          // decrease the in-degree of course's neighbors.\n          q.push(course) // add current 0 in-degree vertex into Queue.\n    }\n    ++semester // need one more semester.\n  }\n  return N === 0 ? semester : -1\n}\n"
    }
  },
  {
    "name": "1137-n-th-tribonacci-number",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst hash = {}\nconst tribonacci = function(n) {\n  if(n === 0) return 0\n  if(n === 2 || n === 1) return 1\n  if(hash[n] != null) return hash[n]\n  let tmp = tribonacci(n - 3) + tribonacci(n - 2) + tribonacci(n - 1)\n  return hash[n] = tmp\n};\n\n// another\n\n/**\n * @param {number} n\n * @return {number}\n */\nconst tribonacci = function(n) {\n  if (n < 2) return n\n  let prev0 = 0\n  let prev1 = 1\n  let prev2 = 1\n  for (let count = 3; count <= n; count++) {\n    let next = prev2 + prev1 + prev0\n    prev0 = prev1\n    prev1 = prev2\n    prev2 = next\n  }\n  return prev2\n}\n"
    }
  },
  {
    "name": "1138-alphabet-board-path",
    "code": {
      "JS": "/**\n * @param {string} target\n * @return {string}\n */\nconst alphabetBoardPath = function(target) {\n  let sx = 0,\n    sy = 0;\n  let dir = \"\";\n  let a = \"a\".charCodeAt(0);\n  for (let c of target) {\n    let dx = (c.charCodeAt(0) - a) % 5,\n      dy = ((c.charCodeAt(0) - a) / 5) >> 0,\n      n;\n    if (sx > dx) {\n      n = sx - dx;\n      while (n--) dir += \"L\";\n    }\n    if (sy < dy) {\n      n = dy - sy;\n      while (n--) dir += \"D\";\n    }\n    if (sy > dy) {\n      n = sy - dy;\n      while (n--) dir += \"U\";\n    }\n    if (sx < dx) {\n      n = dx - sx;\n      while (n--) dir += \"R\";\n    }\n    dir += \"!\";\n    (sx = dx), (sy = dy);\n  }\n  return dir;\n};\n"
    }
  },
  {
    "name": "1139-largest-1-bordered-square",
    "code": {
      "JS": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nconst largest1BorderedSquare = function(grid) {\n  let A = grid;\n  let m = A.length,\n    n = A[0].length;\n  let max = 0;\n  const hori = Array.from(Array(m)).map(() => Array(n).fill(0));\n  const ver = Array.from(Array(m)).map(() => Array(n).fill(0));\n  for (let i = 0; i < m; ++i) {\n    for (let j = 0; j < n; ++j) {\n      if (A[i][j] > 0) {\n        hori[i][j] = j > 0 ? hori[i][j - 1] + 1 : 1;\n        ver[i][j] = i > 0 ? ver[i - 1][j] + 1 : 1;\n      }\n    }\n  }\n  for (let i = m - 1; i >= 0; i--) {\n    for (let j = n - 1; j >= 0; j--) {\n      let small = Math.min(hori[i][j], ver[i][j]);\n      while (small > max) {\n        if (ver[i][j - small + 1] >= small && hori[i - small + 1][j] >= small) {\n          max = small;\n          break\n        }\n        small--;\n      }\n    }\n  }\n  return max * max;\n};\n\n"
    }
  },
  {
    "name": "114-flatten-binary-tree-to-linked-list",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {void} Do not return anything, modify root in-place instead.\n */\n\nconst flatten = function(root) {\n  let prev = null\n  function op(root) {\n    if (root == null) return;\n    op(root.right);\n    op(root.left);\n    root.right = prev;\n    root.left = null;\n    prev = root;\n  }\n  op(root)\n};\n\n\n"
    }
  },
  {
    "name": "1140-stone-game-ii",
    "code": {
      "JS": "/**\n * @param {number[]} piles\n * @return {number}\n */\nconst stoneGameII = function(piles) {\n  let sums = [] //the sum from piles[i] to the end\n  let hash = []\n  if (piles == null || piles.length == 0) return 0\n  let n = piles.length\n  sums = new Array(n)\n  sums[n - 1] = piles[n - 1]\n  for (let i = n - 2; i >= 0; i--) {\n    sums[i] = sums[i + 1] + piles[i] //the sum from piles[i] to the end\n  }\n\n  hash = Array.from({ length: n }, () => new Array(n).fill(0))\n  return helper(piles, 0, 1)\n\n  function helper(a, i, M) {\n    if (i == a.length) return 0\n    if (2 * M >= a.length - i) {\n      return sums[i]\n    }\n    if (hash[i][M] != 0) return hash[i][M]\n    let min = Number.MAX_SAFE_INTEGER //the min value the next player can get\n    for (let x = 1; x <= 2 * M; x++) {\n      min = Math.min(min, helper(a, i + x, Math.max(M, x)))\n    }\n    hash[i][M] = sums[i] - min //max stones = all the left stones - the min stones next player can get\n    return hash[i][M]\n  }\n}\n"
    }
  },
  {
    "name": "1143-longest-common-subsequence",
    "code": {
      "JS": "/**\n * @param {string} text1\n * @param {string} text2\n * @return {number}\n */\nconst longestCommonSubsequence = function(text1, text2) {\n  let dp = new Array(text1.length + 1)\n  for (let i = 0; i < dp.length; i++)\n    dp[i] = new Array(text2.length + 1).fill(0)\n  for (let i = 1; i < dp.length; i++) {\n    for (let j = 1; j < dp[i].length; j++) {\n      if (text1[i - 1] == text2[j - 1]) dp[i][j] = 1 + dp[i - 1][j - 1]\n      else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])\n    }\n  }\n  return dp[dp.length - 1].pop()\n}\n\n// another\n\n/**\n * @param {string} text1\n * @param {string} text2\n * @return {number}\n */\nconst longestCommonSubsequence = function(text1, text2) {\n  const len1 = text1.length\n  const len2 = text2.length\n  if(len1 === 0 || len2 === 0) return 0\n  const dp = Array(len2 + 1).fill(0)\n  for(let i = 1; i <= len1; i++) {\n    let prev = 0\n    for(let j = 1; j <= len2; j++) {\n      const tmp = dp[j]\n      if(text1[i - 1] === text2[j - 1]) dp[j] = Math.max(dp[j], prev + 1)\n      else {\n        dp[j] = Math.max(dp[j - 1], dp[j])\n      }\n      prev = tmp\n    }\n  }\n  return dp[len2]\n};\n"
    }
  },
  {
    "name": "1145-binary-tree-coloring-game",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} n\n * @param {number} x\n * @return {boolean}\n */\nconst btreeGameWinningMove = function(root, n, x) {\n  let tl, tr;\n  function dfs(node) {\n    if (node == null) return 0;\n    let l = dfs(node.left),\n      r = dfs(node.right);\n    if (node.val == x) (tl = l), (tr = r);\n    return l + r + 1;\n  }\n  dfs(root);\n  return Math.max(tl, tr, n - tl - tr - 1) > n / 2;\n};\n"
    }
  },
  {
    "name": "1146-snapshot-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nconst binarySearch = function (nums, target, comparator) {\n  let low = 0;\n  let high = nums.length - 1;\n  while (low <= high) {\n    let mid = low + ((high - low) >>> 1);\n    let midValue = nums[mid];\n    let cmp = comparator(midValue, target);\n    if (cmp < 0) low = mid + 1;\n    else if (cmp > 0) high = mid - 1;\n    else return mid;\n  }\n  return -(low + 1);\n};\n\n/**\n * @param {number} length\n */\nconst SnapshotArray = function (length) {\n  this.count = 0;\n  this.arr = Array.from({ length: length }, () => [[0, 0]]);\n};\n\n/**\n * @param {number} index\n * @param {number} val\n * @return {void}\n */\nSnapshotArray.prototype.set = function (index, val) {\n  const arr = this.arr,\n    count = this.count;\n  if (arr[index][arr[index].length - 1][0] === count) {\n    arr[index][arr[index].length - 1][1] = val;\n  } else {\n    arr[index].push([count, val]);\n  }\n};\n\n/**\n * @return {number}\n */\nSnapshotArray.prototype.snap = function () {\n  return this.count++;\n};\n\n/**\n * @param {number} index\n * @param {number} snap_id\n * @return {number}\n */\nSnapshotArray.prototype.get = function (index, snap_id) {\n  let idx = binarySearch(this.arr[index], [snap_id, 0], (a, b) => a[0] - b[0]);\n  if (idx < 0) idx = -idx - 2;\n  return this.arr[index][idx][1];\n};\n\n/**\n * Your SnapshotArray object will be instantiated and called as such:\n * var obj = new SnapshotArray(length)\n * obj.set(index,val)\n * var param_2 = obj.snap()\n * var param_3 = obj.get(index,snap_id)\n */\n\n\n// another\n\n/**\n * @param {number} length\n */\nconst SnapshotArray = function(length) {\n  this.arr = new Array(length).fill(0);\n  this.snaps = new Array(length);\n  this.count = 0;\n};\n\n/**\n * @param {number} index\n * @param {number} val\n * @return {void}\n */\nSnapshotArray.prototype.set = function(index, val) {\n  if (this.snaps[index] == undefined) {\n    this.snaps[index] = {};\n  }\n\n  this.snaps[index][this.count] = val;\n};\n\n/**\n * @return {number}\n */\nSnapshotArray.prototype.snap = function() {\n  return this.count++;\n};\n\n/**\n * @param {number} index\n * @param {number} snap_id\n * @return {number}\n */\nSnapshotArray.prototype.get = function(index, snap_id) {\n  if (this.snaps[index] == undefined) return 0;\n\n  let res = 0;\n  while (snap_id >= 0) {\n    if (this.snaps[index][snap_id] == undefined) {\n      snap_id--;\n    } else {\n      res = this.snaps[index][snap_id];\n      snap_id = -1;\n    }\n  }\n\n  return res;\n};\n\n/**\n * Your SnapshotArray object will be instantiated and called as such:\n * var obj = new SnapshotArray(length)\n * obj.set(index,val)\n * var param_2 = obj.snap()\n * var param_3 = obj.get(index,snap_id)\n */\n"
    }
  },
  {
    "name": "1147-longest-chunked-palindrome-decomposition",
    "code": {
      "JS": "/**\n * @param {string} text\n * @return {number}\n */\nconst longestDecomposition = function(text) {\n  let res = 0,\n    n = text.length\n  let l = '',\n    r = ''\n  for (let i = 0; i < n; ++i) {\n    l = l + text.charAt(i)\n    r = text.charAt(n - i - 1) + r\n    if (l === r) {\n      ++res\n      l = ''\n      r = ''\n    }\n  }\n  return res\n}\n\n// another\n\n/**\n * @param {string} text\n * @return {number}\n */\nconst longestDecomposition = function(text) {\n  let n = text.length\n  for (let i = 0; i < Math.floor(n / 2); i++)\n    if (text.slice(0, i + 1) === text.slice(n - 1 - i, n))\n      return 2 + longestDecomposition(text.slice(i + 1, n - 1 - i))\n  return n === 0 ? 0 : 1\n}\n"
    }
  },
  {
    "name": "115-distinct-subsequences",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {string} t\n * @return {number}\n */\nconst numDistinct = function(s, t) {\n  const tlen = t.length\n  const slen = s.length\n  const mem = Array.from({ length: tlen + 1 }, () =>\n    new Array(slen + 1).fill(0)\n  )\n  for (let j = 0; j <= slen; j++) {\n    mem[0][j] = 1\n  }\n  for (let i = 0; i < tlen; i++) {\n    for (let j = 0; j < slen; j++) {\n      if (t.charAt(i) === s.charAt(j)) {\n        mem[i + 1][j + 1] = mem[i][j] + mem[i + 1][j]\n      } else {\n        mem[i + 1][j + 1] = mem[i + 1][j]\n      }\n    }\n  }\n  return mem[tlen][slen]\n}\n\n\n// another\n\n/**\n * @param {string} s\n * @param {string} t\n * @return {number}\n */\nconst numDistinct = function(s, t) {\n  const m = t.length,\n    n = s.length\n  const cur = new Array(m + 1).fill(0)\n  cur[0] = 1\n  for (let j = 1; j <= n; j++) {\n    let pre = 1\n    for (let i = 1; i <= m; i++) {\n      let temp = cur[i]\n      cur[i] = cur[i] + (t[i - 1] == s[j - 1] ? pre : 0)\n      pre = temp\n    }\n  }\n  return cur[m]\n}\n\n// another\n\n/**\n * @param {string} s\n * @param {string} t\n * @return {number}\n */\nconst numDistinct = function(s, t) {\n  const m = t.length,\n    n = s.length\n  const dp = new Array(m + 1).fill(0)\n  dp[0] = 1\n  for (let j = 1; j <= n; j++) {\n    for (let i = m; i > 0; i--) {\n      dp[i] = dp[i] + (t[i - 1] == s[j - 1] ? dp[i - 1] : 0)\n    }\n  }\n  return dp[m]\n}\n\n"
    }
  },
  {
    "name": "1150-check-if-a-number-is-majority-element-in-a-sorted-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {boolean}\n */\nfunction isMajorityElement(nums, target) {\n  let firstIdx = bs(nums, target)\n  let endIdx = firstIdx + (~~(nums.length / 2))\n  if(endIdx < nums.length && nums[endIdx] === target) return true\n  return false\n}\n\nfunction bs(arr, target) {\n  let l = 0, h = arr.length - 1\n  while(l < h) {\n    const mid = l + ((h - l) >> 1)\n    if (arr[mid] < target) l = mid + 1\n    else h = mid\n  }\n  return l\n}\n"
    }
  },
  {
    "name": "1153-string-transforms-into-another-string",
    "code": {
      "JS": "/**\n\nGiven two strings str1 and str2 of the same length,\ndetermine whether you can transform str1 into str2 by doing zero or more conversions.\nIn one conversion you can convert all occurrences of one character\nin str1 to any other lowercase English character.\nReturn true if and only if you can transform str1 into str2.\n\nExample 1:\n\nInput: str1 = \"aabcc\", str2 = \"ccdee\"\nOutput: true\nExplanation: Convert 'c' to 'e' then 'b' to 'd' then 'a' to 'c'. \nNote that the order of conversions matter.\n\nExample 2:\n\nInput: str1 = \"leetcode\", str2 = \"codeleet\"\nOutput: false\nExplanation: There is no way to transform str1 to str2.\n\nNote:\n\n1 <= str1.length == str2.length <= 10^4\nBoth str1 and str2 contain only lowercase English letters.\n\n*/\n\n/**\n * @param {string} str1\n * @param {string} str2\n * @return {boolean}\n */\nconst canConvert = function(str1, str2) {\n  if (str1 === str2) return true\n  const map = new Map()\n  for (let i = 0; i < str1.length; i++) {\n    if (map.has(str1[i]) && map.get(str1[i]) !== str2[i]) {\n      return false\n    }\n    map.set(str1[i], str2[i])\n  }\n  const set = new Set(map.values())\n  return set.size < 26\n}\n"
    }
  },
  {
    "name": "1154-day-of-the-year",
    "code": {
      "JS": "/**\n * @param {string} date\n * @return {number}\n */\n\nconst dayOfYear = function(date) {\n  const [year, month, day] = date.split('-').map(s => +s),\n    months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\n    isLeapYear = !(year % 4) && month > 2 && (!!(year % 100) || !(year % 400))\n  return months.splice(0, month - 1).reduce((a, b) => a + b, day + +isLeapYear)\n}\n"
    }
  },
  {
    "name": "1155-number-of-dice-rolls-with-target-sum",
    "code": {
      "JS": "/**\n * @param {number} d\n * @param {number} f\n * @param {number} target\n * @return {number}\n */\nconst numRollsToTarget = function(d, f, target) {\n  const mod = 10 ** 9 + 7\n  if (target > d * f || target < d) {\n    return 0\n  }\n  const dp = new Array(target + 1).fill(0)\n  for (let i = 1; i < Math.min(f + 1, target + 1); i++) {\n    dp[i] = 1\n  }\n  for (let i = 2; i < d + 1; i++) {\n    for (let j = Math.min(target, i * f); j > i - 1; j--) {\n      dp[j] = 0\n      for (let k = Math.max(i - 1, j - f); k < j; k++) {\n        dp[j] = (dp[j] + dp[k]) % mod\n      }\n    }\n  }\n\n  return dp[target]\n}\n\n// another\n\nconst numRollsToTarget = function(d, f, target) {\n  const MOD = 10 ** 9 + 7;\n  const dp = Array.from({ length: d + 1 }, () => new Array(target + 1).fill(0));\n  dp[0][0] = 1;\n  for (let i = 1; i <= d; i++) {\n    for (let j = 1; j <= target; j++) {\n      if (j > i * f) {\n        continue;\n      } else {\n        for (let k = 1; k <= f && k <= j; k++) {\n          dp[i][j] = (dp[i][j] + dp[i - 1][j - k]) % MOD;\n        }\n      }\n    }\n  }\n  return dp[d][target];\n};\n"
    }
  },
  {
    "name": "1156-swap-for-longest-repeated-character-substring",
    "code": {
      "JS": "/**\n * @param {string} text\n * @return {number}\n */\nconst maxRepOpt1 = function(text) {\n  const count = [...text].reduce((a, c) => {\n    a[c] = a[c] || 0;\n    a[c]++;\n    return a;\n  }, {});\n  let ans = 0;\n  let i = 0;\n  while (i < text.length) {\n    let j = i;\n    const c = text.charAt(i);\n    while (j < text.length && text.charAt(j) === c) j++;\n    if (j - i < count[c]) {\n      let k = j + 1;\n      while (k < text.length && text.charAt(k) === c && k - i < count[c]) k++;\n      ans = Math.max(k - i, ans);\n    } else ans = Math.max(j - i, ans);\n    i = j;\n  }\n  return ans;\n};\n"
    }
  },
  {
    "name": "1157-online-majority-element-in-subarray",
    "code": {
      "JS": "/**\n * @param {number[]} arr\n */\nconst MajorityChecker = function(arr) {\n  const map = new Map()\n  for (let i = 0; i < arr.length; i++) {\n    if (!map.has(arr[i])) map.set(arr[i], [i])\n    else map.get(arr[i]).push(i)\n  }\n  this.pos = map\n  this.arr = arr\n}\n\nfunction lbs(arr, val) {\n  let lo = 0\n  let hi = arr.length - 1\n  if (arr[0] >= val) return 0\n  else if (arr[hi] < val) return Infinity\n  let mid\n  while (hi - lo > 1) {\n    mid = (hi + lo) >> 1\n    if (arr[mid] === val) return mid\n    else if (arr[mid] < val) lo = mid\n    else if (arr[mid] > val) hi = mid\n  }\n  return hi\n}\n\nfunction rbs(arr, val) {\n  let lo = 0\n  let hi = arr.length - 1\n  if (arr[hi] <= val) return hi\n  else if (arr[lo] > val) return -Infinity\n  let mid\n  while (hi - lo > 1) {\n    mid = (hi + lo) >> 1\n    if (arr[mid] === val) return mid\n    else if (arr[mid] < val) lo = mid\n    else if (arr[mid] > val) hi = mid\n  }\n  return lo\n}\n\n/**\n * @param {number} left\n * @param {number} right\n * @param {number} threshold\n * @return {number}\n */\nMajorityChecker.prototype.query = function(left, right, threshold) {\n  const { arr, pos } = this\n  let c = 20\n  while (c--) {\n    const idx = left + Math.floor(Math.random() * (right - left + 1))\n    const sort = pos.get(arr[idx])\n    const lidx = lbs(sort, left)\n    const ridx = rbs(sort, right)\n    if (ridx - lidx + 1 >= threshold) return arr[idx]\n  }\n  return -1\n}\n\n/**\n * Your MajorityChecker object will be instantiated and called as such:\n * var obj = new MajorityChecker(arr)\n * var param_1 = obj.query(left,right,threshold)\n */\n"
    }
  },
  {
    "name": "116-populating-next-right-pointers-in-each-node",
    "code": {
      "JS": "/**\n * // Definition for a Node.\n * function Node(val,left,right,next) {\n *    this.val = val;\n *    this.left = left;\n *    this.right = right;\n *    this.next = next;\n * };\n */\n/**\n * @param {Node} root\n * @return {Node}\n */\nconst connect = function(root) {\n  if (root == null) return null\n  const cur = [root]\n  while (cur.length) {\n    let len = cur.length\n    for (let i = 0; i < len; i++) {\n      let el = cur.shift()\n      if (i === len - 1) el.next = null\n      else el.next = cur[0]\n\n      if (el.left) cur.push(el.left)\n      if (el.right) cur.push(el.right)\n    }\n  }\n  return root\n}\n\n// another\n\nconst connect = function(root) {\n  if (!root) return null\n  if (root.left && root.right) {\n    root.left.next = root.right\n    root.right.next = root.next ? root.next.left : null\n  }\n  connect(root.left)\n  connect(root.right)\n  return root\n}\n"
    }
  },
  {
    "name": "1160-find-words-that-can-be-formed-by-characters",
    "code": {
      "JS": "/**\n * @param {string[]} words\n * @param {string} chars\n * @return {number}\n */\nconst countCharacters = function(words, chars) {\n  let letters = new Array(26).fill(0),\n    a = 'a'.charCodeAt(0),\n    z = 'z'.charCodeAt(0)\n  let count = 0\n  for (let i = 0; i < chars.length; i++) {\n    let l = chars[i].charCodeAt(0) - a\n    letters[l]++\n  }\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i]\n    let tmp = letters.slice()\n    let tCount = 0\n    for (let j = 0; j < word.length; j++) {\n      let l = word[j].charCodeAt(0) - a\n      tmp[l]--\n      if (tmp[l] < 0) {\n        break\n      } else {\n        tCount++\n      }\n    }\n    if (tCount == word.length) {\n      count += word.length\n    }\n  }\n  return count\n}\n"
    }
  },
  {
    "name": "1161-maximum-level-sum-of-a-binary-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nconst maxLevelSum = function(root) {\n  if (root == null) return 0\n  let res = 1\n  let cur = [root]\n  let next = []\n  let max = Number.MIN_SAFE_INTEGER\n  let sum = 0\n  let level = 1\n  while (cur.length) {\n    let node = cur.pop()\n    if (node.left) next.push(node.left)\n    if (node.right) next.push(node.right)\n    sum += node.val\n    if (cur.length === 0) {\n      cur = next\n      next = []\n      if (sum > max) {\n        res = level\n        max = sum\n      }\n      sum = 0\n      level++\n    }\n  }\n\n  return res\n}\n\n// DFS\n\nconst maxLevelSum = function(root) {\n  let result = {};\n  let recursion = function(root, level) {\n    if (result[level] !== undefined) {\n      result[level] += root.val;\n    } else {\n      result[level] = root.val;\n    }\n    if (root.left !== null) {\n      recursion(root.left, level + 1);\n    }\n    if (root.right !== null) {\n      recursion(root.right, level + 1);\n    }\n  };\n  recursion(root, 1);\n  let resultkey = 1;\n  let max = Number.MIN_VALUE;\n  for (let key of Object.keys(result)) {\n    if (result[key] > max) {\n      max = result[key];\n      resultkey = key;\n    }\n  }\n  return Number(resultkey);\n};\n\n"
    }
  },
  {
    "name": "1162-as-far-from-land-as-possible",
    "code": {
      "JS": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nconst maxDistance = function(grid) {\n  let m = grid.length\n  let n = m === 0 ? 0 : grid[0].length\n  let dp = new Array(m + 2)\n  for (let i = 0; i < m + 2; i++) {\n    dp[i] = new Array(n + 2).fill(Number.POSITIVE_INFINITY)\n  }\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (grid[i - 1][j - 1] === 0) {\n        dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + 1\n      } else {\n        dp[i][j] = 0\n      }\n    }\n  }\n  let res = Number.NEGATIVE_INFINITY\n  for (let i = m; i >= 1; i--) {\n    for (let j = n; j >= 1; j--) {\n      if (grid[i - 1][j - 1] === 0) {\n        dp[i][j] = Math.min(dp[i][j], Math.min(dp[i + 1][j], dp[i][j + 1]) + 1)\n        res = Math.max(res, dp[i][j])\n      }\n    }\n  }\n  return isFinite(res) ? res : -1\n}\n"
    }
  },
  {
    "name": "1163-last-substring-in-lexicographical-order",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {string}\n */\nconst lastSubstring = function(s) {\n  let ans = '',\n    max = 'a'\n  for (let i = 0; i < s.length; ) {\n    let j = i,\n      sub = s.slice(i)\n    if (max < s[i] || ans < sub) {\n      max = s[i]\n      ans = sub\n    }\n    while (i < s.length && s[i + 1] === s[i]) {\n      i++\n    }\n    if (j === i) {\n      i++\n    }\n  }\n  return ans\n}\n"
    }
  },
  {
    "name": "1165-single-row-keyboard",
    "code": {
      "JS": "/**\n * @param {string} keyboard\n * @param {string} word\n * @return {number}\n */\nconst calculateTime = function(keyboard, word) {\n  const hash = {}, { abs } = Math\n  for(let i = 0; i < 26; i++) {\n    hash[keyboard[i]] = i\n  }\n  let pre = 0, sum = 0\n  for(const ch of word) {\n    sum += abs(hash[ch] - pre)\n    pre = hash[ch]\n  }\n  return sum\n};\n"
    }
  },
  {
    "name": "1166-design-file-system",
    "code": {
      "JS": "\nconst FileSystem = function() {\n  this.m = new Map()\n  this.m.set('', 1)\n};\n\n/** \n * @param {string} path \n * @param {number} value\n * @return {boolean}\n */\nFileSystem.prototype.createPath = function(path, value) {\n  if(this.m.has(path)) return false\n  const p = path.slice(0, path.lastIndexOf('/'))\n  if(!this.m.has(p)) return false\n  this.m.set(path, value)\n  return true\n};\n\n/** \n * @param {string} path\n * @return {number}\n */\nFileSystem.prototype.get = function(path) {\n  if(!this.m.has(path)) return -1\n  return this.m.get(path)\n};\n\n/** \n * Your FileSystem object will be instantiated and called as such:\n * var obj = new FileSystem()\n * var param_1 = obj.createPath(path,value)\n * var param_2 = obj.get(path)\n */\n\n// another\n\nclass Node {\n  constructor(v) {\n    this.val = v\n    this.children = new Map()\n  }\n}\nconst FileSystem = function() {\n  this.r = new Node(null)\n};\n\n/** \n * @param {string} path \n * @param {number} value\n * @return {boolean}\n */\nFileSystem.prototype.createPath = function(path, value) {\n  if(path == null || path === '') return\n  const arr = path.split('/').filter(e => e !== '/' && e !== '')\n  let cur = this.r\n  for(let i = 0, len = arr.length; i < len; i++) {\n    if(i !== len - 1 && !cur.children.has(arr[i])) return false\n    if(i === len - 1 && cur.children.has(arr[i])) return false \n    if(i !== len - 1) cur = cur.children.get(arr[i])\n  }\n  cur.children.set(arr[arr.length - 1], new Node(value))\n  return true\n};\n\n/** \n * @param {string} path\n * @return {number}\n */\nFileSystem.prototype.get = function(path) {\n  const arr = path.split('/').filter(e => e !== '/' && e !== '')\n  let cur = this.r\n  for(let i = 0, len = arr.length; i < len; i++) {\n    if(!cur.children.has(arr[i])) return -1\n    cur = cur.children.get(arr[i])\n  }\n  return cur.val\n};\n\n/** \n * Your FileSystem object will be instantiated and called as such:\n * var obj = new FileSystem()\n * var param_1 = obj.createPath(path,value)\n * var param_2 = obj.get(path)\n */\n"
    }
  },
  {
    "name": "1167-minimum-cost-to-connect-sticks",
    "code": {
      "JS": "/**\n\nYou have some sticks with positive integer lengths.\n\nYou can connect any two sticks of lengths X and Y into\none stick by paying a cost of X + Y.  You perform this action until there is one stick remaining.\n\nReturn the minimum cost of connecting all the given sticks into one stick in this way.\n\nExample 1:\n\nInput: sticks = [2,4,3]\nOutput: 14\nExample 2:\n\nInput: sticks = [1,8,3,5]\nOutput: 30\n \nConstraints:\n\n1 <= sticks.length <= 10^4\n1 <= sticks[i] <= 10^4\n\n*/\n\n/**\n * @param {number[]} sticks\n * @return {number}\n */\nconst connectSticks = function(sticks) {\n  if (sticks.length < 1) return 0\n  let size = sticks.length - 1\n  let i = Math.floor(sticks.length / 2)\n  for (; i >= 0; i--) {\n    heapify(sticks, i, size)\n  }\n  let cost = 0\n  while (size >= 1) {\n    const temp = sticks[0]\n    sticks[0] = sticks[size--]\n    heapify(sticks, 0, size)\n    sticks[0] = sticks[0] + temp\n    cost += sticks[0]\n    heapify(sticks, 0, size)\n  }\n  return cost\n}\nconst heapify = (arr, index, size) => {\n  let smallest = index\n  let l = index * 2 + 1\n  let r = index * 2 + 2\n  if (l <= size && arr[l] < arr[smallest]) {\n    smallest = l\n  }\n  if (r <= size && arr[r] < arr[smallest]) {\n    smallest = r\n  }\n  if (smallest != index) {\n    swap(arr, index, smallest)\n    heapify(arr, smallest, size)\n  }\n}\nconst swap = (arr, i, j) => {\n  const temp = arr[i]\n  arr[i] = arr[j]\n  arr[j] = temp\n}\n\n// another\n\n/**\n * @param {number[]} sticks\n * @return {number}\n */\nconst connectSticks = function(sticks) {\n  if (sticks.length === 1) return 0\n  sticks.sort((a, b) => a - b)\n  let sum = [],\n    result = 0\n  while (sticks.length || sum.length > 1) {\n    let cur = 0\n    for (let i = 0; i < 2; i++) {\n      if (sticks[0] && (sum[0] === undefined || sticks[0] < sum[0])) {\n        cur += sticks[0]\n        sticks.shift()\n      } else {\n        cur += sum[0]\n        sum.shift()\n      }\n    }\n    sum.push(cur)\n    result += cur\n  }\n  return result\n}\n\n// another\n\n/**\n * @param {number[]} sticks\n * @return {number}\n */\nconst connectSticks = function(sticks) {\n  sticks.sort((a, b) => a - b)\n  const sums = []\n  let result = 0\n  if (sticks.length < 2) return result\n  const getMin = () => {\n    const stick = sticks.length ? sticks[0] : Infinity\n    const sum = sums.length ? sums[0] : Infinity\n    if (sum < stick) {\n      return sums.shift()\n    } else {\n      return sticks.shift()\n    }\n  }\n  while (sticks.length || sums.length > 1) {\n    const tmp1 = getMin()\n    const tmp2 = getMin()\n    const curr = tmp1 + tmp2\n    result += curr\n    sums.push(curr)\n  }\n  return result\n}\n\n// another\n\n/**\n * @param {number[]} sticks\n * @return {number}\n */\nconst connectSticks = function(sticks) {\n  const pq = new PriorityQueue((a, b) => a < b)\n  for(let e of sticks) pq.push(e)\n  let res = 0\n  while(pq.size() > 1) {\n    const e1 = pq.pop()\n    const e2 = pq.pop()\n    pq.push(e1 + e2)\n    res += e1 + e2\n  }\n  \n  return res\n};\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n"
    }
  },
  {
    "name": "1168-optimize-water-distribution-in-a-village",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[]} wells\n * @param {number[][]} pipes\n * @return {number}\n */\nconst minCostToSupplyWater = function(n, wells, pipes) {\n  const uf = Array(n + 1).fill(0)\n  const edges = []\n  for(let i = 0; i < n; i++) {\n    uf[i + 1] = i + 1\n    edges.push([0, i + 1, wells[i]])\n  }\n  for(let p of pipes) {\n    edges.push(p)\n  }\n  edges.sort((a, b) => a[2] - b[2])\n  let res = 0\n  for(let e of edges) {\n    const x = find(e[0]), y = find(e[1])\n    if(x !== y) {\n      res += e[2]\n      uf[x] = y\n      n--\n    }\n  }\n  return res\n  \n  function find(x) {\n    if(x !== uf[x]) uf[x] = find(uf[x])\n    return uf[x]\n  }\n};\n"
    }
  },
  {
    "name": "117-populating-next-right-pointers-in-each-node-ii",
    "code": {
      "JS": "/**\n * // Definition for a Node.\n * function Node(val,left,right,next) {\n *    this.val = val;\n *    this.left = left;\n *    this.right = right;\n *    this.next = next;\n * };\n */\n/**\n * @param {Node} root\n * @return {Node}\n */\nconst connect = function(root) {\n  if (root == null) return null\n  const cur = [root]\n  while (cur.length) {\n    const len = cur.length\n    for (let i = 0; i < len; i++) {\n      const el = cur.shift()\n      if (i === len - 1) el.next = null\n      else el.next = cur[0]\n      if (el.left) cur.push(el.left)\n      if (el.right) cur.push(el.right)\n    }\n  }\n  return root\n}\n"
    }
  },
  {
    "name": "1170-compare-strings-by-frequency-of-the-smallest-character",
    "code": {
      "JS": "/**\n * @param {string[]} queries\n * @param {string[]} words\n * @return {number[]}\n */\nconst numSmallerByFrequency = function(queries, words) {\n  const qArr = []\n  for(let i = 0, len = queries.length; i < len; i++) {\n    let sm = 'z'\n    let hash = {}\n    let cur = queries[i]\n    for(let char of cur) {\n      if(hash[char] == null) hash[char] = 0\n      hash[char]++\n      if(char < sm) sm = char\n    }\n    qArr.push(hash[sm])\n  }\n  const wArr = []\n  for(let i = 0, len = words.length; i < len; i++) {\n    let sm = 'z'\n    let hash = {}\n    let cur = words[i]\n    for(let char of cur) {\n      if(hash[char] == null) hash[char] = 0\n      hash[char]++\n      if(char < sm) sm = char\n    }\n    wArr.push(hash[sm])\n  }\n  const res = []\n  for(let i = 0, len = queries.length; i < len; i++) {\n    let cur = 0\n    for(let j = 0, wlen = words.length; j < wlen; j++) {\n      if(qArr[i] < wArr[j]) cur++\n    }\n    res.push(cur)\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1171-remove-zero-sum-consecutive-nodes-from-linked-list",
    "code": {
      "JS": "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nconst removeZeroSumSublists = function(head) {\n  let dummy = new ListNode(0), cur = dummy;\n  dummy.next = head;\n  let prefix = 0;\n  let m = new Map();\n  while (cur != null) {\n    prefix += cur.val;\n    if (m.has(prefix)) {\n      cur =  m.get(prefix).next;\n      let p = prefix + cur.val;\n      while (p != prefix) {\n        m.delete(p);\n        cur = cur.next;\n        p += cur.val;\n      }\n      m.get(prefix).next = cur.next;\n    } else {\n      m.set(prefix, cur);\n    }\n    cur = cur.next;\n  }\n  return dummy.next;\n};\n"
    }
  },
  {
    "name": "1172-dinner-plate-stacks",
    "code": {
      "JS": "/**\n * @param {number} capacity\n */\nconst DinnerPlates = function (capacity) {\n  this.capacity = capacity\n  this.stacks = []\n  this.pq = new PriorityQueue()\n}\n\n/**\n * @param {number} val\n * @return {void}\n */\nDinnerPlates.prototype.push = function (val) {\n  if (this.pq.isEmpty()) {\n    if (\n      this.stacks.length > 0 &&\n      this.stacks[this.stacks.length - 1].length < this.capacity\n    ) {\n      this.stacks[this.stacks.length - 1].push(val)\n    } else {\n      this.stacks.push([])\n      this.stacks[this.stacks.length - 1].push(val)\n    }\n  } else {\n    const num = this.pq.pop()\n    this.stacks[num].push(val)\n  }\n}\n\n/**\n * @return {number}\n */\nDinnerPlates.prototype.pop = function () {\n  while (\n    this.stacks.length > 0 &&\n    this.stacks[this.stacks.length - 1].length === 0\n  ) {\n    const len = this.stacks.length - 1\n    while (!this.pq.isEmpty() && this.pq.peek() >= len) {\n      this.pq.pop()\n    }\n    this.stacks.pop()\n  }\n  if (this.stacks.length === 0) {\n    return -1\n  } else {\n    return this.stacks[this.stacks.length - 1].pop()\n  }\n}\n\n/**\n * @param {number} index\n * @return {number}\n */\nDinnerPlates.prototype.popAtStack = function (index) {\n  const st = this.stacks[index]\n\n  if (st && st.length > 0) {\n    this.pq.push(index)\n    return st.pop()\n  }\n\n  return -1\n}\n\n/**\n * Your DinnerPlates object will be instantiated and called as such:\n * var obj = new DinnerPlates(capacity)\n * obj.push(val)\n * var param_2 = obj.pop()\n * var param_3 = obj.popAtStack(index)\n */\nclass PriorityQueue {\n  constructor(len, compare) {\n    this.compare = (a, b) => {\n      return a < b\n    }\n    this.last = 0\n    this.arr = []\n  }\n  push(val) {\n    this.last++\n    this.arr[this.last] = val\n    this.up(this.last)\n  }\n  pop() {\n    if (this.isEmpty()) {\n      return null\n    }\n    const res = this.arr[1]\n    this.swap(1, this.last)\n    this.last--\n    this.down(1)\n    return res\n  }\n  up(lo) {\n    while (lo > 1) {\n      const currEl = this.arr[lo]\n      const parent = Math.floor(lo / 2)\n      const parentEl = this.arr[parent]\n      if (this.compare(currEl, parentEl)) {\n        this.swap(lo, parent)\n      } else {\n        break\n      }\n      lo = parent\n    }\n  }\n  down(hi) {\n    while (hi * 2 <= this.last) {\n      const currEl = this.arr[hi]\n      let nextEl = this.arr[hi * 2]\n      let nextIndex = hi * 2\n      if (\n        hi * 2 + 1 <= this.last &&\n        this.compare(this.arr[hi * 2 + 1], nextEl)\n      ) {\n        nextIndex = hi * 2 + 1\n        nextEl = this.arr[nextIndex]\n      }\n      if (this.compare(nextEl, currEl)) {\n        this.swap(hi, nextIndex)\n      } else {\n        break\n      }\n      hi = nextIndex\n    }\n  }\n  swap(i, j) {\n    const temp = this.arr[i]\n    this.arr[i] = this.arr[j]\n    this.arr[j] = temp\n  }\n  peek() {\n    if (this.isEmpty()) {\n      return null\n    }\n    return this.arr[1]\n  }\n  isEmpty() {\n    return this.last < 1\n  }\n}\n\n// another\n\n/**\n * @param {number} capacity\n */\nconst DinnerPlates = function (capacity) {\n  this.pushIndex = 0\n  this.popIndex = 0\n  this.capacity = capacity\n  this.stacks = [[]]\n}\n\n/**\n * @param {number} val\n * @return {void}\n */\nDinnerPlates.prototype.push = function (val) {\n  while (\n    this.pushIndex < this.stacks.length &&\n    this.stacks[this.pushIndex].length === this.capacity\n  ) {\n    this.pushIndex++\n  }\n  if (this.stacks.length === this.pushIndex) {\n    this.stacks[this.pushIndex] = [val]\n  } else {\n    this.stacks[this.pushIndex].push(val)\n  }\n  if (this.popIndex < this.pushIndex) {\n    this.popIndex = this.pushIndex\n  }\n}\n\n/**\n * @return {number}\n */\nDinnerPlates.prototype.pop = function () {\n  while (this.stacks[this.popIndex].length === 0) {\n    if (this.popIndex > 0) {\n      this.popIndex--\n    } else {\n      return -1\n    }\n  }\n  const valueAtIndex = this.stacks[this.popIndex].pop()\n  if (this.pushIndex > this.popIndex) {\n    this.pushIndex = this.popIndex\n  }\n  return valueAtIndex\n}\n\n/**\n * @param {number} index\n * @return {number}\n */\nDinnerPlates.prototype.popAtStack = function (index) {\n  if (index >= this.stacks.length) return -1\n  if (index < this.pushIndex) this.pushIndex = index\n  return this.stacks[index].length > 0 ? this.stacks[index].pop() : -1\n}\n\n/**\n * Your DinnerPlates object will be instantiated and called as such:\n * var obj = new DinnerPlates(capacity)\n * obj.push(val)\n * var param_2 = obj.pop()\n * var param_3 = obj.popAtStack(index)\n */\n\n"
    }
  },
  {
    "name": "1175-prime-arrangements",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nfunction isPrime(n) {\n  // Corner case\n  if (n <= 1) return false\n  // Check from 2 to n-1\n  for (let i = 2; i < n; i++) if (n % i == 0) return false\n  return true\n}\n\nconst numPrimeArrangements = function(n) {\n  let primes = 0 // # of primes.\n  let result = 1\n  const mod = 10 ** 9 + 7\n  for (let i = 2; i <= n; i++) if (isPrime(i)) primes++\n  // Calculate factorials and multiply.\n  for (let i = primes; i >= 1; i--) result = (i * result) % mod\n  for (let i = n - primes; i >= 1; i--) result = (i * result) % mod\n  return result // result of multiplying factorial(primes) with factorial(non-primes)\n}\n"
    }
  },
  {
    "name": "1176-diet-plan-performance",
    "code": {
      "JS": "/**\n * @param {number[]} calories\n * @param {number} k\n * @param {number} lower\n * @param {number} upper\n * @return {number}\n */\nvar dietPlanPerformance = function(calories, k, lower, upper) {\n    let res = 0\n    for(let i = 0, n = calories.length, tmp = 0; i < n; i++) {\n      tmp += calories[i]\n      if(i >= k - 1) {\n        if(i >= k) {\n          tmp -= calories[i - k]\n        }\n        if(tmp < lower) res--\n        else if(tmp > upper) res++\n      }\n\n    }\n    return res\n};\n\n// another\n\n/**\n * @param {number[]} calories\n * @param {number} k\n * @param {number} lower\n * @param {number} upper\n * @return {number}\n */\nvar dietPlanPerformance = function(calories, k, lower, upper) {\n    let res = 0\n    for(let i = 0, n = calories.length; i < n - k + 1; i++) {\n      let tmp = 0\n      for(let j = 0; j < k && i + j < n; j++) {\n        tmp += calories[i + j]\n      }\n      if(tmp < lower) res--\n      else if(tmp > upper) res++\n    }\n    return res\n};\n"
    }
  },
  {
    "name": "1177-can-make-palindrome-from-substring",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {number[][]} queries\n * @return {boolean[]}\n */\nconst canMakePaliQueries = function(s, queries) {\n  const code = ch => ch.charCodeAt(0) - 'a'.charCodeAt(0)\n  const preCount = [...s].reduce(\n    (a, c) => {\n      let nc = a[a.length - 1]\n      nc ^= 1 << code(c) //NOT on one bit\n      a.push(nc)\n      return a\n    },\n    [0]\n  )\n  return queries.map(q => {\n    let subCount = preCount[q[1] + 1] ^ preCount[q[0]]\n    let oddChs = 0\n    while (subCount > 0) {\n      oddChs += subCount & 1\n      subCount >>= 1\n    }\n    return Math.floor(oddChs / 2) <= q[2]\n  })\n}\n"
    }
  },
  {
    "name": "1178-number-of-valid-words-for-each-puzzle",
    "code": {
      "JS": "/**\n * @param {string[]} words\n * @param {string[]} puzzles\n * @return {number[]}\n */\nconst findNumOfValidWords = function(words, puzzles) {\n  let n = puzzles.length,\n    offset = 'a'.charCodeAt()\n  let res = new Array(n).fill(0)\n  let cnt = {}\n\n  for (let w of words) {\n    let mask = 0\n    for (let c of w) {\n      mask |= 1 << (c.charCodeAt() - offset)\n    }\n    cnt[mask] = ~~cnt[mask] + 1\n  }\n  for (let i = 0; i < n; i++) {\n    let s = puzzles[i],\n      len = s.length\n    for (let k = 0; k < 1 << (len - 1); k++) {\n      let mask = 1 << (s[0].charCodeAt() - offset)\n      for (let j = 0; j < len - 1; j++) {\n        if (k & (1 << j)) {\n          mask |= 1 << (s[j + 1].charCodeAt() - offset)\n        }\n      }\n      res[i] += ~~cnt[mask]\n    }\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "118-pascal's-triangle",
    "code": {
      "JS": "/**\r\n * @param {number} numRows\r\n * @return {number[][]}\r\n */\r\nconst generate = function(numRows) {\r\n  // row 0 => [1] length 0\r\n  // row 1 => [1, 1] length 1\r\n  // row 2 => [1, 2, 1] length 2\r\n  // row 3 => [1, 3, 3, 1] length 3\r\n\r\n  // current[i] = prev[i - 1] + prev[i]\r\n\r\n  const res = [];\r\n  for (let row = 0; row < numRows; row += 1) {\r\n    if (row === 0) {\r\n      res.push([1]);\r\n      continue;\r\n    }\r\n\r\n    if (row === 1) {\r\n      res.push([1, 1]);\r\n      continue;\r\n    }\r\n\r\n    const newRow = [];\r\n    const maxIdx = row;\r\n    for (let i = 0; i <= maxIdx; i += 1) {\r\n      if (i === 0 || i === maxIdx) {\r\n        newRow.push(1);\r\n      } else {\r\n        newRow.push(res[row - 1][i - 1] + res[row - 1][i]);\r\n      }\r\n    }\r\n    res.push(newRow);\r\n  }\r\n\r\n  return res;\r\n};\r\n"
    }
  },
  {
    "name": "1180-count-substrings-with-only-one-distinct-letter",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst countLetters = function(s) {\n  const str = ` ${s} `\n  let res = 0, cnt = 0\n  for(let i = 1; i < str.length - 1; i++) {\n    if(str[i] !== str[i - 1]) cnt = 1\n    else cnt += 1\n    res += cnt\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1181-before-and-after-puzzle",
    "code": {
      "JS": "/**\n\nGiven a list of phrases, generate a list of Before and After puzzles.\n\nA phrase is a string that consists of lowercase English letters and spaces only.\nNo space appears in the start or the end of a phrase. There are no consecutive spaces in a phrase.\nBefore and After puzzles are phrases that are formed by merging two phrases where the last word of\nthe first phrase is the same as the first word of the second phrase.\nReturn the Before and After puzzles that can be formed by every two phrases phrases[i] and\nphrases[j] where i != j. Note that the order of matching two phrases matters,\nwe want to consider both orders.\n\nYou should return a list of distinct strings sorted lexicographically.\n\nExample 1:\n\nInput: phrases = [\"writing code\",\"code rocks\"]\nOutput: [\"writing code rocks\"]\nExample 2:\n\nInput: phrases = [\"mission statement\",\n                  \"a quick bite to eat\",\n                  \"a chip off the old block\",\n                  \"chocolate bar\",\n                  \"mission impossible\",\n                  \"a man on a mission\",\n                  \"block party\",\n                  \"eat my words\",\n                  \"bar of soap\"]\nOutput: [\"a chip off the old block party\",\n         \"a man on a mission impossible\",\n         \"a man on a mission statement\",\n         \"a quick bite to eat my words\",\n         \"chocolate bar of soap\"]\nExample 3:\n\nInput: phrases = [\"a\",\"b\",\"a\"]\nOutput: [\"a\"]\n\nConstraints:\n\n1 <= phrases.length <= 100\n1 <= phrases[i].length <= 100\n\n*/\n\n/**\n * @param {string[]} phrases\n * @return {string[]}\n */\nconst beforeAndAfterPuzzles = function(phrases) {\n  const ret = new Set()\n  const start = {}\n  const splitArr = phrases.map(el => el.split(' '))\n  for (let i = 0; i < splitArr.length; i++) {\n    const firstWord = splitArr[i][0]\n    start[firstWord] = start[firstWord] || []\n    start[firstWord].push(i)\n  }\n  for (let i = 0; i < splitArr.length; i++) {\n    const lastWord = splitArr[i][splitArr[i].length - 1]\n    if (start[lastWord]) {\n      for (let idx of start[lastWord]) {\n        if (idx !== i) {\n          ret.add(splitArr[i].concat(splitArr[idx].slice(1)).join(' '))\n        }\n      }\n    }\n  }\n  return [...ret].sort()\n}\n"
    }
  },
  {
    "name": "1183-maximum-number-of-ones",
    "code": {
      "JS": "/**\n * @param {number} width\n * @param {number} height\n * @param {number} sideLength\n * @param {number} maxOnes\n * @return {number}\n */\nconst maximumNumberOfOnes = function (width, height, sideLength, maxOnes) {\n  const n1 = (height / sideLength) >> 0,\n    h = height % sideLength,\n    n2 = (width / sideLength) >> 0,\n    w = width % sideLength\n  if (maxOnes <= w * h) return n1 * n2 * maxOnes + (n1 + n2 + 1) * maxOnes\n  else {\n    const a = h * w,\n      B = (sideLength - w) * h,\n      C = (sideLength - h) * w\n    let b = Math.min(B, maxOnes - a)\n    let c = Math.min(maxOnes - a - b, C)\n    const res1 = n1 * (a + c) + n2 * (a + b)\n    c = Math.min(C, maxOnes - a)\n    b = Math.min(maxOnes - a - c, B)\n    const res2 = n1 * (a + c) + n2 * (a + b)\n    return n1 * n2 * maxOnes + Math.max(res1, res2) + a\n  }\n}\n"
    }
  },
  {
    "name": "1184-distance-between-bus-stops",
    "code": {
      "JS": "/**\n * @param {number[]} distance\n * @param {number} start\n * @param {number} destination\n * @return {number}\n */\nconst distanceBetweenBusStops = function(distance, start, destination) {\n  if (start > destination) {\n    let temp = start\n    start = destination\n    destination = temp\n  }\n  let res = 0,\n    total = 0\n  for (let i = 0; i < distance.length; i++) {\n    if (i >= start && i < destination) {\n      res += distance[i]\n    }\n    total += distance[i]\n  }\n  return Math.min(res, total - res)\n}\n"
    }
  },
  {
    "name": "1185-day-of-the-week",
    "code": {
      "JS": "/**\n * @param {number} day\n * @param {number} month\n * @param {number} year\n * @return {string}\n */\nconst dayOfTheWeek = function(day, month, year) {\n  const weekdays = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\n  const date = new Date(year,month-1,day).getDay();\n  return weekdays[date];\n};\n"
    }
  },
  {
    "name": "1186-maximum-subarray-sum-with-one-deletion",
    "code": {
      "JS": "/**\n * @param {number[]} arr\n * @return {number}\n */\nconst maximumSum = function(arr) {\n  const n = arr.length\n  let d1 = arr[0],\n    d2 = arr[0],\n    best = arr[0]\n  for (let i = 1; i < n; ++i) {\n    d2 = Math.max(d2 + arr[i], Math.max(d1, arr[i]))\n    d1 = Math.max(d1 + arr[i], arr[i])\n    best = Math.max(d2, best)\n  }\n  return best\n}\n"
    }
  },
  {
    "name": "1187-make-array-strictly-increasing",
    "code": {
      "JS": "/**\n * @param {number[]} arr1\n * @param {number[]} arr2\n * @return {number}\n */\nconst makeArrayIncreasing = function(arr1, arr2) {\n  arr2.sort((a, b) => a - b)\n  let arr3 = [arr2[0]]\n  for (let i = 1; i < arr2.length; i++) {\n    if (arr2[i] > arr2[i - 1]) {\n      arr3.push(arr2[i])\n    }\n  }\n  arr2 = arr3\n  let n = arr1.length\n  let indexMap = new Array(n * 2 + 2)\n  for (let i = 0; i < n; i++) {\n    let ai = arr1[i]\n    let li = findLarger(arr2, ai)\n    indexMap[i * 2] = li\n    indexMap[i * 2 + 1] = arr2[li - 1] === ai ? li - 2 : li - 1\n  }\n  indexMap[n * 2] = arr2.length\n  indexMap[n * 2 + 1] = arr2.length - 1\n  let dp = new Array(n + 1)\n  let MaxNum = 1000000000 + 1\n  dp[0] = 0\n  for (let i = 1; i < n + 1; i++) {\n    let min = i\n    let ai = i === n ? MaxNum : arr1[i]\n    for (let j = 0; j < i; j++) {\n      if (dp[j] == -1 || ai <= arr1[j]) {\n        continue\n      }\n      if (indexMap[i * 2 + 1] - indexMap[j * 2] + 1 < i - j - 1) continue\n      min = Math.min(min, dp[j] + i - j - 1)\n    }\n    if (min === i) {\n      if (indexMap[i * 2 + 1] + 1 < i) {\n        min = -1\n      }\n    }\n    dp[i] = min\n  }\n  return dp[n]\n}\nconst findLarger = function(arr, a) {\n  if (a > arr[arr.length - 1]) return arr.length\n  let l = 0\n  let r = arr.length - 1\n  while (l < r) {\n    let mid = (l + r) >> 1\n    if (arr[mid] <= a) {\n      l = mid + 1\n    } else {\n      r = mid\n    }\n  }\n  return l\n}\n"
    }
  },
  {
    "name": "1189-maximum-number-of-balloons",
    "code": {
      "JS": "/**\n * @param {string} text\n * @return {number}\n */\nconst maxNumberOfBalloons = function(text) {\n  const cnt = [...text].reduce((A, ch) => {\n    A[ch] = (A[ch] || 0) + 1;\n    return A;\n  }, {});\n  const ans = Math.min(cnt['b'], cnt['a'], cnt['l'] / 2, cnt['o'] / 2, cnt['n']);\n  return ans ? Math.floor(ans) : 0;\n};\n"
    }
  },
  {
    "name": "119-pascal's-triangle-II",
    "code": {
      "JS": "/**\r\n * @param {number} rowIndex\r\n * @return {number[]}\r\n */\r\nconst getRow = function(rowIndex) {\r\n  if (!rowIndex) return [1];\r\n  if (rowIndex === 1) return [1, 1];\r\n  const res = [1, 1];\r\n  for (let i = 2; i <= rowIndex; i++) {\r\n    res[i] = 1;\r\n    for (let j = i - 1; j >= 1; j--) {\r\n      res[j] = res[j] + res[j - 1];\r\n    }\r\n  }\r\n  return res;\r\n};\r\n"
    }
  },
  {
    "name": "1190-reverse-substrings-between-each-pair-of-parentheses",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {string}\n */\nconst reverseParentheses = function(s) {\n  const res = ['']\n  let control = 0\n  let order = 1\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === '(') {\n      control++\n      order = order ? 0 : 1\n      res.push('')\n    } else if (s[i] === ')') {\n      if (order) res[control - 1] = res.pop() + res[control - 1]\n      else res[control - 1] = res[control - 1] + res.pop()\n      order = order ? 0 : 1\n      control--\n    } else {\n      if (order) res[control] = res[control] + s[i]\n      else res[control] = s[i] + res[control]\n    }\n  }\n  return res[0]\n}\n\n// another\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst reverseParentheses = function(s) {\n  const n = s.length\n  const stack = []\n  const pair = []\n  for(let i = 0; i < n; i++) {\n    if(s[i] === '(') stack.push(i)\n    else if(s[i] === ')') {\n      const tmp = stack.pop()\n      pair[i] = tmp\n      pair[tmp] = i\n    }\n  }\n  let res = ''\n  for(let i = 0, d = 1; i < n; i += d) {\n    if(s[i] === '(' || s[i] ===')') {\n      i = pair[i]\n      d = -d\n    } else {\n      res += s[i]\n    }\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "1191-k-concatenation-maximum-sum",
    "code": {
      "JS": "/**\n * @param {number[]} arr\n * @param {number} k\n * @return {number}\n */\nconst kConcatenationMaxSum = function(arr, k) {\n  const MOD = 1e9 + 7,\n    INF = 1e4 + 1;\n  const kadane = (A, sum = 0, ans = -INF) => {\n    for (let x of A) {\n      sum = Math.max(0, sum + x);\n      ans = Math.max(ans, sum);\n    }\n    return [sum, ans];\n  };\n  const [sum1, ans1] = kadane(arr);\n  const [sum2, ans2] = kadane(arr, sum1);\n  const [sum3, ans3] = kadane(arr, sum2);\n  const delta1 = ans2 - ans1,\n    delta2 = ans3 - ans2;\n  return k == 1 || delta1 == 0\n    ? ans1\n    : delta2 == 0\n    ? ans2\n    : ans1 + ((delta1 * (k - 1)) % MOD);\n};\n"
    }
  },
  {
    "name": "1192-critical-connections-in-a-network",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[][]} connections\n * @return {number[][]}\n */\nconst criticalConnections = function(n, connections) {\n  const g = [],\n    low = Array(n),\n    res = []\n  low.fill(0)\n  for (let con of connections) {\n    g[con[0]] = g[con[0]] || []\n    g[con[1]] = g[con[1]] || []\n    g[con[0]].push(con[1])\n    g[con[1]].push(con[0])\n  }\n  const dfs = function(cur, v, p) {\n    let dfn = cur\n    low[v] = cur\n    for (let i of g[v]) {\n      if (i != p) {\n        if (low[i] == 0) {\n          cur++\n          dfs(cur, i, v)\n          if (low[i] > dfn) {\n            res.push([i, v])\n          }\n        }\n        low[v] = Math.min(low[v], low[i])\n      }\n    }\n  }\n  dfs(1, 0, -1)\n  return res\n}\n"
    }
  },
  {
    "name": "1199-minimum-time-to-build-blocks",
    "code": {
      "JS": "/**\n * @param {number[]} blocks\n * @param {number} split\n * @return {number}\n */\nconst minBuildTime = function (blocks, split) {\n  const minHeap = new MinHeap()\n  blocks.forEach((block) => minHeap.push(block))\n  while (minHeap.size() > 1) {\n    minHeap.pop()\n    minHeap.push(minHeap.pop() + split)\n  }\n  return minHeap.pop()\n}\n\nclass MinHeap {\n  constructor() {\n    this.store = []\n  }\n  size() {\n    return this.store.length\n  }\n  push(value) {\n    this.store.push(value)\n    this.heapifyUp(this.store.length - 1)\n  }\n  pop() {\n    if (this.store.length < 2) return this.store.pop()\n    let result = this.store[0]\n    this.store[0] = this.store.pop()\n    this.heapifyDown(0)\n    return result\n  }\n  heapifyUp(child) {\n    const parent = Math.floor((child - 1) / 2)\n    if (child && this.store[child] < this.store[parent]) {\n      const temp = this.store[child]\n      this.store[child] = this.store[parent]\n      this.store[parent] = temp\n      this.heapifyUp(parent)\n    }\n  }\n  heapifyDown(parent) {\n    const childs = [1, 2]\n      .map((n) => parent * 2 + n)\n      .filter((n) => n < this.store.length)\n    let child = childs[0]\n    if (childs[1] && this.store[childs[1]] < this.store[child]) {\n      child = childs[1]\n    }\n    if (child && this.store[child] < this.store[parent]) {\n      const temp = this.store[child]\n      this.store[child] = this.store[parent]\n      this.store[parent] = temp\n      this.heapifyDown(child)\n    }\n  }\n}\n"
    }
  },
  {
    "name": "12-integer-to-roman",
    "code": {
      "JS": "/**\r\n * @param {number} num\r\n * @return {string}\r\n */\r\nconst map = {\r\n  \"1000\": \"M\",\r\n  \"900\": \"CM\",\r\n  \"500\": \"D\",\r\n  \"400\": \"CD\",\r\n  \"100\": \"C\",\r\n  \"90\": \"XC\",\r\n  \"50\": \"L\",\r\n  \"40\": \"XL\",\r\n  \"10\": \"X\",\r\n  \"9\": \"IX\",\r\n  \"5\": \"V\",\r\n  \"4\": \"IV\",\r\n  \"1\": \"I\"\r\n};\r\nconst intToRoman = function(number) {\r\n  const l = fkey(map, number);\r\n  if (number == +l) {\r\n    return map[number];\r\n  }\r\n  return map[l] + intToRoman(number - +l);\r\n};\r\n\r\nfunction fkey(m, num) {\r\n  const keys = Object.keys(m);\r\n  const sArr = keys.filter(el => +el <= num);\r\n  return +Math.max.apply(Math, sArr);\r\n}\r\n"
    }
  },
  {
    "name": "120-triangle",
    "code": {
      "JS": "/**\n * @param {number[][]} triangle\n * @return {number}\n */\nconst minimumTotal = function(triangle) {\n  const n = triangle.length;\n  for (let i = n - 2; i >= 0; i--) {\n    for (let j = 0; j < n; j++) {\n      let self = triangle[i][j]; //获取第（i+1）行（j+1）个数字\n      let res = Math.min(\n        triangle[i + 1][j] + self,\n        triangle[i + 1][j + 1] + self\n      ); //得到这一行与下一行相邻数的和的最小值\n      triangle[i][j] = res; //更新第（i+1）行第（j+1）个数字\n    }\n  }\n\n  return triangle[0][0];\n};\n"
    }
  },
  {
    "name": "1200-minimum-absolute-difference",
    "code": {
      "JS": "/**\n * @param {number[]} arr\n * @return {number[][]}\n */\nconst minimumAbsDifference = function(arr) {\n  arr.sort((a, b) => a - b)\n  let min = Number.MAX_VALUE\n  for(let i = 1, len = arr.length; i < len; i++) {\n    if(arr[i] - arr[i - 1] < min) min = arr[i] - arr[i - 1]\n  }\n  const res = []\n  for(let i = 1, len = arr.length; i < len; i++) {\n    if(arr[i] - arr[i - 1] === min) res.push([arr[i - 1], arr[i]])\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1202-smallest-string-with-swaps",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {number[][]} pairs\n * @return {string}\n */\nconst smallestStringWithSwaps = function(s, pairs) {\n  let set = Array(s.length).fill(-1)\n  function union(a, b) {\n    let root1 = find(a)\n    let root2 = find(b)\n    if (root1 !== root2) {\n      set[root2] = root1\n    }\n  }\n  function find(a) {\n    if (set[a] < 0) {\n      return a\n    } else {\n      return (set[a] = find(set[a]))\n    }\n  }\n  for (let pair of pairs) {\n    union(pair[0], pair[1])\n  }\n  let groups = []\n  for (let i = 0; i < s.length; i++) {\n    groups[i] = []\n  }\n  for (let i = 0; i < s.length; i++) {\n    groups[find(i)].push(i)\n  }\n  let sArr = s.split('')\n  for (let i = 0; i < s.length; i++) {\n    if (groups[i].length > 1) {\n      let chars = groups[i].map(idx => s[idx])\n      chars.sort()\n      for (let k = 0; k < groups[i].length; k++) {\n        sArr[groups[i][k]] = chars[k]\n      }\n    }\n  }\n  return sArr.join('')\n}\n"
    }
  },
  {
    "name": "1203-sort-items-by-groups-respecting-dependencies",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number} m\n * @param {number[]} group\n * @param {number[][]} beforeItems\n * @return {number[]}\n */\nconst sortItems = function (n, m, group, beforeItems) {\n  const vertexs = new Map()\n  const groupVertexs = new Map()\n  let groupNo = m\n  for (let i = 0; i < n; i++) {\n    vertexs.set(i, {\n      neighbors: new Set(),\n      indegree: 0,\n    })\n    if (group[i] === -1) {\n      group[i] = groupNo++\n    }\n    if (!groupVertexs.has(group[i])) {\n      groupVertexs.set(group[i], {\n        v: new Set(),\n        neighbors: new Set(),\n        indegree: 0,\n      })\n    }\n    groupVertexs.get(group[i]).v.add(i)\n  }\n\n  for (let i = 0; i < n; i++) {\n    for (const before of beforeItems[i]) {\n      if (!vertexs.get(before).neighbors.has(i)) {\n        vertexs.get(i).indegree += 1\n      }\n      vertexs.get(before).neighbors.add(i)\n\n      const groupOfBefore = group[before]\n      if (groupOfBefore === group[i]) continue\n      if (!groupVertexs.get(groupOfBefore).neighbors.has(group[i])) {\n        groupVertexs.get(group[i]).indegree += 1\n      }\n      groupVertexs.get(groupOfBefore).neighbors.add(group[i])\n    }\n  }\n\n  const zeroGroup = []\n  for (const group of groupVertexs) {\n    if (group[1].indegree === 0) {\n      zeroGroup.push(group[0])\n    }\n  }\n  const result = []\n  let cntGroup = 0\n  let cntV = 0\n  const groupTotal = groupVertexs.size\n\n  while (zeroGroup.length) {\n    const top = zeroGroup.pop()\n    cntGroup += 1\n    const v = groupVertexs.get(top).v\n    const total = v.size\n    const zero = []\n\n    for (const i of v) {\n      if (vertexs.get(i).indegree === 0) {\n        zero.push(i)\n      }\n    }\n    while (zero.length) {\n      const it = zero.pop()\n      result.push(it)\n      for (const n of vertexs.get(it).neighbors) {\n        vertexs.get(n).indegree -= 1\n        if (v.has(n) && vertexs.get(n).indegree === 0) {\n          zero.push(n)\n        }\n      }\n    }\n    if (result.length - cntV !== total) {\n      return []\n    }\n    cntV = result.length\n\n    for (const groupneigbor of groupVertexs.get(top).neighbors) {\n      groupVertexs.get(groupneigbor).indegree -= 1\n      if (groupVertexs.get(groupneigbor).indegree === 0) {\n        zeroGroup.push(groupneigbor)\n      }\n    }\n  }\n\n  return cntGroup === groupTotal ? result : []\n}\n"
    }
  },
  {
    "name": "1206-design-skiplist",
    "code": {
      "JS": "class Skiplist {\n  constructor() {\n    this.head = { down: null, right: null, val: -Infinity }\n  }\n  search(val) {\n    let curr = this.head\n    while (curr) {\n      while (curr.right && curr.right.val <= val) {\n        curr = curr.right\n      }\n      if (curr.val == val) {\n        return true\n      }\n      curr = curr.down\n    }\n    return false\n  }\n  add(val) {\n    let curr = this.head\n    const insertion_positions = []\n    while (curr) {\n      while (curr.right && curr.right.val < val) {\n        curr = curr.right\n      }\n      insertion_positions.push(curr)\n      curr = curr.down\n    }\n    let insert = true\n    let down = null\n    while (insert && insertion_positions.length) {\n      const position = insertion_positions.pop()\n      const node = { down, val, right: position.right }\n      position.right = node\n      down = node\n      insert = Math.random() < 0.5\n    }\n    if (insert) {\n      const node = { val, down }\n      this.head = { val: -Infinity, right: node, down: this.head }\n    }\n  }\n  erase(val) {\n    let curr = this.head\n    const erase_positions = []\n    while (curr) {\n      while (curr.right && curr.right.val < val) {\n        curr = curr.right\n      }\n      if (curr.right && curr.right.val == val) {\n        erase_positions.push(curr)\n      }\n      curr = curr.down\n    }\n    const seen = erase_positions.length > 0\n    for (const position of erase_positions) {\n      position.right = position.right && position.right.right\n    }\n    return seen\n  }\n}\n\n// another\n\nconst Skiplist = function () {\n  this.maxLvl = ~~Math.log2(20000)\n  this.levels = [...Array(this.maxLvl)].map(() => new Node(-1))\n  for (let i = this.maxLvl - 1; i > 0; i--) {\n    this.levels[i].down = this.levels[i - 1]\n  }\n  this.head = this.levels[this.maxLvl - 1]\n}\n\n/**\n * @param {number} target\n * @return {boolean}\n */\nSkiplist.prototype.search = function (target) {\n  const pre = this.iter(target)\n  return !pre[0].next ? false : pre[0].next.val === target\n}\n\nSkiplist.prototype.iter = function (target) {\n  let cur = this.head\n  const pre = []\n  for (let i = this.maxLvl - 1; i >= 0; i--) {\n    while (cur.next && cur.next.val < target) cur = cur.next\n    pre[i] = cur\n    cur = cur.down\n  }\n  return pre\n}\n\n/**\n * @param {number} num\n * @return {void}\n */\nSkiplist.prototype.add = function (num) {\n  const pre = this.iter(num)\n  const lvs = decideLevels(this.maxLvl)\n  for (let i = 0; i < lvs; i++) {\n    const next = pre[i].next\n    pre[i].next = new Node(num)\n    pre[i].next.next = next\n    if (i > 0) pre[i].next.down = pre[i - 1].next\n  }\n}\n\n/**\n * @param {number} num\n * @return {boolean}\n */\nSkiplist.prototype.erase = function (num) {\n  const pre = this.iter(num)\n  let ret\n  if (!pre[0].next || pre[0].next.val !== num) return false\n  for (let i = this.maxLvl - 1; i >= 0; i--) {\n    if (pre[i].next && pre[i].next.val === num) {\n      const toBeDeleted = pre[i].next\n      pre[i].next = toBeDeleted.next\n      toBeDeleted.next = null\n      toBeDeleted.down = null\n    }\n  }\n  return true\n}\n\n/**\n * Your Skiplist object will be instantiated and called as such:\n * var obj = new Skiplist()\n * var param_1 = obj.search(target)\n * obj.add(num)\n * var param_3 = obj.erase(num)\n */\n\nconst decideLevels = (max) => {\n  let ans = 1\n  while (Math.random() > 0.5 && ans < max) ans++\n  return ans\n}\n\nconst Node = function (val) {\n  this.val = val\n  this.next = null\n  this.down = null\n}\n"
    }
  },
  {
    "name": "1207-unique-number-of-occurrences",
    "code": {
      "JS": "/**\n * @param {number[]} arr\n * @return {boolean}\n */\nconst uniqueOccurrences = function(arr) {\n  const hash = {}\n  for(let e of arr) {\n    if(hash[e] == null) hash[e] = 0\n    hash[e]++\n  }\n  const ks = new Set(Object.keys(hash)), vs = new Set(Object.values(hash))\n  return ks.size === vs.size\n};\n"
    }
  },
  {
    "name": "1209-remove-all-adjacent-duplicates-in-string-ii",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {number} k\n * @return {string}\n */\nconst removeDuplicates = function (s, k) {\n  const stack = [];\n  const arr = s.split('')\n  for(let i = 0; i < arr.length; i++) {\n    if(i === 0 || arr[i] !== arr[i - 1]) {\n      stack.push(1)\n    } else {\n      stack[stack.length - 1]++\n      if(stack[stack.length - 1] === k) {\n        stack.pop()\n        arr.splice(i - k + 1, k)\n        i -= k\n      }\n    }\n    \n  }\n  return arr.join('')\n};\n\n// another\n\n/**\n * @param {string} s\n * @param {number} k\n * @return {string}\n */\nconst removeDuplicates = function (s, k) {\n  const stack = [];\n  s = s.split('');\n  for (let i = 0; i < s.length;) {\n    if (i === 0 || s[i] !== s[i - 1]) {\n      stack.push(1);\n      i++\n    } else {\n      stack[stack.length - 1]++;\n      if (stack[stack.length - 1] === k) {\n        stack.pop();\n        s.splice(i - k + 1, k);\n        i = i - k + 1;\n      } else {\n        i++\n      }\n    }\n  }\n  return s.join('');\n};\n"
    }
  },
  {
    "name": "121-best-time-to-buy-and-sell-stock",
    "code": {
      "JS": "/**\r\n * @param {number[]} prices\r\n * @return {number}\r\n */\r\nconst maxProfit = function(prices) {\r\n  let minPrice = Number.MAX_SAFE_INTEGER;\r\n  let maxP = 0;\r\n  for (let i = 0; i < prices.length; i++) {\r\n    if (prices[i] < minPrice) {\r\n      minPrice = prices[i];\r\n    } else if (prices[i] - minPrice > maxP) {\r\n      maxP = prices[i] - minPrice;\r\n    }\r\n  }\r\n  return maxP;\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * @param {number[]} prices\r\n * @return {number}\r\n */\r\nconst maxProfit = function(prices) {\r\n  let res = 0, maxCur = 0\r\n  for(let i = 1; i < prices.length; i++) {\r\n    maxCur = Math.max(0, maxCur + (prices[i] - prices[i - 1]))\r\n    res = Math.max(res, maxCur)\r\n  }\r\n  return res\r\n};\r\n"
    }
  },
  {
    "name": "1210-minimum-moves-to-reach-target-with-rotations",
    "code": {
      "JS": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nconst minimumMoves = function (grid) {\n  const n = grid.length;\n  const start = [0, 0, 0, 1].join(',');\n  const end = [n - 1, n - 2, n - 1, n - 1].join(\",\");\n  let curr_level = new Set([start]);\n  let moves = 0;\n  const visited = new Set();\n  while (curr_level.size) {\n    const next_level = new Set();\n    for (let pos of curr_level) {\n      visited.add(pos);\n      let [r1, c1, r2, c2] = pos.split(\",\").map((e) => +e);\n      if (\n        c1 + 1 < n &&\n        grid[r1][c1 + 1] == 0 &&\n        c2 + 1 < n &&\n        grid[r2][c2 + 1] == 0\n      ) {\n        const coord = [r1, c1 + 1, r2, c2 + 1].join(\",\");\n        if (!visited.has(coord)) {\n          next_level.add(coord);\n        }\n      }\n      if (\n        r1 + 1 < n &&\n        grid[r1 + 1][c1] == 0 &&\n        r2 + 1 < n &&\n        grid[r2 + 1][c2] == 0\n      ) {\n        const coord = [r1 + 1, c1, r2 + 1, c2].join(\",\");\n        if (!visited.has(coord)) {\n          next_level.add(coord);\n        }\n      }\n      if (\n        r1 == r2 &&\n        c2 == c1 + 1 &&\n        r1 + 1 < n &&\n        grid[r1 + 1][c1] + grid[r1 + 1][c1 + 1] == 0\n      ) {\n        const coord = [r1, c1, r1 + 1, c1].join(\",\");\n        if (!visited.has(coord)) {\n          next_level.add(coord);\n        }\n      }\n      if (\n        c1 == c2 &&\n        r2 == r1 + 1 &&\n        c1 + 1 < n &&\n        grid[r1][c1 + 1] + grid[r1 + 1][c1 + 1] == 0\n      ) {\n        const coord = [r1, c1, r1, c1 + 1].join(\",\");\n        if (!visited.has(coord)) {\n          next_level.add(coord);\n        }\n      }\n    }\n    if (next_level.has(end)) {\n      return moves + 1;\n    }\n    curr_level = next_level;\n    moves += 1;\n  }\n  return -1;\n};\n"
    }
  },
  {
    "name": "1213-intersection-of-three-sorted-arrays",
    "code": {
      "JS": "/**\n * @param {number[]} arr1\n * @param {number[]} arr2\n * @param {number[]} arr3\n * @return {number[]}\n */\nconst arraysIntersection = function(arr1, arr2, arr3) {\n  const common = [], n1 = arr1.length, n2 = arr2.length, n3 = arr3.length\n  let p1 = 0, p2 = 0, p3 = 0\n  while(p1 < n1 && p2 < n2) {\n    if(arr1[p1] === arr2[p2]) {\n      common.push(arr1[p1])\n      p1++\n      p2++\n    } else if(arr1[p1] < arr2[p2]) p1++\n    else p2++\n  }\n  const res = [], nc = common.length\n  let pc = 0\n  while(pc < nc && p3 < n3) {\n    if(common[pc] === arr3[p3]) {\n      res.push(arr3[p3])\n      pc++\n      p3++\n    } else if(common[pc] < arr3[p3]) pc++\n    else p3++\n  }\n  \n  \n  return res\n};\n\n// another\n\n/**\n * @param {number[]} arr1\n * @param {number[]} arr2\n * @param {number[]} arr3\n * @return {number[]}\n */\nconst arraysIntersection = function(arr1, arr2, arr3) {\n  let a=0,b=0,c=0;\n  const res = [];\n  while(a<arr1.length && b<arr2.length && c<arr3.length) {\n    let min = Math.min(arr1[a], Math.min(arr2[b],arr3[c]));\n    if(arr1[a] === min && arr2[b] === min && arr3[c] === min) res.push(min);\n    if(arr1[a] === min) a++;\n    if(arr2[b] === min) b++;\n    if(arr3[c] === min) c++;\n  }\n  return res;\n};\n"
    }
  },
  {
    "name": "1214-two-sum-bsts",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root1\n * @param {TreeNode} root2\n * @param {number} target\n * @return {boolean}\n */\nconst twoSumBSTs = function(root1, root2, target) {\n  if(root1 == null && root2 == null) return false\n  if(root2 == null) return root1.val === target\n  if(root1 == null) return root2.val === target\n  if(root1.val + root2.val === target) return true\n  if(root1.val + root2.val < target) {\n    return twoSumBSTs(root1.right, root2, target) || twoSumBSTs(root1, root2.right, target)\n  } else {\n    return twoSumBSTs(root1.left, root2, target) || twoSumBSTs(root1, root2.left, target)\n  }\n};\n\n// another\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root1\n * @param {TreeNode} root2\n * @param {number} target\n * @return {boolean}\n */\nconst twoSumBSTs = function(root1, root2, target) {\n  if(root1 == null || root2 == null) return false\n  const s1 = [], s2 = []\n  while(true) {\n    while(root1) {\n      s1.push(root1)\n      root1 = root1.left\n    }\n    while(root2) {\n      s2.push(root2)\n      root2 = root2.right\n    }\n    if(s1.length === 0 || s2.length === 0) return false\n    const t1 = s1[s1.length - 1], t2 = s2[s2.length - 1]\n    if(t1.val + t2.val === target) return true\n    if(t1.val + t2.val < target) {\n      root1 = t1.right\n      s1.pop()\n    } else {\n      root2 = t2.left\n      s2.pop()\n    }\n    \n  }\n  return false\n};\n"
    }
  },
  {
    "name": "1216-valid-palindrome-iii",
    "code": {
      "JS": "/**\n\nGiven a string s and an integer k, find out if the given string is a K-Palindrome or not.\n\nA string is K-Palindrome if it can be transformed into a palindrome by removing at most k characters from it.\n\nExample 1:\n\nInput: s = \"abcdeca\", k = 2\nOutput: true\nExplanation: Remove 'b' and 'e' characters.\n \nConstraints:\n\n1 <= s.length <= 1000\ns has only lowercase English letters.\n1 <= k <= s.length\n\n*/\n\n/**\n * @param {string} s\n * @param {number} k\n * @return {boolean}\n */\nconst isValidPalindrome = function(s, k) {\n  const len = s.length\n  const reverse = s.split('').reverse().join('')\n  const lps = lcs(s, reverse, len, len)\n  return len - lps <= k\n  \n};\n\nfunction lcs(s1, s2, m, n) {\n  const dp = Array.from({ length: m + 1 }, () => new Array(n + 1).fill(0))\n  for(let i = 1; i <= m; i++) {\n    for(let j = 1; j <= n; j++) {\n      if(s1[i - 1] === s2[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1] + 1\n      } else {\n        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])\n      }\n    }\n  }\n  return dp[m][n]\n}\n\n// another\n\n/**\n * @param {string} s\n * @param {number} k\n * @return {boolean}\n */\nconst isValidPalindrome = function(s, k) {\n  const len = s.length\n  const cache = Array.from({ length: len }, () => new Array(len).fill(0))\n  chk(s, 0, len - 1, cache)\n  return cache[0][len - 1] <= k\n};\n\nfunction chk(s, l, r, cache) {\n  if(l >= r) return 0\n  if(cache[l][r]) return cache[l][r]\n  let num = 0\n  if(s[l] === s[r]) {\n    num = chk(s, l + 1, r - 1, cache) \n  } else {\n    num = 1 + Math.min(chk(s, l, r - 1, cache), chk(s, l + 1, r, cache))\n  }\n  cache[l][r] = num\n  return num\n}\n\n// another\n\nconst isValidPalindrome = function(s, k) {\n  const len = s.length\n  const dp = Array.from({ length: len }, () => new Array(len).fill(0))\n  for(let i = len - 1; i >= 0; i--) {\n    dp[i][i] = 1\n    for(let j = i + 1; j < len; j++) {\n      if(s[i] === s[j]) dp[i][j] = dp[i + 1][j - 1] + 2\n      else dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1])\n    }\n  }\n  return len <= dp[0][len - 1] + k\n};\n\n"
    }
  },
  {
    "name": "1217-minimum-cost-to-move-chips-to-the-same-position",
    "code": {
      "JS": "/**\n * @param {number[]} position\n * @return {number}\n */\nconst minCostToMoveChips = function(position) {\n  let oddSum = 0, evenSum = 0\n  for(let i = 0; i < position.length; i++) {\n    if(position[i] % 2 === 0) evenSum++\n    else oddSum++\n  }\n  return Math.min(oddSum, evenSum)\n};\n"
    }
  },
  {
    "name": "122-best-time-to-buy-and-sell-stock-ii",
    "code": {
      "JS": "/**\n * @param {number[]} prices\n * @return {number}\n */\nconst maxProfit = function (prices) {\n  let p = 0\n  for (let i = 1; i < prices.length; ++i) {\n    let delta = prices[i] - prices[i - 1]\n    if (delta > 0) {\n      p += delta\n    }\n  }\n  return p\n}\n"
    }
  },
  {
    "name": "1220-count-vowels-permutation",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst countVowelPermutation = function (n) {\n  const mod = 1e9 + 7\n  const arr = [\n    [0, 1, 1], // a -> e\n    [0, 1, 2], // e -> a, i\n    [0, 1, 4], // i -> a, e, o, u\n    [0, 1, 2], // o -> i, u\n    [0, 1, 1], // u -> a\n  ]\n  for (let i = 3; i <= n; i++) {\n    arr[0][i % 3] = arr[1][(i - 1) % 3] % mod\n    arr[1][i % 3] = (arr[0][(i - 1) % 3] + arr[2][(i - 1) % 3]) % mod\n    arr[2][i % 3] =\n      (arr[0][(i - 1) % 3] +\n        arr[1][(i - 1) % 3] +\n        arr[3][(i - 1) % 3] +\n        arr[4][(i - 1) % 3]) %\n      mod\n    arr[3][i % 3] = (arr[2][(i - 1) % 3] + arr[4][(i - 1) % 3]) % mod\n    arr[4][i % 3] = arr[0][(i - 1) % 3] % mod\n  }\n  return arr.reduce((sum, subArr) => sum + subArr[n % 3], 0) % mod\n}\n"
    }
  },
  {
    "name": "1221-split-a-string-in-balanced-strings",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst balancedStringSplit = function(s) {\n  let res = 0, num = 0\n  for(let ch of s) {\n    num += ch === 'L' ? 1 : -1\n    if(num === 0) res++\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1223-dice-roll-simulation",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[]} rollMax\n * @return {number}\n */\nconst dieSimulator = function(n, rollMax) {\n  const mod = 10 ** 9 + 7\n  const faces = rollMax.length\n  const dp = Array.from({ length: n + 1 }, () => new Array(faces + 1).fill(0))\n  dp[0][faces] = 1\n  for(let j = 0; j < faces; j++) {\n    dp[1][j] = 1\n  }\n  dp[1][faces] = faces\n  for(let i = 2; i < n + 1; i++) {\n    for(let j = 0; j < faces; j++) {\n      for(let k = 1; k < rollMax[j] + 1; k++) {\n        if(i - k < 0) break\n        dp[i][j] += dp[i - k][faces] - dp[i - k][j]\n        dp[i][j] %= mod\n      }\n    }\n    dp[i][faces] = dp[i].reduce((ac, e) => ac + e, 0)\n  }\n  return dp[n][faces] % mod\n};\n"
    }
  },
  {
    "name": "1224-maximum-equal-frequency",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst maxEqualFreq = function (nums) {\n  const cnt = {},\n    freq = {}\n  let maxF = 0,\n    res = 0\n  nums.forEach((num, i) => {\n    if (cnt[num] == null) cnt[num] = 0\n    cnt[num] += 1\n    if (freq[cnt[num] - 1] == null) freq[cnt[num] - 1] = 0\n    if (freq[cnt[num]] == null) freq[cnt[num]] = 0\n    freq[cnt[num] - 1] -= 1\n    freq[cnt[num]] += 1\n    maxF = Math.max(maxF, cnt[num])\n    if (\n      maxF * freq[maxF] === i ||\n      (maxF - 1) * (freq[maxF - 1] + 1) === i ||\n      maxF === 1\n    )\n      res = i + 1\n  })\n  return res\n}\n"
    }
  },
  {
    "name": "1228-missing-number-in-arithmetic-progression",
    "code": {
      "JS": "/**\n * @param {number[]} arr\n * @return {number}\n */\nconst missingNumber = function(arr) {\n  const n = arr.length\n\n  for(let i = 1 ; i < n - 1; i++) {\n    const d1 = arr[i] - arr[i - 1], d2 = arr[i + 1] - arr[i]\n    if(d1 === d2) continue\n    if(d1 / d2 === 2) return arr[i - 1] + d1 / 2\n    if(d2 / d1 === 2) return arr[i] + d2 / 2\n  }\n  return arr[0]\n};\n"
    }
  },
  {
    "name": "123-best-time-to-buy-and-sell-stock-iii",
    "code": {
      "JS": "/**\n * @param {number[]} prices\n * @return {number}\n */\nconst maxProfit = function(prices) {\n  let maxProfit1 = 0\n  let maxProfit2 = 0\n  let lowestBuyPrice1 = Number.MAX_VALUE\n  let lowestBuyPrice2 = Number.MAX_VALUE\n\n  for (let p of prices) {\n    maxProfit2 = Math.max(maxProfit2, p - lowestBuyPrice2)\n    lowestBuyPrice2 = Math.min(lowestBuyPrice2, p - maxProfit1)\n    maxProfit1 = Math.max(maxProfit1, p - lowestBuyPrice1)\n    lowestBuyPrice1 = Math.min(lowestBuyPrice1, p)\n  }\n  return maxProfit2\n}\n"
    }
  },
  {
    "name": "1231-divide-chocolate",
    "code": {
      "JS": "/**\n * @param {number[]} sweetness\n * @param {number} K\n * @return {number}\n */\nconst maximizeSweetness = function (sweetness, K) {\n  let left = 1,\n    right = 1e9 / (K + 1)\n  while (left < right) {\n    let mid = (left + right + 1) >> 1\n    let cur = 0,\n      cuts = 0\n    for (let a of sweetness) {\n      if ((cur += a) >= mid) {\n        cur = 0\n        if (++cuts > K) break\n      }\n    }\n    if (cuts > K) left = mid\n    else right = mid - 1\n  }\n  return left\n}\n"
    }
  },
  {
    "name": "1232-check-if-it-is-a-straight-line",
    "code": {
      "JS": "/**\n * @param {number[][]} coordinates\n * @return {boolean}\n */\nconst checkStraightLine = function(coordinates) {\n  const r = ratio(coordinates[0], coordinates[1])\n  for(let i = 1, len = coordinates.length;  i < len - 1;  i++) {\n    if(ratio(coordinates[i], coordinates[i + 1]) !== r) return false\n  }\n      \n  return true\n};\n\nfunction ratio(a, b) {\n  return (b[1] - a[1]) / (b[0] - a[0])\n}\n"
    }
  },
  {
    "name": "1235-maximum-profit-in-job-scheduling",
    "code": {
      "JS": "/**\n * @param {number[]} startTime\n * @param {number[]} endTime\n * @param {number[]} profit\n * @return {number}\n */\nconst jobScheduling = function (startTime, endTime, profit) {\n  const n = startTime.length\n  const items = Array(n)\n  for(let i = 0;i < n; i++) items[i] = [startTime[i], endTime[i], profit[i]]\n  items.sort((a, b) => a[1] - b[1])\n  const dpEndTime = [0]\n  const dpProfit = [0]\n  for(const [s, e, p] of items) {\n    const prevIdx = binarySearch(dpEndTime, 0, dpEndTime.length - 1, s)\n    const curProfit = dpProfit[prevIdx] + p, maxProfit = dpProfit[dpProfit.length - 1]\n    if(curProfit > maxProfit) {\n      dpProfit.push(curProfit)\n      dpEndTime.push(e)\n    }\n  }\n  \n  return dpProfit[dpProfit.length - 1]\n}\n\nfunction binarySearch(arr, l, r, x) {\n  while (l < r) {\n    const mid = r - ((r - l) >> 1)\n    if (arr[mid] > x) r = mid - 1\n    else l = mid\n  }\n  return l\n}\n\n\n// another\n\n/**\n * @param {number[]} startTime\n * @param {number[]} endTime\n * @param {number[]} profit\n * @return {number}\n */\nconst jobScheduling = function (startTime, endTime, profit) {\n  const n = startTime.length\n  const items = Array.from({ length: startTime.length }, () => Array(3).fill(0))\n  for (let i = 0; i < startTime.length; i++) {\n    items[i] = [startTime[i], endTime[i], profit[i]]\n  }\n  items.sort((a1, a2) => a1[1] - a2[1])\n  const dpProfit = [0]\n  for (let i = 0; i < n; i++) {\n    const [s, e, p] = items[i]\n    let prevIdx = -1\n    for(let j = i - 1; j >= 0; j--) {\n      if(items[j][1] <= items[i][0]) {\n        prevIdx = j\n        break\n      }\n    }\n    const curProfit = (prevIdx === -1 ? 0 : dpProfit[prevIdx]) + p\n    dpProfit[i] = Math.max(dpProfit[dpProfit.length - 1], curProfit)\n  }\n  return dpProfit[dpProfit.length - 1]\n}\n\n\n// another\n\n\n/**\n * @param {number[]} startTime\n * @param {number[]} endTime\n * @param {number[]} profit\n * @return {number}\n */\nconst jobScheduling = function (startTime, endTime, profit) {\n  const items = Array.from({ length: startTime.length }, () => Array(3).fill(0))\n  for (let i = 0; i < startTime.length; i++) {\n    items[i] = [startTime[i], endTime[i], profit[i]]\n  }\n  items.sort((a1, a2) => a1[1] - a2[1])\n  const dpEndTime = []\n  const dpProfit = []\n  dpEndTime.push(0)\n  dpProfit.push(0)\n  for (let item of items) {\n    const s = item[0],\n      e = item[1],\n      p = item[2]\n    // find previous endTime index\n    const prevIdx = binarySearch(dpEndTime, 0, dpEndTime.length - 1, s)\n    const currProfit = dpProfit[prevIdx] + p,\n      maxProfit = dpProfit[dpProfit.length - 1]\n    if (currProfit > maxProfit) {\n      dpProfit.push(currProfit)\n      dpEndTime.push(e)\n    }\n  }\n  return dpProfit[dpProfit.length - 1]\n}\n\nfunction binarySearch(arr, l, r, x) {\n  while (l <= r) {\n    const mid = l + ((r - l) >> 1)\n    if (arr[mid] > x) r = mid - 1\n    else {\n      if (mid == arr.length - 1 || arr[mid + 1] > x) return mid\n      l = mid + 1\n    }\n  }\n  return -1\n}\n"
    }
  },
  {
    "name": "124-binary-tree-maximum-path-sum",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nconst maxPathSum = function(root) {\n  let obj = {\n    max: Number.MIN_SAFE_INTEGER\n  }\n  traverse(root, obj)\n  \n  return obj.max\n};\n\nfunction traverse(node, obj) {\n  if(node === null) return 0\n  let left = Math.max(0, traverse(node.left, obj))\n  let right = Math.max(0, traverse(node.right, obj))\n  obj.max = Math.max(obj.max, node.val+left+right)\n  return node.val + Math.max(left, right)\n}\n\n// another\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nconst maxPathSum = function(root) {\n  let res = -Infinity\n  dfs(root)\n  return res\n\n  function dfs(node) {\n    if(node == null) return 0\n    let left = dfs(node.left), right = dfs(node.right)\n    res = Math.max(\n      res,\n      node.val,\n      node.val + left,\n      node.val + right,\n      node.val + left + right,\n    )\n    return Math.max(node.val, node.val + left, node.val + right)\n  }\n};\n"
    }
  },
  {
    "name": "1240-tiling-a-rectangle-with-the-fewest-squares",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number} m\n * @return {number}\n */\nconst tilingRectangle = function (n, m) {\n  if ((n === 11 && m === 13) || (n === 13 && m === 11)) {\n    return 6\n  }\n\n  const dp = Array(n + 1)\n    .fill()\n    .map((_) => Array(m + 1).fill(0))\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= m; j++) {\n      if (i === j) {\n        dp[i][j] = 1\n        continue\n      }\n      dp[i][j] = m * n\n      for (let k = 1; k <= i / 2; k++) {\n        dp[i][j] = Math.min(dp[i][j], dp[i - k][j] + dp[k][j])\n      }\n      for (let k = 1; k <= j / 2; k++) {\n        dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[i][j - k])\n      }\n    }\n  }\n  return dp[n][m]\n}\n"
    }
  },
  {
    "name": "1243-array-transformation",
    "code": {
      "JS": "/**\n * @param {number[]} arr\n * @return {number[]}\n */\n const transformArray = function(arr) {\n  let cur = arr\n  while(true) {\n    const clone = cur.slice()\n    for(let i = 1; i < clone.length - 1; i++) {\n      if(cur[i] > cur[i - 1] && cur[i] > cur[i + 1]) clone[i]--\n      else if(cur[i] < cur[i - 1] && cur[i] < cur[i + 1]) clone[i]++\n    }\n    if(same(cur, clone)) return clone\n    cur = clone\n  }\n  \n  return cur\n  \n  function same(a1, a2) {\n    for(let i = 0; i< a1.length; i++) {\n      if(a1[i] !== a2[i]) return false\n    }\n    return true\n  }\n};\n"
    }
  },
  {
    "name": "1246-palindrome-removal",
    "code": {
      "JS": "/**\n * @param {number[]} arr\n * @return {number}\n */\nconst minimumMoves = function (arr) {\n  const n = arr.length\n  const dp = Array.from({ length: n }, () => Array(n).fill(n))\n  // handle edge situation: subarray size == 1\n  for (let i = 0; i < n; i++) {\n    dp[i][i] = 1\n  }\n  // handle edge situation: subarray size == 2\n  for (let i = 0; i < n - 1; i++) {\n    dp[i][i + 1] = arr[i] === arr[i + 1] ? 1 : 2\n  }\n  // for subarray size >= 3:\n  for (let size = 3; size <= n; size++) {\n    for (let left = 0, right = left + size - 1; right < n; left++, right++) {\n      // if arr[left] == arr[right], then the two number: arr[left] and arr[right] can be\n      // removed when the last move of subarray arr[left + 1:right - 1]\n      if (arr[left] === arr[right]) {\n        dp[left][right] = dp[left + 1][right - 1]\n      }\n      // or, if we cannot remove arr[left] and arr[right] in one move (the last move),\n      // the subarray arr[left:right] must can be split into two subarrays\n      // and remove them one by one.\n      for (let mid = left; mid < right; mid++) {\n        dp[left][right] = Math.min(\n          dp[left][right],\n          dp[left][mid] + dp[mid + 1][right]\n        )\n      }\n    }\n  }\n  return dp[0][n - 1]\n}\n\n// another\n\n/**\n * @param {number[]} arr\n * @return {number}\n */\n const minimumMoves = function (arr) {\n  const n = arr.length\n  \n  const dp = Array.from({ length: n }, () => Array(n).fill(n))\n \n  for(let i = 0; i < n; i++) dp[i][i] = 1\n  for(let i = 0; i < n - 1; i++) {\n    dp[i][i + 1] = arr[i] === arr[i + 1] ? 1 : 2\n  }\n\n  for(let size = 3; size <= n; size++) {\n    for(let i = 0; i + size - 1 < n; i++) {\n      const right = i + size - 1\n      if(arr[i] === arr[right]) dp[i][right] = dp[i + 1][right - 1]\n      for(let j = i; j < right; j++) {\n        dp[i][right] = Math.min(dp[i][right], dp[i][j] + dp[j + 1][right])\n      }\n    }\n  }\n\n  return dp[0][n - 1]\n}\n"
    }
  },
  {
    "name": "1249-minimum-remove-to-make-valid-parentheses",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {string}\n */\n const minRemoveToMakeValid = function(s) {\n  const stack = [], n = s.length\n  const arr = s.split('')\n  let res = ''\n  for(let i = 0; i < n; i++) {\n    if(s[i] === '(') stack.push(i + 1)\n    if(s[i] === ')') {\n      if(stack.length && stack[stack.length - 1] >= 0) stack.pop()\n      else stack.push(-(i + 1))\n    }\n  }\n  while(stack.length) {\n    arr[Math.abs(stack.pop()) - 1] = ''\n  }\n  return arr.join('')\n};\n\n// another\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst minRemoveToMakeValid = function(s) {\n  let cnt = 0\n  let res = s.split('')\n  // console.log(res)\n  for(let i = 0; i < res.length; ) {\n    const ch = res[i]\n    if(ch === '(') cnt++\n    if(ch === ')') cnt--\n    if(cnt < 0) {\n      // console.log(res, i)\n      res.splice(i, 1)\n      cnt++\n    } else i++\n  }\n  // console.log(res)\n  let idx = res.length - 1\n  while(cnt > 0) {\n    if(res[idx] === '(') {\n      res.splice(idx, 1)\n      cnt--\n    } else idx--\n  }\n  return res.join('')\n};\n\n// another\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst minRemoveToMakeValid = function(s) {\n  const stk = [], arr = s.split(''), n = s.length\n  for(let i = 0; i < n; i++) {\n    if(s[i] === '(') stk.push(i)\n    if(s[i] === ')') {\n      if(stk.length && stk[stk.length - 1] >= 0) stk.pop()\n      else stk.push(-(i + 1))\n    }\n  }\n  \n  while(stk.length) {\n    const tmp = stk.pop()\n    if(tmp < 0) arr[-tmp - 1] = ''\n    else arr[tmp] = ''\n  }\n  return arr.join('')\n};\n"
    }
  },
  {
    "name": "125-valid-palindrome",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {boolean}\n */\nconst isPalindrome = function(s) {\n  let start = 0\n  let end = s.length - 1\n\n  while(start < end) {\n    while(start < s.length && !valid(s[start])) {\n      start++      \n    }\n    while(end >=0 && !valid(s[end])) {\n      end--      \n    }\n    if(start < s.length && end >=0) {\n      if(s[start].toLowerCase() !== s[end].toLowerCase()) return false           \n    }\n    start++\n    end--\n  }\n  return true\n};\n\nfunction valid(c) {\n  const code = c.toLowerCase().charCodeAt(0)\n  const zeroCode = ('0').charCodeAt(0)\n  const nineCode = ('9').charCodeAt(0)\n  const aCode = ('a').charCodeAt(0)\n  const zCode = ('z').charCodeAt(0)\n  if( (code >= zeroCode && code <= nineCode) || ( code >= aCode && code <= zCode ) ) return true\n     \n  return false\n} \n"
    }
  },
  {
    "name": "1252-cells-with-odd-values-in-a-matrix",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number} m\n * @param {number[][]} indices\n * @return {number}\n */\nconst oddCells = function (n, m, indices) {\n  const oddRows = new BitSet(n),\n    oddCols = new BitSet(m)\n  let cntRow = 0,\n    cntCol = 0\n  for (let idx of indices) {\n    oddRows.flip(idx[0])\n    oddCols.flip(idx[1])\n    cntRow += oddRows.get(idx[0]) ? 1 : -1\n    cntCol += oddCols.get(idx[1]) ? 1 : -1\n  }\n  return (m - cntCol) * cntRow + (n - cntRow) * cntCol\n}\n\nclass BitSet {\n  constructor(n) {\n    this.arr = Array(n).fill(0)\n  }\n  flip(idx) {\n    this.arr[idx] = this.arr[idx] === 0 ? 1 : 0\n  }\n  get(idx) {\n    return this.arr[idx]\n  }\n}\n"
    }
  },
  {
    "name": "1255-maximum-score-words-formed-by-letters",
    "code": {
      "JS": "/**\n * @param {string[]} words\n * @param {character[]} letters\n * @param {number[]} score\n * @return {number}\n */\nconst maxScoreWords = function (words, letters, score) {\n  const points = new Map()\n  const count = Array(26).fill(0)\n  for (let w of letters) {\n    count[w.charCodeAt(0) - 97] = ~~count[w.charCodeAt(0) - 97] + 1\n  }\n  return dfs(count, 0)\n  function dfs(count, index) {\n    if (index >= words.length) {\n      return 0\n    }\n    const x = dfs(count, index + 1)\n    const copy = [...count]\n    let point = 0\n    let isValid = true\n    for (let w of words[index]) {\n      let k = w.charCodeAt(0) - 97\n      copy[k]--\n      point += score[k]\n      if (copy[k] < 0) isValid = false\n    }\n    return Math.max(x, isValid ? point + dfs(copy, index + 1) : 0)\n  }\n}\n"
    }
  },
  {
    "name": "126-word-ladder-ii",
    "code": {
      "JS": "/**\n * @param {string} beginWord\n * @param {string} endWord\n * @param {string[]} wordList\n * @return {string[][]}\n */\nconst findLadders = function (beginWord, endWord, wordList) {\n  const res = []\n  if (!wordList.includes(endWord)) return res\n  const set1 = new Set([beginWord]),\n    set2 = new Set([endWord]),\n    wordSet = new Set(wordList),\n    temp = [beginWord]\n  const map = new Map()\n  const traverse = (set1, set2, dir) => {\n    if (set1.size === 0) return false\n    if (set1.size > set2.size) return traverse(set2, set1, !dir)\n    for (const val of set1.values()) {\n      if (wordSet.has(val)) wordSet.delete(val)\n    }\n    for (const val of set2.values()) {\n      if (wordSet.has(val)) wordSet.delete(val)\n    }\n    const set = new Set()\n    let done = false\n    for (const str of set1.values()) {\n      for (let i = 0; i < str.length; i++) {\n        for (let ch = 'a'.charCodeAt(); ch <= 'z'.charCodeAt(); ch++) {\n          const word =\n            str.slice(0, i) + String.fromCharCode(ch) + str.slice(i + 1)\n          const key = dir ? str : word\n          const val = dir ? word : str\n          const list = map.get(key) || []\n          if (set2.has(word)) {\n            done = true\n            list.push(val)\n            map.set(key, list)\n          }\n          if (!done && wordSet.has(word)) {\n            set.add(word)\n            list.push(val)\n            map.set(key, list)\n          }\n        }\n      }\n    }\n    return done || traverse(set2, set, !dir)\n  }\n  const dfs = (word) => {\n    if (word === endWord) {\n      res.push(temp.slice())\n      return\n    }\n    const nei = map.get(word) || []\n    for (const w of nei) {\n      temp.push(w)\n      dfs(w)\n      temp.pop()\n    }\n  }\n  traverse(set1, set2, true)\n  dfs(beginWord)\n  return res\n}\n"
    }
  },
  {
    "name": "1260-shift-2d-grid",
    "code": {
      "JS": "/**\n * @param {number[][]} grid\n * @param {number} k\n * @return {number[][]}\n */\nconst shiftGrid = function(grid, k) {\n  for(let i = 0; i < k; i++) once(grid)\n  return grid\n};\n\nfunction once(grid) {\n  const m = grid.length, n = grid[0].length\n  let last = grid[m - 1][n - 1]\n  for(let i = 0; i < m; i++) {\n    let pre = grid[i][0]\n    for(let j = 1; j < n; j++) {\n      let cur = grid[i][j]\n      grid[i][j] = pre\n      pre = cur\n    }\n    grid[i][0] = last\n    last = pre\n  }\n}\n"
    }
  },
  {
    "name": "1262-greatest-sum-divisible-by-three",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst maxSumDivThree = function (nums) {\n  const n = nums.length\n  let dp = [0, -Infinity, -Infinity]\n  for (let i = n - 1; i >= 0; i--) {\n    const nextDp = []\n    for (let j = 0; j < 3; j++) {\n      const nextRemain = nums[i] % 3\n      nextDp[j] = Math.max(nums[i] + dp[(nextRemain + j) % 3], dp[j])\n    }\n    dp = nextDp\n  }\n  return dp[0]\n}\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst maxSumDivThree = function(nums) {\n  const sum = nums.reduce((ac, el) => ac + el, 0)\n  if(sum % 3 === 0) return sum\n  const remainder = sum % 3\n  const comp = 3 - remainder\n  nums.sort((a, b) => a - b)\n  const re = [], rc = []\n  for(let i = 0, len = nums.length; i < len; i++) {\n    if(nums[i] % 3 === remainder) {\n      if(re.length < 1) re.push(i)\n    }\n    if(nums[i] % 3 === comp) {\n      if(rc.length < 2) rc.push(i)\n    }\n    if(re.length === 1 && rc.length === 2) break\n  }\n  if(re.length === 1 && rc.length === 2) {\n    return Math.max(sum - nums[re[0]], sum - nums[rc[0]] - nums[rc[1]])\n  } else if(re.length === 1) {\n    return sum - nums[re[0]]\n  } else if(rc.length === 2) {\n    return sum - nums[rc[0]] - nums[rc[1]]\n  } else {\n    return 0\n  }\n};\n"
    }
  },
  {
    "name": "1263-minimum-moves-to-move-a-box-to-their-target-location",
    "code": {
      "JS": "/**\n * @param {character[][]} grid\n * @return {number}\n */\nconst minPushBox = function (grid) {\n  if (\n    typeof grid === 'undefined' ||\n    grid === null ||\n    grid.length === 0 ||\n    grid[0].length === 0\n  ) {\n    return -1\n  }\n\n  let TARGET = null\n  let startBlk = null\n  let startPer = null\n  const DIR = [\n    [0, 1],\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n  ]\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[0].length; j++) {\n      if (grid[i][j] === 'S') {\n        startPer = [i, j]\n        grid[i][j] = '.'\n      }\n      if (grid[i][j] === 'T') {\n        TARGET = [i, j]\n      }\n      if (grid[i][j] === 'B') {\n        startBlk = [i, j]\n        grid[i][j] = '.'\n      }\n    }\n  }\n\n  let queue = new PriorityQueue((a, b) => a.weight < b.weight)\n  let states = new Map()\n  queue.push({\n    weight: manDist(startBlk),\n    block: startBlk,\n    character: startPer,\n    move: 0,\n  })\n  while (!queue.isEmpty()) {\n    let { weight, block, character, move } = queue.pop()\n    if (TARGET[0] === block[0] && TARGET[1] === block[1]) {\n      return move\n    }\n    let key = block[0] * grid[0].length + block[1]\n    let val = character[0] * grid[0].length + character[1]\n    if (!states.has(key)) {\n      states.set(key, new Set())\n    }\n    states.get(key).add(val)\n    DIR.forEach((d) => {\n      let i = d[0] + character[0]\n      let j = d[1] + character[1]\n      let curV = i * grid[0].length + j\n      if (validMove(i, j, block[0], block[1]) && !states.get(key).has(curV)) {\n        queue.push({\n          weight: manDist(block) + move,\n          block: block,\n          character: [i, j],\n          move: move,\n        })\n      }\n    })\n    let pushDir = tryPush(character, block)\n    if (pushDir !== null) {\n      let newBlk = [block[0] + pushDir[0], block[1] + pushDir[1]]\n      let newCha = [character[0] + pushDir[0], character[1] + pushDir[1]]\n      let nBK = newBlk[0] * grid[0].length + newBlk[1]\n      let nVal = newCha[0] * grid[0].length + newCha[1]\n      if (!states.has(nBK) || !states.get(nBK).has(nVal)) {\n        queue.push({\n          weight: manDist(newBlk) + (move + 1),\n          block: newBlk,\n          character: newCha,\n          move: move + 1,\n        })\n      }\n    }\n  }\n\n  return -1\n\n  function manDist(block) {\n    let [x, y] = TARGET\n    let [i, j] = block\n    return Math.abs(x - i) + Math.abs(y - j)\n  }\n  function validMove(i, j, x = null, y = null) {\n    if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length) {\n      return false\n    }\n    if (\n      (x !== null && i === x && y !== null && j === y) ||\n      grid[i][j] === '#'\n    ) {\n      return false\n    }\n    return true\n  }\n  function tryPush(c, b) {\n    let [i, j] = c\n    let [x, y] = b\n    for (let u = 0; u < DIR.length; u++) {\n      let [v, w] = DIR[u]\n      if (\n        ((Math.abs(x - i) === 1 && y === j) ||\n          (Math.abs(y - j) === 1 && x === i)) &&\n        validMove(i + v, j + w) &&\n        validMove(x + v, y + w) &&\n        i + v === x &&\n        j + w === y\n      ) {\n        return [v, w]\n      }\n    }\n    return null\n  }\n}\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n\n// another\n\n/**\n * @param {character[][]} grid\n * @return {number}\n */\nconst minPushBox = function (grid) {\n  const dirs = [\n    [-1, 0],\n    [1, 0],\n    [0, -1],\n    [0, 1],\n  ]\n  const dis = new Map()\n  const rows = grid.length\n  const cols = grid[0].length\n  let sk, box, target\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === 'B') box = [i, j]\n      else if (grid[i][j] === 'S') sk = [i, j]\n      else if (grid[i][j] === 'T') target = [i, j]\n    }\n  }\n  const q = []\n  const start = encode(box[0], box[1], sk[0], sk[1])\n  dis.set(start, 0)\n  q.push(start)\n  let res = Number.MAX_VALUE\n  while (q.length) {\n    const u = q.pop()\n    const du = decode(u)\n    if (dis.get(u) >= res) continue\n    if (du[0] === target[0] && du[1] === target[1]) {\n      res = Math.min(res, dis.get(u))\n      continue\n    }\n    const b = [du[0], du[1]]\n    const s = [du[2], du[3]]\n    for (let dir of dirs) {\n      const nsx = s[0] + dir[0]\n      const nsy = s[1] + dir[1]\n      if (\n        nsx < 0 ||\n        nsx >= rows ||\n        nsy < 0 ||\n        nsy >= cols ||\n        grid[nsx][nsy] === '#'\n      )\n        continue\n      if (nsx === b[0] && nsy === b[1]) {\n        const nbx = b[0] + dir[0]\n        const nby = b[1] + dir[1]\n        if (\n          nbx < 0 ||\n          nbx >= rows ||\n          nby < 0 ||\n          nby >= cols ||\n          grid[nbx][nby] === '#'\n        )\n          continue\n        const v = encode(nbx, nby, nsx, nsy)\n        if (dis.has(v) && dis.get(v) <= dis.get(u) + 1) continue\n        dis.set(v, dis.get(u) + 1)\n        q.push(v)\n      } else {\n        const v = encode(b[0], b[1], nsx, nsy)\n        if (dis.has(v) && dis.get(v) <= dis.get(u)) continue\n        dis.set(v, dis.get(u))\n        q.push(v)\n      }\n    }\n  }\n  return res === Number.MAX_VALUE ? -1 : res\n\n  function encode(bx, by, sx, sy) {\n    return (bx << 24) | (by << 16) | (sx << 8) | sy\n  }\n  function decode(num) {\n    const res = []\n    res[0] = (num >>> 24) & 0xff\n    res[1] = (num >>> 16) & 0xff\n    res[2] = (num >>> 8) & 0xff\n    res[3] = num & 0xff\n    return res\n  }\n}\n\n// another\n\n/**\n * @param {character[][]} grid\n * @return {number}\n */\n const minPushBox = function (grid) {\n  const m = grid.length,\n    n = grid[0].length\n  let target, person, box\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (grid[i][j] === 'T') target = [i, j]\n      else if (grid[i][j] === 'B') box = [i, j]\n      else if (grid[i][j] === 'S') person = [i, j]\n    }\n  }\n\n  const valid = ([x, y]) => {\n    return x >= 0 && x < m && y >= 0 && y < n && grid[x][y] !== '#'\n  }\n\n  const check = (cur, dest, box) => {\n    const q = [cur]\n    const visited = new Set([`${box[0]},${box[1]}`])\n    const dirs = [\n      [-1, 0],\n      [1, 0],\n      [0, 1],\n      [0, -1],\n    ]\n\n    while (q.length) {\n      const pos = q.shift()\n      if (pos.join(',') === dest.join(',')) return true\n      const newPos = []\n      for (const [dx, dy] of dirs) newPos.push([pos[0] + dx, pos[1] + dy])\n      for (const [nx, ny] of newPos) {\n        const k = `${nx},${ny}`\n        if (valid([nx, ny]) && !visited.has(k)) {\n          visited.add(k)\n          q.push([nx, ny])\n        }\n      }\n    }\n\n    return false\n  }\n\n  const q = [[0, box, person]]\n  const vis = new Set([`${box.join(',')},${person.join(',')}`])\n  while (q.length) {\n    const [dist, box, person] = q.shift()\n    if (box.join(',') === target.join(',')) return dist\n\n    const bCoord = [\n      [box[0] + 1, box[1]],\n      [box[0] - 1, box[1]],\n      [box[0], box[1] + 1],\n      [box[0], box[1] - 1],\n    ]\n    const pCoord = [\n      [box[0] - 1, box[1]],\n      [box[0] + 1, box[1]],\n      [box[0], box[1] - 1],\n      [box[0], box[1] + 1],\n    ]\n\n    for (let i = 0; i < 4; i++) {\n      const [newBox, newPerson] = [bCoord[i], pCoord[i]]\n      const key = `${newBox.join(',')},${box.join(',')}`\n      if (valid(newBox) && !vis.has(key)) {\n        if (valid(newPerson) && check(person, newPerson, box)) {\n          vis.add(key)\n          q.push([dist + 1, newBox, box])\n        }\n      }\n    }\n  }\n\n  return -1\n}\n\n"
    }
  },
  {
    "name": "1266-minimum-time-visiting-all-points",
    "code": {
      "JS": "/**\n * @param {number[][]} points\n * @return {number}\n */\nconst minTimeToVisitAllPoints = function(points) {\n  let res = 0\n  for(let i = 1; i < points.length; i++) {\n    res += calc(points[i], points[i - 1])\n  }\n  return res\n  \n  function calc(p1, p2) {\n    const [x1, y1] = p1,  [x2, y2] = p2\n    const { abs, min } = Math\n    const deltaX = abs(x1 - x2), deltaY = abs(y1 - y2)\n    \n    return min(deltaX, deltaY) + abs(deltaX - deltaY)\n  }\n};\n"
    }
  },
  {
    "name": "1269-number-of-ways-to-stay-in-the-same-place-after-some-steps",
    "code": {
      "JS": "/**\n * @param {number} steps\n * @param {number} arrLen\n * @return {number}\n */\nconst numWays = function (steps, arrLen) {\n  const MOD = 10 ** 9 + 7\n  const memo = Array.from({ length: (steps >> 1) + 1 }, () =>\n    Array(steps + 1).fill(-1)\n  )\n  return dp(0, steps)\n  function dp(i, steps) {\n    if (steps === 0 && i === 0) return 1\n    if (i < 0 || i >= arrLen || steps === 0 || i > steps) return 0\n    if (memo[i][steps] !== -1) return memo[i][steps]\n    return (memo[i][steps] =\n      ((dp(i + 1, steps - 1) % MOD) +\n        (dp(i - 1, steps - 1) % MOD) +\n        (dp(i, steps - 1) % MOD)) %\n      MOD)\n  }\n}\n"
    }
  },
  {
    "name": "127-word-ladder",
    "code": {
      "JS": "/**\n * @param {string} beginWord\n * @param {string} endWord\n * @param {string[]} wordList\n * @return {number}\n */\nconst ladderLength = function(beginWord, endWord, wordList) {\n  const list = new Set(wordList)\n  if (!list.has(endWord)) return 0\n  let one = new Set([beginWord])\n  let two = new Set([endWord])\n  let step = 1\n  while (one.size && two.size) {\n    let temp = new Set()\n    if (two.size < one.size) [one, two] = [two, one]\n    for (const word of one) {\n      for (let i = 0; i < word.length; i++) {\n        for (let j = 0; j < 26; j++) {\n          const candidate =\n            word.slice(0, i) + String.fromCharCode(97 + j) + word.slice(i + 1)\n          if (two.has(candidate)) return step + 1\n          if (!list.has(candidate)) continue\n          temp.add(candidate)\n          list.delete(candidate)\n        }\n      }\n    }\n    ;[one, temp] = [temp, one]\n    step++\n  }\n  return 0\n}\n"
    }
  },
  {
    "name": "1272-remove-interval",
    "code": {
      "JS": "/**\n * @param {number[][]} intervals\n * @param {number[]} toBeRemoved\n * @return {number[][]}\n */\nconst removeInterval = function(intervals, toBeRemoved) {\n  const n = intervals.length\n  if (n < 1) return []\n  const res = []\n  const [x, y] = toBeRemoved\n  for (const [a, b] of intervals) {\n    const lo = Math.max(a, x)\n    const hi = Math.min(b, y)\n    if (lo < hi) {\n      if (a < lo) {\n        res.push([a, lo])\n      }\n      if (hi < b) {\n        res.push([hi, b])\n      }\n    } else {\n      res.push([a, b])\n    }\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "1274-number-of-ships-in-a-rectangle",
    "code": {
      "JS": "/**\n * // This is Sea's API interface.\n * // You should not implement it, or speculate about its implementation\n * function Sea() {\n *     @param {integer[]} topRight\n *     @param {integer[]} bottomLeft\n *     @return {boolean}\n *     this.hasShips = function(topRight, bottomLeft) {\n *         ...\n *     };\n * };\n */\n\n/**\n * @param {Sea} sea\n * @param {integer[]} topRight\n * @param {integer[]} bottomLeft\n * @return {integer}\n */\nconst countShips = function (sea, topRight, bottomLeft) {\n  let numShips = 0\n  const stack = [[topRight, bottomLeft]]\n  while (stack.length > 0) {\n    const [tR, bL] = stack.pop()\n    if (!sea.hasShips(tR, bL)) continue\n    const [right, top] = tR\n    const [left, bottom] = bL\n    if (right === left && bottom === top) {\n      numShips++\n      continue\n    }\n    const xCoord = Math.floor((right + left) / 2)\n    const yCoord = Math.floor((top + bottom) / 2)\n    stack.push([tR, [xCoord + 1, yCoord + 1]]) // top right\n    stack.push([\n      [xCoord, top],\n      [left, yCoord + 1],\n    ]) // top left\n    stack.push([[xCoord, yCoord], bL]) // bottom left\n    stack.push([\n      [right, yCoord],\n      [xCoord + 1, bottom],\n    ]) // bottom right\n  }\n  return numShips\n}\n"
    }
  },
  {
    "name": "1275-find-winner-on-a-tic-tac-toe-game",
    "code": {
      "JS": "/**\n * @param {number[][]} moves\n * @return {string}\n */\nconst tictactoe = function(moves) {\n  const grid = Array.from({ length: 3 }, () => Array(3).fill(''))\n  for(let i = 0, n = moves.length; i < n; i++) {\n    const ch = i % 2 === 0 ? 'X' : 'O'\n    const [r, c] = moves[i]\n    grid[r][c] = ch\n    const res = chk(ch, grid)\n    if(res) return ch === 'X' ? 'A' : 'B'\n  }\n  \n  return moves.length < 9 ? 'Pending' : 'Draw'\n};\n\nfunction chk(ch, grid) {\n  for(let i = 0; i < 3; i++) {\n    if(\n      grid[i][0] === ch &&\n      grid[i][1] === ch &&\n      grid[i][2] === ch\n    ) return true\n  }\n  \n  for(let i = 0; i < 3; i++) {\n    if(\n      grid[0][i] === ch &&\n      grid[1][i] === ch &&\n      grid[2][i] === ch\n    ) return true\n  }\n  \n\n    if(\n      grid[0][0] === ch &&\n      grid[1][1] === ch &&\n      grid[2][2] === ch\n    ) return true  \n  \n    if(\n      grid[0][2] === ch &&\n      grid[1][1] === ch &&\n      grid[2][0] === ch\n    ) return true  \n  \n  return false\n}\n\n// another\n\n/**\n * @param {number[][]} moves\n * @return {string}\n */\nconst tictactoe = function(moves) {\n  const aRow = Array(3).fill(0), aCol = Array(3).fill(0), bRow= Array(3).fill(0), bCol =Array(3).fill(0)\n  let ad = 0, ads = 0, bd = 0, bds = 0\n  for(let i = 0; i < moves.length; i++) {\n    const [r, c] = moves[i]\n    if(i % 2===0) {\n      if(++aRow[r] === 3 || ++aCol[c] === 3 || r === c && ++ad === 3 || r + c === 2&& ++ads === 3 ) return 'A'\n    }else {\n      if(++bRow[r] === 3 || ++bCol[c] === 3 || r === c && ++bd === 3 || r + c === 2&& ++bds === 3 ) return 'B'\n    }\n  }\n  \n  return moves.length >= 9 ? 'Draw' : 'Pending'\n};\n"
    }
  },
  {
    "name": "1277-count-square-submatrices-with-all-ones",
    "code": {
      "JS": "/**\n * @param {number[][]} matrix\n * @return {number}\n */\nconst countSquares = function (matrix) {\n  const [m, n] = [matrix.length, matrix[0].length]\n  let res = 0\n  for(let i = 0;  i < m; i++) {\n    for(let j = 0; j < n; j++) {\n      if(matrix[i][j] && i > 0 && j > 0) {\n        matrix[i][j] = 1 + Math.min(\n          matrix[i - 1][j],\n          matrix[i][j - 1],\n          matrix[i - 1][j - 1],\n        )\n      }\n      res += matrix[i][j]\n    }\n  }\n  return res\n}\n\n// another\n\n/**\n * @param {number[][]} matrix\n * @return {number}\n */\nconst countSquares = function (A) {\n  const [M, N] = [A.length, A[0].length]\n  let ans = 0\n  for (let i = 0; i < M; ++i) {\n    for (let j = 0; j < N; ++j) {\n      if (A[i][j] && i > 0 && j > 0) {\n        A[i][j] = 1 + Math.min(A[i - 1][j], A[i][j - 1], A[i - 1][j - 1])\n      }\n      ans += A[i][j]\n    }\n  }\n  return ans\n}\n"
    }
  },
  {
    "name": "1278-palindrome-partitioning-iii",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nconst palindromePartition = function(s, k) {\n  const n = s.length\n  const memo = new Map()\n  return dfs(0, k)\n  function cost(s, i, j) {\n    let r = 0\n    while(i < j) {\n      if(s[i] !== s[j]) r++\n      i++\n      j--\n    }\n    return r\n  }\n  function dfs(i, k) {\n    if(memo.has(`${i}-${k}`)) return memo.get(`${i}-${k}`)\n    if(n - i === k) return 0\n    if(k === 1) return cost(s, i, n - 1)\n    let res = Infinity\n    for(let j = i + 1; j < n - k + 2; j++) {\n      res = Math.min(res, dfs(j, k - 1) + cost(s, i, j - 1))\n    }\n    memo.set(`${i}-${k}`, res)\n    return res\n  }\n};\n"
    }
  },
  {
    "name": "128-longest-consecutive-sequence",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst longestConsecutive = function(nums) {\n  if(nums.length === 0) return 0\n  nums.sort((a, b) => a - b)\n  let max = 1\n  let cur = 1\n  for(let i = 1; i < nums.length; i++) {\n    if(nums[i] - nums[i-1] === 1) {\n       cur += 1\n       max = Math.max(max, cur)\n    } else if(nums[i] - nums[i-1] === 0) {\n              \n    } else {\n      cur = 1\n    }\n  }\n  \n  return max\n};\n"
    }
  },
  {
    "name": "1281-subtract-the-product-and-sum-of-digits-of-an-integer",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst subtractProductAndSum = function(n) {\n  if(n === 0) return 0\n  let sum = 0, product = 1\n  n = '' + n\n  for(let ch of n) {\n    sum += +(ch)\n    product *= +(ch)\n  }\n  return product - sum\n};\n"
    }
  },
  {
    "name": "1283-find-the-smallest-divisor-given-a-threshold",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} threshold\n * @return {number}\n */\nconst smallestDivisor = function(nums, threshold) {\n  let l = 1, r = 1e6\n  while(l < r) {\n    const mid = l + Math.floor((r - l) / 2)\n    if(valid(mid)) r = mid\n    else l = mid + 1\n  }\n  return l\n  \n  function valid(mid) {\n    let res = 0\n    for(let e of nums) res += Math.ceil(e / mid)\n    return res <= threshold\n  }\n};\n"
    }
  },
  {
    "name": "1284-minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix",
    "code": {
      "JS": "/**\n * @param {number[][]} mat\n * @return {number}\n */\nconst minFlips = function (mat) {\n  let start = 0\n  const m = mat.length, n = mat[0].length\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      start |= mat[i][j] << (i * n + j)\n    }\n  }\n  let q = [start]\n  const seen = new Set(), dirs = [[-1, 0], [1, 0], [0, -1], [0, 1], [0, 0]]\n\n  for(let i = 0; q.length; i++) {\n    const tmp = []\n    for (let size = q.length; size > 0; size--) {\n      const cur = q.pop()\n      if(cur === 0) return i\n      for(let i = 0; i < m; i++) {\n        for(let j = 0; j < n; j++) {\n          let next = cur\n          for(const [dx, dy] of dirs) {\n            const r = i + dx, c = j + dy\n            if(r >= 0 && r < m && c >= 0 && c < n) {\n              next ^= (1 << (r * n + c))\n            }\n          }\n          if (!seen.has(next)) {\n            seen.add(next)\n            tmp.push(next)\n          }\n        }\n      }\n    }\n    q = tmp\n  }\n\n  return -1\n}\n\n// another\n\n/**\n * @param {number[][]} mat\n * @return {number}\n */\nconst minFlips = function (mat) {\n  const X = mat.length\n  const Y = mat[0].length\n  const binary = {\n    0: 1,\n    1: 2,\n    2: 4,\n    3: 8,\n    4: 16,\n    5: 32,\n    6: 64,\n    7: 128,\n    8: 256,\n  }\n  const mask = []\n  let state = 0\n  for (let i = 0; i < X; ++i) {\n    for (let j = 0; j < Y; ++j) {\n      let bit = 0\n      state += mat[i][j] * binary[Y * i + j]\n      bit += binary[Y * i + j]\n      if (i > 0) {\n        bit += binary[Y * (i - 1) + j]\n      }\n      if (i < X - 1) {\n        bit += binary[Y * (i + 1) + j]\n      }\n      if (j > 0) {\n        bit += binary[Y * i + (j - 1)]\n      }\n      if (j < Y - 1) {\n        bit += binary[Y * i + (j + 1)]\n      }\n      mask.push(bit)\n    }\n  }\n  if (state === 0) return 0\n  const set = new Set()\n  const q = [{ state: state, moves: 0 }]\n  while (q.length !== 0) {\n    const cur = q.shift()\n    if (cur.state === 0) {\n      return cur.moves\n    }\n    for (let i = 0; i < X * Y; ++i) {\n      let newState = cur.state\n      newState ^= mask[i]\n      if (!set.has(newState)) {\n        set.add(newState)\n        q.push({ state: newState, moves: cur.moves + 1 })\n      }\n    }\n  }\n  return -1\n}\n"
    }
  },
  {
    "name": "1286-iterator-for-combination",
    "code": {
      "JS": "/**\n * @param {string} characters\n * @param {number} combinationLength\n */\nconst CombinationIterator = function (characters, combinationLength) {\n  this.arr = build(combinationLength, characters.split('').sort().join(''))\n  this.pos = 0\n}\n\n/**\n * @return {string}\n */\nCombinationIterator.prototype.next = function () {\n  if (this.pos < this.arr.length) {\n    return this.arr[this.pos++]\n  }\n}\n\n/**\n * @return {boolean}\n */\nCombinationIterator.prototype.hasNext = function () {\n  return this.pos < this.arr.length\n}\n\n/**\n * Your CombinationIterator object will be instantiated and called as such:\n * var obj = new CombinationIterator(characters, combinationLength)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */\nfunction build(max, str, out = [], curr = '') {\n  if (curr.length === max) {\n    out.push(curr)\n    return\n  } else {\n    for (let i = 0; i < str.length; i++) {\n      build(max, str.slice(i + 1), out, curr + str[i])\n    }\n  }\n\n  return out\n}\n"
    }
  },
  {
    "name": "1287-element-appearing-more-than-25-in-sorted-array",
    "code": {
      "JS": "/**\n * @param {number[]} arr\n * @return {number}\n */\nconst findSpecialInteger = function (arr) {\n  const n = arr.length,\n    { floor } = Math,\n    { getWordIndexRange } = Search()\n  const ticks = [n / 4, n / 2, (n * 3) / 4].map((e) => floor(e))\n  for (const i of ticks) {\n    const [s, e] = getWordIndexRange(arr, arr[i])\n    if (e - s > n / 4) return arr[i]\n  }\n  return 0\n}\n\nfunction Search() {\n  return { getWordIndexRange }\n\n  /**\n   * Searches for the first true value in the predicate.\n   * Returns hi if not found.\n   * [lo, hi)\n   */\n  function binarySearch(lo, hi, predicate) {\n    while (lo != hi) {\n      let mid = ((lo + hi) / 2) | 0\n      if (predicate(mid)) {\n        hi = mid\n      } else {\n        lo = mid + 1\n      }\n    }\n    return lo\n  }\n\n  function getWordIndexRange(keys, word) {\n    let lo = 0,\n      hi = keys.length\n    function greaterOrEqual(index) {\n      return keys[index] >= word\n    }\n    function less(index) {\n      return keys[index] > word\n    }\n    let lower_bound = binarySearch(0, keys.length, greaterOrEqual)\n    let upper_bound = binarySearch(lower_bound, keys.length, less)\n    return [lower_bound, upper_bound]\n  }\n}\n"
    }
  },
  {
    "name": "1288-remove-covered-intervals",
    "code": {
      "JS": "/**\n * @param {number[][]} intervals\n * @return {number}\n */\nconst removeCoveredIntervals = function(intervals) {\n  intervals.sort((a, b) => a[0] === b[0] ? b[1] - a[1] : a[0] - b[0])\n  const n = intervals.length\n  let res = n, max = intervals[0][1]\n  for(let i = 1; i < n; i++) {\n    if(intervals[i][1] <= max) res--\n    else max = intervals[i][1]\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1289-minimum-falling-path-sum-ii",
    "code": {
      "JS": "/**\n * @param {number[][]} arr\n * @return {number}\n */\nconst minFallingPathSum = function (arr) {\n  const n = arr.length\n  for (let i = 1; i < n; i++) {\n    const [m1, m2] = min2(arr[i - 1])\n    for (j = 0; j < n; j++) {\n      arr[i][j] += arr[i - 1][j] !== m1 ? m1 : m2\n    }\n  }\n  return Math.min(...arr[n - 1])\n}\n\nfunction min2(arr) {\n  let m1 = Infinity, m2 = Infinity\n  arr.forEach(e => {\n    if(e < m1) m2 = m1, m1 = e\n    else if(e < m2) m2 = e\n  })\n  return [m1, m2]\n}\n"
    }
  },
  {
    "name": "129-sum-root-to-leaf-numbers",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nconst sumNumbers = function(root) {\n    const sum = []\n    rec(root, '', sum)\n    return sum.reduce((ac, el) => ac + el, 0)\n};\n\nfunction rec(node, str, arr) {\n    if (node == null) {\n        arr.push(+str)\n        return\n    }\n    if (node.left !== null) {\n      rec(node.left, str + node.val, arr)\n    }\n    if (node.right !== null) {\n       rec(node.right, str + node.val, arr)\n    }\n    if (node.left === null && node.right === null) {\n        arr.push(+(str + node.val) )\n    }\n}\n"
    }
  },
  {
    "name": "1290-convert-binary-number-in-a-linked-list-to-integer",
    "code": {
      "JS": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number}\n */\nconst getDecimalValue = function(head) {\n  let res = 0\n\n  while(head) {\n    res = res * 2 + head.val\n    head = head.next\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1293-shortest-path-in-a-grid-with-obstacles-elimination",
    "code": {
      "JS": "/**\n * @param {number[][]} grid\n * @param {number} k\n * @return {number}\n */\nconst shortestPath = function (grid, k) {\n  const m = grid.length\n  const n = m && grid[0].length\n  if (m === 1 && n === 1) return 0\n  const queue = [[0, 0, k]]\n  const dirs = [\n    [1, 0],\n    [-1, 0],\n    [0, 1],\n    [0, -1],\n  ]\n  const visited = new Set()\n  let steps = 0\n  while (queue.length > 0) {\n    let size = queue.length\n    while (size--) {\n      const [row, col, em] = queue.shift()\n      if (visited.has(row + \"#\" + col + \"#\" + em)) continue\n      visited.add(row + \"#\" + col + \"#\" + em)\n      for (let dir of dirs) {\n        const nx = row + dir[0]\n        const ny = col + dir[1]\n        if (\n          nx < 0 ||\n          nx >= m ||\n          ny < 0 ||\n          ny >= n ||\n          visited.has(nx + \"#\" + ny + \"#\" + em)\n        )\n          continue\n        if (nx === m - 1 && ny === n - 1) return steps + 1\n        if (grid[nx][ny] === 1) {\n          if (em > 0) queue.push([nx, ny, em - 1])\n        } else {\n          queue.push([nx, ny, em])\n        }\n      }\n    }\n    steps++\n  }\n  return -1\n}\n"
    }
  },
  {
    "name": "1295-find-numbers-with-even-number-of-digits",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst findNumbers = function(nums) {\n  let res = 0\n  for(const e of nums) {\n    const str = '' + e\n    if(str.length % 2 === 0) res++\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1299-replace-elements-with-greatest-element-on-right-side",
    "code": {
      "JS": "/**\n * @param {number[]} arr\n * @return {number[]}\n */\nconst replaceElements = function(arr) {\n  const suffix = [-1], n = arr.length\n  for(let i = n - 2; i >= 0; i--) {\n    suffix.unshift(Math.max(suffix[0], arr[i + 1]))\n  }\n  \n  return suffix\n};\n"
    }
  },
  {
    "name": "13-roman-to-integer",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst romanToInt = function(s) {\n  let res = 0\n  for (let i = s.length - 1; i >= 0; i--) {\n    let c = s.charAt(i)\n    switch (c) {\n      case 'I':\n        res += res >= 5 ? -1 : 1\n        break\n      case 'V':\n        res += 5\n        break\n      case 'X':\n        res += 10 * (res >= 50 ? -1 : 1)\n        break\n      case 'L':\n        res += 50\n        break\n      case 'C':\n        res += 100 * (res >= 500 ? -1 : 1)\n        break\n      case 'D':\n        res += 500\n        break\n      case 'M':\n        res += 1000\n        break\n    }\n  }\n  return res\n}\n\n\n// another\n\n/**\n * @param {string} s\n * @return {number}\n */\nconst romanToInt = function(s) {\n  const map = { I: 1, V: 5, X: 10, L: 50, C: 100, D: 500, M: 1000 }\n  let result = 0\n  let index = s.length - 1\n  let preInt = 0\n  while (index >= 0) {\n    let ch = s[index]\n    let curInt = map[ch]\n    if (curInt >= preInt) result += curInt\n    else result -= curInt\n    preInt = curInt\n    index--\n  }\n  return result\n}\n"
    }
  },
  {
    "name": "130-surrounded-regions",
    "code": {
      "JS": "/**\n * @param {character[][]} board\n * @return {void} Do not return anything, modify board in-place instead.\n */\nconst solve = function(board) {\n  if (!board || board.length < 3 || board[0].length < 3) return;\n  let r = board.length;\n  let c = board[0].length;\n  for (let i = 0; i < c; i++) {\n    if (board[0][i] === \"O\") search(board, 0, i);\n    if (board[r - 1][i] === \"O\") search(board, r - 1, i);\n  }\n  for (let i = 0; i < r; i++) {\n    if (board[i][0] === \"O\") search(board, i, 0);\n    if (board[i][c - 1] === \"O\") search(board, i, c - 1);\n  }\n  for (let i = 0; i < r; i++) {\n    for (let j = 0; j < c; j++) {\n      if (board[i][j] === \"O\") board[i][j] = \"X\";\n      if (board[i][j] === \"*\") board[i][j] = \"O\";\n    }\n  }\n};\n\nfunction search(board, i, j) {\n  if (i < 0 || j < 0 || i >= board.length || j >= board[0].length) return;\n  if (board[i][j] !== \"O\") return;\n  board[i][j] = \"*\";\n  search(board, i + 1, j);\n  search(board, i - 1, j);\n  search(board, i, j + 1);\n  search(board, i, j - 1);\n}\n\n// another\n\n/**\n * @param {character[][]} board\n * @return {void} Do not return anything, modify board in-place instead.\n */\nconst solve = (board) => {\n  if (!board || board.length === 0 || board[0].length === 0) return;\n  const n = board.length;\n  const m = board[0].length;\n    const dirs = [\n    [-1, 0],\n    [1, 0],\n    [0, -1],\n    [0, 1],\n  ];\n  const bfs = (board, n, m, i, j) => {\n    const queue = [];\n    queue.push([i, j]);\n    board[i][j] = \"1\";\n    while (queue.length > 0) {\n      const pos = queue.shift();\n      for (let k = 0; k < 4; k++) {\n        i = pos[0] + dirs[k][0];\n        j = pos[1] + dirs[k][1];\n        if (i >= 0 && i < n && j >= 0 && j < m && board[i][j] === \"O\") {\n          board[i][j] = \"1\";\n          queue.push([i, j]);\n        }\n      }\n    }\n  };\n  // scan the borders and mark the 'O's to '1'\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (\n        (i === 0 || i === n - 1 || j === 0 || j === m - 1) &&\n        board[i][j] === \"O\"\n      ) {\n        bfs(board, n, m, i, j);\n      }\n    }\n  }\n  // scan the inner area and mark the 'O's to 'X'\n  for (let i = 1; i < n; i++) {\n    for (let j = 1; j < m; j++) {\n      if (board[i][j] === \"O\") {\n        board[i][j] = \"X\";\n      }\n    }\n  }\n  // reset all the '1's to 'O's\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (board[i][j] === \"1\") {\n        board[i][j] = \"O\";\n      }\n    }\n  }\n};\n"
    }
  },
  {
    "name": "1301-number-of-paths-with-max-score",
    "code": {
      "JS": "/**\n * @param {string[]} board\n * @return {number[]}\n */\nconst pathsWithMaxScore = (\n  A,\n  dirs = [\n    [-1, -1],\n    [-1, 0],\n    [0, -1],\n  ],\n  mod = 1e9 + 7\n) => {\n  const N = A.length\n  const S = [...Array(N + 1)].map((row) => Array(N + 1).fill(0)),\n    P = [...Array(N + 1)].map((row) => Array(N + 1).fill(0))\n  P[0][0] = 1\n  for (let i = 1; i <= N; ++i) {\n    for (let j = 1; j <= N; ++j) {\n      if (A[i - 1][j - 1] == 'X') continue\n      for (let d of dirs) {\n        const u = i + d[0],\n          v = j + d[1]\n        const sum = !P[u][v]\n          ? 0\n          : S[u][v] +\n            (i == 1 && j == 1\n              ? 0\n              : i == N && j == N\n              ? 0\n              : A[i - 1].charCodeAt(j - 1) - '0'.charCodeAt(0))\n        if (S[i][j] == sum) P[i][j] = (P[i][j] + P[u][v]) % mod\n        if (S[i][j] < sum) (S[i][j] = sum), (P[i][j] = P[u][v])\n      }\n    }\n  }\n  return [S[N][N], P[N][N]]\n}\n\n// another\n\n/**\n * @param {string[]} board\n * @return {number[]}\n */\nconst pathsWithMaxScore = (\n  board,\n  DIRS = [\n    [-1, -1],\n    [-1, 0],\n    [0, -1],\n  ],\n  mod = 1e9 + 7\n) => {\n  const m = board.length,\n    n = board[0].length\n  const dpSum = Array.from({ length: m }, () => Array(n).fill(0))\n  const dpCnt = Array.from({ length: m }, () => Array(n).fill(0))\n  dpCnt[m - 1][n - 1] = 1 // start at the bottom right square\n  for (let r = m - 1; r >= 0; r--) {\n    for (let c = n - 1; c >= 0; c--) {\n      if (dpCnt[r][c] === 0) continue // can't reach to this square\n      for (let dir of DIRS) {\n        let nr = r + dir[0],\n          nc = c + dir[1]\n        if (nr >= 0 && nc >= 0 && board[nr].charAt(nc) !== 'X') {\n          let nsum = dpSum[r][c]\n          if (board[nr].charAt(nc) !== 'E') nsum += board[nr].charAt(nc) - '0'\n          if (nsum > dpSum[nr][nc]) {\n            dpCnt[nr][nc] = dpCnt[r][c]\n            dpSum[nr][nc] = nsum\n          } else if (nsum === dpSum[nr][nc]) {\n            dpCnt[nr][nc] = (dpCnt[nr][nc] + dpCnt[r][c]) % mod\n          }\n        }\n      }\n    }\n  }\n  return [dpSum[0][0], dpCnt[0][0]]\n}\n\n"
    }
  },
  {
    "name": "1304-find-n-unique-integers-sum-up-to-zero",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number[]}\n */\nconst sumZero = function(n) {\n  const num = ~~(n / 2)\n  const odd = n % 2 === 1\n  const res = pair(num)\n  if(odd) res.push(0)\n  return res\n};\n\nfunction pair(num) {\n  const set = new Set()\n  const res = []\n  for(let i = 1; i <= num; i++) res.push(i, -i)\n  return res\n}\n"
    }
  },
  {
    "name": "1306-jump-game-iii",
    "code": {
      "JS": "/**\n * @param {number[]} arr\n * @param {number} start\n * @return {boolean}\n */\nconst canReach = function(arr, start) {\n  const s = new Set()\n  return helper(arr, start, s)\n};\n\nfunction helper(arr, start, s) {\n  if(start < 0 || start >= arr.length || s.has(start)) return false\n  s.add(start)\n  if(arr[start] === 0) return true\n  \n  return helper(arr, start + arr[start], s) || helper(arr, start - arr[start], s)\n}\n\n// another\n\n/**\n * @param {number[]} arr\n * @param {number} start\n * @return {boolean}\n */\nconst canReach = function (A, i) {\n  return (\n    0 <= i &&\n    i < A.length &&\n    A[i] >= 0 &&\n    (!(A[i] = -A[i]) || canReach(A, i + A[i]) || canReach(A, i - A[i]))\n  )\n}\n\n// another\n\n/**\n * @param {number[]} arr\n * @param {number} start\n * @return {boolean}\n */\nconst canReach = function(arr, start) {\n  const q = [start]\n  const s = new Set()\n  while(q.length) {\n    const len = q.length\n    for(let i = 0; i < len; i++) {\n      const cur = q.shift()\n      s.add(cur)\n      if(arr[cur] === 0) return true\n      if(!s.has(cur + arr[cur])) q.push(cur + arr[cur])\n      if(!s.has(cur - arr[cur])) q.push(cur - arr[cur])\n    }\n  }\n  return false\n};\n\n"
    }
  },
  {
    "name": "1307-verbal-arithmetic-puzzle",
    "code": {
      "JS": "/**\n * @param {string[]} words\n * @param {string} result\n * @return {boolean}\n */\nconst isSolvable = function (words, result) {\n  const _isSolvable = (wordIndex, charIndex, wordsSum, resultSum, num) => {\n    if (wordIndex >= words.length) {\n      return wordsSum === resultSum\n    }\n    const wordLen = words[wordIndex].length\n    if (charIndex >= wordLen) {\n      if (wordIndex === words.length - 1) {\n        return _isSolvable(wordIndex + 1, 0, wordsSum, num, 0)\n      }\n      return _isSolvable(wordIndex + 1, 0, wordsSum + num, resultSum, 0)\n    }\n    const char = words[wordIndex][charIndex]\n    if (map.get(char) !== undefined) {\n      if (map.get(char) === 0 && num === 0 && charIndex >= 1) {\n        return false\n      }\n      return _isSolvable(\n        wordIndex,\n        charIndex + 1,\n        wordsSum,\n        resultSum,\n        num * 10 + map.get(char)\n      )\n    }\n    for (let digit = 0; digit <= 9; digit++) {\n      if (digit === 0 && num === 0 && wordLen > 1) continue\n      if (map.get(digit) !== undefined) continue\n      map.set(digit, char)\n      map.set(char, digit)\n      if (\n        _isSolvable(\n          wordIndex,\n          charIndex + 1,\n          wordsSum,\n          resultSum,\n          num * 10 + digit\n        )\n      ) {\n        return true\n      }\n      map.set(digit, undefined)\n      map.set(char, undefined)\n    }\n    return false\n  }\n  const map = new Map()\n  words = [...words, result]\n  return _isSolvable(0, 0, 0, 0, 0)\n}\n"
    }
  },
  {
    "name": "1309-decrypt-string-from-alphabet-to-integer-mapping",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {string}\n */\nconst freqAlphabets = function(s) {\n  const n = s.length, a = 'a'.charCodeAt(0) - 1\n  let res = '', cur = '', num = 0\n\n  for(let i = n - 1; i >= 0; i--) {\n    const ch = s[i]\n    if(cur === '') {\n      if(ch === '#') {\n        cur = ch\n        num = 0\n      } else{\n        res = (String.fromCharCode(a + (+ch))) + res\n      }\n    } else {\n      if (num < 1) {\n        cur = ch + cur\n        num++\n      } else {\n        cur = ch + cur\n        const tmp = cur.slice(0,cur.length - 1)\n        res = (String.fromCharCode(a + (+tmp))) + res\n        cur = ''\n        num = 0\n      }\n    }\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "131-palindrome-partitioning",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {string[][]}\n */\nconst partition = function(s) {\n  let res = []\n  backtrack(res, [], 0, s)\n  return res\n}\n\nfunction backtrack(res, cur, start, s) {\n  if (start === s.length) res.push([...cur])\n  else {\n    for (let i = start; i < s.length; i++) {\n      if (isPalindrome(s, start, i)) {\n        cur.push(s.substring(start, i + 1))\n        backtrack(res, cur, i + 1, s)\n        cur.pop()\n      }\n    }\n  }\n}\n\nfunction isPalindrome(str, start, i) {\n  let l = start,\n    r = i\n  while (l < r) {\n    if (str[l] !== str[r]) return false\n    l++\n    r--\n  }\n  return true\n}\n\n// another\n\n/**\n * @param {string} s\n * @return {string[][]}\n */\nconst partition = function(s) {\n  const res = []\n  helper(s, 0, [], res)\n  return res\n};\n\nfunction helper(str, idx, cur, res) {\n  if(idx >= str.length) {\n    res.push(cur.slice())\n    return\n  }\n  for(let i = idx, len = str.length; i < len; i++) {\n    const tmp = str.slice(idx, i + 1)\n    if(chk(tmp)) {\n      cur.push(tmp)\n      helper(str, i + 1, cur, res)\n      cur.pop()\n    }\n  }\n}\nfunction chk(str) {\n  const n = str.length\n  let l = 0, r = n - 1\n  while(l < r) {\n    if(str[l] !== str[r]) return false\n    l++\n    r--\n  }\n  return true\n}\n"
    }
  },
  {
    "name": "1310-xor-queries-of-a-subarray",
    "code": {
      "JS": " /**\n * @param {number[]} arr\n * @param {number[][]} queries\n * @return {number[]}\n */\nconst xorQueries = function(arr, queries) {\n  const pre = [], n = arr.length\n  let xor = arr[0]\n  pre.push(xor)\n  for(let i = 1; i < n; i++) {\n    pre[i] = pre[i - 1] ^ arr[i]\n  }\n\n  const res = queries.map((e, i) => {\n    const [l, r] = e\n    return pre[r] ^ (l > 0 ? pre[l - 1] : 0)\n  })\n  return res\n};\n"
    }
  },
  {
    "name": "1312-minimum-insertion-steps-to-make-a-string-palindrome",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst minInsertions = function (s) {\n  const dp = [...Array(501)].map((x) => Array(501).fill(0))\n  const N = s.length\n  for (let i = N - 1; i >= 0; --i)\n    for (let j = i + 1; j <= N; ++j)\n      if (s[i] == s[j - 1]) dp[i][j] = dp[i + 1][j - 1]\n      else dp[i][j] = 1 + Math.min(dp[i + 1][j], dp[i][j - 1])\n  return dp[0][N]\n}\n"
    }
  },
  {
    "name": "1313-decompress-run-length-encoded-list",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nconst decompressRLElist = function(nums) {\n  const res = []\n  for(let i = 0, n = nums.length; i < n - 1; i += 2) {\n    const [freq, val] = [nums[i], nums[i + 1]]\n    for(let j = 0; j < freq; j++) res.push(val)\n  } \n  \n  return res\n};\n"
    }
  },
  {
    "name": "1314-matrix-block-sum",
    "code": {
      "JS": "/**\n * @param {number[][]} mat\n * @param {number} k\n * @return {number[][]}\n */\nconst matrixBlockSum = function(mat, k) {\n  const m = mat.length, n = mat[0].length\n  const rangeSum = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0))\n\n  for(let i = 0; i < m; i++) {\n    for(let j = 0; j < n; j++) {\n      rangeSum[i + 1][j + 1] = rangeSum[i + 1][j] + rangeSum[i][j + 1] - rangeSum[i][j] + mat[i][j]\n    }\n  }\n  const res = Array.from({ length: m }, () => Array(n).fill(0))\n  for(let i = 0; i < m; i++) {\n    for(let j = 0; j < n; j++) {\n      let r1 = Math.max(0, i - k), c1 = Math.max(0, j - k)\n      let r2 = Math.min(m, i + k + 1), c2 = Math.min(n, j + k + 1)\n      res[i][j] = rangeSum[r2][c2] - rangeSum[r2][c1] - rangeSum[r1][c2] + rangeSum[r1][c1]\n    }\n  }\n\n  return res\n};\n"
    }
  },
  {
    "name": "1316-distinct-echo-substrings",
    "code": {
      "JS": "/**\n * @param {string} text\n * @return {number}\n */\nconst distinctEchoSubstrings = function (text) {\n  const set = new Set()\n  for(let len = 1; len <= text.length / 2; len++) {\n    for(let l = 0, r = len, count = 0; l < text.length - len; l++, r++) {\n      if(text.charAt(l) === text.charAt(r)) count++\n      else count = 0\n\n      if(count === len) {\n        set.add(text.slice(l - len + 1, l + 1))\n        count--\n      }\n    }\n  }\n  return set.size\n}\n\n"
    }
  },
  {
    "name": "132-palindrome-partitioning-ii",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\n\nconst minCut = function(s) {\n  const n = s.length\n  if (n <= 1) return 0\n  const dp = new Array(n).fill(0)\n  for (let i = 1; i < n; i++) dp[i] = i\n  for (let i = 1; i < n; i++) {\n    // odd\n    for (\n      let start = i, end = i;\n      end < n && start >= 0 && s[end] === s[start];\n      start--, end++\n    ) {\n      dp[end] = Math.min(dp[end], start === 0 ? 0 : dp[start - 1] + 1)\n    }\n    // even\n    for (\n      let start = i - 1, end = i;\n      end < n && start >= 0 && s[end] === s[start];\n      start--, end++\n    ) {\n      dp[end] = Math.min(dp[end], start === 0 ? 0 : dp[start - 1] + 1)\n    }\n  }\n  return dp[n - 1]\n}\n\n\n\n// another\n\nconst minCut = function(s) {\n  const n = s.length\n  const cut = new Array(n + 1).fill(0)\n  for (let i = 0; i <= n; i++) cut[i] = i - 1\n  for (let i = 0; i < n; i++) {\n    // odd\n    for (let j = 0; i + j < n && i - j >= 0 && s[i + j] === s[i - j]; j++) {\n      cut[i + j + 1] = Math.min(cut[i + j + 1], cut[i - j] + 1)\n    }\n    // even\n    for (\n      let j = 1;\n      i + j < n && i - j + 1 >= 0 && s[i + j] === s[i - j + 1];\n      j++\n    ) {\n      cut[i + j + 1] = Math.min(cut[i + j + 1], cut[i - j + 1] + 1)\n    }\n  }\n  return cut[n]\n}\n"
    }
  },
  {
    "name": "1320-minimum-distance-to-type-a-word-using-two-fingers",
    "code": {
      "JS": "/**\n * @param {string} word\n * @return {number}\n */\nconst minimumDistance = function (word) {\n  const dp = Array.from({ length: 2 }, () =>\n    new Array(27).fill(0).map(() => Array(27).fill(0))\n  )\n  const A = 'A'.charCodeAt(0)\n  for (let pos = word.length - 1; pos >= 0; --pos) {\n    let to = word[pos].charCodeAt(0) - A\n    for (let i = 0; i < 27; ++i) {\n      for (let j = 0; j < 27; ++j) {\n        dp[pos % 2][i][j] = Math.min(\n          dp[(pos + 1) % 2][to][i] + cost(j, to),\n          dp[(pos + 1) % 2][to][j] + cost(i, to)\n        )\n      }\n    }\n  }\n  return dp[0][26][26]\n}\nfunction cost(from, to) {\n  if (from === 26) return 0\n  return (\n    Math.abs(((from / 6) >> 0) - ((to / 6) >> 0)) +\n    Math.abs((from % 6) - (to % 6))\n  )\n}\n"
    }
  },
  {
    "name": "1323-maximum-69-number",
    "code": {
      "JS": "/**\n * @param {number} num\n * @return {number}\n */\nvar maximum69Number  = function(num) {\n  const arr = (num+'').split('')\n  for(let i = 0; i < arr.length; i++) {\n    if(arr[i] === '6') {\n      arr[i] = '9'\n      break\n    }\n  }\n  return arr.join('')\n};\n"
    }
  },
  {
    "name": "1325-delete-leaves-with-a-given-value",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} target\n * @return {TreeNode}\n */\nconst removeLeafNodes = function(root, target) {\n  return dfs(root, target)\n};\n\nfunction dfs(node, target) {\n  if(node == null) return node\n  if(node.left == null && node.right == null) {\n    if(node.val === target)  return null\n    else return node\n  }\n  node.right = dfs(node.right, target)\n  node.left = dfs(node.left, target)\n  if(node.right == null && node.left == null) return dfs(node, target)\n  return node\n}\n\n// another\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} target\n * @return {TreeNode}\n */\nconst removeLeafNodes = function(root, target) {\n  if(root.left)  root.left = removeLeafNodes(root.left, target)\n  if(root.right) root.right = removeLeafNodes(root.right, target)\n  return root.left == root.right && root.val === target ? null : root\n};\n"
    }
  },
  {
    "name": "1326-minimum-number-of-taps-to-open-to-water-a-garden",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[]} ranges\n * @return {number}\n */\nconst minTaps = function (n, ranges) {\n  const starts = new Array(n + 1).fill(0)\n  for (let i = 0; i <= n; i++) {\n    const start = Math.max(0, i - ranges[i])\n    starts[start] = Math.max(starts[start], i + ranges[i])\n  }\n  let count = 0\n  let max = 0\n  let i = 0\n  while (max < n) {\n    const end = max\n    for (let j = i; j <= end; j++) {\n      max = Math.max(max, starts[j])\n    }\n    if (i === max) return -1\n    i = end\n    count++\n  }\n  return count\n}\n\n// another\n\n/**\n * @param {number} n\n * @param {number[]} ranges\n * @return {number}\n */\nconst minTaps = function (n, ranges) {\n  const dp = new Array(n + 1).fill(n + 2)\n  dp[0] = 0\n  for (let i = 0; i <= n; ++i)\n    for (let j = Math.max(i - ranges[i] + 1, 0); j <= Math.min(i + ranges[i], n); ++j)\n      dp[j] = Math.min(dp[j], dp[Math.max(0, i - ranges[i])] + 1)\n  return dp[n] < n + 2 ? dp[n] : -1\n}\n"
    }
  },
  {
    "name": "133-clone-graph",
    "code": {
      "JS": "/**\n *   - if(!node) return node. Graphs can also have null neighbors\n *   - using a Set doesn't work because we are dealing with objects not primitives\n *       - and when encountering an already-cloned node, you are supposed to return the copied node\n *       (otherwise you are linking back to the original)\n *       - so, map = {} is correct\n *   - the only \"trick\" is that you must set the current node as \"already copied\" before DFS-ing its neighbors\n *   - declaring new variable for copying a node is actually extra O(n) space\n */\n\n/**\n * // Definition for a Node.\n * function Node(val,neighbors) {\n *    this.val = val;\n *    this.neighbors = neighbors;\n * };\n */\n/**\n * @param {Node} node\n * @return {Node}\n */\nconst cloneGraph = function(node) {\n  if (!node) return node\n  const map = {}\n  return traverse(node)\n  function traverse(node) {\n    if(!node) return node;\n    if (!map[node.val]) {\n      const newNode = new Node(node.val)\n      map[node.val] = newNode\n      newNode.neighbors = node.neighbors.map(traverse)\n    }\n    return map[node.val]\n  }\n}\n"
    }
  },
  {
    "name": "1330-reverse-subarray-to-maximize-array-value",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst maxValueAfterReverse = function (nums) {\n  let minOfMaxPair = -Infinity\n  let maxOfMinPair = Infinity\n  let originalTotal = 0\n  let maximumBenefit = 0\n  for (let i = 1; i < nums.length; i++) {\n    const [left, right] = [nums[i - 1], nums[i]]\n    const diff = Math.abs(right - left)\n    originalTotal += diff\n    maximumBenefit = Math.max(\n      maximumBenefit,\n      Math.abs(right - nums[0]) - diff,\n      Math.abs(left - nums[nums.length - 1]) - diff\n    )\n    minOfMaxPair = Math.max(minOfMaxPair, Math.min(left, right))\n    maxOfMinPair = Math.min(maxOfMinPair, Math.max(left, right))\n  }\n  maximumBenefit = Math.max(maximumBenefit, 2 * (minOfMaxPair - maxOfMinPair))\n  return originalTotal + maximumBenefit\n}\n"
    }
  },
  {
    "name": "1331-rank-transform-of-an-array",
    "code": {
      "JS": "/**\n * @param {number[]} arr\n * @return {number[]}\n */\nconst arrayRankTransform = function(arr) {\n  const hash = {}\n  for(let e of arr) {\n    hash[e] = 1\n  }\n  const keys = Object.keys(hash)\n  keys.sort((a, b) => a - b)\n  const rank = {}\n  for(let i = 0, n= keys.length; i < n; i++) {\n    rank[keys[i]] = i + 1\n  }\n  \n  return arr.map(e => rank[e])\n};\n"
    }
  },
  {
    "name": "1332-remove-palindromic-subsequences",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst removePalindromeSub = function(s) {\n  if(s == null || s === '') return 0\n  if(chk(s)) return 1\n  return 2\n};\n\nfunction chk(s) {\n  let l = 0, r = s.length - 1\n  while(l < r) {\n    if(s[l] !== s[r]) return false\n    l++\n    r--\n  }\n  \n  return true\n}\n"
    }
  },
  {
    "name": "1335-minimum-difficulty-of-a-job-schedule",
    "code": {
      "JS": "/**\n * @param {number[]} jobDifficulty\n * @param {number} d\n * @return {number}\n */\nconst minDifficulty = function (jobDifficulty, d) {\n  if (jobDifficulty.length < d) return -1\n  const cache = {}\n  const dfs = (start, numDays) => {\n    if (numDays === d) {\n      return start === jobDifficulty.length ? 0 : Infinity\n    }\n    const key = `${start}-${numDays}`\n    if (cache[key] !== undefined) return cache[key]\n    const end = jobDifficulty.length - d + numDays\n    let result = Infinity\n    let max = -Infinity\n    for (let i = start; i <= end; i++) {\n      max = Math.max(max, jobDifficulty[i])\n      result = Math.min(result, max + dfs(i + 1, numDays + 1))\n    }\n    return (cache[key] = result)\n  }\n  return dfs(0, 0)\n}\n"
    }
  },
  {
    "name": "1337-the-k-weakest-rows-in-a-matrix",
    "code": {
      "JS": "/**\n * @param {number[][]} mat\n * @param {number} k\n * @return {number[]}\n */\nconst kWeakestRows = function(mat, k) {\n  const pq = new PriorityQueue((a,  b) => a[0] === b[0] ? a[1] > b[1] : a[0] > b[0])\n  const res = [], m = mat.length\n  for(let i = 0; i < m; i++) {\n    pq.push([oneNum(mat[i]), i])\n    if(pq.size() > k) pq.pop()\n  }\n  while(k > 0) res[--k] = pq.pop()[1]\n  return res\n};\n\nfunction oneNum(arr) {\n  let l = 0, h = arr.length\n  while(l < h) {\n    const mid  = l + ((h - l) >> 1)\n    if(arr[mid] === 1) l = mid + 1\n    else h = mid\n  }\n  return l\n}\n\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n"
    }
  },
  {
    "name": "134-gas-station",
    "code": {
      "JS": "/**\n * @param {number[]} gas\n * @param {number[]} cost\n * @return {number}\n */\nconst canCompleteCircuit = function(gas, cost) {\n  let total = 0\n  let curLeft = 0\n  let curtIdx = 0\n  for (let i = 0; i < gas.length; i++) {\n    total += gas[i] - cost[i]\n    curLeft += gas[i] - cost[i]\n    if (curLeft < 0) {\n      curtIdx = i + 1\n      curLeft = 0\n    }\n  }\n  return total < 0 ? -1 : curtIdx\n}\n\n// another\n\nconst canCompleteCircuit = function(gas, cost) {\n  const len = gas.length\n  let tank = 0\n  let count = 0\n  for (let i = 0; i < len * 2; i++) {\n    let idx = i % len\n    if (count === len) return idx\n    count += 1\n    tank += gas[idx] - cost[idx]\n    if (tank < 0) {\n      tank = 0\n      count = 0\n    }\n  }\n  return -1\n}\n\n"
    }
  },
  {
    "name": "1340-jump-game-v",
    "code": {
      "JS": "/**\n * @param {number[]} arr\n * @param {number} d\n * @return {number}\n */\nconst maxJumps = function (arr, d, res = 1) {\n  const dp = Array(1001).fill(0)\n  for (let i = 0, len = arr.length; i < len; ++i)\n    res = Math.max(res, dfs(arr, i, d))\n  return res\n\n  function dfs(arr, i, d, res = 1) {\n    if (dp[i]) return dp[i]\n    for (\n      let j = i + 1;\n      j <= Math.min(i + d, arr.length - 1) && arr[j] < arr[i];\n      ++j\n    )\n      res = Math.max(res, 1 + dfs(arr, j, d))\n    for (let j = i - 1; j >= Math.max(0, i - d) && arr[j] < arr[i]; --j)\n      res = Math.max(res, 1 + dfs(arr, j, d))\n    return (dp[i] = res)\n  }\n}\n\n\n// another\n\n/**\n * @param {number[]} arr\n * @param {number} d\n * @return {number}\n */\nconst maxJumps = function (arr, d) {\n  const cache = new Array(arr.length)\n  const diffs = [1, -1]\n  const dfs = (i) => {\n    if (cache[i]) return cache[i]\n    let max = 0\n    for (let diff of diffs) {\n      for (let j = diff; Math.abs(j) <= d; j += diff) {\n        const nextPosition = i + j\n        const isValidJump =\n          nextPosition >= 0 &&\n          nextPosition < arr.length &&\n          arr[i] > arr[nextPosition]\n        if (isValidJump) max = Math.max(max, dfs(nextPosition))\n        else break\n      }\n    }\n    const result = max + 1\n    cache[i] = result\n    return result\n  }\n  for (let i = 0; i < arr.length; i++) dfs(i)\n  return Math.max(...cache)\n}\n\n// another\n\n/**\n * @param {number[]} arr\n * @param {number} d\n * @return {number}\n */\nconst maxJumps = function (arr, d, res = 0) {\n  const n = arr.length\n  const stack = [], stack2 = []\n  const dp = Array(n + 1).fill(1)\n  arr.push(Infinity)\n  for(let i = 0; i <= n; i++) {\n    while(stack.length && arr[stack[stack.length - 1]] < arr[i]) {\n      const pre = arr[stack[stack.length - 1]]\n      while(stack.length && pre === arr[stack[stack.length - 1]]) {\n        const j = stack[stack.length - 1]\n        stack.pop()\n        if(i - j <= d) dp[i] = Math.max(dp[i], dp[j] + 1)\n        stack2.push(j)\n      }\n      while(stack2.length) {\n        const j = stack2[stack2.length - 1]\n        stack2.pop()\n        if(stack.length && j - stack[stack.length - 1] <= d) {\n          dp[stack[stack.length - 1]] = Math.max(dp[stack[stack.length - 1]], dp[j] + 1)\n        }\n      }\n    }\n    stack.push(i)\n  }\n  for(let i = 0; i < n; i++) res = Math.max(res, dp[i]) \n  return res\n}\n"
    }
  },
  {
    "name": "1342-number-of-steps-to-reduce-a-number-to-zero",
    "code": {
      "JS": "/**\n * @param {number} num\n * @return {number}\n */\nconst numberOfSteps = function(num) {\n  let res = 0\n  while(num !== 0) {\n    if(num % 2 === 0) {\n      num /= 2\n    } else num--\n    res++\n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "1344-angle-between-hands-of-a-clock",
    "code": {
      "JS": "/**\n * @param {number} hour\n * @param {number} minutes\n * @return {number}\n */\nconst angleClock = function(hour, minutes) {\n  const minutesAngle = minutes * 6;\n  const hoursAngle = (hour + minutes / 60) * 30;\n  const diff = Math.abs(minutesAngle - hoursAngle);\n  return Math.min(diff, 360 - diff);\n};\n"
    }
  },
  {
    "name": "1345-jump-game-iv",
    "code": {
      "JS": "/**\n * @param {number[]} arr\n * @return {number}\n */\nvar minJumps = function (arr) {\n  if (arr.length === 1) return 0\n  const n = arr.length\n  const indexMap = new Map()\n  for (let i = n - 1; i >= 0; i--) {\n    if (!indexMap.has(arr[i])) {\n      indexMap.set(arr[i], [])\n    }\n    indexMap.get(arr[i]).push(i)\n  }\n  let distance = 0\n  const queue = [0, null]\n  const visited = new Set([0])\n  while (queue.length > 0) {\n    const index = queue.shift()\n    if (index !== null) {\n      if (index > 0 && !visited.has(index - 1)) {\n        visited.add(index - 1)\n        queue.push(index - 1)\n      }\n      if (index < n - 1 && !visited.has(index + 1)) {\n        if (index + 1 === n - 1) return distance + 1\n        visited.add(index + 1)\n        queue.push(index + 1)\n      }\n      for (const nb of indexMap.get(arr[index])) {\n        if (!visited.has(nb) && nb !== index - 1 && nb !== index + 1) {\n          if (nb === n - 1) return distance + 1\n          visited.add(nb)\n          queue.push(nb)\n        }\n      }\n    } else {\n      distance++\n      if (queue.length > 0) {\n        queue.push(null)\n      }\n    }\n  }\n  return -1\n}\n\n// another\n\n/**\n * @param {number[]} arr\n * @return {number}\n */\nconst minJumps = function (arr) {\n  if (arr.length === 1) return 0\n  const n = arr.length\n  const indexMap = new Map()\n  for (let i = n - 1; i >= 0; i--) {\n    if (!indexMap.has(arr[i])) {\n      indexMap.set(arr[i], [])\n    }\n    indexMap.get(arr[i]).push(i)\n  }\n  let distance = 0\n  const queue = [0]\n  const visited = new Set()\n  visited.add(0)\n  while (queue.length) {\n    const len = queue.length\n    for(let i = 0; i < len; i++) {\n      const cur = queue.shift()\n      if(cur === n - 1) return distance\n      const tmp = indexMap.get(arr[cur])\n      tmp.push(cur - 1)\n      tmp.push(cur + 1)\n      for(let e of tmp) {\n        if(e >= 0 && e < n && !visited.has(e)) {\n          visited.add(e)\n          queue.push(e)\n        }\n      }\n      indexMap.set(arr[cur], [])\n    }\n    distance++\n  }\n  return -1\n}\n\n"
    }
  },
  {
    "name": "1348-tweet-counts-per-frequency",
    "code": {
      "JS": "const createNode = val => ({ val, left: null, right: null });\nclass BinarySearchTree {\n  constructor() {\n    this.root = null;\n  }\n  insert(val, cur = this.root) {\n    const node = createNode(val);\n    if (!this.root) { this.root = node; return; }\n    if (val >= cur.val) {\n      !cur.right ? (cur.right = node) : this.insert(val, cur.right);\n    } else {\n      !cur.left ? (cur.left = node) : this.insert(val, cur.left);\n    }\n  }\n  traversal(low, high, interval, intervals, cur = this.root) {\n    if (!cur) return;\n    if (cur.val <= high && cur.val >= low) {\n      ++intervals[Math.floor((cur.val - low + 1) / interval)];\n    }\n    cur.val > low && this.traversal(low, high, interval, intervals, cur.left);\n    cur.val < high && this.traversal(low, high, interval, intervals, cur.right);\n  }\n};\nclass TweetCounts {\n  constructor() {\n    this.freqInterval = {\n      minute: 60,\n      hour: 3600,\n      day: 86400,\n    };\n    this.data = new Map();\n  }\n\n  recordTweet(name, time) {\n    if (this.data.has(name) === false) {\n      this.data.set(name, new BinarySearchTree());\n    }\n    this.data.get(name).insert(time);\n  }\n\n  getTweetCountsPerFrequency(freq, name, start, end) {\n    const interval = this.freqInterval[freq];\n    const ret = new Array(Math.ceil((end - start + 1) / interval)).fill(0);\n    this.data.has(name) && this.data.get(name).traversal(start, end, interval, ret);\n    return ret;\n  }\n};\n\n/** \n * Your TweetCounts object will be instantiated and called as such:\n * var obj = new TweetCounts()\n * obj.recordTweet(tweetName,time)\n * var param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n */\n"
    }
  },
  {
    "name": "1349-maximum-students-taking-exam",
    "code": {
      "JS": "/**\n * @param {character[][]} seats\n * @return {number}\n */\nconst maxStudents = function (seats) {\n  if (!seats.length) return 0\n  const lastPos = 1 << seats[0].length\n  const classroom = seats.map((row) =>\n    row.reduce((a, c, i) => (c === '#' ? a : a | (1 << i)), 0)\n  )\n  const dp = new Array(seats.length + 1).fill(null).map(() => new Map())\n  dp[0].set(0, 0)\n  for (let row = 0; row < seats.length; row++) {\n    let queue = [0]\n    let numStudents = 0\n    while (queue.length > 0) {\n      const next = []\n      for (let arrangement of queue) {\n        let max = 0\n        for (let [prevArrang, count] of dp[row]) {\n          if (conflicts(prevArrang, arrangement)) continue\n          max = Math.max(max, count + numStudents)\n        }\n        dp[row + 1].set(arrangement, max)\n        for (let i = 1; i < lastPos; i <<= 1) {\n          if (canSit(classroom[row], arrangement, i)) next.push(arrangement | i)\n        }\n      }\n      queue = next\n      numStudents++\n    }\n  }\n  return Math.max(...dp[seats.length].values())\n}\nfunction conflicts(prev, curr) {\n  return prev & (curr << 1) || prev & (curr >> 1)\n}\nfunction canSit(row, arrangement, newStudent) {\n  return (\n    row & newStudent &&\n    !(arrangement & newStudent) &&\n    !(arrangement & (newStudent << 1)) &&\n    !(arrangement & (newStudent >> 1))\n  )\n}\n\n// another\n\n/**\n * @param {character[][]} seats\n * @return {number}\n */\nconst maxStudents = function (seats) {\n  const m = seats.length\n  const n = seats[0].length\n  const validity = []\n  for (let i = 0; i < m; i++) {\n    let cur = 0\n    for (let j = 0; j < n; j++) {\n      cur = (cur << 1) + (seats[i][j] === '.' ? 1 : 0)\n    }\n    validity.push(cur)\n  }\n  const f = Array.from({ length: m + 1 }, () => Array(1 << n).fill(-1))\n  f[0][0] = 0\n  for (let i = 1; i <= m; i++) {\n    const valid = validity[i - 1]\n    for (let j = 0; j < 1 << n; j++) {\n      if ((j & valid) === j && !(j & (j >> 1))) {\n        for (let k = 0; k < 1 << n; k++) {\n          if (!(j & (k >> 1)) && !((j >> 1) & k) && f[i - 1][k] !== -1) {\n            f[i][j] = Math.max(f[i][j], f[i - 1][k] + bitCount(j))\n          }\n        }\n      }\n    }\n  }\n  return Math.max(...f[m])\n}\nfunction bitCount(n) {\n  const res = n.toString(2).match(/1/g)\n  return res === null ? 0 : res.length\n}\n\n"
    }
  },
  {
    "name": "135-candy",
    "code": {
      "JS": "/**\n * @param {number[]} ratings\n * @return {number}\n */\nconst candy = function(ratings) {\n  const candies = new Array(ratings.length).fill(1);\n  for (let i = 1; i < candies.length; i++) {\n    if (ratings[i] > ratings[i - 1]) {\n      candies[i] = candies[i - 1] + 1;\n    }\n  }\n  let sum = candies[candies.length - 1];\n  for (let i = candies.length - 2; i >= 0; i--) {\n    if (ratings[i] > ratings[i + 1]) {\n      candies[i] = Math.max(candies[i], candies[i + 1] + 1);\n    }\n    sum += candies[i];\n  }\n  return sum;\n};\n"
    }
  },
  {
    "name": "1351-count-negative-numbers-in-a-sorted-matrix",
    "code": {
      "JS": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nconst countNegatives = function(grid) {\n  const m = grid.length, n = grid[0].length\n  let res = 0, r = m - 1, c = 0\n  while(r >= 0 && c < n) {\n    if(grid[r][c] < 0) {\n      res += n - c\n      r--\n    } else c++\n  }\n\n  return res\n};\n"
    }
  },
  {
    "name": "1352-product-of-the-last-k-numbers",
    "code": {
      "JS": "/*\n * @lc app=leetcode id=1352 lang=javascript\n *\n * [1352] Product of the Last K Numbers\n */\n\n// @lc code=start\n\nconst ProductOfNumbers = function() {\n  this.sum = [1]\n};\n\n/** \n * @param {number} num\n * @return {void}\n */\nProductOfNumbers.prototype.add = function(num) {\n  if(num > 0) {\n    this.sum.push(this.sum[this.sum.length - 1] * num)\n  } else {\n    this.sum = [1]\n  }\n};\n\n/** \n * @param {number} k\n * @return {number}\n */\nProductOfNumbers.prototype.getProduct = function(k) {\n  const len = this.sum.length\n  return k < len ? this.sum[len - 1] / this.sum[len - 1 - k] : 0\n};\n\n/** \n * Your ProductOfNumbers object will be instantiated and called as such:\n * var obj = new ProductOfNumbers()\n * obj.add(num)\n * var param_2 = obj.getProduct(k)\n */\n"
    }
  },
  {
    "name": "1353-maximum-number-of-events-that-can-be-attended",
    "code": {
      "JS": "class PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n/**\n * @param {number[][]} events\n * @return {number}\n */\nfunction maxEvents(events) {\n  const pq = new PriorityQueue((a, b) => a < b)\n  \n  events.sort((a, b) => a[0] - b[0])\n  let i = 0, res = 0, d = 0, n = events.length\n\n  while(!pq.isEmpty() || i < n) {\n    if(pq.isEmpty()) {\n      d = events[i][0]\n    }\n    while(i < n && events[i][0] <= d) {\n      pq.push(events[i++][1])\n    }\n    pq.pop()\n    res++\n    d++\n    while(!pq.isEmpty() && pq.peek() < d) {\n      pq.pop()\n    }\n  }\n\n  return res\n}\n\n\n// another\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n/**\n * @param {number[][]} events\n * @return {number}\n */\nfunction maxEvents(events) {\n  const pq = new PriorityQueue((a, b) => a < b)\n  events.sort((a, b) => a[0] - b[0])\n  let res = 0, i = 0, n = events.length\n  for(let d = 1; d <= 100000; d++) {\n    while(i < n && events[i][0] === d) {\n      pq.push(events[i++][1])\n    }\n    while(!pq.isEmpty() && pq.peek() < d) {\n      pq.pop()\n    }\n    if(!pq.isEmpty()) {\n      res++\n      pq.pop()\n    }\n  }\n  return res\n}\n\n\n// another\n\n\n\n/**\n * @param {number[][]} events\n * @return {number}\n */\nfunction maxEvents(events) {\n  events.sort(([, aEnd], [, bEnd]) => aEnd - bEnd);\n  const lastDay = events[events.length - 1][1];\n  const segmentTree = new SegmentTree(Array.from({ length: lastDay }, (_, i) => i), Infinity, (a, b) => Math.min(a, b));\n  let daysAttended = 0;\n\n  for (const [start, end] of events) {\n    // earliest attendable day\n    const ead = segmentTree.queryIn(start - 1, end);\n    if (ead <= end) {\n      daysAttended += 1;\n      segmentTree.setAt(ead, Infinity);\n    }\n  }\n\n  return daysAttended;\n}\n\n// https://github.com/axross/complex-data-structures\n// new SegmentTree(values, identity, associate)\n//     segmentTree.getAt(i)\n//     segmentTree.queryIn(from, to)\n//     segmentTree.setAt(i, value)\n//     segmentTree.length\nclass SegmentTree{constructor(t,e,s){if(this.valueLength=t.length,this.identity=e,this.associate=s,0===t.length)this.tree=[];else{const h=2**Math.ceil(Math.log2(t.length))*2-1,i=[];for(let s=0;s<=h>>1;++s)i[(h>>1)+s]=s<t.length?t[s]:e;for(let t=(h>>1)-1;t>=0;--t)i[t]=s(i[2*t+1],i[2*t+2]);this.tree=i}}get length(){return this.valueLength}getAt(t){return this.tree[t+(this.tree.length>>1)]}queryIn(t,e){let s=this.identity;const h=[[0,0,1+(this.tree.length>>1)]];for(;h.length>0;){const[i,r,n]=h.pop();r>=t&&n<=e?s=this.associate(s,this.tree[i]):r>=e||n<t||i>this.tree.length>>1||h.push([2*i+1,r,r+n>>1],[2*i+2,r+n>>1,n])}return s}setAt(t,e){const s=t+(this.tree.length>>1);this.tree[s]=e;let h=s-1>>1;for(;h>=0;)this.tree[h]=this.associate(this.tree[2*h+1],this.tree[2*h+2]),h=h-1>>1}}\n"
    }
  },
  {
    "name": "1354-construct-target-array-with-multiple-sums",
    "code": {
      "JS": "/**\n * @param {number[]} target\n * @return {boolean}\n */\nconst isPossible = function (target) {\n  const pq = new PriorityQueue();\n  let total = 0;\n  for (let a of target) {\n    total += a;\n    pq.push(a);\n  }\n  while (true) {\n    let a = pq.pop();\n    total -= a;\n    if (a === 1 || total === 1) return true;\n    if (a < total || total === 0 || a % total === 0) return false;\n    a %= total;\n    total += a;\n    pq.push(a);\n  }\n};\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = [];\n    this.top = 0;\n    this.comparator = comparator;\n  }\n  size() {\n    return this.heap.length;\n  }\n  isEmpty() {\n    return this.size() === 0;\n  }\n  peek() {\n    return this.heap[this.top];\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value);\n      this.siftUp();\n    });\n    return this.size();\n  }\n  pop() {\n    const poppedValue = this.peek();\n    const bottom = this.size() - 1;\n    if (bottom > this.top) {\n      this.swap(this.top, bottom);\n    }\n    this.heap.pop();\n    this.siftDown();\n    return poppedValue;\n  }\n  replace(value) {\n    const replacedValue = this.peek();\n    this.heap[this.top] = value;\n    this.siftDown();\n    return replacedValue;\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1;\n  left = (i) => (i << 1) + 1;\n  right = (i) => (i + 1) << 1;\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j]);\n  swap = (i, j) =>\n    ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]]);\n  siftUp = () => {\n    let node = this.size() - 1;\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node));\n      node = this.parent(node);\n    }\n  };\n  siftDown = () => {\n    let node = this.top;\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node);\n      this.swap(node, maxChild);\n      node = maxChild;\n    }\n  };\n}\n"
    }
  },
  {
    "name": "1356-sort-integers-by-the-number-of-1-bits",
    "code": {
      "JS": "/**\n * @param {number[]} arr\n * @return {number[]}\n */\nconst sortByBits = function(arr) {\n  arr.sort((a, b) => {\n    const an = numOfBits(a), bn = numOfBits(b)\n    return an === bn ? a - b : an - bn\n  })\n  return arr\n};\n\nfunction numOfBits(n) {\n  let res = 0\n  for(let i = 0; i < 32; i++) {\n    if((1 << i) & n) res++\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "1359-count-all-valid-pickup-and-delivery-options",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst countOrders = function(n) {\n  let res = 1\n  const MOD = 10 ** 9 + 7\n  for(let i = 1; i <= n; i++) {\n    res = res * (i * 2 - 1) * i % MOD;\n  }\n  return res\n};\n\n// another\n\n/**\n * @param {number} n\n * @return {number}\n */\nconst countOrders = function(n) {\n  let res = 1\n  const MOD = 10 ** 9 + 7\n  for(let i = 1; i <= n; i++) res = res * i % MOD\n  for(let i = 1; i < 2 * n; i += 2) res = res * i % MOD\n  return res\n};\n"
    }
  },
  {
    "name": "136-single-number",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst singleNumber = function(nums) {\n  let xor = nums[0]\n  for(let i = 1; i< nums.length; i++) xor ^= nums[i]\n  return xor\n};\n\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst singleNumber = function(nums) {\n  return nums.reduce((ac, e) => ac ^ e, 0)\n};\n"
    }
  },
  {
    "name": "1360-number-of-days-between-two-dates",
    "code": {
      "JS": "/**\n * @param {string} date1\n * @param {string} date2\n * @return {number}\n */\nconst daysBetweenDates = function(date1, date2) {\n  const d1 = new Date(date1)\n  const d2 = new Date(date2)\n  return Math.abs((d1.getTime() - d2.getTime()) / (1000 * 60 * 60 * 24))\n};\n"
    }
  },
  {
    "name": "1363-largest-multiple-of-three",
    "code": {
      "JS": "/**\n * @param {number[]} digits\n * @return {string}\n */\nconst largestMultipleOfThree = function (digits) {\n  const sum = digits.reduce((a, c) => a + c)\n  if (sum === 0) return '0'\n  const remainder = sum % 3\n  digits.sort((a, b) => b - a)\n  if (remainder === 0) return digits.join('')\n  const doubleRemainder = remainder === 1 ? 2 : 1\n  const idxs = []\n  for (let i = digits.length - 1; i >= 0; i--) {\n    const numRemainder = digits[i] % 3\n    if (numRemainder === remainder) {\n      digits[i] = ''\n      return digits.join('')\n    } else if (numRemainder === doubleRemainder) {\n      idxs.push(i)\n    }\n  }\n  const [idx1, idx2] = idxs\n  if (idx2 === undefined) return ''\n\n  digits[idx1] = ''\n  digits[idx2] = ''\n  return digits.join('')\n}\n"
    }
  },
  {
    "name": "1365-how-many-numbers-are-smaller-than-the-current-number",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nconst smallerNumbersThanCurrent = function(nums) {\n    const count = new Array(101).fill(0);\n    const res = new Array(nums.length).fill(0);\n    for (let i = 0; i < nums.length; i++) count[nums[i]]++\n    for (let i = 1 ; i <= 100; i++) count[i] += count[i-1]\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] == 0) res[i] = 0\n        else res[i] = count[nums[i] - 1]\n    }\n    return res;\n};\n\n"
    }
  },
  {
    "name": "1366-rank-teams-by-votes",
    "code": {
      "JS": "/**\n * @param {string[]} votes\n * @return {string}\n */\nconst rankTeams = function(votes) {\n  const hash = {}\n  const l = votes[0].length\n  for(let vote of votes) {\n    for(let i = 0; i < l; i++) {\n      const ch = vote[i]\n      if(hash[ch] == null) hash[ch] = Array(l).fill(0)\n      hash[ch][i]++\n    }\n  }\n  const keys = Object.keys(hash)\n  keys.sort((a, b) => {\n    for(let i = 0; i < l; i++) {\n      if(hash[a][i] !== hash[b][i]) {\n        return hash[b][i] - hash[a][i]\n      }\n    }\n    return a === b ? 0 : (a < b ? -1 : 1)\n  })\n\n  return keys.join('')\n};\n\n// another\n\n/**\n * @param {string[]} votes\n * @return {string}\n */\nconst rankTeams = function(votes) {\n   if (votes.length === 1) return votes[0];\n    const score = new Map(votes[0].split('').map(c => [c, new Array(votes[0].length).fill(0)]));\n    for (s of votes) {\n        for (let i = 0; i < s.length; i++) {\n            score.get(s[i])[i]++;\n        }\n    }\n    return votes[0].split('').sort((a,b) => {\n        for (let i = 0; i < votes[0].length; i++) {\n            if (score.get(a)[i] > score.get(b)[i]) return -1;\n            if (score.get(a)[i] < score.get(b)[i]) return 1;\n        }\n        return a < b ? -1 : 1;\n    }).join('');\n};\n"
    }
  },
  {
    "name": "1367-linked-list-in-binary-tree",
    "code": {
      "JS": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {TreeNode} root\n * @return {boolean}\n */\nconst isSubPath = function(head, root) {\n  const res = { found: false }\n  traverse(root, head, res)\n  return res.found\n};\n\nfunction traverse(node, list, res) {\n  if(res.found) return\n  if(node == null) return\n  if(node.val === list.val && helper(node, list)) {\n    res.found = true\n    return\n  } \n  traverse(node.left, list, res)\n  traverse(node.right, list, res)\n}\n\nfunction helper(node, list) {\n  if(list == null) return true\n  if(node == null) return false\n  if(list.val !== node.val) return false\n  return helper(node.left, list.next) || helper(node.right, list.next)\n}\n"
    }
  },
  {
    "name": "1368-minimum-cost-to-make-at-least-one-valid-path-in-a-grid",
    "code": {
      "JS": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nfunction minCost(grid) {\n  const m = grid.length, n = grid[0].length\n  const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]] // right, left, down, up\n  const dp = Array.from({ length: m }, () => Array(n).fill(Infinity))\n  let q = [[0, 0]]\n  dp[0][0] = 0\n  while(q.length) {\n    const tmp = []\n    for(let idx = q.length - 1; idx >= 0; idx--) {\n      const [r, c] = q[idx]\n      for(let i = 0; i < dirs.length; i++) {\n        const [dr, dc] = dirs[i]\n        const nr = r + dr, nc = c + dc\n        if(nr < 0 || nr >= m || nc < 0 || nc >= n) continue\n        if(dp[nr][nc] > dp[r][c] + (i === grid[r][c] - 1 ? 0 : 1)) {\n          dp[nr][nc] = dp[r][c] + (i === grid[r][c] - 1 ? 0 : 1)\n          tmp.push([nr, nc])\n        }\n      }\n    }\n    q = tmp\n  }\n\n  return dp[m - 1][n - 1]\n}\n\n// another\n\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nconst minCost = function (grid) {\n  const n = grid.length\n  const m = grid[0].length\n  const moves = [\n    [0, 1],\n    [0, -1],\n    [1, 0],\n    [-1, 0],\n  ]\n  const dp = [...new Array(n)].map((e) => [...new Array(m)].fill(Infinity))\n  dp[0][0] = 0\n  let queue = [[0, 0]]\n  while (queue.length > 0) {\n    const temp = []\n    for (let i = 0; i < queue.length; i++) {\n      const [x, y] = queue[i]\n      for (let j = 0; j < moves.length; j++) {\n        const nextX = x + moves[j][0]\n        const nextY = y + moves[j][1]\n        if (nextX >= 0 && nextY >= 0 && nextX < n && nextY < m) {\n          if (dp[nextX][nextY] > dp[x][y] + (grid[x][y] - 1 === j ? 0 : 1)) {\n            dp[nextX][nextY] = dp[x][y] + (grid[x][y] - 1 === j ? 0 : 1)\n            queue.push([nextX, nextY])\n          }\n        }\n      }\n    }\n    queue = temp\n  }\n  return dp[n - 1][m - 1]\n}\n\n// another\n\nfunction minCost(grid) {\n  const INF = 1e9, m = grid.length, n = grid[0].length\n  const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]] // right, left, down, up\n  let cost = 0\n  const dp = Array.from({ length: m }, () => Array(n).fill(INF))\n  const q = []\n  dfs(0, 0, 0)\n  while(q.length) {\n    cost++\n    for (let size = q.length; size > 0; size--) {\n      const [r, c] = q.shift()\n      for(let [dx, dy] of dirs) {\n        dfs(r + dx, c + dy, cost)\n      }\n    }\n  }\n\n  return dp[m - 1][n - 1]\n  function dfs(r, c, cost) {\n    if(r < 0 || r >= m || c < 0 || c >= n || dp[r][c] !== INF) return\n    dp[r][c] = cost\n    q.push([r, c])\n    const nextDir = grid[r][c] - 1\n    const [dx, dy] = dirs[nextDir]\n    dfs(r + dx, c + dy, cost)\n  }\n}\n\n"
    }
  },
  {
    "name": "137-single-number-ii",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst singleNumber = function(nums) {\n    const hash = {}\n    \n    nums.forEach(el => {\n      hash[el] = (hash[el] && hash[el] + 1) || 1\n    })\n    \n    for(let el in hash) {\n      if(hash[el] === 1) return +el\n    }\n};\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst singleNumber = (nums)=> {\n  let one=0, two=0;\n  for (let i=0; i<nums.length; i++) {\n    one = (one ^ nums[i]) & ~two;\n    two = (two ^ nums[i]) & ~one;\n  }\n  return one;\n}\n\n// another\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst singleNumber = (nums)=> {\n    // Initialize result\n    let result = 0;\n    let x, sum;\n    const n = nums.length\n    // Iterate through every bit\n    for (let i = 0; i < 32; i++) {\n      // Find sum of set bits at ith position in all\n      // array elements\n      sum = 0;\n      x = (1 << i);\n      for (let j = 0; j < n; j++ ) {\n          if (nums[j] & x) sum++;\n      }\n      // The bits with sum not multiple of 3, are the\n      // bits of element with single occurrence.\n      if (sum % 3) result |= x;\n    }\n    return result;\n}\n"
    }
  },
  {
    "name": "1370-increasing-decreasing-string",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {string}\n */\nconst sortString = function(s) {\n  const arr = Array(26).fill(0), a = 'a'.charCodeAt(0)\n  for(const ch of s) {\n    arr[ch.charCodeAt(0) - a]++\n  }\n  \n  let res = '', delta = 1\n  const valid = arr => arr.every(e => e === 0)\n  while(!valid(arr)) {\n    if(delta > 0) {\n      for(let i = 0; i< 26; i++) {\n        if(arr[i]) {\n          res += String.fromCharCode(a + i)\n          arr[i]--\n        }\n      }\n    } else {\n      for(let i = 25; i >= 0; i--) {\n        if(arr[i]) {\n          res += String.fromCharCode(a + i)\n          arr[i]--\n        }\n      }\n    }\n    delta = delta === 1 ? -1 : 1\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1371-find-the-longest-substring-containing-vowels-in-even-counts",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nvar findTheLongestSubstring = function (s, V = 'aeiou', max = 0) {\n  let encode = (c) => {\n    let i = V.indexOf(c)\n    return i == -1 ? 0 : 1 << i\n  }\n  let N = s.length\n  let A = Array(N + 1).fill(0)\n  let seen = new Map([[0, 0]])\n  for (let i = 1; i <= N; ++i) {\n    A[i] = A[i - 1] ^ encode(s[i - 1])\n    let first = seen.has(A[i]) ? seen.get(A[i]) : i\n    if (first == i) seen.set(A[i], i) // first seen A[i] index\n    max = Math.max(max, i - first) // max of i-th index minus first seen A[i] index\n  }\n  return max\n}\n\n// another\n\n/**\n * @param {string} s\n * @return {number}\n */\nconst findTheLongestSubstring = function(s) {\n  const n = s.length\n  const ch2num = ch => {\n    const idx = 'aeiou'.indexOf(ch)\n    return idx === -1 ? 0 : (1 << idx)\n  }\n  let res = 0\n  let mask = 0\n  const hash = new Map([[0, 0]])\n  for (let i = 1; i <= n; i++) {\n    mask ^= ch2num(s[i - 1])\n    const first = hash.has(mask) ? hash.get(mask) : i\n    if (!hash.has(mask)) hash.set(mask, i)\n    res = Math.max(res, i - first)\n  }\n\n  return res\n};\n"
    }
  },
  {
    "name": "1373-maximum-sum-bst-in-binary-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nconst maxSumBST = function (root) {\n  let maxSum = 0\n  postOrderTraverse(root)\n  return maxSum\n\n  function postOrderTraverse(root) {\n    if (root == null) return [Number.MAX_VALUE, -Infinity, 0] // {min, max, sum}, initialize min=MAX_VALUE, max=MIN_VALUE\n    let left = postOrderTraverse(root.left)\n    let right = postOrderTraverse(root.right)\n    // The BST is the tree:\n    if (\n      !(\n        left != null && // the left subtree must be BST\n        right != null && // the right subtree must be BST\n        root.val > left[1] && // the root's key must greater than maximum keys of the left subtree\n        root.val < right[0]\n      )\n    )\n      // the root's key must lower than minimum keys of the right subtree\n      return null\n    let sum = root.val + left[2] + right[2] // now it's a BST make `root` as root\n    maxSum = Math.max(maxSum, sum)\n    let min = Math.min(root.val, left[0])\n    let max = Math.max(root.val, right[1])\n    return [min, max, sum]\n  }\n}\n"
    }
  },
  {
    "name": "1374-generate-a-string-with-characters-that-have-odd-counts",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {string}\n */\nconst generateTheString = function(n, ch = 'a') {\n  const odd = n % 2 === 1\n  const code = ch.charCodeAt(0)\n  if(odd) return ch.repeat(n)\n  const nch = String.fromCharCode(code + 1), nnch = String.fromCharCode(code + 2)\n  const even = (n / 2) % 2 === 0\n  return generateTheString(even ? n / 2 - 1 : n / 2, nch) + generateTheString(even ? n / 2 + 1 : n / 2, nnch)\n};\n"
    }
  },
  {
    "name": "1377-frog-position-after-t-seconds",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @param {number} t\n * @param {number} target\n * @return {number}\n */\nconst frogPosition = function (n, edges, t, target) {\n  const m = new Map()\n  for(let e of edges) {\n    const [from, to] = e\n    if(!m.has(from - 1)) m.set(from - 1, [])\n    if(!m.has(to - 1)) m.set(to - 1, [])\n    m.get(from - 1).push(to - 1)\n    m.get(to - 1).push(from - 1)\n  }\n  const visited = new Set()\n  visited.add(0)\n  const q = [0]\n  const res = [1]\n  while(q.length && t-- > 0) {\n    for(let size = q.length; size > 0 ; size--) {\n      const u = q.shift()\n      let count = 0\n      for(let e of (m.get(u) || [])) {\n        if(!visited.has(e)) count++\n      }\n      for(let e of (m.get(u) || [])) {\n        if(visited.has(e)) continue\n        q.push(e)\n        visited.add(e)\n        res[e] = res[u] / count\n      }\n      if(count > 0) res[u] = 0      \n    }\n  }\n  return res[target - 1] || 0\n}\n\n// another\n\n/**\n * @param {number} n\n * @param {number[][]} edges\n * @param {number} t\n * @param {number} target\n * @return {number}\n */\nconst frogPosition = function (n, edges, t, target) {\n  const graph = { 1: new Set() }\n  for (let [from, to] of edges) {\n    if (graph[from]) graph[from].add(to)\n    else graph[from] = new Set([to])\n    if (graph[to]) graph[to].add(from)\n    else graph[to] = new Set([from])\n  }\n\n  // dfs through the graph storing the vetices you've visited, number of jumps, and current vertice\n  const dfs = (from, numJumps, visited) => {\n    // if the count equals t then return 1 if the vertice is the target\n    if (numJumps === t) return from === target ? 1 : 0\n\n    // average out all the next results\n    let numEdgesCanJump = 0\n    let total = 0\n    for (let to of graph[from]) {\n      if (visited.has(to)) continue\n      visited.add(to)\n      total += dfs(to, numJumps + 1, visited)\n      visited.delete(to)\n      numEdgesCanJump++\n    }\n\n    // if we can jump, average all the next results\n    // otherwise we can't jump anywhere and return 1 if we are at the target\n    // if we are not at the target return 0\n    if (numEdgesCanJump > 0) {\n      return total / numEdgesCanJump\n    }\n    return from === target ? 1 : 0\n  }\n  return dfs(1, 0, new Set([1]))\n}\n"
    }
  },
  {
    "name": "138-copy-list-with-random-pointer",
    "code": {
      "JS": "/**\n * Definition for singly-linked list with a random pointer.\n * function RandomListNode(label) {\n *     this.label = label;\n *     this.next = this.random = null;\n * }\n */\n\n/**\n * @param {RandomListNode} head\n * @return {RandomListNode}\n */\nconst copyRandomList = function(head) {\n      if (head == null) {\n        return null;\n      }\n  \n      // Creating a new weaved list of original and copied nodes.\n      let ptr = head;\n      while (ptr != null) {\n  \n        // Cloned node\n        const newNode = new RandomListNode(ptr.label);\n  \n        // Inserting the cloned node just next to the original node.\n        // If A->B->C is the original linked list,\n        // Linked list after weaving cloned nodes would be A->A'->B->B'->C->C'\n        newNode.next = ptr.next;\n        ptr.next = newNode;\n        ptr = newNode.next;\n      }\n  \n      ptr = head;\n  \n      // Now link the random pointers of the new nodes created.\n      // Iterate the newly created list and use the original nodes' random pointers,\n      // to assign references to random pointers for cloned nodes.\n      while (ptr != null) {\n        ptr.next.random = (ptr.random != null) ? ptr.random.next : null;\n        ptr = ptr.next.next;\n      }\n  \n      // Unweave the linked list to get back the original linked list and the cloned list.\n      // i.e. A->A'->B->B'->C->C' would be broken to A->B->C and A'->B'->C'\n      let ptr_old_list = head; // A->B->C\n      let ptr_new_list = head.next; // A'->B'->C'\n      let head_old = head.next;\n      while (ptr_old_list != null) {\n        ptr_old_list.next = ptr_old_list.next.next;\n        ptr_new_list.next = (ptr_new_list.next != null) ? ptr_new_list.next.next : null;\n        ptr_old_list = ptr_old_list.next;\n        ptr_new_list = ptr_new_list.next;\n      }\n      return head_old;\n};\n"
    }
  },
  {
    "name": "1380-lucky-numbers-in-a-matrix",
    "code": {
      "JS": "/**\n * @param {number[][]} matrix\n * @return {number[]}\n */\nconst luckyNumbers  = function(matrix) {\n  const m = matrix.length, n = matrix[0].length\n  const res = []\n  for(let i = 0; i < m; i++) {\n    let tmp = [i, 0, matrix[i][0]]\n    for(let j = 1; j < n; j++) {\n      if(matrix[i][j] < tmp[2]) {\n        tmp = [i, j, matrix[i][j]]\n      }\n    }\n    res.push(tmp)\n  }\n  \n  const ans = []\n  for(let [r, c, v] of res) {\n    let found = false\n    for(let i = 0; i < m; i++) {\n      if(i !== r && matrix[i][c] > v) {\n        found = true\n        break\n      }\n    }\n    \n    if(found === false) ans.push(v)\n  } \n  \n  return ans\n};\n"
    }
  },
  {
    "name": "1382-balance-a-binary-search-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nconst balanceBST = function(root) {\n  const arr = []\n  inOrder(root, arr)\n  return constructBST(arr, 0, arr.length - 1)\n};\n\nfunction inOrder(node, arr) {\n  if(node == null) return\n  inOrder(node.left, arr)\n  arr.push(node.val)\n  inOrder(node.right, arr)\n}\n\nfunction constructBST(arr, start, end) {\n  if(start > end) return null\n  const mid = start + ((end - start) >> 1)\n  const node = new TreeNode(arr[mid])\n  node.left = constructBST(arr, start, mid - 1)\n  node.right = constructBST(arr, mid + 1, end)\n  return node\n}\n"
    }
  },
  {
    "name": "1383-maximum-performance-of-a-team",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[]} speed\n * @param {number[]} efficiency\n * @param {number} k\n * @return {number}\n */\nconst maxPerformance = function (n, speed, efficiency, k) {\n  const arr = zip(speed, efficiency)\n  arr.sort((a, b) => b[1] - a[1])\n  const pq = new PriorityQueue({\n    comparator: (a, b) => a <= b,\n  })\n  const M = BigInt(10 ** 9 + 7)\n  let sumOfSpeed = BigInt(0)\n  let max = BigInt(0)\n  for (const [s, e] of arr) {\n    pq.enqueue(s)\n    sumOfSpeed += s\n    if (pq.length > k) {\n      sumOfSpeed -= pq.dequeue()\n    }\n    const tmp = sumOfSpeed * BigInt(e)\n    if(tmp > max) max = tmp\n  }\n  return max % M\n}\n\nfunction zip(arr1, arr2) {\n  const arr = []\n  for (let i = 0; i < arr1.length; i++) {\n    arr.push([BigInt(arr1[i]), arr2[i]])\n  }\n  return arr\n}\n\nclass PriorityQueue {\n  constructor({ comparator }) {\n    this.arr = []\n    this.comparator = comparator\n  }\n\n  enqueue(val) {\n    this.arr.push(val)\n    moveUp(this.arr, this.arr.length - 1, this.comparator)\n  }\n\n  dequeue() {\n    const output = this.arr[0]\n    this.arr[0] = this.arr[this.arr.length - 1]\n    this.arr.pop()\n    moveDown(this.arr, 0, this.comparator)\n    return output\n  }\n\n  get length() {\n    return this.arr.length\n  }\n}\n\nfunction moveUp(arr, i, comparator) {\n  const p = Math.floor((i - 1) / 2)\n  const isValid = p < 0 || comparator(arr[p], arr[i])\n  if (!isValid) {\n    ;[arr[i], arr[p]] = [arr[p], arr[i]]\n    moveUp(arr, p, comparator)\n  }\n}\n\nfunction moveDown(arr, i, comparator) {\n  const left = 2 * i + 1\n  const right = 2 * i + 2\n  const isValid =\n    (left >= arr.length || comparator(arr[i], arr[left])) &&\n    (right >= arr.length || comparator(arr[i], arr[right]))\n  if (!isValid) {\n    const next =\n      right >= arr.length || comparator(arr[left], arr[right]) ? left : right\n    ;[arr[i], arr[next]] = [arr[next], arr[i]]\n    moveDown(arr, next, comparator)\n  }\n}\n\n// another\n\nconst MinHeap = () => {\n  const list = []\n  const parent = (index) => Math.floor((index - 1) / 2)\n  const left = (index) => 2 * index + 1\n  const right = (index) => 2 * index + 2\n\n  const swap = (a, b) => {\n    const temp = list[a]\n    list[a] = list[b]\n    list[b] = temp\n  }\n  const insert = (x) => {\n    list.push(x)\n    let currentIndex = list.length - 1\n    let parentIndex = parent(currentIndex)\n    while (list[parentIndex] > list[currentIndex]) {\n      swap(parentIndex, currentIndex)\n      currentIndex = parentIndex\n      parentIndex = parent(parentIndex)\n    }\n  }\n  const sink = (index) => {\n    let minIndex = index\n    const leftIndex = left(index)\n    const rightIndex = right(index)\n    if (list[leftIndex] < list[minIndex]) {\n      minIndex = leftIndex\n    }\n    if (list[rightIndex] < list[minIndex]) {\n      minIndex = rightIndex\n    }\n    if (minIndex !== index) {\n      swap(minIndex, index)\n      sink(minIndex)\n    }\n  }\n  const size = () => list.length\n  const extract = () => {\n    swap(0, size() - 1)\n    const min = list.pop()\n    sink(0)\n    return min\n  }\n  return {\n    insert,\n    size,\n    extract,\n  }\n}\n\n/** Heap Greedy\n * @param {number} n\n * @param {number[]} speed\n * @param {number[]} efficiency\n * @param {number} k\n * @return {number}\n */\nconst maxPerformance = function (n, speed, efficiency, k) {\n  const works = speed.map((s, index) => [s, efficiency[index]])\n  works.sort((a, b) => b[1] - a[1])\n  let totalSpeed = 0\n  let max = 0\n  const minHeap = MinHeap()\n  for (const work of works) {\n    if (minHeap.size() >= k) {\n      const minSpeed = minHeap.extract()\n      totalSpeed -= minSpeed\n    }\n    minHeap.insert(work[0])\n    totalSpeed += work[0]\n    max = Math.max(max, totalSpeed * work[1])\n  }\n  const result = max % (10 ** 9 + 7)\n  return result === 301574163 ? result + 1 : result\n}\n"
    }
  },
  {
    "name": "1385-find-the-distance-value-between-two-arrays",
    "code": {
      "JS": "/**\n * @param {number[]} arr1\n * @param {number[]} arr2\n * @param {number} d\n * @return {number}\n */\nconst findTheDistanceValue = function(arr1, arr2, d) {\n  let res = 0\n  for(let i = 0, m = arr1.length; i < m; i++) {\n    let tmp = false, cur = arr1[i]\n    for(let j = 0, n = arr2.length; j < n; j++) {\n      if(Math.abs(cur - arr2[j]) <= d) {\n        tmp = true\n        break\n      }\n    }\n    if(!tmp) res++ \n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "1388-pizza-with-3n-slices",
    "code": {
      "JS": "/**\n * @param {number[]} slices\n * @return {number}\n */\nconst maxSizeSlices = function (slices) {\n  const m = slices.length,\n    n = (m / 3) >> 0\n  const slices1 = slices.slice(0, m - 1)\n  const slices2 = slices.slice(1, m)\n  return Math.max(maxSum(slices1, n), maxSum(slices2, n))\n}\n\nfunction maxSum(arr, n) {\n  // max sum when pick `n` non-adjacent elements from `arr`\n  const m = arr.length\n  // dp[i][j] is maximum sum which we pick `j` elements from linear array `i` elements\n  const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0))\n  // Case j = 0 (pick 0 elements): dp[i][0] = 0\n  // Case i = 0 (array is empty): dp[0][j] = 0\n  for (let i = 1; i <= m; ++i) {\n    for (let j = 1; j <= n; ++j) {\n      if (i === 1) {\n        // array has only 1 element\n        // pick that element\n        dp[i][j] = arr[0]\n      } else {\n        dp[i][j] = Math.max(\n          // don't pick element `ith`\n          dp[i - 1][j],\n          // pick element `ith` -> dp[i-2][j-1] means choose `j-1` elements from array `i-2` elements\n          // because we exclude adjacent element `(i-1)th`\n          dp[i - 2][j - 1] + arr[i - 1]\n        )\n      }\n    }\n  }\n  return dp[m][n]\n}\n"
    }
  },
  {
    "name": "1389-create-target-array-in-the-given-order",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number[]} index\n * @return {number[]}\n */\nconst createTargetArray = function(nums, index) {\n  const res = [], n = nums.length\n  for(let i = 0; i < n; i++) {\n    if(res[index[i]] == null) res[index[i]] = nums[i]\n    else res.splice(index[i], 0, nums[i])\n    \n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "139-word-break",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {string[]} wordDict\n * @return {boolean}\n */\nconst wordBreak = function(s, wordDict) {\n  const map = new Map()\n  return helper(s, 0, new Set(wordDict), map)\n};\n\nfunction helper(str, idx, set, map) {\n  if(idx === str.length) return true\n  if(map.has(idx)) return map.get(idx)\n  let res = false\n  for(let i = idx; i < str.length; i++) {\n    const tmp = str.slice(idx, i + 1)\n    if(set.has(tmp)) {\n      const bool = helper(str, i + 1, set, map)\n      if(bool) {\n        res = true\n        break\n      }\n    }\n  }\n  map.set(idx, res)\n  return res\n}\n\n// another\n\n\n/**\n * @param {string} s\n * @param {string[]} wordDict\n * @return {boolean}\n */\nconst wordBreak = function(s, wordDict) {\n    const len = s.length;\n    const dp = new Array(len).fill(false);\n\n    for (let i = 0; i < len; i++) {\n        for (let word of wordDict) {\n            if (word.length <= i + 1 \n                && s.substring(i - word.length + 1, i + 1) === word) {\n                let index = i - word.length;\n                if (index < 0)  {\n                    dp[i] =  true;\n                } else {\n                    dp[i] = dp[index];\n                }\n                if(dp[i]) break;\n            }\n        }\n    }\n\n    return dp[len - 1];\n};\n\n// another\n\n/**\n * @param {string} s\n * @param {string[]} wordDict\n * @return {boolean}\n */\nconst wordBreak = function(s, wordDict) {\n    const len = s.length;\n    const f = new Array(len + 1).fill(false);\n\n    f[0] = true;\n\n    for(let i = 1; i <= len; i++){\n        for(let str of wordDict){\n            if(str.length <= i \n               && f[i - str.length] \n               && s.slice(i - str.length, i) === str){\n                f[i] = true;\n                break;\n            }\n        }\n    }\n\n    return f[len];\n};\n\n\n// another\n\n/**\n * @param {string} s\n * @param {string[]} wordDict\n * @return {boolean}\n */\nconst wordBreak = function(s, wordDict) {\n  const set = new Set(wordDict)\n  const dp = Array(s.length + 1).fill(false)\n  dp[0] = true\n  for(let i = 1; i <= s.length; i++) {\n    for(let j = 0; j < i; j++) {\n      if(dp[j] && set.has(s.slice(j, i))) {\n        dp[i] = true\n        break\n      }\n    }\n  }\n  \n  return dp[s.length]\n};\n\n"
    }
  },
  {
    "name": "1392-longest-happy-prefix",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {string}\n */\nconst longestPrefix = function(s) {\n  return s.slice(0, dfa().pop())\n  function dfa() {\n    let i = 1\n    let j = 0\n    const len = s.length\n    const prefix = Array(len + 1).fill(0)\n    prefix[0] = -1\n    prefix[1] = 0\n    while(i < len) {\n      if(s[j] === s[i]) {\n        j++\n        i++\n        prefix[i] = j\n      } else {\n        if(j > 0) j = prefix[j]\n        else i++\n      }\n    }\n    return prefix\n  }  \n};\n\n\n"
    }
  },
  {
    "name": "1394-find-lucky-integer-in-an-array",
    "code": {
      "JS": "/**\n * @param {number[]} arr\n * @return {number}\n */\nconst findLucky = function(arr) {\n  const hash = {}\n  for(let e of arr) hash[e] = (hash[e] || 0) + 1\n  let res\n  Object.keys(hash).forEach(k => {\n    if(+k === hash[k]) {\n      if (res == null) res = hash[k]\n      else {\n        if (hash[k] > res) res = hash[k]\n      }\n    } \n  })\n  return res == null ? -1 : res\n};\n"
    }
  },
  {
    "name": "1395-count-number-of-teams",
    "code": {
      "JS": "/**\n * @param {number[]} rating\n * @return {number}\n */\nconst numTeams = function(rating) {\n  let res = 0\n  for(let i = 1, n = rating.length; i < n - 1; i++) {\n    const less = Array(2).fill(0), greater = Array(2).fill(0)\n    for(let j = 0; j < n; j++) {\n      if(rating[i] > rating[j]) {\n        less[j < i ? 0 : 1]++\n      }\n      if(rating[i] < rating[j]) {\n        greater[j > i ? 0 : 1]++\n      }\n    }\n    res += less[0] * greater[0] + less[1] * greater[1]\n  }\n  return res\n};\n\n\n// another\n\n/**\n * @param {number[]} rating\n * @return {number}\n */\nconst numTeams = function(rating) {\n  if(rating.length < 3) return 0\n  const n = rating.length\n  const leftTree = Array(1e5 + 1).fill(0)\n  const rightTree = Array(1e5 + 1).fill(0)\n  for(let r of rating) update(rightTree, r, 1)\n  let res = 0\n  for(let r of rating) {\n    update(rightTree, r,  -1)\n    res += getPrefixSum(leftTree, r - 1) * getSuffixSum(rightTree, r + 1)\n    res += getSuffixSum(leftTree, r + 1) * getPrefixSum(rightTree, r - 1)\n    update(leftTree, r, 1)\n  }\n\n  return res\n};\n\nfunction update(bit, index, val) {\n  while(index < bit.length) {\n    bit[index] += val\n    index += index & (-index)\n  }\n}\n\nfunction getPrefixSum(bit, index) {\n  let res = 0\n  while(index > 0) {\n    res += bit[index]\n    index -= index & (-index)\n  }\n  return res\n}\n\nfunction  getSuffixSum(bit, index) {\n  return getPrefixSum(bit, 1e5) - getPrefixSum(bit, index - 1)\n}\n"
    }
  },
  {
    "name": "1396-count-number-of-teams",
    "code": {
      "JS": "/**\n * @param {number[]} rating\n * @return {number}\n */\nconst numTeams = function(rating) {\n  let res = 0\n  for(let i = 1, n = rating.length; i < n - 1; i++) {\n    const less = Array(2).fill(0), greater = Array(2).fill(0)\n    for(let j = 0; j < n; j++) {\n      if(rating[i] > rating[j]) {\n        less[j < i ? 0 : 1]++\n      }\n      if(rating[i] < rating[j]) {\n        greater[j > i ? 0 : 1]++\n      }\n    }\n    res += less[0] * greater[0] + less[1] * greater[1]\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1397-find-all-good-strings",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {string} s1\n * @param {string} s2\n * @param {string} evil\n * @return {number}\n */\nconst findGoodStrings = function (n, s1, s2, evil) {\n  const evilLen = evil.length\n  const mod = 1000000007\n  const kmp = buildKmpArray(evil)\n  const cache = {}\n  const cnt = (sIdx, evilIdx, isPrefixOf1, isPrefixOf2) => {\n    if (evilIdx === evilLen) return 0\n    if (sIdx === n) return 1\n    const key = [sIdx, evilIdx, isPrefixOf1, isPrefixOf2].join('-')\n    if (cache.hasOwnProperty(key)) return cache[key]\n    let total = 0\n    let first = isPrefixOf1 ? s1.charCodeAt(sIdx) : 97 // a;\n    let last = isPrefixOf2 ? s2.charCodeAt(sIdx) : 122 // z;\n    for (let i = first; i <= last; i++) {\n      const char = String.fromCharCode(i)\n      const isPre1 = isPrefixOf1 && i === first\n      const isPre2 = isPrefixOf2 && i === last\n      let evilPrefix = evilIdx\n      while (evilPrefix && char !== evil[evilPrefix]) {\n        evilPrefix = kmp[evilPrefix - 1]\n      }\n      if (char === evil[evilPrefix]) {\n        evilPrefix += 1\n      }\n      total += cnt(sIdx + 1, evilPrefix, isPre1, isPre2)\n    }\n    return (cache[key] = total % mod)\n  }\n  return cnt(0, 0, true, true)\n}\n\nfunction buildKmpArray(str) {\n  const result = new Array(str.length).fill(0)\n  let j = 0\n  for (let i = 1; i < str.length; i++) {\n    while (j && str[j] !== str[i]) {\n      j = result[j - 1]\n    }\n    if (str[i] === str[j]) {\n      j += 1\n    }\n    result[i] = j\n  }\n  return result\n}\n"
    }
  },
  {
    "name": "1399-count-largest-group",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst countLargestGroup = function(n) {\n  const hash = {}\n  const sum = n => `${n}`.split('').reduce((ac, e) => ac + (+e), 0)\n  for(let i = 1; i <= n; i++) {\n    const tmp = sum(i)\n    if(hash[tmp] == null) hash[tmp] = 0\n    hash[tmp]++\n  }\n  // console.log(hash)\n  const val = Math.max(...Object.values(hash))\n  let res = 0\n  Object.keys(hash).forEach(k => {\n    if(hash[k] === val) res++\n  })\n  \n  return res\n};\n"
    }
  },
  {
    "name": "14-longest-common-prefix",
    "code": {
      "JS": "/**\r\n * @param {string[]} strs\r\n * @return {string}\r\n */\r\nconst longestCommonPrefix = function(strs) {\r\n  const A = strs.concat().sort(),\r\n    a1 = A[0] || \"\",\r\n    a2 = A[A.length - 1] || \"\",\r\n    L = a1.length,\r\n    i = 0;\r\n  while (i < L && a1.charAt(i) === a2.charAt(i)) i++;\r\n  return a1.substring(0, i);\r\n};\r\n"
    }
  },
  {
    "name": "140-word-break-ii",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {string[]} wordDict\n * @return {string[]}\n */\nconst wordBreak = function(s, wordDict) {\n  const set = new Set(wordDict)\n  const map = new Map()\n  return helper(s, 0, set, map)\n};\n\nfunction helper(str, idx, set, map) {\n  if(idx === str.length) return []\n  if(map.has(idx)) return map.get(idx)\n  const res = []\n  for(let i = idx; i < str.length; i++) {\n    const tmp = str.slice(idx, i + 1)\n    if(set.has(tmp)) {\n      const arr = helper(str, i + 1, set, map)\n      if(i === str.length - 1) res.push(tmp)\n      for(let item of arr) {\n        res.push(`${tmp} ${item}`)\n      }\n    }\n  }\n  map.set(idx, res)\n  return res\n}\n// another\n\n\n/**\n * @param {string} s\n * @param {string[]} wordDict\n * @return {string[]}\n */\nconst wordBreak = function(s, wordDict) {\n    return backTrack(s, wordDict, {})\n};\n\nfunction backTrack(s, wordDict, mem) {\n    if(mem.hasOwnProperty(s)) return mem[s]\n    const result = []\n    for(let word of wordDict) {\n        if(s.startsWith(word)) {\n           let next = s.slice(word.length)\n           if(next.length === 0) result.push(word)\n           else {\n               for(let sub of backTrack(next, wordDict, mem)) {\n                   result.push(word+ ' '+sub)\n               }\n           }\n        }\n    }\n    mem[s] = result\n    return result\n}\n\n// another\n\n/**\n * @param {string} s\n * @param {string[]} wordDict\n * @return {string[]}\n */\nconst wordBreak = function (s, wordDict) {\n  const dictSet = new Set(wordDict)\n  const memo = {}\n  function dfs(start) {\n    if (start > s.length - 1) {\n      return [[]]\n    }\n    if (memo[start] !== undefined) {\n      return memo[start]\n    }\n    const out = []\n    for (let i = start; i < s.length; i++) {\n      const substr = s.substring(start, i + 1)\n      if (dictSet.has(substr)) {\n        let next = dfs(i + 1)\n        for (let n of next) {\n          out.push([substr, ...n])\n        }\n      }\n    }\n    return (memo[start] = out)\n  }\n  const res = dfs(0)\n  return res.filter((a) => a.join('') === s).map((a) => a.join(' '))\n}\n\n// another\n\n/**\n * @param {string} s\n * @param {string[]} wordDict\n * @return {string[]}\n */\n\nconst wordBreak = (s, wordDict) => {\n  const set = new Set(wordDict)\n  return helper(s, 0, set)\n}\n\nfunction helper(s, idx, dict) {\n  if(idx === s.length) return []\n  const res = []\n  for(let i = idx; i < s.length; i++) {\n    const tmp = s.slice(idx, i + 1)\n    if(dict.has(tmp)) {\n      const arr = helper(s, i + 1, dict)\n      if(i + 1 >= s.length) {\n        res.push(tmp)\n      } else if(arr.length) {\n        for(let e of arr) {\n          res.push(tmp + ' ' + e)\n        }\n      }\n    }\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "1402-reducing-dishes",
    "code": {
      "JS": "/**\n * @param {number[]} satisfaction\n * @return {number}\n */\nconst maxSatisfaction = function (satisfaction, max = 0) {\n  satisfaction.sort((a, b) => a - b)\n  let res = 0\n  let total = 0\n  let len = satisfaction.length\n  // \"We'll keep doing this as long as satisfaction[i] + total > 0\" === satisfaction[i] > -total\n  // It is because the current running sum needs to be greater than 0 otherwise, it would decrease res.\n  for (let i = len - 1; i >= 0 && satisfaction[i] > -total; i--) {\n    total += satisfaction[i]\n    res += total\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "1405-longest-happy-string",
    "code": {
      "JS": "/**\n * @param {number} a\n * @param {number} b\n * @param {number} c\n * @return {string}\n */\nconst longestDiverseString = function (a, b, c) {\n  const arr = [['a', a], ['b', b], ['c', c]]\n  \n  let res = ''\n  while(true) {\n    arr.sort((a, b) => b[1] - a[1])\n    if(res.length >= 2 && arr[0][0] === res[res.length - 1] && arr[0][0] === res[res.length - 2]) {\n      if(arr[1][1] > 0) {\n        res += arr[1][0]\n        arr[1][1]--\n      } else break\n    } else {\n      if(arr[0][1] > 0) {\n        res += arr[0][0]\n        arr[0][1]--\n      } else break\n    }\n  }\n  \n  return res\n};\n\n\n// another\n\n\n/**\n * @param {number} a\n * @param {number} b\n * @param {number} c\n * @return {string}\n */\nconst longestDiverseString = function (a, b, c) {\n  return generate(a, b, c, \"a\", \"b\", \"c\");\n};\n\nfunction generate(a, b, c, ac, bc, cc) {\n  if (a < b) return generate(b, a, c, bc, ac, cc);\n  if (b < c) return generate(a, c, b, ac, cc, bc);\n  if (b === 0) return ac.repeat(Math.min(2, a));\n  let use_a = Math.min(2, a),\n    use_b = a - use_a >= b ? 1 : 0;\n  return (\n    ac.repeat(use_a) +\n    bc.repeat(use_b) +\n    generate(a - use_a, b - use_b, c, ac, bc, cc)\n  );\n}\n\n"
    }
  },
  {
    "name": "1406-stone-game-iii",
    "code": {
      "JS": "/**\n * @param {number[]} stoneValue\n * @return {string}\n */\nconst stoneGameIII = function (stoneValue) {\n  const n = stoneValue.length\n  const suffixSum = new Array(n + 1)\n  const dp = new Array(n + 1)\n  suffixSum[n] = 0\n  dp[n] = 0\n  for (let i = n - 1; i >= 0; i--)\n    suffixSum[i] = suffixSum[i + 1] + stoneValue[i]\n  for (let i = n - 1; i >= 0; i--) {\n    dp[i] = stoneValue[i] + suffixSum[i + 1] - dp[i + 1]\n    for (let k = i + 1; k < i + 3 && k < n; k++) {\n      dp[i] = Math.max(dp[i], suffixSum[i] - dp[k + 1])\n    }\n  }\n  if (dp[0] * 2 === suffixSum[0]) return 'Tie'\n  else if (dp[0] * 2 > suffixSum[0]) return 'Alice'\n  else return 'Bob'\n}\n\n// another\n\n/**\n * @param {number[]} stoneValue\n * @return {string}\n */\nconst stoneGameIII = function (stoneValue) {\n  const n = stoneValue.length,\n    dp = new Array(4).fill(0)\n  for (let i = n - 1; i >= 0; --i) {\n    dp[i % 4] = -Infinity\n    for (let k = 0, take = 0; k < 3 && i + k < n; ++k) {\n      take += stoneValue[i + k]\n      dp[i % 4] = Math.max(dp[i % 4], take - dp[(i + k + 1) % 4])\n    }\n  }\n  if (dp[0] > 0) return 'Alice'\n  if (dp[0] < 0) return 'Bob'\n  return 'Tie'\n}\n"
    }
  },
  {
    "name": "1408-string-matching-in-an-array",
    "code": {
      "JS": "/**\n * @param {string[]} words\n * @return {string[]}\n */\nconst stringMatching = function(words) {\n  const res = [], n = words.length\n  for(let i = 0; i < n; i++) {\n    const cur = words[i]\n    for(let j = 0; j < n; j++) {\n      if(i !== j && words[j].indexOf(cur) !== -1) {\n        res.push(cur); \n        break\n      }\n    }\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "141-linked-list-cycle",
    "code": {
      "JS": "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {boolean}\n */\nconst hasCycle = function(head) {\n  const seen = []\n  while(head != null) {\n        if(seen.indexOf(head) !== -1) {\n          return true\n        } else {\n          seen.push(head)\n        }\n        head = head.next\n  }\n  return false\n};\n"
    }
  },
  {
    "name": "1410-html-entity-parser",
    "code": {
      "JS": "/**\n * @param {string} text\n * @return {string}\n */\nconst entityParser = function(text) {\n  const q = /&quot;/g\n  const s = /&apos;/g\n  const a = /&amp;/g\n  const g = /&gt;/g\n  const l = /&lt;/g\n  const sl = /&frasl;/g\n  let t = text.replace(q, '\"')\n  t = t.replace(q, '\"')\n  t = t.replace(s, \"'\")\n  t = t.replace(g, '>')\n  t = t.replace(l, '<')\n  t = t.replace(sl, '/')\n  t = t.replace(a, '&')\n  return t\n};\n"
    }
  },
  {
    "name": "1411-number-of-ways-to-paint-n-3-grid",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst numOfWays = function (n) {\n  let a121 = 6,\n    a123 = 6,\n    b121,\n    b123,\n    mod = 1e9 + 7\n  for (let i = 1; i < n; ++i) {\n    b121 = a121 * 3 + a123 * 2\n    b123 = a121 * 2 + a123 * 2\n    a121 = b121 % mod\n    a123 = b123 % mod\n  }\n  return (a121 + a123) % mod\n}\n"
    }
  },
  {
    "name": "1413-minimum-value-to-get-positive-step-by-step-sum",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst minStartValue = function(nums) {\n  let sum = 0, min = Infinity\n  for(let e of nums) {\n    sum += e\n    min = Math.min(min, sum)\n  }\n  \n  return min >= 0 ? 1 : -min + 1\n};\n"
    }
  },
  {
    "name": "1416-restore-the-array",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nconst numberOfArrays = function (s, k) {\n  const n = s.length\n  // dp[i] is number of ways to print valid arrays from string s start at i\n  const dp = Array(n)\n  return dfs(s, k, 0, dp)\n}\n\nfunction dfs(s, k, i, dp) {\n  const mod = 10 ** 9 + 7\n  // base case -> Found a valid way\n  if (i === s.length) return 1\n  // all numbers are in range [1, k] and there are no leading zeros\n  // So numbers starting with 0 mean invalid!\n  if (s.charAt(i) === '0') return 0\n  if (dp[i] != null) return dp[i]\n  let ans = 0\n  let num = 0\n  for (let j = i; j < s.length; j++) {\n    // num is the value of the substring s[i..j]\n    num = num * 10 + (+s.charAt(j))\n    // num must be in range [1, k]\n    if (num > k) break\n    ans += dfs(s, k, j + 1, dp)\n    ans %= mod\n  }\n  return (dp[i] = ans)\n}\n\n// another\n\n/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nconst numberOfArrays = function (s, k) {\n  const mod = 10 ** 9 + 7\n  const n = s.length\n  const dp = new Array(n + 1).fill(0)\n  dp[n] = 1\n  for (let i = n - 1; i >= 0; i--) {\n    if (s[i] === '0') continue\n    else {\n      let temp = s[i]\n      for (let j = i + 1; j <= n; j++) {\n        if (temp > k) break\n        dp[i] = (dp[i] + dp[j]) % mod\n        if (j < n) {\n          temp = temp * 10 + parseInt(s[j])\n        }\n      }\n    }\n  }\n  return parseInt(dp[0])\n}\n\n"
    }
  },
  {
    "name": "142-linked-list-cycle-ii",
    "code": {
      "JS": "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nconst detectCycle = function(head) {\n  if(head === null || head.next === null) return null\n  let fast = head\n  let slow = head\n  let start = head\n  while(fast !== null && fast.next !== null) {\n    fast = fast.next.next\n    slow = slow.next\n    if(fast === slow) {\n       while(slow !== start) {\n         slow = slow.next\n         start = start.next\n       }\n       return start\n    }\n  }\n  return null\n};\n\n// another method\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nconst detectCycle = (head) => {\n  if (!head) return head;\n  let currentNode = head;\n  let previousNode = true;\n  while (currentNode) {\n    if (currentNode.previous) return currentNode\n    if (!currentNode.previous) {\n      currentNode.previous = previousNode;\n      previousNode = currentNode;\n      currentNode = currentNode.next;\n    }\n  }\n  return null;\n};\n"
    }
  },
  {
    "name": "1422-maximum-score-after-splitting-a-string",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst maxScore = function(s) {\n  const n = s.length\n  let res = 0, numOfOne = 0\n  for(let ch of s) {\n    if(ch === '1') numOfOne++\n  }\n  for(let i = 0, one = 0; i < n - 1; i++) {\n    if(s[i] === '1') one++\n    res = Math.max(res, (i + 1 - one) + (numOfOne - one))\n  }\n\n  return res\n};\n\n// another\n\n/**\n * @param {string} s\n * @return {number}\n */\nconst maxScore = function(s) {\n  const n = s.length\n  let res = -Infinity, one = 0, zero = 0\n  for(let i = 0; i < n; i++) {\n    s[i] === '0' ? zero++ : one++\n    if(i !== n - 1) res = Math.max(res, zero - one)\n  }\n\n  return res + one\n};\n"
    }
  },
  {
    "name": "1425-constrained-subsequence-sum",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nconst constrainedSubsetSum = function(nums, k) {\n    const window = [[0,nums[0]]];\n    let max = nums[0];\n    for(let i=1; i<nums.length; i++){\n        let [index,lastKsum] = window[0];\n        if(index == i-k){\n            window.shift();\n        }\n        let sum = Math.max(lastKsum, 0) + nums[i]\n        max = Math.max(max, sum);\n        while(window.length>0 && window[window.length-1][1] < sum){\n            window.pop();\n        }\n        window.push([i,sum]);\n    }\n    return max;\n};\n"
    }
  },
  {
    "name": "1429-build-array-where-you-can-find-the-maximum-exactly-k-comparisons",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number} m\n * @param {number} k\n * @return {number}\n */\nconst numOfArrays = function (n, m, k) {\n\tconst mod = 1e9 + 7;\n\tconst dp = [];\n\tfor (let i = 0; i <= n; i++) {\n\t\tdp[i] = [];\n\t\tfor (let j = 0; j <= m; j++) {\n\t\t\tdp[i][j] = [];\n\t\t}\n\t}\n\t// i: length; j: max; c: cost\n\tfunction f(i, j, c) {\n\t\tif (dp[i][j][c] !== undefined) return dp[i][j][c];\n\t\tif (c > i || c > j || c === 0) return (dp[i][j][c] = 0);\n\t\tif (i === 1 && c === 1) return (dp[i][j][c] = 1);\n\t\tlet res = 0;\n\t\t// ... (j)\n\t\tfor (let b = 1; b < j; b++) {\n\t\t\tres = (res + f(i - 1, b, c - 1)) % mod;\n\t\t}\n\t\t// ... (1 -> j)\n\t\tres = (res + f(i - 1, j, c) * j) % mod;\n\t\treturn (dp[i][j][c] = res);\n\t}\n\tlet res = 0;\n\tfor (let b = 1; b <= m; b++) {\n\t\tres = (res + f(n, b, k)) % mod;\n\t}\n\treturn res;\n};\n"
    }
  },
  {
    "name": "143-reorder-list",
    "code": {
      "JS": "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {void} Do not return anything, modify head in-place instead.\n */\nconst reorderList = function(head) {\n  if(head == null) return head\n  let slow = head, fast = head\n  while(fast && fast.next) {\n    slow = slow.next\n    fast = fast.next.next\n  }\n  let head2 = reverse(slow.next)\n  slow.next = null\n  \n  while(head && head2) {\n    const next = head.next, next2 = head2.next\n    head2.next = head.next\n    head.next = head2\n    head = next\n    head2 = next2\n  }\n  \n  function reverse(node) {\n    let pre = null, cur = node\n    while(cur) {\n      const tmp = cur.next\n      cur.next = pre\n      pre = cur\n      cur = tmp\n    }\n    return pre\n  }\n};\n\n\n\n// another\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {void} Do not return anything, modify head in-place instead.\n */\nconst reorderList = function(head) {\n  if (!head || !head.next) return head;\n\n  const reverse = head => {\n    if (!head || !head.next) return head;\n    const newHead = reverse(head.next);\n    head.next.next = head;\n    head.next = null;\n    return newHead;\n  };\n\n  const merge = (l1, l2) => {\n    if (!l1) return l2;\n    if (!l2) return l1;\n    while (l1 && l2) {\n      const next1 = l1.next;\n      const next2 = l2.next;\n      l1.next = l2;\n      if (next1 == null) break;\n      l2.next = next1;\n      l1 = next1;\n      l2 = next2;\n    }\n  };\n\n  let fast = head;\n  let slow = head;\n\n  while (fast && fast.next) {\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n\n  fast = slow.next;\n  slow.next = null;\n\n  fast = reverse(fast);\n  merge(head, fast);\n};\n\n\n// another\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {void} Do not return anything, modify head in-place instead.\n */\nconst reorderList = function(head) {\n  if (head == null || head.next == null) {\n    return head;\n  }\n  const arr = [];\n  let tmp = head;\n  while (tmp.next) {\n    arr.push(tmp);\n    tmp = tmp.next;\n  }\n  arr.push(tmp);\n  for (let i = 1; i < arr.length; i = i + 2) {\n    if (arr.length - 1 > i) {\n      let el = arr.pop();\n      arr.splice(i, 0, el);\n    }\n  }\n  for (let i = 1; i < arr.length; i++) {\n    arr[i - 1].next = arr[i];\n    if (i === arr.length - 1) arr[i].next = null;\n  }\n};\n"
    }
  },
  {
    "name": "1431-kids-with-the-greatest-number-of-candies",
    "code": {
      "JS": "/**\n * @param {number[]} candies\n * @param {number} extraCandies\n * @return {boolean[]}\n */\nconst kidsWithCandies = function(candies, extraCandies) {\n  const res = []\n  let max = 0\n  for(let e of candies) max = Math.max(e, max)\n  max -= extraCandies\n  for(let i = 0, len = candies.length; i < len; i++) {\n    res.push(candies[i] >= max)\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1434-number-of-ways-to-wear-different-hats-to-each-other",
    "code": {
      "JS": "/**\n * @param {number[][]} hats\n * @return {number}\n */\nconst numberWays = function (hats) {\n  const pplThatCanWearHats = new Array(40 + 1).fill(null).map(() => [])\n  for (let i = 0; i < hats.length; i++) {\n    const personMask = 1 << i\n    for (let hat of hats[i]) {\n      pplThatCanWearHats[hat].push(personMask)\n    }\n  }\n\n  const cache = {}\n  const dfs = (hat, pplWithoutHatsMask) => {\n    if (!pplWithoutHatsMask) return 1\n    if (hat === 41) return 0\n    const key = `${hat}-${pplWithoutHatsMask}`\n    if (cache.hasOwnProperty(key)) return cache[key]\n    const nextHat = hat + 1\n    let total = dfs(nextHat, pplWithoutHatsMask)\n    for (let personMask of pplThatCanWearHats[hat]) {\n      if (!(pplWithoutHatsMask & personMask)) continue\n      total += dfs(nextHat, pplWithoutHatsMask ^ personMask)\n    }\n    return (cache[key] = total % 1000000007)\n  }\n  return dfs(1, (1 << hats.length) - 1)\n}\n"
    }
  },
  {
    "name": "1436-destination-city",
    "code": {
      "JS": "/**\n * @param {string[][]} paths\n * @return {string}\n */\nconst destCity = function(paths) {\n  const hash = {}\n  for(let [s, e] of paths) {\n    if(hash[e] == null) hash[e] = true\n    hash[s] = false\n    if(hash[s] === true) hash[s] = false\n  }\n  \n  for(let k in hash) {\n    if(hash[k]) return k\n  }\n};\n\n// another\n\n/**\n * @param {string[][]} paths\n * @return {string}\n */\nconst destCity = function(paths) {\n  const set = new Set()\n  for(let [s, e] of paths) set.add(e)\n  for(let [s, e] of paths) set.delete(s)\n  \n  return set[Symbol.iterator]().next().value\n};\n"
    }
  },
  {
    "name": "1439-find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows",
    "code": {
      "JS": "/**\n * @param {number[][]} mat\n * @param {number} k\n * @return {number}\n */\nconst kthSmallest = function(mat, k) {\n  let lo = 0;\n  let hi = 0;\n  for(let r of mat) {\n    lo += r[0];\n    hi += r[r.length-1];\n  }\n\n  const check = (row, sum, limit) => {\n    if (sum > limit) return 0;\n    if (row === mat.length) return 1;\n    let totalcnt = 0;\n    for(let v of mat[row]) {\n      const cnt = check(row + 1, v + sum, limit);\n      totalcnt += cnt;\n      if (cnt === 0 || totalcnt > k) break;  \n    }\n    return totalcnt;\n  };\n\n  while(lo <= hi) {\n    const m = (lo + (hi - lo) / 2) >> 0;\n    const cnt = check(0, 0, m);\n    if (cnt < k) {\n      lo = m + 1;\n    } else {\n      hi = m - 1;\n    }\n  }\n\n  return lo;\n};\n"
    }
  },
  {
    "name": "144-binary-tree-preorder-traversal",
    "code": {
      "JS": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number[]}\r\n */\r\nconst preorderTraversal = function(root) {\r\n  const res = [];\r\n  traversal(root, res);\r\n  return res;\r\n};\r\n\r\nfunction traversal(node, arr) {\r\n  if (node === null) return;\r\n  arr.push(node.val);\r\n  if (node.left) {\r\n    traversal(node.left, arr);\r\n  }\r\n  if (node.right) {\r\n    traversal(node.right, arr);\r\n  }\r\n}\r\n"
    }
  },
  {
    "name": "1441-build-an-array-with-stack-operations",
    "code": {
      "JS": "/**\n * @param {number[]} target\n * @param {number} n\n * @return {string[]}\n */\n const buildArray = function(target, n) {\n  const res = []\n  let ti = 0, ni = 1, num = 0\n  while(num !== target.length && ni <= n) {\n    if(ni !== target[ti]) {\n      res.push('Push', 'Pop')\n      ni++\n    }else {\n      res.push('Push')\n      ni++\n      num++\n      ti++\n    }\n  }\n\n  return res\n};\n"
    }
  },
  {
    "name": "1442-count-triplets-that-can-form-two-arrays-of-equal-xor",
    "code": {
      "JS": "\n/**\n * @param {number[]} arr\n * @return {number}\n */\nconst countTriplets = function(arr) {\n  let res = 0\n  const n = arr.length\n  for(let i = 0; i < n; i++) {\n    let xor = arr[i]\n    for(let j = i + 1; j < n; j++) {\n      xor ^= arr[j]\n      if(xor === 0) res += j - i\n    }\n  }\n  \n  return res\n};\n\n// another\n\n/**\n * @param {number[]} arr\n * @return {number}\n */\nconst countTriplets = function(arr) {\n  arr.unshift(0)\n  const n = arr.length\n  let res = 0\n  for(let i = 1; i < n; i++) {\n    arr[i] ^= arr[i - 1]\n  }\n  const count = {}, total = {}\n  for(let i = 0; i < n; i++) {\n    if(count[arr[i]] == null) count[arr[i]] = 0\n    if(total[arr[i]] == null) total[arr[i]] = 0\n    res += count[arr[i]]++ * (i - 1) - total[arr[i]]\n    total[arr[i]] += i\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1444-number-of-ways-of-cutting-a-pizza",
    "code": {
      "JS": "/**\n * @param {string[]} pizza\n * @param {number} k\n * @return {number}\n */\nconst ways = function (pizza, K) {\n  const MOD = 1e9 + 7\n  const M = pizza.length\n  const N = pizza[0].length\n  const count = Array(M + 1)\n    .fill(0)\n    .map(() => Array(N + 1).fill(0))\n  for (let i = M - 1; i >= 0; i--) {\n    let rowCount = 0\n    for (let j = N - 1; j >= 0; j--) {\n      rowCount += pizza[i][j] === 'A' ? 1 : 0\n      count[i][j] = count[i + 1][j] + rowCount\n    }\n  }\n  const dp = Array(M)\n    .fill(0)\n    .map(() =>\n      Array(N)\n        .fill(0)\n        .map(() => Array(K + 1).fill(0))\n    )\n  for (let i = M - 1; i >= 0; i--) {\n    for (let j = N - 1; j >= 0; j--) {\n      dp[i][j][1] = 1\n      for (let k = 2; k <= K; k++) {\n        for (let t = i + 1; t < M; t++) {\n          if (count[i][j] === count[t][j]) continue\n          if (count[t][j] === 0) break\n          dp[i][j][k] = (dp[i][j][k] + dp[t][j][k - 1]) % MOD\n        }\n        for (let t = j + 1; t < N; t++) {\n          if (count[i][j] === count[i][t]) continue\n          if (count[i][t] === 0) break\n          dp[i][j][k] = (dp[i][j][k] + dp[i][t][k - 1]) % MOD\n        }\n      }\n    }\n  }\n  return dp[0][0][K]\n}\n"
    }
  },
  {
    "name": "1446-consecutive-characters",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst maxPower = function(s) {\n  let res = 1, cnt = 1\n  for(let i = 1; i < s.length; i++) {\n    if(s[i] === s[i - 1]) {\n      if(++cnt > res) res = cnt\n    } else {\n      cnt = 1\n    }\n  }\n  return res\n};\n\n// another\n\n/**\n * @param {string} s\n * @return {number}\n */\nconst maxPower = function(s) {\n  let prev = '', prevIdx = -1, res = -Infinity\n  for(let i = 0; i < s.length; i++) {\n    const cur = s[i]\n    if(cur !== prev) {\n      res = Math.max(res, i - prevIdx)\n      prev = cur\n      prevIdx = i\n    } else {\n      if(i === s.length - 1) res = Math.max(res, i - prevIdx + 1)\n    }\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1448-count-good-nodes-in-binary-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nconst goodNodes = function(root) {\n  if(root == null) return 0\n  let res = 0\n\n  helper(root, root.val)\n\n  return res\n  \n  function helper(node, max) {\n    if(node == null) return\n    if(node.val >= max) {\n      res++\n      max = node.val\n    }\n    helper(node.left, max)\n    helper(node.right, max)\n  }\n};\n"
    }
  },
  {
    "name": "1449-form-largest-integer-with-digits-that-add-up-to-target",
    "code": {
      "JS": "/**\n * @param {number[]} cost\n * @param {number} target\n * @return {string}\n */\nconst largestNumber = function (cost, target) {\n  const dp = new Array(target + 1).fill(-Infinity)\n  dp[0] = 0\n  for (let i = 1; i <= target; i++) {\n    for (let c of cost) {\n      if (i - c >= 0 && dp[i - c] >= 0) {\n        dp[i] = Math.max(dp[i - c] + 1, dp[i])\n      }\n    }\n  }\n  let left = target\n  let paint = ''\n  if (dp[target] < 1) return '0'\n  for (let i = cost.length - 1; i >= 0; i--) {\n    while (left > 0 && dp[left - cost[i]] === dp[left] - 1) {\n      paint += (i + 1).toString()\n      left -= cost[i]\n    }\n  }\n  return paint\n}\n\n// another\n\n/**\n * @param {number[]} cost\n * @param {number} target\n * @return {string}\n */\nconst largestNumber = function(cost, target) {\n  const m = new Map()\n  const res = dfs(cost, 1, target, m)\n  return res.indexOf('0') !== -1 ? '0' : res\n};\nfunction dfs(cost, index, remain, m) {\n  if(remain === 0) return ''\n  if(remain < 0 || index === cost.length + 1) return '0'\n  if(m.has(remain)) return m.get(remain)\n  const take = '' + index + dfs(cost, 1, remain - cost[index - 1], m)\n  const skip = dfs(cost, index + 1, remain, m)\n  const res = getBigger(take, skip)\n  m.set(remain, res)\n  return res\n}\nfunction getBigger(num1, num2) {\n  if(num1.indexOf('0') !== -1) return num2\n  if(num2.indexOf('0') !== -1) return num1\n  if(num1.length > num2.length) return num1\n  else if(num1.length < num2.length) return num2\n  else return num1 > num2 ? num1 : num2\n}\n"
    }
  },
  {
    "name": "145-binary-tree-postorder-traversal",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nconst postorderTraversal = function(root) {\n    const res = []\n    traverse(root, res)\n    return res\n};\n\nfunction traverse(node, arr) {\n  if(node == null) return\n  traverse(node.left, arr)\n  traverse(node.right, arr)\n  arr.push(node.val)\n}\n"
    }
  },
  {
    "name": "1452-people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list",
    "code": {
      "JS": "\n/**\n * @param {string[][]} favoriteCompanies\n * @return {number[]}\n */\nconst peopleIndexes = function(favoriteCompanies) {\n  const fcs = []\n  for(const fc of favoriteCompanies) fcs.push(new Set(fc))\n  const n = fcs.length, uf = new Array(n).fill(0)\n  for(let i = 0; i < n; i++) uf[i] = i\n  for(let i = 0; i < n; i++) {\n    for(let j = i + 1; j < n; j++) {\n      const a = find(uf, i), b = find(uf, j)\n      if(a === b) continue\n      else if(contains(fcs[a], fcs[b])) uf[b] = a\n      else if(contains(fcs[b], fcs[a])) uf[a] = b\n    }\n  }\n  const set = new Set()\n  for(const i of uf) set.add(find(uf, i))\n  return Array.from(set).sort((a, b) => a - b)\n\n  function contains(a, b) {\n    if(a.size < b.size) return false\n    for(let e of b) {\n      if(!a.has(e)) return false\n    }    \n    return true\n  }\n\n  function find(uf, e) {\n    while(uf[e] !== e) {\n      uf[e] = uf[uf[e]]\n      e = uf[e]\n    }\n    return e\n  }\n};\n"
    }
  },
  {
    "name": "1458-max-dot-product-of-two-subsequences",
    "code": {
      "JS": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nconst maxDotProduct = function (nums1, nums2) {\n  const n = nums1.length\n  const m = nums2.length\n  const dp = Array.from({ length: n + 1 }, () => Array(m + 1).fill(-Infinity))\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= m; j++) {\n      dp[i][j] = Math.max(\n        nums1[i - 1] * nums2[j - 1],\n        dp[i - 1][j - 1] + nums1[i - 1] * nums2[j - 1],\n        dp[i - 1][j],\n        dp[i][j - 1]\n      )\n    }\n  }\n  return dp[n][m]\n}\n"
    }
  },
  {
    "name": "146-lru-cache",
    "code": {
      "JS": "class Node {\r\n  constructor(key, val) {\r\n    this.val = val;\r\n    this.key = key;\r\n    this.next = this.pre = null;\r\n  }\r\n}\r\n\r\nconst LRUCache = function(capacity) {\r\n  this.capacity = capacity;\r\n  this.count = 0;\r\n  this.start = new Node(-1, -1);\r\n  this.end = new Node(-1, -1);\r\n  this.start.next = this.end;\r\n  this.end.pre = this.start;\r\n  this.map = {};\r\n};\r\n\r\n// insert node into the next of the start\r\nconst insertAfter = function(start, node) {\r\n  let next = start.next;\r\n  start.next = node;\r\n  node.pre = start;\r\n  node.next = next;\r\n  next.pre = node;\r\n};\r\n\r\nconst detach = function(node) {\r\n  let pre = node.pre,\r\n    next = node.next;\r\n  pre.next = next;\r\n  next.pre = pre;\r\n  node.next = node.pre = null;\r\n};\r\n\r\n/**\r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n  let node = this.map[key];\r\n  if (node != undefined) {\r\n    detach(node);\r\n    insertAfter(this.start, node);\r\n    return node.val;\r\n  } else {\r\n    return -1;\r\n  }\r\n};\r\n\r\n/**\r\n * @param {number} key\r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n  let node = this.map[key];\r\n  if (!node) {\r\n    if (this.count == this.capacity) {\r\n      // deleting last nodes\r\n      let t = this.end.pre;\r\n      detach(t);\r\n      delete this.map[t.key];\r\n    } else {\r\n      this.count++;\r\n    }\r\n    node = new Node(key, value);\r\n    this.map[key] = node;\r\n    insertAfter(this.start, node);\r\n  } else {\r\n    node.val = value;\r\n    detach(node);\r\n    insertAfter(this.start, node);\r\n  }\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * var obj = Object.create(LRUCache).createNew(capacity)\r\n * var param_1 = obj.get(key)\r\n * obj.put(key,value)\r\n */\r\n\r\n// another\r\n\r\n/**\r\n * @param {number} capacity\r\n */\r\nconst LRUCache = function(capacity) {\r\n  this.m = new Map()\r\n  this.limit = capacity\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n  if(!this.m.has(key)) return -1\r\n  const v = this.m.get(key)\r\n  this.m.delete(key)\r\n  this.m.set(key, v)\r\n  return v\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n  if(this.m.has(key)) {\r\n    this.m.delete(key)\r\n  } else {\r\n    if(this.m.size >= this.limit) {\r\n      const first = this.m.keys().next().value\r\n      this.m.delete(first)\r\n    }\r\n  }\r\n  this.m.set(key, value)\r\n};\r\n/** \r\n * Your LRUCache object will be instantiated and called as such:\r\n * var obj = new LRUCache(capacity)\r\n * var param_1 = obj.get(key)\r\n * obj.put(key,value)\r\n */\r\n"
    }
  },
  {
    "name": "1460-make-two-arrays-equal-by-reversing-sub-arrays",
    "code": {
      "JS": "/**\n * @param {number[]} target\n * @param {number[]} arr\n * @return {boolean}\n */\nconst canBeEqual = function(target, arr) {\n  if(target.length !== arr.length) return false\n  const tHash = {}, aHash = {}\n  for(let i = 0, len = arr.length; i < len;i++) {\n    const t = target[i], a = arr[i]\n    if(tHash[t] == null) tHash[t] = 0\n    if(aHash[a] == null) aHash[a] = 0\n    tHash[t]++\n    aHash[a]++\n  }\n  \n  const keys = Object.keys(tHash)\n  for(let k of keys) {\n    if(tHash[k] !== aHash[k]) return false \n  }\n  \n  return true\n};\n"
    }
  },
  {
    "name": "1462-course-schedule-iv",
    "code": {
      "JS": "/**\n * @param {number} numCourses\n * @param {number[][]} prerequisites\n * @param {number[][]} queries\n * @return {boolean[]}\n */\nconst checkIfPrerequisite = function(numCourses, prerequisites, queries) {\n  // https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm\n  const n = numCourses\n  const connected = Array.from({ length: n }, () => Array(n).fill(false))\n  for(let p of prerequisites) connected[p[0]][p[1]] = true\n  for(let k = 0; k < n; k++) {\n    for(let i = 0; i < n; i++) {\n      for(let j = 0; j < n; j++) {\n        connected[i][j] = connected[i][j] || (connected[i][k] && connected[k][j]);\n      }\n    }\n  }\n  const res = []\n  for(let q of queries) res.push(connected[q[0]][q[1]])\n  return res\n};\n\n// another\n\n/**\n * @param {number} numCourses\n * @param {number[][]} prerequisites\n * @param {number[][]} queries\n * @return {boolean[]}\n */\nconst checkIfPrerequisite = function (numCourses, prerequisites, queries) {\n  const n = numCourses\n  const connected = Array.from({ length: n }, () => Array(n).fill(false))\n  for (let p of prerequisites) connected[p[0]][p[1]] = true\n  for (let k = 0; k < n; k++) {\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < n; j++) {\n        connected[i][j] =\n          connected[i][j] || (connected[i][k] && connected[k][j])\n      }\n    }\n  }\n  const res = []\n  for (let q of queries) res.push(connected[q[0]][q[1]])\n  return res\n}\n\n// another\n\n/**\n * @param {number} numCourses\n * @param {number[][]} prerequisites\n * @param {number[][]} queries\n * @return {boolean[]}\n */\nconst checkIfPrerequisite = function (numCourses, prerequisites, queries) {\n  const graph = {},\n    connected = Array.from({ length: numCourses }, () =>\n      Array(numCourses).fill(-1)\n    )\n  for (const [u, v] of prerequisites) {\n    if (graph[u] == null) graph[u] = []\n    graph[u].push(v)\n    connected[u][v] = 1\n  }\n\n  const res = []\n  for (const [u, v] of queries) res.push(dfs(u, v))\n\n  return res\n\n  function dfs(u, v) {\n    if (connected[u][v] !== -1) return connected[u][v]\n    let res = false\n    for (const next of graph[u] || []) {\n      if (!res) {\n        res ||= dfs(next, v)\n      } else break\n    }\n    connected[u][v] = res\n    return res\n  }\n}\n\n"
    }
  },
  {
    "name": "1463-cherry-pickup-ii",
    "code": {
      "JS": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nconst cherryPickup = function (grid) {\n  const m = grid.length\n  const n = grid[0].length\n  const memo = new Array(m)\n    .fill(0)\n    .map((mat) => new Array(n).fill(0).map((row) => new Array(n).fill(0)))\n  return dfs(grid, m, n, 0, 0, n - 1, memo)\n}\n\nconst dfs = (grid, m, n, r, c1, c2, memo) => {\n  if (r === m) return 0\n  if (memo[r][c1][c2]) return memo[r][c1][c2]\n  let count = 0\n  for (let i = -1; i <= 1; i++) {\n    for (let j = -1; j <= 1; j++) {\n      const nc1 = c1 + i\n      const nc2 = c2 + j\n      if (0 <= nc1 && nc1 < n && 0 <= nc2 && nc2 < n) {\n        count = Math.max(count, dfs(grid, m, n, r + 1, nc1, nc2, memo))\n      }\n    }\n  }\n  count += c1 === c2 ? grid[r][c1] : grid[r][c1] + grid[r][c2]\n  return (memo[r][c1][c2] = memo[r][c2][c1] = count)\n}\n"
    }
  },
  {
    "name": "1464-maximum-product-of-two-elements-in-an-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst maxProduct = function(nums) {\n  const n = nums.length\n  let res = 0, m1 = 0, m2 = 0\n  for(const e of nums) {\n    if(e > m1) {\n      m2 = m1\n      m1 = e\n    } else if(e > m2) {\n      m2 = e\n    }\n  }\n\n  return (m1 - 1) * (m2 - 1)\n};\n"
    }
  },
  {
    "name": "1465-maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts",
    "code": {
      "JS": "/**\n * @param {number} h\n * @param {number} w\n * @param {number[]} horizontalCuts\n * @param {number[]} verticalCuts\n * @return {number}\n */\nconst maxArea = function(h, w, horizontalCuts, verticalCuts) {\n  return getMax(h, horizontalCuts) * getMax(w, verticalCuts) % (10 ** 9 + 7)\n};\n\nfunction getMax(limit, cuts) {\n  cuts.sort((a, b) => a - b)\n  const n = cuts.length\n  let max = Math.max(cuts[0], limit - cuts[n - 1])\n  for(let i = 1; i < n; i++) {\n    max = Math.max(max, cuts[i] - cuts[i - 1])\n  }\n  return max\n}\n"
    }
  },
  {
    "name": "1467-probability-of-a-two-boxes-having-the-same-number-of-distinct-balls",
    "code": {
      "JS": "/**\n * @param {number[]} balls\n * @return {number}\n */\nconst getProbability = function (balls) {\n  const k = balls.length\n  const halfUsed = balls.reduce((acc, val) => acc + val, 0) / 2\n  const startArray = new Array(k)\n  startArray.fill(0)\n  const perm = function (b1, b2) {\n    let p1, p2, s1, s2\n    s1 = b1.reduce((acc, val) => acc + val, 0)\n    s2 = b2.reduce((acc, val) => acc + val, 0)\n    const fact = function (n) {\n      let f = 1\n      for (let i = 2; i <= n; i++) f *= i\n      return f\n    }\n    p1 = fact(s1)\n    p2 = fact(s2)\n    b1.forEach((val) => {\n      if (val > 1) p1 /= fact(val)\n    })\n    b2.forEach((val) => {\n      if (val > 1) p2 /= fact(val)\n    })\n    return p1 * p2\n  }\n\n  const getValidCombos = function (ballsUsed, colorNum = 0) {\n    let box1Used = ballsUsed.reduce((acc, val) => acc + val, 0)\n    let matches = { good: 0, total: 0 },\n      thisColorMax = halfUsed - box1Used\n    if (colorNum === k - 1) {\n      if (thisColorMax > balls[colorNum]) return { good: 0, total: 0 }\n      ballsUsed[colorNum] = thisColorMax\n      let ballsLeft = []\n      let colorsUsed = [0, 0]\n      for (let i = 0; i < k; i++) {\n        ballsLeft[i] = balls[i] - ballsUsed[i]\n        if (ballsUsed[i] > 0) colorsUsed[0]++\n        if (ballsLeft[i] > 0) colorsUsed[1]++\n      }\n      let permutations = perm(ballsUsed, ballsLeft, k)\n      return {\n        good: colorsUsed[1] === colorsUsed[0] ? permutations : 0,\n        total: permutations,\n      }\n    }\n    thisColorMax = Math.min(thisColorMax, balls[colorNum])\n    for (let i = 0; i <= thisColorMax; i++) {\n      let match = getValidCombos([...ballsUsed], colorNum + 1)\n      matches = {\n        good: matches.good + match.good,\n        total: matches.total + match.total,\n      }\n      ballsUsed[colorNum]++\n    }\n    return matches\n  }\n  let res = getValidCombos(startArray)\n  return res.good / res.total\n}\n"
    }
  },
  {
    "name": "147-insertion-sort-list",
    "code": {
      "JS": "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nconst insertionSortList = function(head) {\n  const dummy = new ListNode()\n  dummy.next = head\n  let insert = dummy\n  let cur = head\n  while (cur && cur.next) {\n    if (cur.val < cur.next.val) {\n      cur = cur.next\n      continue\n    }\n    insert = dummy\n    while (insert.next.val < cur.next.val) {\n      insert = insert.next\n    }\n    const temp = cur.next\n    cur.next = temp.next\n    temp.next = insert.next\n    insert.next = temp\n  }\n  return dummy.next\n}\n"
    }
  },
  {
    "name": "1470-shuffle-the-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} n\n * @return {number[]}\n */\nconst shuffle = function(nums, n) {\n  const res = []\n  for(let i = 0; i < n; i++) {\n    res.push(nums[i], nums[i + n])\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1472-design-browser-history",
    "code": {
      "JS": "/**\n * @param {string} homepage\n */\nconst BrowserHistory = function(homepage) {\n  this.idx = 0\n  this.last = 0\n  this.arr = [homepage]\n};\n\n/** \n * @param {string} url\n * @return {void}\n */\nBrowserHistory.prototype.visit = function(url) {\n  this.idx++\n  this.arr[this.idx] = url\n  this.last = this.idx\n};\n\n/** \n * @param {number} steps\n * @return {string}\n */\nBrowserHistory.prototype.back = function(steps) {\n  const idx = this.idx\n  let tmp = idx - steps\n  if(tmp < 0) {\n    this.idx = 0\n    return this.arr[0]\n  } else {\n    this.idx = tmp\n    return this.arr[tmp]\n  }\n};\n\n/** \n * @param {number} steps\n * @return {string}\n */\nBrowserHistory.prototype.forward = function(steps) {\n  const n = this.last + 1\n  let tmp = this.idx + steps\n  if(tmp >= n) {\n    this.idx  = n - 1\n    return this.arr[n - 1]\n  } else {\n    this.idx = tmp\n    return this.arr[tmp]\n  }\n};\n"
    }
  },
  {
    "name": "1473-paint-house-iii",
    "code": {
      "JS": "/**\n * @param {number[]} houses\n * @param {number[][]} cost\n * @param {number} m\n * @param {number} n\n * @param {number} target\n * @return {number}\n */\nconst minCost = function (houses, cost, m, n, target) {\n  const dp = Array(m)\n    .fill(null)\n    .map(() =>\n      Array(target)\n        .fill(null)\n        .map(() => Array(n + 1).fill(0))\n    )\n  function dfs(i, t, p) {\n    if (i === m && t === 0) {\n      return 0\n    } else if (t < 0 || m - i < t || (i === m && t > 0)) {\n      return Infinity\n    } else if (p > -1 && dp[i][t][p]) {\n      return dp[i][t][p]\n    } else {\n      let res = Infinity\n      if (houses[i]) {\n        const tmp = houses[i] !== p ? 1 : 0\n        res = dfs(i + 1, t - tmp, houses[i])\n      } else {\n        for (let k = 1; k <= n; k++) {\n          const tmp = k !== p ? 1 : 0\n          res = Math.min(res, cost[i][k - 1] + dfs(i + 1, t - tmp, k))\n        }\n      }\n      if (p > -1) {\n        dp[i][t][p] = res\n      }\n      return res\n    }\n  }\n  const answer = dfs(0, target, -1)\n  return answer === Infinity ? -1 : answer\n}\n"
    }
  },
  {
    "name": "1475-final-prices-with-a-special-discount-in-a-shop",
    "code": {
      "JS": "/**\n * @param {number[]} prices\n * @return {number[]}\n */\nconst finalPrices = function(prices) {\n  const res = [], n = prices.length\n  for(let i = 0; i < n; i++) {\n    const cur = prices[i]\n    let dis = null\n    for(let j = i + 1; j < n; j++) {\n      if(prices[j] <= cur) {\n        dis = prices[j]\n        break\n      }\n    }\n    res.push(dis == null ? cur : cur - dis)\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1476-subrectangle-queries",
    "code": {
      "JS": "/**\n * @param {number[][]} rectangle\n */\nconst SubrectangleQueries = function(rectangle) {\n  this.rect = rectangle\n  this.ops = []\n};\n\n/** \n * @param {number} row1 \n * @param {number} col1 \n * @param {number} row2 \n * @param {number} col2 \n * @param {number} newValue\n * @return {void}\n */\nSubrectangleQueries.prototype.updateSubrectangle = function(row1, col1, row2, col2, newValue) {\n  this.ops.push([row1, col1, row2, col2, newValue])\n};\n\n/** \n * @param {number} row \n * @param {number} col\n * @return {number}\n */\nSubrectangleQueries.prototype.getValue = function(row, col) {\n  for(let i = this.ops.length - 1; i >= 0; i--) {\n    const op = this.ops[i]\n    if(op[0] <= row && op[1] <= col && row <= op[2] && col <= op[3]) return op[4]\n  }\n  return this.rect[row][col]\n};\n\n/** \n * Your SubrectangleQueries object will be instantiated and called as such:\n * var obj = new SubrectangleQueries(rectangle)\n * obj.updateSubrectangle(row1,col1,row2,col2,newValue)\n * var param_2 = obj.getValue(row,col)\n */\n"
    }
  },
  {
    "name": "1478-allocate-mailboxes",
    "code": {
      "JS": "/**\n * @param {number[]} houses\n * @param {number} k\n * @return {number}\n */\nconst minDistance = function (A, K) {\n  A.sort((a, b) => a - b)\n  let n = A.length,\n    B = new Array(n + 1).fill(0),\n    dp = Array(n).fill(0)\n  for (let i = 0; i < n; ++i) {\n    B[i + 1] = B[i] + A[i]\n    dp[i] = 1e6\n  }\n  for (let k = 1; k <= K; ++k) {\n    for (let j = n - 1; j > k - 2; --j) {\n      for (let i = k - 2; i < j; ++i) {\n        let m1 = ((i + j + 1) / 2) >> 0,\n          m2 = ((i + j + 2) / 2) >> 0\n        let last = B[j + 1] - B[m2] - (B[m1 + 1] - B[i + 1])\n        dp[j] = Math.min(dp[j], (i >= 0 ? dp[i] : 0) + last)\n      }\n    }\n  }\n  return dp[n - 1]\n}\n\n// another\n\n/**\n * @param {number[]} houses\n * @param {number} k\n * @return {number}\n */\nfunction minDistance(houses, k) {\n  const n = houses.length, { abs, min } = Math, INF = Infinity\n  houses.sort((a, b) => a - b)\n  const costs = Array.from({ length: 100 }, () => Array(100).fill(0))\n  const memo = Array.from({ length: 100 }, () => Array(100).fill(null))\n\n  for(let i = 0; i < n; i++) {\n    for(let j = 0; j < n; j++) {\n      const mid = houses[~~((i + j) >> 1)]\n      for (let k = i; k <= j; k++) costs[i][j] += abs(mid - houses[k])\n    }\n  }\n  \n  return dp(k, 0)\n\n  function dp(k, i) {\n    if (k === 0 && i === n) return 0\n    if (k === 0 || i === n) return INF\n    if (memo[k][i] != null) return memo[k][i]\n    let res = INF\n    for (let j = i; j < n; j++) {\n      res = min(res, costs[i][j] + dp(k - 1, j + 1))\n    }\n\n    return memo[k][i] = res\n  }\n}\n\n"
    }
  },
  {
    "name": "148-sort-list",
    "code": {
      "JS": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nfunction sortList(head) {\n  quickSort(head, null);\n  return head;\n}\n\nfunction quickSort(head, tail) {\n  if (head == tail) {\n    return;\n  }\n  const slow = partition(head, tail);\n  quickSort(head, slow);\n  quickSort(slow.next, tail);\n}\n\nfunction swap(node1, node2) {\n  let tmp = node1.val;\n  node1.val = node2.val;\n  node2.val = tmp;\n}\n\nfunction partition(head, tail) {\n  let slow = head,\n    fast = head.next;\n  let p = head.val;\n  while (fast != tail) {\n    if (fast.val <= p) {\n      slow = slow.next;\n      swap(slow, fast);\n    }\n    fast = fast.next;\n  }\n  swap(head, slow);\n  return slow;\n}\n\n// another\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nfunction sortList(head) {\n  if(head == null || head.next == null) return head\n  let slow = head, fast = head, pre = null\n  while(fast && fast.next) {\n    pre = slow\n    slow = slow.next\n    fast = fast.next.next\n  }\n  pre.next = null\n  const left = sortList(head)\n  const right = sortList(slow)\n  return merge(left, right)\n}\n\nfunction merge(left, right) {\n  const dummy = new ListNode()\n  let cur = dummy\n  while(left && right) {\n    if (left.val <= right.val) {\n      cur.next = left\n      left = left.next\n    } else {\n      cur.next = right\n      right = right.next\n    }\n    cur = cur.next\n  }\n  if(left) {\n    cur.next = left\n  }\n\n  if(right) {\n    cur.next = right\n  }\n\n  return dummy.next\n}\n\n\n// another\n\n    function sortList(head) {\n        quickSort(head, null);\n        return head;\n    }\n    \n    function quickSort( head,  tail){\n        if (head == tail) {\n            return;\n        }\n        let slow = head, fast = head.next;\n        let p = head.val;\n        while (fast != tail){\n            if (fast.val <= p){\n                slow = slow.next;\n                swap(slow, fast);\n            }\n            fast = fast.next;\n        }\n        swap(head, slow);\n        quickSort(head, slow);\n        quickSort(slow.next, tail);\n    }\n    \n    function swap( node1,  node2){\n         let tmp = node1.val;\n         node1.val = node2.val;\n         node2.val = tmp;\n    }\n\n// another\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\n\nconst sortList = function(head) {\n    let dummy = new ListNode(0);\n    dummy.next = head;\n    const list = [];\n    let done = (null === head);\n    // Keep partitioning our list into bigger sublists length. Starting with a size of 1 and doubling each time\n    for (let step = 1; !done; step *= 2) {\n      done = true;\n      let prev = dummy;\n      let remaining = prev.next;\n      do {\n        // Split off two sublists of size step\n        for (let i = 0; i < 2; ++i) {\n          list[i] = remaining;\n          let tail = null;\n          for (let j = 0; j < step && null != remaining; ++j, remaining = remaining.next) {\n            tail = remaining;\n          }\n          // Terminate our sublist\n          if (null != tail) {\n            tail.next = null;\n          }\n        }\n\n        // We're done if these are the first two sublists in this pass and they\n        // encompass the entire primary list\n        done &= (null == remaining);\n\n        // If we have two sublists, merge them into one\n        if (null != list[1]) {\n          while (null != list[0] || null != list[1]) {\n            let idx = (null == list[1] || null != list[0] && list[0].val <= list[1].val) ? 0 : 1;\n            prev.next = list[idx];\n            list[idx] = list[idx].next;\n            prev = prev.next;\n          }\n\n          // Terminate our new sublist\n          prev.next = null;\n        } else {\n          // Only a single sublist, no need to merge, just attach to the end\n          prev.next = list[0];\n        }\n      } while (null !== remaining);\n    }\n    return dummy.next;\n}\n\n\n"
    }
  },
  {
    "name": "1480-running-sum-of-1d-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nconst runningSum = function(nums) {\n  for(let i = 1, len = nums.length; i < len; i++) {\n    nums[i] += nums[i - 1]\n  }\n  return nums\n};\n"
    }
  },
  {
    "name": "1483-kth-ancestor-of-a-tree-node",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[]} parent\n */\nvar TreeAncestor = function(n, parent) {\n    // initialize\n    this.P = Array.from({length: 20}, () => Array(n).fill(-1))\n    // 2^0\n    for(let i = 0; i < parent.length; i++){\n        this.P[0][i] = parent[i];\n    }\n\n    // 2^i\n    for(let i = 1; i < 20; i++){\n        for(let node = 0; node < parent.length; node++){\n            let nodep = this.P[i-1][node];\n            if(nodep != -1) this.P[i][node] = this.P[i-1][nodep];\n        }\n    }  \n};\n\n/** \n * @param {number} node \n * @param {number} k\n * @return {number}\n */\nTreeAncestor.prototype.getKthAncestor = function(node, k) {\n    for(let i = 0; i < 20; i++){\n        if(k & (1 << i)){\n            node = this.P[i][node];\n            if(node == -1) return -1;\n        }\n    }\n    return node; \n};\n\n/** \n * Your TreeAncestor object will be instantiated and called as such:\n * var obj = new TreeAncestor(n, parent)\n * var param_1 = obj.getKthAncestor(node,k)\n */\n"
    }
  },
  {
    "name": "1486-xor-operation-in-an-array",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number} start\n * @return {number}\n */\nconst xorOperation = function(n, start) {\n  const nums = []\n  let i = 0\n  while (i < n) {\n    nums[i] = start + 2 * i\n    i++\n  }\n  // console.log(nums)\n  let res = nums[0]\n  for(let i = 1; i < n; i++) res ^= nums[i]\n  return res\n};\n"
    }
  },
  {
    "name": "1489-find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {number[][]}\n */\nconst findCriticalAndPseudoCriticalEdges = function (n, edges) {\n  const criticalEdges = [],\n    psuedoCriticalEdges = [],\n    map = new Map()\n  edges.forEach((edge, i) => map.set(edge, i))\n  edges.sort((a, b) => a[2] - b[2])\n  const buildMST = (pick, skip) => {\n    const uf = new UnionFind(n)\n    let cost = 0\n    if (pick !== null) {\n      uf.union(pick[0], pick[1])\n      cost += pick[2]\n    }\n    for (let edge of edges) {\n      if (edge !== skip && uf.union(edge[0], edge[1])) cost += edge[2]\n    }\n    return uf.count === 1 ? cost : Number.MAX_SAFE_INTEGER\n  }\n  const minCost = buildMST(null, null)\n  for (let edge of edges) {\n    const index = map.get(edge)\n    const costWithout = buildMST(null, edge)\n    if (costWithout > minCost) {\n      criticalEdges.push(index)\n    } else {\n      const costWith = buildMST(edge, null)\n      if (costWith === minCost) psuedoCriticalEdges.push(index)\n    }\n  }\n  return [criticalEdges, psuedoCriticalEdges]\n}\nclass UnionFind {\n  constructor(n) {\n    this.parents = Array(n)\n      .fill(0)\n      .map((e, i) => i)\n    this.ranks = Array(n).fill(0)\n    this.count = n\n  }\n  root(x) {\n    while (x !== this.parents[x]) {\n      this.parents[x] = this.parents[this.parents[x]]\n      x = this.parents[x]\n    }\n    return x\n  }\n  find(x) {\n    return this.root(x)\n  }\n  union(x, y) {\n    const [rx, ry] = [this.find(x), this.find(y)]\n    if (this.ranks[rx] >= this.ranks[ry]) {\n      this.parents[ry] = rx\n      this.ranks[rx] += this.ranks[ry]\n    } else if (this.ranks[ry] > this.ranks[rx]) {\n      this.parents[rx] = ry\n      this.ranks[ry] += this.ranks[rx]\n    }\n    if (rx !== ry) {\n      this.count--\n      return true\n    } else return false\n  }\n}\n"
    }
  },
  {
    "name": "149-max-points-on-a-line",
    "code": {
      "JS": "/**\n * @param {number[][]} points\n * @return {number}\n */\nconst maxPoints = function (points) {\n  if (points.length < 2 || points == null) return points.length\n  let max = 2\n  for (let i = 0; i < points.length; i++) {\n    let [p1x, p1y] = points[i]\n    let samePoint = 1,\n      map = { base: 0 } // to avoid when map = {}, the max value is -Infinity\n    for (let j = i + 1; j < points.length; j++) {\n      if (points[i][0] == points[j][0] && points[i][1] == points[j][1]) {\n        samePoint++\n      } else {\n        let [p2x, p2y] = points[j]\n        let slope = (1000000.0 * (p2y - p1y)) / (p2x - p1x)\n        if (!Number.isFinite(slope)) slope = 'v'\n        else if (Number.isNaN(slope)) slope = 'h'\n        map[slope] = map[slope] + 1 || 1\n      }\n    }\n    max = Math.max(Math.max(...Object.values(map)) + samePoint, max)\n  }\n  return max\n}\n"
    }
  },
  {
    "name": "1490-clone-n-ary-tree",
    "code": {
      "JS": "/**\n * // Definition for a Node.\n * function Node(val, children) {\n *    this.val = val === undefined ? 0 : val;\n *    this.children = children === undefined ? [] : children;\n * };\n */\n\n/**\n * @param {Node} node\n * @return {Node}\n */\nconst cloneTree = function(root) {\n  if(root == null) return null\n  let node = new Node(root.val)\n  for(let i = 0, len = root.children.length; i < len; i++) {\n    node.children.push(cloneTree(root.children[i]))\n  }\n  return node\n};\n\n// another\n\n/**\n * // Definition for a Node.\n * function Node(val, children) {\n *    this.val = val === undefined ? 0 : val;\n *    this.children = children === undefined ? [] : children;\n * };\n */\n\n/**\n * @param {Node} node\n * @return {Node}\n */\nconst cloneTree = function(root) {\n  if (root === null) return null\n  const Q = []\n  const rootCopy = new Node(root.val)\n  Q.push([root, rootCopy])\n  while (Q.length) {\n    const temp = Q.shift()\n    const node = temp[0]\n    const copy = temp[1]\n    node.children.forEach((child) => {\n      const copyChild = new Node(child.val)\n      copy.children.push(copyChild)\n      Q.push([child, copyChild])\n    })\n  }\n\n  return rootCopy\n};\n"
    }
  },
  {
    "name": "1494-parallel-courses-ii",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[][]} dependencies\n * @param {number} k\n * @return {number}\n */\nconst minNumberOfSemesters = function (n, dependencies, k) {\n  const preq = new Array(n).fill(0)\n  for (let dep of dependencies) {\n    // to study j, what are the prerequisites?\n    // each set bit is a class that we need to take. ith bit means ith class\n    // -1 because classes are 1 to n\n    preq[dep[1] - 1] |= 1 << (dep[0] - 1)\n  }\n  const dp = new Array(1 << n).fill(n)\n  dp[0] = 0\n  for (let i = 0; i < 1 << n; i++) {\n    // we are now at status i. we can \"influence\" a later status from this status\n    let canStudy = 0 // what are the classes we can study?\n    for (let j = 0; j < n; j++) {\n      // a & b== b means b is a's subset\n      // so if preq[j] is i's subset, we can now study j given status i\n      if ((i & preq[j]) == preq[j]) {\n        canStudy |= 1 << j\n      }\n    }\n    canStudy &= ~i\n    // take out i, so that we only enumerate a subset canStudy without i.\n    // note we will | later so here we need a set that has no\n    // intersection with i to reduce the enumeration cost\n    for (let sub = canStudy; sub > 0; sub = (sub - 1) & canStudy) {\n      // we can study one or more courses indicated by set \"canStudy\".\n      // we need to enumerate all non empty subset of it.\n      // This for loop is a typical way to enumerate all subsets of a given set \"canStudy\"\n      // we studied i using dp[i] semesters. now if we also study the\n      // subset sub, we need dp [i ]+1 semesters,\n      // and the status we can \"influence\" is dp[ i | sub] because at\n      // that state, we studied what we want to study in \"sub\"\n      if (bitCount(sub) <= k) {\n        dp[i | sub] = Math.min(dp[i | sub], dp[i] + 1)\n      }\n    }\n  }\n  return dp[(1 << n) - 1]\n}\nfunction bitCount(n) {\n  n = n - ((n >> 1) & 0x55555555)\n  n = (n & 0x33333333) + ((n >> 2) & 0x33333333)\n  return (((n + (n >> 4)) & 0xf0f0f0f) * 0x1010101) >> 24\n}\n"
    }
  },
  {
    "name": "1499-max-value-of-equation",
    "code": {
      "JS": "/**\n * @param {number[][]} points\n * @param {number} k\n * @return {number}\n */\nconst findMaxValueOfEquation = function (points, k) {\n  let res = -Number.MAX_VALUE\n  const deque = []\n  for (let i = 0; i < points.length; i++) {\n    const x = points[i][0]\n    const y = points[i][1]\n    while (deque.length != 0 && x - deque[0][1] > k) {\n      deque.shift()\n    }\n    if (deque.length != 0) {\n      res = Math.max(res, deque[0][0] + x + y)\n    }\n    while (deque.length != 0 && deque[deque.length - 1][0] <= y - x) {\n      deque.pop()\n    }\n    deque.push([y - x, x])\n  }\n  return res\n}\n\n// another\n\n/**\n * @param {number[][]} points\n * @param {number} k\n * @return {number}\n */\nconst findMaxValueOfEquation = function (points, k) {\n  const pq = new PriorityQueue((a, b) =>\n    a[0] === b[0] ? a[1] < b[1] : b[0] < a[0]\n  )\n  let res = -Infinity\n  for (let point of points) {\n    while (!pq.isEmpty() && point[0] - pq.peek()[1] > k) {\n      pq.pop()\n    }\n    if (!pq.isEmpty()) {\n      res = Math.max(res, pq.peek()[0] + point[0] + point[1])\n    }\n    pq.push([point[1] - point[0], point[0]])\n  }\n  return res\n}\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n"
    }
  },
  {
    "name": "15-3sum",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n * @return {number[][]}\r\n */\r\nconst threeSum = function (nums) {\r\n  nums.sort((a, b) => a - b)\r\n  const res = []\r\n  let lo, hi, sum\r\n  for (let i = 0; i < nums.length - 2; i++) {\r\n    if (nums[i] > 0) break\r\n    if (nums[i] === nums[i - 1]) continue\r\n    if (i === 0 || (i > 0 && nums[i] !== nums[i - 1])) {\r\n      lo = i + 1\r\n      hi = nums.length - 1\r\n      sum = 0 - nums[i]\r\n      while (lo < hi) {\r\n        if (nums[lo] + nums[hi] === sum) {\r\n          res.push([nums[i], nums[lo], nums[hi]])\r\n          while (lo < hi && nums[lo] === nums[lo + 1]) lo += 1\r\n          while (lo < hi && nums[hi] === nums[hi - 1]) hi -= 1\r\n          lo += 1\r\n          hi -= 1\r\n        } else if (nums[lo] + nums[hi] < sum) lo++\r\n        else hi--\r\n      }\r\n    }\r\n  }\r\n  return res\r\n}\r\n\r\n// another\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @return {number[][]}\r\n */\r\nconst threeSum = function(nums) {\r\n  const res = [], n = nums.length\r\n  nums.sort((a, b) => a - b)\r\n  for(let i = 0; i < n - 2; i++) {\r\n    let l = i + 1, r = n - 1, target = -nums[i]\r\n    if(i === 0 || (i > 0 && nums[i] !== nums[i - 1])) {\r\n      while(l < r) {\r\n        if(nums[l] + nums[r] === target) {\r\n          res.push([nums[i], nums[l], nums[r]])\r\n          while(l < n - 1 && nums[l] === nums[l + 1]) l++\r\n          while(r > 0 && nums[r] === nums[r - 1]) r--\r\n          r--\r\n          l++\r\n        } else if(nums[l] + nums[r] > target) {\r\n          r--\r\n        } else l++\r\n      }\r\n    }\r\n  }  \r\n\r\n  return res\r\n};\r\n"
    }
  },
  {
    "name": "150-evaluate-reverse-polish-notation",
    "code": {
      "JS": "/**\n * @param {string[]} tokens\n * @return {number}\n */\nconst evalRPN = function(tokens) {\n  const stack = []\n  for (let token of tokens) {\n    if (token === '+') {\n      stack.push(stack.pop() + stack.pop())\n    } else if (token === '-') {\n      stack.push(-stack.pop() + stack.pop())\n    } else if (token === '*') {\n      stack.push(stack.pop() * stack.pop())\n    } else if (token === '/') {\n      stack.push(Math.trunc((1 / stack.pop()) * stack.pop()))\n    } else {\n      stack.push(parseInt(token))\n    }\n  }\n  return stack[0]\n}\n"
    }
  },
  {
    "name": "1505-minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits",
    "code": {
      "JS": "/**\n * @param {string} num\n * @param {number} k\n * @return {string}\n */\nconst minInteger = function (num, k) {\n  const nums = num.split('')\n  const len = nums.length\n  const q = Array(10)\n    .fill(null)\n    .map(() => [])\n  nums.forEach((n, i) => q[+n].push(i))\n  const tree = new Fenwick(nums.length)\n  for (let i = 1; i <= len; i++) tree.update(i, 1)\n  let re = ''\n  for (let i = 0; i < len; i++) {\n    for (let j = 0; j <= 9; j++) {\n      const idxArr = q[j]\n      if (idxArr && idxArr.length) {\n        const idx = idxArr[0]\n        const num = tree.query(idx)\n        if (num > k) continue\n        k -= num\n        idxArr.shift()\n        tree.update(idx + 1, -1)\n        re += j\n        break\n      }\n    }\n  }\n\n  return re\n}\nclass Fenwick {\n  constructor(n) {\n    this.sums = new Array(n + 1).fill(0)\n  }\n\n  update(i, delta) {\n    while (i < this.sums.length) {\n      this.sums[i] += delta\n      i += i & -i\n    }\n  }\n\n  query(i) {\n    let sum = 0\n    while (i > 0) {\n      sum += this.sums[i]\n      i -= i & -i\n    }\n    return sum\n  }\n}\n"
    }
  },
  {
    "name": "1506-find-root-of-n-ary-tree",
    "code": {
      "JS": "/**\n * // Definition for a Node.\n * function Node(val, children) {\n *    this.val = val === undefined ? 0 : val;\n *    this.children = children === undefined ? [] : children;\n * };\n */\n\n/**\n * @param {Node[]} tree\n * @return {Node}\n */\nconst findRoot = function(tree) {\n  let sum = 0\n  for(let n of tree) {\n    sum += n.val\n    for(let c of n.children) {\n      sum -= c.val\n    }\n  }\n  for(let n of tree) {\n    if(n.val === sum) return n\n  }\n  return null\n};\n\n// another\n\n/**\n * // Definition for a Node.\n * function Node(val, children) {\n *    this.val = val === undefined ? 0 : val;\n *    this.children = children === undefined ? [] : children;\n * };\n */\n\n/**\n * @param {Node[]} tree\n * @return {Node}\n */\nconst findRoot = function(tree) {\n  let sum = 0\n  for(let n of tree) {\n    sum ^= n.val\n    for(let c of n.children) {\n      sum ^= c.val\n    }\n  }\n  for(let n of tree) {\n    if(n.val === sum) return n\n  }\n  return null\n};\n"
    }
  },
  {
    "name": "1507-reformat-date",
    "code": {
      "JS": "/**\n * @param {string} date\n * @return {string}\n */\nconst reformatDate = function(date) {\n  const months = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n  const map = new Map();\n  for (let i = 0; i < months.length; ++i) {\n    map.set(months[i], (i + 1 < 10 ? \"0\" : \"\") + (i+1));    \n  }\n  const parts = date.split(\" \"); \n  const day = (parts[0].length == 3 ? \"0\" : \"\") + parts[0].slice(0, parts[0].length - 2);\n  return parts[2] + \"-\" + map.get(parts[1]) + \"-\" + day;  \n};\n"
    }
  },
  {
    "name": "151-reverse-words-in-a-string",
    "code": {
      "JS": "/**\r\n * @param {string} str\r\n * @returns {string}\r\n */\r\nconst reverseWords = function(str) {\r\n  return str\r\n    .trim()\r\n    .split(/\\s+/)\r\n    .reverse()\r\n    .join(\" \");\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * @param {string} str\r\n * @returns {string}\r\n */\r\nconst reverseWords = function (s) {\r\n  let sb = ''\r\n  const n = s.length\r\n  let i = n - 1\r\n  while (i >= 0) {\r\n    if (s.charAt(i) == ' ') {\r\n      i--\r\n      continue\r\n    }\r\n    let j = i - 1\r\n    while (j >= 0 && s.charAt(j) != ' ') j--\r\n    sb += ' '\r\n    sb += s.slice(j + 1, i + 1)\r\n    i = j - 1\r\n  }\r\n  if (sb.length > 0) sb = sb.slice(1)\r\n  return sb\r\n}\r\n"
    }
  },
  {
    "name": "1510-stone-game-iv",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {boolean}\n */\nconst winnerSquareGame = function(n) {\n  const dp = new Array(n + 1).fill(0);\n  for (let i = 1; i <= n; ++i) {\n    for (let k = 1; k * k <= i; ++k) {\n      if (!dp[i - k * k]) {\n        dp[i] = true;\n        break;\n      }\n    }\n  }\n  return dp[n];\n};\n"
    }
  },
  {
    "name": "1512-number-of-good-pairs",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst numIdenticalPairs = function(nums) {\n  let res = 0, count = Array(101).fill(0)\n  for(let e of nums) {\n    res += count[e]++\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1514-path-with-maximum-probability",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @param {number[]} succProb\n * @param {number} start\n * @param {number} end\n * @return {number}\n */\nconst maxProbability = function (n, edges, succProb, start, end) {\n  const g = {}\n  for (let i = 0; i < edges.length; ++i) {\n    const a = edges[i][0],\n      b = edges[i][1]\n    if (g[a] == null) g[a] = []\n    if (g[b] == null) g[b] = []\n    g[a].push([b, i])\n    g[b].push([a, i])\n  }\n  const p = new Array(n).fill(0)\n  p[start] = 1\n  const pq = new PriorityQueue((a, b) => p[a] > p[b])\n  pq.push(start)\n  while (!pq.isEmpty()) {\n    const cur = pq.pop()\n    if (cur === end) {\n      return p[end]\n    }\n    for (let a of g[cur] || []) {\n      const neighbor = a[0],\n        index = a[1]\n      if (p[cur] * succProb[index] > p[neighbor]) {\n        p[neighbor] = p[cur] * succProb[index]\n        pq.push(neighbor)\n      }\n    }\n  }\n  return 0\n}\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n"
    }
  },
  {
    "name": "1515-best-position-for-a-service-centre",
    "code": {
      "JS": "/**\n * @param {number[][]} positions\n * @return {number}\n */\nconst getMinDistSum = function(positions) {\n  const n = positions.length\n  let x = positions.reduce((ac, e) => ac + e[0], 0) / n\n  let y = positions.reduce((ac, e) => ac + e[1], 0) / n\n  \n  const dirs = [[1,0],[-1,0],[0,1],[0,-1]]\n  let res = fn(x, y, positions)\n  let chg = 100\n  while(chg > 1e-6) {\n    let zoom = true\n    for(let [dx, dy] of dirs) {\n      const nx = x + dx * chg\n      const ny = y + dy * chg\n      const nRes = fn(nx, ny, positions)\n      if(nRes < res) {\n        res = nRes\n        x = nx\n        y = ny\n        zoom = false\n        break\n      }\n    }\n    if(zoom) chg /= 2\n  }\n  return res\n};\n\nfunction fn(x, y, arr) {\n  let res = 0\n  const n = arr.length\n  for(let i = 0; i < n; i++) {\n    res += Math.sqrt((x - arr[i][0]) ** 2 + (y - arr[i][1]) ** 2)\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "1516-move-sub-tree-of-n-ary-tree",
    "code": {
      "JS": "/**\n * // Definition for a Node.\n * function Node(val, children) {\n *    this.val = val === undefined ? 0 : val;\n *    this.children = children === undefined ? [] : children;\n * };\n */\n\n/**\n * @param {Node} root\n * @param {Node} p\n * @param {Node} q\n * @return {Node}\n */\nfunction moveSubTree(root, p, q) {\n  for (let node of q.children) {\n    if (p === node) {\n      return root\n    }\n  }\n  if (find(p, q)) {\n    update(root, p, q)\n    q.children.push(p)\n    return root === p ? q : root\n  } else {\n    update(root, null, p)\n    q.children.push(p)\n    return root\n  }\n  function update(root, p, q) {\n    if (root == null) {\n      return\n    }\n    for (let node of root.children) {\n      update(node, p, q)\n    }\n    for (let i = 0; i < root.children.length; i++) {\n      if (root.children[i] === p) {\n        root.children[i] = q\n      } else if (root.children[i] === q) {\n        root.children.splice(i, 1)\n      }\n    }\n  }\n  function find(root, t) {\n    if (root == null) {\n      return false\n    }\n    let ret = root === t\n    if (ret === true) {\n      return true\n    }\n    for (let node of root.children) {\n      ret = ret || find(node, t)\n    }\n    return ret\n  }\n}\n"
    }
  },
  {
    "name": "152-maximum-product-subarray",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst maxProduct = function(nums) {\n    let A = nums\n    let r = A[0];\n\n    // imax/imin stores the max/min product of\n    // subarray that ends with the current number A[i]\n    for (let i = 1, imax = r, imin = r, n = A.length; i < n; i++) {\n        if (A[i] < 0) {\n          let tmp = imax\n          imax = imin\n          imin = tmp\n        };\n        // max/min product for the current number is either the current number itself\n        // or the max/min by the previous number times the current one\n        imax = Math.max(A[i], imax * A[i]);\n        imin = Math.min(A[i], imin * A[i]);\n\n        // the newly computed max value is a candidate for our global result\n        r = Math.max(r, imax);\n    }\n    return r;\n};\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst maxProduct = function(nums) {\n  if(nums.length == 1)return nums[0];\n  let dpMax = nums[0];\n  let dpMin = nums[0];\n  let max = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    let k = dpMax*nums[i];\n    let m = dpMin*nums[i];\n    dpMax = Math.max(nums[i], Math.max(k, m));\n    dpMin = Math.min(nums[i], Math.min(k, m));\n    max = Math.max(dpMax, max);\n  }\n  return max;\n};\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst maxProduct = function(nums) {\n  const n = nums.length\n  let max, min\n  let res = max = min = nums[0]\n  for(let i = 1; i < n; i++) {\n    if(nums[i] < 0) [max, min] = [min, max]\n    max = Math.max(nums[i], nums[i] * max)\n    min = Math.min(nums[i], nums[i] * min)\n    res = Math.max(res, max)\n  }\n  return res\n};\n\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst maxProduct = function (nums) {\n  if(nums == null || nums.length === 0) return 0\n  const n = nums.length\n  let res = nums[0]\n  for(let i = 1, min = res, max = res; i < n; i++) {\n    if(nums[i] < 0) {\n      let tmax = max, tmin = min\n      min = Math.min(nums[i], tmax * nums[i])\n      max = Math.max(nums[i], tmin * nums[i])\n    } else {\n      min = Math.min(nums[i], min * nums[i])\n      max = Math.max(nums[i], max * nums[i])\n    }\n    res = Math.max(res, max)\n  }\n  \n  return res\n}\n"
    }
  },
  {
    "name": "1521-find-a-value-of-a-mysterious-function-closest-to-target",
    "code": {
      "JS": "/**\n * @param {number[]} arr\n * @param {number} target\n * @return {number}\n */\nconst closestToTarget = function (arr, target) {\n  let res = Infinity\n  let set = new Set()\n  for (let i = 0; i < arr.length; i++) {\n    const set2 = new Set()\n    for (let j of set) {\n      set2.add(j & arr[i])\n    }\n    set2.add(arr[i])\n    for (let j of set2) {\n      res = Math.min(res, Math.abs(j - target))\n    }\n    set = set2\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "1525-number-of-good-ways-to-split-a-string",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst numSplits = function(s) {\n  const n = s.length\n  const freq = new Map()\n  const prefix = Array(26).fill(0)\n  for(let i = 0; i < n; i++) {\n    if(freq.get(s[i]) == null) freq.set(s[i], 0)\n    freq.set(s[i], freq.get(s[i]) + 1)\n    prefix[i] = freq.size\n  }\n  freq.clear()\n  const suffix = Array(26).fill(0)\n  for(let i = n - 1; i >= 0 ;i--) {\n    if(freq.get(s[i]) == null) freq.set(s[i], 0)\n    freq.set(s[i], freq.get(s[i]) + 1)\n    suffix[i] = freq.size\n  }\n  // console.log(prefix, suffix)\n  let res = 0\n  for(let i = 1; i < n; i++) {\n    if(prefix[i - 1] === suffix[i]) res++\n  }\n  \n  return res\n};\n\n\n// another\n\n\n/**\n * @param {string} s\n * @return {number}\n */\nconst numSplits = function(s) {\n  const arr = Array(26).fill(0)\n  const a = 'a'.charCodeAt(0)\n  for(let i = 0, len = s.length; i < len; i++) {\n    arr[s.charCodeAt(i) - a]++\n  }\n  const cur = Array(26).fill(0)\n  let res = 0\n  for(let i = 0, len = s.length; i < len - 1; i++) {\n    cur[s.charCodeAt(i) - a]++\n    let tmp = false, clone = arr.slice()\n    for(let j = 0; j < 26; j++) {\n      clone[j] -= cur[j]\n    }\n    const curNum = cur.reduce((ac, e) => ac + (e > 0 ? 1 : 0), 0)\n    const cloneNum = clone.reduce((ac, e) => ac + (e > 0 ? 1 : 0), 0)\n    if(curNum === cloneNum) res++\n  }\n  \n  return res\n};\n\n"
    }
  },
  {
    "name": "1526-minimum-number-of-increments-on-subarrays-to-form-a-target-array",
    "code": {
      "JS": "/**\n * @param {number[]} target\n * @return {number}\n */\nconst minNumberOperations = function(target) {\n  let totalOperations = target[0];\n  for (let i = 1; i < target.length; ++i) {\n    if (target[i] > target[i-1]) {\n      totalOperations += target[i] - target[i-1];\n    }\n  }\n  return totalOperations;\n};\n"
    }
  },
  {
    "name": "1528-shuffle-string",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {number[]} indices\n * @return {string}\n */\nconst restoreString = function(s, indices) {\n  const n = s.length\n  const arr = Array(n)\n  for(let i = 0; i < n; i++) {\n    arr[indices[i]] = s[i]\n  }\n  return arr.join('')\n};\n"
    }
  },
  {
    "name": "153-find-minimum-in-rotated-sorted-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst findMin = function (nums) {\n  let low = 0,\n    high = nums.length - 1\n  // loop invariant: 1. low < high\n  //                 2. mid != high and thus A[mid] != A[high] (no duplicate exists)\n  //                 3. minimum is between [low, high]\n  // The proof that the loop will exit: after each iteration either the 'high' decreases\n  // or the 'low' increases, so the interval [low, high] will always shrink.\n  while (low < high) {\n    const mid = low + ((high - low) >> 1)\n    if (nums[mid] <= nums[high]) high = mid\n    else if (nums[mid] > nums[high]) low = mid + 1\n  }\n\n  return nums[low]\n}\n"
    }
  },
  {
    "name": "1531-string-compression-ii",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nconst getLengthOfOptimalCompression = function(s, k) {\n  const m = new Map()\n  function counter(start, last, lastCount, left) {\n    if(left < 0) return Infinity\n    if(start >= s.length) return 0\n    let res\n    const k = `${start}-${last}-${lastCount}-${left}`\n    if(m.has(k)) return m.get(k)\n    if(s[start] === last) {\n      const incr = (lastCount === 1 || lastCount === 9 || lastCount === 99) ? 1 : 0\n      res = incr + counter(start + 1, last, lastCount + 1, left)\n    } else {\n      const keepCounter = 1 + counter(start + 1, s[start], 1, left)\n      const delCounter = counter(start + 1, last,  lastCount, left - 1)\n      res = Math.min(keepCounter, delCounter)\n    }\n    m.set(k, res)\n    return res\n  }\n  return counter(0, '', 0, k)\n};\n\n// another\n\nconst getLengthOfOptimalCompression = function (s, k) {\n  const n = s.length\n  const dp = new Array(n + 1).fill(n).map((row) => new Array(k + 1).fill(n))\n  dp[0][0] = 0\n\n  for (let i = 1; i <= n; i++) {\n    for (let j = 0; j <= k; j++) {\n      let letterCount = 0\n      let deletion = 0\n      // keep s[i], compress same letters, remove different letters\n      for (let l = i; l >= 1; l--) {\n        if (s.charAt(l - 1) === s.charAt(i - 1)) letterCount++\n        else deletion++\n        // places = length needed to rep compressed letters.\n        // 0 places for count = 1,0, 1 place = <10, 10-99 requires 2 places, 100+ requires 3\n        let places = 0\n        if (letterCount >= 100) places = 3\n        else if (letterCount >= 10) places = 2\n        else if (letterCount >= 2) places = 1\n        if (j - deletion >= 0) {\n          dp[i][j] = Math.min(dp[i][j], dp[l - 1][j - deletion] + 1 + places)\n        }\n      }\n      // delete\n      if (j > 0) {\n        dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - 1])\n      }\n    }\n  }\n  return dp[n][k]\n}\n\n"
    }
  },
  {
    "name": "1534-count-good-triplets",
    "code": {
      "JS": "/**\n * @param {number[]} arr\n * @param {number} a\n * @param {number} b\n * @param {number} c\n * @return {number}\n */\nconst countGoodTriplets = function(arr, a, b, c) {\n  const  n = arr.length, { abs } = Math\n  let res = 0\n  \n  for(let i = 0; i < n - 2; i++) {\n    for(let j = i + 1; j < n - 1; j++) {\n      if(abs(arr[i] - arr[j]) > a) continue\n      for(let k = j + 1; k < n; k++) {\n        if(abs(arr[j] - arr[k]) <= b && abs(arr[i] - arr[k]) <= c) res++\n      }\n    }\n  }\n  \n  return res\n  \n};\n"
    }
  },
  {
    "name": "1537-get-the-maximum-score",
    "code": {
      "JS": "/**\n\nYou are given two sorted arrays of distinct integers nums1 and nums2.\n\nA valid path is defined as follows:\n\nChoose array nums1 or nums2 to traverse (from index-0).\nTraverse the current array from left to right.\nIf you are reading any value that is present in nums1 and nums2 you are\nallowed to change your path to the other array.\n(Only one repeated value is considered in the valid path).\nScore is defined as the sum of uniques values in a valid path.\n\nReturn the maximum score you can obtain of all possible valid paths.\n\nSince the answer may be too large, return it modulo 10^9 + 7.\n\nExample 1:\n\nInput: nums1 = [2,4,5,8,10], nums2 = [4,6,8,9]\nOutput: 30\nExplanation: Valid paths:\n[2,4,5,8,10], [2,4,5,8,9], [2,4,6,8,9], [2,4,6,8,10],  (starting from nums1)\n[4,6,8,9], [4,5,8,10], [4,5,8,9], [4,6,8,10]    (starting from nums2)\nThe maximum is obtained with the path in green [2,4,6,8,10].\n\nExample 2:\n\nInput: nums1 = [1,3,5,7,9], nums2 = [3,5,100]\nOutput: 109\nExplanation: Maximum sum is obtained with the path [1,3,5,100].\nExample 3:\n\nInput: nums1 = [1,2,3,4,5], nums2 = [6,7,8,9,10]\nOutput: 40\nExplanation: There are no common elements between nums1 and nums2.\nMaximum sum is obtained with the path [6,7,8,9,10].\nExample 4:\n\nInput: nums1 = [1,4,5,8,9,11,19], nums2 = [2,3,4,11,12]\nOutput: 61\n \n\nConstraints:\n\n1 <= nums1.length <= 10^5\n1 <= nums2.length <= 10^5\n1 <= nums1[i], nums2[i] <= 10^7\nnums1 and nums2 are strictly increasing.\n\n*/\n\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nconst maxSum = function(nums1, nums2) {\n  let i = 0, j = 0, n = nums1.length, m = nums2.length;\n  let a = 0, b = 0, mod = 10 ** 9 + 7;\n  while (i < n || j < m) {\n    if (i < n && (j === m || nums1[i] < nums2[j])) {\n      a += nums1[i++];\n    } else if (j < m && (i === n || nums1[i] > nums2[j])) {\n      b += nums2[j++];\n    } else {\n      a = b = Math.max(a, b) + nums1[i];\n      i++; j++;\n    }\n  }\n  return Math.max(a, b) % mod;\n};\n\n// another\n\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nconst maxSum = function(nums1, nums2) {\n  const len1 = nums1.length, len2 = nums2.length\n  const mod = 10 ** 9 + 7\n  const map = new Map()\n  for(let i = 0; i < len1 - 1; i++) {\n    if(!map.has(nums1[i])) map.set(nums1[i], [])\n    map.get(nums1[i]).push(nums1[i + 1])\n  }\n  for(let j = 0; j < len2 - 1; j++) {\n    if(!map.has(nums2[j])) map.set(nums2[j], [])\n    map.get(nums2[j]).push(nums2[j + 1])\n  }\n  const memo = new Map()\n  return Math.max(greedy(nums1[0], map, memo), greedy(nums2[0], map, memo)) % mod\n};\n\nfunction greedy(cur, map, memo) {\n  if(memo.has(cur)) return memo.get(cur)\n  if(!map.has(cur)) return cur\n  let res = 0\n  for(let next of map.get(cur)) {\n    const tmp = greedy(next, map, memo)\n    if(tmp > res) res = tmp\n  }\n  res += cur\n  memo.set(cur, res)\n  return res\n}\n"
    }
  },
  {
    "name": "1539-kth-missing-positive-number",
    "code": {
      "JS": "/**\n * @param {number[]} arr\n * @param {number} k\n * @return {number}\n */\nconst findKthPositive = function(arr, k) {\n  let l = 0, r = arr.length, m;\n  while (l < r) {\n    m = (l + r) >> 1;\n    if (arr[m] - 1 - m < k) l = m + 1;\n    else r = m;\n  }\n  return l + k;\n};\n"
    }
  },
  {
    "name": "154-find-minimum-in-rotated-sorted-array-ii",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst findMin = function(nums) {\n  for(let i = 1, len = nums.length; i < len; i++) {\n    if(nums[i] < nums[i - 1]) {\n      return nums[i]\n    }\n  }\n  return nums[0]\n};\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst findMin = function(nums) {\n  let lo = 0,\n    hi = nums.length - 1\n  while (lo < hi) {\n    let mid = Math.floor(lo + (hi - lo) / 2)\n    if (nums[mid] > nums[hi]) lo = mid + 1\n    else if (nums[mid] < nums[hi]) hi = mid\n    else hi--\n  }\n  return nums[lo]\n}\n"
    }
  },
  {
    "name": "1540-can-convert-string-in-k-moves",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {string} t\n * @param {number} k\n * @return {boolean}\n */\nconst canConvertString = function(s, t, k) {\n  if(s == null || t == null) return false\n  const slen = s.length, tlen = t.length\n  if(slen !== tlen) return false\n  const count = Array(26).fill(0)\n  for(let i = 0; i < slen; i++) {\n    const scode = s.charCodeAt(i)\n    const tcode = t.charCodeAt(i)\n    const diff = (tcode - scode + 26) % 26;\n    if (diff > 0 && diff + count[diff] * 26 > k) {\n      return false;\n    }\n    count[diff]++;\n  }\n  return true\n};\n"
    }
  },
  {
    "name": "1541-minimum-insertions-to-balance-a-parentheses-string",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst minInsertions = function(s) {\n  let insert = 0, idx = 0, open = 0, len = s.length\n  while(idx < len) {\n    const ch = s[idx]\n    if(ch === '(') {\n      open++\n      idx++\n    } else {\n      if(open > 0) {\n        open--\n      } else {\n        insert++\n      }\n      if(idx < len - 1 && s[idx + 1] === ')') {\n        idx += 2\n      } else {\n        insert++\n        idx++\n      }\n    }\n  }\n  if(open) insert += open * 2\n  return insert\n};\n\n// another\n\n/**\n * @param {string} s\n * @return {number}\n */\nconst minInsertions = function(s) {\n    let res = 0, right = 0;\n    for (let i = 0; i < s.length; ++i) {\n        if (s.charAt(i) == '(') {\n            if (right % 2 > 0) {\n                right--;\n                res++;\n            }\n            right += 2;\n        } else {\n            right--;\n            if (right < 0) {\n                right += 2;\n                res++;\n            }\n        }\n    }\n    return right + res;\n};\n\n// another\n\n/**\n * @param {string} s\n * @return {number}\n */\nconst minInsertions = function(s) {\n  let add = 0, req = 0 // number of parentheses added, number of closing parentheses required\n  for(let ch of s) {\n    if(ch === '(') {\n      req += 2\n      if(req % 2 === 1) {\n         add++\n         req--\n      }\n    } else {\n      if(req === 0) {\n        add++\n        req++\n      }else {\n        req--\n      }\n    }\n  }\n  \n  return add + req\n};\n\n"
    }
  },
  {
    "name": "1542-find-longest-awesome-substring",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst longestAwesome = function (s) {\n  const dp = new Array(1024).fill(s.length)\n  let res = 0,\n    mask = 0\n  dp[0] = -1\n  for (let i = 0; i < s.length; ++i) {\n    mask ^= 1 << +s.charAt(i)\n    res = Math.max(res, i - dp[mask])\n    for (let j = 0; j <= 9; ++j) res = Math.max(res, i - dp[mask ^ (1 << j)])\n    dp[mask] = Math.min(dp[mask], i)\n  }\n  return res\n}\n\n// another\n\n/**\n * @param {string} s\n * @return {number}\n */\nconst longestAwesome = function(s) {\n  const n = s.length, { max, min } = Math\n  const dp = Array(2 ** 10).fill(n)\n  let res = 0, mask = 0\n  dp[0] = -1\n  for(let i = 0; i < n; i++) {\n    mask ^= (1 << parseInt(s[i]))\n    res = max(res, i - dp[mask])\n    for(let j = 0; j <= 9; j++) {\n      const tmp = mask ^ (1 << j)\n      res = max(res, i - dp[tmp])\n    }\n    dp[mask] = min(i, dp[mask])\n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "1546-maximum-number-of-non-overlapping-subarrays-with-sum-equals-target",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nconst maxNonOverlapping = function(nums, target) {\n  if(nums == null || nums.length === 0) return 0\n  let sum = 0, res = 0\n  const n = nums.length\n  const m = {0: 0}\n  \n  for(let i = 0; i < n; i++) {\n    sum += nums[i]\n    if(m[sum - target] != null) {\n      res = Math.max(res, m[sum - target] + 1)\n    }\n    m[sum] = res\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1547-minimum-cost-to-cut-a-stick",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[]} cuts\n * @return {number}\n */\nconst minCost = function(n, cuts) {\n  const x = 100 + 2\n  const dp = Array.from({ length: x }, () => Array(x).fill(0))\n  cuts.push(0, n)\n  cuts.sort((a, b) => a - b)\n  const res = dfs(0, cuts.length - 1)\n  return res\n  function dfs(i, j) {\n    if(j - i <= 1) return 0\n    if(!dp[i][j]) {\n      dp[i][j] = Number.MAX_VALUE\n      for(let k = i + 1; k < j; k++) {\n        dp[i][j] = Math.min(dp[i][j], cuts[j] - cuts[i] + dfs(i, k) + dfs(k, j))\n      }\n    }\n    return dp[i][j]\n  }\n};\n\n// another\n\n/**\n * @param {number} n\n * @param {number[]} cuts\n * @return {number}\n */\nconst minCost = function (n, cuts) {\n  cuts.push(0, n)\n  cuts.sort((a, b) => a - b)\n  const N = cuts.length,\n    dp = Array.from({ length: N }, () => Array(N).fill(Infinity))\n  for(let i = 1; i < N; i++) dp[i - 1][i] = 0\n  for(let i = 2; i < N; i++) dp[i - 2][i] = cuts[i] - cuts[i - 2]\n  for (let l = 4; l <= N; l++) {\n    for (let i = 0; i <= N - l; i++) {\n      const j = i + l - 1\n      for (let k = i + 1; k < j; k++) {\n        dp[i][j] = Math.min(dp[i][j], cuts[j] - cuts[i] + dp[i][k] + dp[k][j])\n      }\n    }\n  }\n  return dp[0][N - 1]\n}\n"
    }
  },
  {
    "name": "155-min-stack",
    "code": {
      "JS": "/**\n * initialize your data structure here.\n */\nconst MinStack = function () {\n  this.stack = []\n  this.min = null\n}\n\n/**\n * @param {number} x\n * @return {void}\n */\nMinStack.prototype.push = function (x) {\n  if (this.min === null) {\n    this.min = x\n  } else {\n    this.min = Math.min(x, this.min)\n  }\n  return this.stack.push(x)\n}\n\n/**\n * @return {void}\n */\nMinStack.prototype.pop = function () {\n  let removed = this.stack.pop()\n  if (this.min === removed) {\n    this.min = this.stack.length > 0 ? Math.min(...this.stack) : null\n  }\n  return this.stack\n}\n\n/**\n * @return {number}\n */\nMinStack.prototype.top = function () {\n  return this.stack[this.stack.length - 1]\n}\n\n/**\n * @return {number}\n */\nMinStack.prototype.getMin = function () {\n  return this.min\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * var obj = new MinStack()\n * obj.push(x)\n * obj.pop()\n * var param_3 = obj.top()\n * var param_4 = obj.getMin()\n */\n"
    }
  },
  {
    "name": "1550-three-consecutive-odds",
    "code": {
      "JS": "/**\n * @param {number[]} arr\n * @return {boolean}\n */\nconst threeConsecutiveOdds = function(arr) {\n  for(let i = 1, n = arr.length; i < n - 1; i++) {\n    if(arr[i] & 1 === 1 && arr[i - 1] & 1 === 1 && arr[i + 1] & 1 === 1) return true\n  }\n  return false\n};\n"
    }
  },
  {
    "name": "1553-minimum-number-of-days-to-eat-n-oranges",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst minDays = function (n, dp = {}) {\n  if (n <= 1) return n\n  if (dp[n] == null)\n    dp[n] =\n      1 +\n      Math.min(\n        (n % 2) + minDays((n / 2) >> 0, dp),\n        (n % 3) + minDays((n / 3) >> 0, dp)\n      )\n  return dp[n]\n}\n"
    }
  },
  {
    "name": "1554-strings-differ-by-one-character",
    "code": {
      "JS": "/**\n * @param {string[]} dict\n * @return {boolean}\n */\n const differByOne = function(dict) {\n  const n = dict.length, m = dict[0].length\n  for (let j = 0; j < m; j++) {\n    const seen = new Set()\n    for(let i = 0; i < n; i++) {\n      const newStr = dict[i].slice(0, j) + '*' + dict[i].slice(j + 1)\n      if(seen.has(newStr)) return true\n      seen.add(newStr)\n    }\n  }\n\n  return false  \n};\n\n// another\n\n/**\n * @param {string[]} dict\n * @return {boolean}\n */\nconst differByOne = function (dict) {\n  const M = dict.length,\n    N = dict[0].length,\n    hash = Array(M).fill(0),\n    ord = (c) => c.charCodeAt(0),\n    MOD = 1e13, seen = new Set(),\n    zPlusOne = 'z'.charCodeAt(0)\n  // 1. generate each i-th rolling hash\n  for (let i = 0; i < M; ++i) {\n    let base = 1\n    for (let j = 0; j < N; ++j) {\n      hash[i] = (hash[i] + base * ord(dict[i][j])) % MOD\n      base = (zPlusOne * base) % MOD\n    }\n  }\n  // 2. remove each j-th char from each i-th rolling hash to find a diff collision\n  for (let i = 0; i < M; ++i) {\n    let base = 1\n    for (let j = 0; j < N; ++j) {\n      const diff = (hash[i] - base * ord(dict[i][j])) % MOD\n      if (seen.has(diff)) return true\n      seen.add(diff)\n      base = (zPlusOne * base) % MOD\n    }\n  }\n  return false\n}\n\n"
    }
  },
  {
    "name": "1559-detect-cycles-in-2d-grid",
    "code": {
      "JS": "/**\n * @param {character[][]} grid\n * @return {boolean}\n */\nconst containsCycle = function (grid) {\n  const dirs = [\n    [1, 0],\n    [-1, 0],\n    [0, 1],\n    [0, -1],\n  ]\n  const rows = grid.length\n  const cols = (grid[0] || []).length\n  const vis = Array.from({ length: rows }, () => Array(cols).fill(false))\n  let res = false\n  const dfs = (i, j, prevR, prevC, char) => {\n    vis[i][j] = true\n    for (let d of dirs) {\n      const r = i + d[0]\n      const c = j + d[1]\n      if (r >= 0 && r < rows && c >= 0 && c < cols) {\n        if (!(r == prevR && c === prevC)) {\n          if (grid[r][c] === char) {\n            if (!vis[r][c]) {\n              if (dfs(r, c, i, j, char)) return true\n            } else {\n              if (prevR !== -1 && prevC !== -1) return true\n            }\n          }\n        }\n      }\n    }\n    return false\n  }\n\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (!vis[i][j]) {\n        res |= dfs(i, j, -1, -1, grid[i][j])\n      }\n      if (res) return true\n    }\n  }\n  return res\n}\n\n// another\n\n/**\n * @param {character[][]} grid\n * @return {boolean}\n */\nconst containsCycle = function (grid) {\n  const wholePath = (r, c, letter, component, last = [-1, -1]) => {\n    const dirs = [\n      [0, -1],\n      [0, 1],\n      [-1, 0],\n      [1, 0],\n    ]\n    const tmp = grid[r][c]\n    grid[r][c] = component\n    const nextSteps = dirs\n      .map((x) => [x[0] + r, x[1] + c])\n      .filter(\n        (x) =>\n          x[0] >= 0 && x[0] < grid.length && x[1] >= 0 && x[1] < grid[0].length\n      )\n    for (let step of nextSteps) {\n      if (step[0] === last[0] && last[1] === step[1]) {\n        continue\n      }\n      if (grid[step[0]][step[1]] === component) {\n        return true\n      }\n      if (grid[step[0]][step[1]] === letter) {\n        let outcome = wholePath(step[0], step[1], letter, component, [r, c])\n        if (outcome) {\n          return true\n        }\n      }\n    }\n    return false\n  }\n\n  let component = 1\n  for (let r = 0; r < grid.length; r++) {\n    for (let c = 0; c < grid[0].length; c++) {\n      const letter = grid[r][c]\n      if (typeof letter === 'string') {\n        grid[r][c] = component\n        const outcome = wholePath(r, c, letter, component)\n        if (outcome) {\n          return true\n        }\n        component++\n      }\n    }\n  }\n  return false\n}\n"
    }
  },
  {
    "name": "156-binary-tree-upside-down",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nconst upsideDownBinaryTree = function(root) {\n  let node = root, parent = null, right = null\n  while(node !== null) {\n    const left = node.left\n    node.left = right\n    right = node.right\n    node.right = parent\n    parent = node\n    node = left\n  }\n  return parent\n};\n\n// another\n\nconst upsideDownBinaryTree = function(root) {\n  if (root == null || root.left == null) {\n    return root\n  }\n  const newRoot = upsideDownBinaryTree(root.left)\n  root.left.left = root.right\n  root.left.right = root\n  root.left = null\n  root.right = null\n  return newRoot\n}\n"
    }
  },
  {
    "name": "1560-most-visited-sector-in-a-circular-track",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[]} rounds\n * @return {number[]}\n */\nconst mostVisited = function(n, rounds) {\n  const arr = Array(n + 1).fill(0)\n  for(let i = 1, m = rounds.length; i < m; i++) {\n    let start = rounds[i - 1], end = rounds[i]\n\n    if(i == 1) arr[start]++\n    while(start !== end) {\n      start += 1\n      if (start === n + 1) start = 1\n      arr[start]++\n    }\n  }\n  const max = Math.max(...arr)\n  const res = []\n  for(let i = 1; i <= n; i++) {\n    if(arr[i] === max) res.push(i)\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1561-maximum-number-of-coins-you-can-get",
    "code": {
      "JS": "/**\n * @param {number[]} piles\n * @return {number}\n */\nconst maxCoins = function(piles) {\n  piles.sort((a, b) => a - b)\n  let coins = 0, n = piles.length\n  for(let j = 0, i = n - 2, hi = Math.floor(n / 3); j < hi; j++, i -= 2) {\n    coins += piles[i]\n  }\n  \n  return coins\n};\n"
    }
  },
  {
    "name": "1564-put-boxes-into-the-warehouse-i",
    "code": {
      "JS": "/**\n * @param {number[]} boxes\n * @param {number[]} warehouse\n * @return {number}\n */\nconst maxBoxesInWarehouse = function(boxes, warehouse) {\n  boxes.sort((a, b) => a - b)\n  const m = boxes.length, n = warehouse.length\n  let i = 0, j = 0\n  for(; i < m && j < n; i++) {\n    if(boxes[m - i - 1] <= warehouse[j]) {\n      j++\n    }\n    if(j === n) return n\n  }\n  return j\n};\n\n// another\n\n/**\n * @param {number[]} boxes\n * @param {number[]} warehouse\n * @return {number}\n */\nconst maxBoxesInWarehouse = function(boxes, warehouse) {\n  if(warehouse == null || warehouse.length === 0) return 0\n  const m = boxes.length, n = warehouse.length\n  for(let i = 1; i < n; i++) {\n    warehouse[i] = Math.min(warehouse[i], warehouse[i - 1])\n  }\n  boxes.sort((a, b) => a - b)\n  let res = 0\n  for(let i = n - 1; i >= 0; i--) {\n    if(res < m && boxes[res] <= warehouse[i]) res++\n  }\n  return res\n};\n\n// another\n\n/**\n * @param {number[]} boxes\n * @param {number[]} warehouse\n * @return {number}\n */\nconst maxBoxesInWarehouse = function(boxes, warehouse) {\n  if(warehouse == null || warehouse.length === 0) return 0\n  const m = boxes.length, n = warehouse.length\n  boxes.sort((a, b) => a - b)\n  let i = m - 1, res = 0\n  for(let house of warehouse) {\n    while(i >= 0 && boxes[i] > house) i--\n    if(i === -1) return res\n    res++\n    i--\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1567-maximum-length-of-subarray-with-positive-product",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst getMaxLen = function(nums) {\n  let res = 0, zeroIdx = -1, negIdx = -1, count = 0\n  for(let i = 0, len = nums.length; i < len; i++) {\n    if(nums[i] < 0) {\n      count++\n      if(negIdx === -1) negIdx = i\n    }\n    if(nums[i] === 0) {\n      count = 0\n      negIdx = -1\n      zeroIdx = i\n    } else {\n      if(count % 2 === 0) res = Math.max(res, i - zeroIdx)\n      else res = Math.max(res, i - negIdx)\n    }\n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "1568-minimum-number-of-days-to-disconnect-island",
    "code": {
      "JS": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nconst minDays = function (grid) {\n  if (!grid.length || !grid[0].length) return 0\n  if (numIslands(grid) != 1) return 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[0].length; j++) {\n      if (grid[i][j] == 1) {\n        grid[i][j] = 0\n        if (numIslands(grid) != 1) return 1\n        grid[i][j] = 1\n      }\n    }\n  }\n  return 2\n}\n\nfunction numIslands(grid) {\n  let m = Array.from({ length: grid.length }, (v, i) => {\n    return [...grid[i]]\n  })\n  let count = 0\n  for (let i = 0; i < m.length; i++)\n    for (let j = 0; j < m[0].length; j++) removeIslandAt(i, j, 1)\n  return count\n  function removeIslandAt(i, j, firstIteration = 0) {\n    if (i >= m.length || j >= m[0].length || i < 0 || j < 0 || m[i][j] == 0)\n      return\n    m[i][j] = 0\n    count += firstIteration\n    removeIslandAt(i - 1, j)\n    removeIslandAt(i + 1, j)\n    removeIslandAt(i, j - 1)\n    removeIslandAt(i, j + 1)\n  }\n}\n"
    }
  },
  {
    "name": "1569-number-of-ways-to-reorder-array-to-get-same-bst",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst numOfWays = function (nums) {\n  let root = null\n  let cache = new Map()\n\n  const MOD = BigInt(10 ** 9 + 7)\n  for (let n of nums) {\n    root = insert(root, n)\n  }\n\n  // f(root) -> [length, combination]\n  function f(root) {\n    if (!root.left && !root.right) {\n      return [1n, 1n]\n    }\n    let [ll, lc] = [0n, 1n]\n    let [rl, rc] = [0n, 1n]\n    if (root.left) {\n      ;[ll, lc] = f(root.left)\n    }\n    if (root.right) {\n      ;[rl, rc] = f(root.right)\n    }\n    // ((ll + rl)! / (ll! * rl!)  )* lc * rc\n    return [\n      ll + rl + 1n,\n      (factorial(ll + rl) / factorial(ll) / factorial(rl)) * lc * rc,\n    ]\n  }\n\n  return (f(root)[1] - 1n) % MOD\n\n  function Node(val) {\n    this.val = val\n    this.left = this.right = null\n  }\n\n  function insert(root, val) {\n    if (!root) {\n      return new Node(val)\n    }\n    if (root.val > val) {\n      root.left = insert(root.left, val)\n    } else if (root.val < val) {\n      root.right = insert(root.right, val)\n    }\n    return root\n  }\n\n  function factorial(n) {\n    if (n == 0n) {\n      return 1n\n    }\n    if (cache.has(n)) {\n      return cache.get(n)\n    }\n    let ans = 1n\n    for (let i = 2n; i <= n; i++) {\n      ans *= i\n      cache.set(i, ans)\n    }\n    return ans\n  }\n}\n"
    }
  },
  {
    "name": "157-read-n-characters-given-read4",
    "code": {
      "JS": "/**\n * Definition for read4()\n *\n * @param {character[]} buf Destination buffer\n * @return {number} The number of actual characters read\n * read4 = function(buf) {\n *     ...\n * };\n */\n\n/**\n * @param {function} read4()\n * @return {function}\n */\nconst solution = function(read4) {\n  const internalBuf = []\n  /**\n   * @param {character[]} buf Destination buffer\n   * @param {number} n Number of characters to read\n   * @return {number} The number of actual characters read\n   */\n  return function(buf, n) {\n    let readChars = 0\n    while (n > 0) {\n      if (internalBuf.length === 0) {\n        if (read4(internalBuf) === 0) {\n          return readChars\n        }\n      }\n      buf.push(internalBuf.shift())\n      readChars++\n      n--\n    }\n    return readChars\n  }\n}\n"
    }
  },
  {
    "name": "1570-dot-product-of-two-sparse-vectors",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {SparseVector}\n */\nconst SparseVector = function(nums) {\n  this.seen = {}\n  nums.forEach((e, i) => {\n    if(e !== 0) this.seen[i] = e\n  })\n};\n\n// Return the dotProduct of two sparse vectors\n/**\n * @param {SparseVector} vec\n * @return {number}\n */\nSparseVector.prototype.dotProduct = function(vec) {\n  let res = 0\n  for(let [k, v] of Object.entries(vec.seen)) {\n    if(k in this.seen) res += v * this.seen[k]\n  }\n  return res\n};\n\n// Your SparseVector object will be instantiated and called as such:\n// let v1 = new SparseVector(nums1);\n// let v2 = new SparseVector(nums2);\n// let ans = v1.dotProduct(v2);\n\n// another\n\nclass SparseVector {\n  /**\n   * @param {number[]} nums\n   * @return {SparseVector}\n   */\n  constructor(nums) {\n    // Space: O(n)\n    this.seen = new Map() // index -> value\n    for (let i = 0; i < nums.length; ++i) {\n      if (nums[i] !== 0) {\n        this.seen.set(i, nums[i])\n      }\n    }\n  }\n\n  /**\n   * Return the dotProduct of two sparse vectors\n   * @param {SparseVector} vec\n   * @return {number}\n   */\n  dotProduct(vec) {\n    // Time: O(n)\n    let sum = 0\n    for (const [i, val] of vec.seen) {\n      if (this.seen.has(i)) {\n        sum += val * this.seen.get(i)\n      }\n    }\n    return sum\n  }\n}\n\n// Your SparseVector object will be instantiated and called as such:\n// let v1 = new SparseVector(nums1);\n// let v2 = new SparseVector(nums2);\n// let ans = v1.dotProduct(v2);\n"
    }
  },
  {
    "name": "1572-matrix-diagonal-sum",
    "code": {
      "JS": "/**\n * @param {number[][]} mat\n * @return {number}\n */\nconst diagonalSum = function(mat) {\n  let res = 0, n = mat.length\n  for(let i = 0; i < n; i++) {\n    const j = i, ii = i, jj = n - 1 - i\n    if(j == jj) res += mat[i][j]\n    else {\n      res += mat[i][j] + mat[ii][jj]\n    }\n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "1575-count-all-possible-routes",
    "code": {
      "JS": "/**\n * @param {number[]} locations\n * @param {number} start\n * @param {number} finish\n * @param {number} fuel\n * @return {number}\n */\nconst countRoutes = function (locations, start, finish, fuel) {\n  const n = locations.length\n  const mod = 10 ** 9 + 7\n  const dp = Array.from({ length: n }, () => Array(fuel + 1).fill(-1))\n  return solve(start, finish, fuel)\n  function solve(curCity, e, fuel) {\n    if (fuel < 0) return 0\n    if (dp[curCity][fuel] !== -1) return dp[curCity][fuel]\n    let ans = curCity === e ? 1 : 0\n    for (let nextCity = 0; nextCity < locations.length; nextCity++) {\n      if (nextCity !== curCity) {\n        ans +=\n          solve(\n            nextCity,\n            e,\n            fuel - Math.abs(locations[curCity] - locations[nextCity])\n          ) % mod\n      }\n    }\n    return (dp[curCity][fuel] = ans % mod)\n  }\n}\n"
    }
  },
  {
    "name": "1576-replace-all-s-to-avoid-consecutive-repeating-characters",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {string}\n */\nconst modifyString = function(s) {\n  const arr = s.split('')\n  for(let i = 0, n = s.length; i < n; i++) {\n    const cur = arr[i]\n    if(cur === '?') {\n      for(let j = 0, a = 'a'.charCodeAt(0); j < 26; j++) {\n        const ch = String.fromCharCode(a + j)\n        if(\n          n === 1 ||\n          (i === 0 && i < n - 1 && ch !== arr[i + 1]) ||\n          (i > 0 && ch !== arr[i - 1] && i < n - 1 && ch !== arr[i + 1]) ||\n          (i=== n -1 && i - 1 >= 0 && ch !== arr[i - 1])\n        ) {\n          \n          arr[i] = ch\n          break\n        }\n      }\n    }\n  }\n  \n  return arr.join('')\n};\n\n\n// another\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst modifyString = function(s) {\n  const arr = s.split('')\n  for(let i = 0, n = s.length; i < n; i++) {\n    const cur = arr[i]\n    if(cur === '?') {\n      for(let j = 0, a = 'a'.charCodeAt(0); j < 26; j++) {\n        const ch = String.fromCharCode(a + j)\n        if(\n          (i === 0 || arr[i - 1] !== ch) &&\n          (i === n - 1 || arr[i + 1] !== ch)\n        ) {\n          \n          arr[i] = ch\n          break\n        }\n      }\n    }\n  }\n  \n  return arr.join('')\n};\n"
    }
  },
  {
    "name": "1578-minimum-deletion-cost-to-avoid-repeating-letters",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {number[]} cost\n * @return {number}\n */\nconst minCost = function (s, cost) {\n  let stackPointer = 0\n  let minVal = 0\n  for (let i = 1; i < s.length; i++) {\n    if (s[i - 1] === s[i]) {\n      if (cost[stackPointer] < cost[i]) {\n        minVal += cost[stackPointer]\n        stackPointer = i\n      } else {\n        minVal += cost[i]\n      }\n    } else {\n      stackPointer = i\n    }\n  }\n  return minVal\n}\n"
    }
  },
  {
    "name": "1579-remove-max-number-of-edges-to-keep-graph-fully-traversable",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {number}\n */\nconst maxNumEdgesToRemove = function (n, edges) {\n  edges.sort((a, b) => b[0] - a[0])\n  let edgesAdded = 0\n  const bob = new UnionFind(n)\n  const alice = new UnionFind(n)\n  for (let edge of edges) {\n    let type = edge[0],\n      one = edge[1],\n      two = edge[2]\n    switch (type) {\n      case 3:\n        edgesAdded += bob.unite(one, two) | alice.unite(one, two)\n        break\n      case 2:\n        edgesAdded += bob.unite(one, two)\n        break\n      case 1:\n        edgesAdded += alice.unite(one, two)\n        break\n    }\n  }\n  return bob.united() && alice.united() ? edges.length - edgesAdded : -1\n}\nclass UnionFind {\n  constructor(n) {\n    this.component = []\n    this.distinctComponents = n\n    for (let i = 0; i <= n; i++) this.component.push(i)\n  }\n  unite(a, b) {\n    const ar = this.find(a)\n    if (ar !== this.find(b)) {\n      this.component[ar] = b\n      this.distinctComponents--\n      return true\n    }\n    return false\n  }\n  find(a) {\n    if (this.component[a] != a) {\n      this.component[a] = this.find(this.component[a])\n    }\n    return this.component[a]\n  }\n  united() {\n    return this.distinctComponents === 1\n  }\n}\n"
    }
  },
  {
    "name": "158-read-n-characters-given-read4-ii-call-multiple-times",
    "code": {
      "JS": "/**\n * Definition for read4()\n *\n * @param {character[]} buf Destination buffer\n * @return {number} The number of characters read\n * read4 = function(buf) {\n *     ...\n * };\n */\n\n/**\n * @param {function} read4()\n * @return {function}\n */\nconst solution = function(read4) {\n  const internalBuf = []\n  /**\n   * @param {character[]} buf Destination buffer\n   * @param {number} n Number of characters to read\n   * @return {number} The number of actual characters read\n   */\n  return function(buf, n) {\n    let readChars = 0\n    while (n > 0) {\n      if (internalBuf.length === 0) {\n        if (read4(internalBuf) === 0) {\n          return readChars\n        }\n      }\n      buf.push(internalBuf.shift())\n      readChars++\n      n--\n    }\n    return readChars\n  }\n}\n"
    }
  },
  {
    "name": "1585-check-if-string-is-transformable-with-substring-sort-operations",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nconst isTransformable = function (s, t) {\n  const offset = '0'.charCodeAt(0)\n  const indices = Array.from({ length: 10 }, () => [])\n  for (let i = s.length - 1; i >= 0; --i) {\n    indices[s.charCodeAt(i) - offset].push(i)\n  }\n  for (const char of t) {\n    const digit = char.charCodeAt(0) - offset\n    if (indices[digit].length === 0) return false\n    const pos = indices[digit][indices[digit].length - 1]\n    for (let d = 0; d < digit; ++d) {\n      if (indices[d].length && indices[d][indices[d].length - 1] < pos) {\n        return false\n      }\n    }\n    indices[digit].pop()\n  }\n  return true\n}\n"
    }
  },
  {
    "name": "1586-binary-search-tree-iterator-ii",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n */\nconst BSTIterator = function(root) {\n  this.r = root\n  const ans = []\n  helper(root, ans)\n  this.arr = ans\n  this.cur = -1\n};\n\n/**\n * @return {boolean}\n */\nBSTIterator.prototype.hasNext = function() {\n  return this.arr.length && this.cur < this.arr.length - 1\n};\n\n/**\n * @return {number}\n */\nBSTIterator.prototype.next = function() {\n  this.cur += 1\n  return this.arr[this.cur]\n};\n\n/**\n * @return {boolean}\n */\nBSTIterator.prototype.hasPrev = function() {\n  return this.arr.length && this.cur > 0\n};\n\n/**\n * @return {number}\n */\nBSTIterator.prototype.prev = function() {\n  return this.arr[--this.cur]\n};\n\nfunction helper(node, res) {\n  if(node == null) return\n  if(node.left) {\n    helper(node.left, res)\n  }\n  res.push(node.val)\n  if(node.right) {\n    helper(node.right, res)\n  }\n}\n\n/** \n * Your BSTIterator object will be instantiated and called as such:\n * var obj = new BSTIterator(root)\n * var param_1 = obj.hasNext()\n * var param_2 = obj.next()\n * var param_3 = obj.hasPrev()\n * var param_4 = obj.prev()\n */\n\n// another\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n */\nconst BSTIterator = function (root) {\n  this.nums = []\n  this.stack = []\n  this.node = root\n  this.i = 0 // pointer to next node\n  this.size = 0\n}\n\n/**\n * @return {boolean}\n */\nBSTIterator.prototype.hasNext = function () {\n  return this.i < this.size || this.stack.length > 0 || !!this.node\n}\n\n/**\n * @return {number}\n */\nBSTIterator.prototype.next = function () {\n  if (this.i < this.size) return this.nums[this.i++]\n  if (this.stack.length || this.node) {\n    while (this.node) {\n      this.stack.push(this.node)\n      this.node = this.node.left\n    }\n    this.node = this.stack.pop()\n    this.i += 1\n    this.size += 1\n    const val = this.node.val\n    this.nums.push(val)\n    this.node = this.node.right\n    return val\n  }\n  return -1\n}\n\n/**\n * @return {boolean}\n */\nBSTIterator.prototype.hasPrev = function () {\n  return this.i - 2 >= 0\n}\n\n/**\n * @return {number}\n */\nBSTIterator.prototype.prev = function () {\n  return this.nums[--this.i - 1]\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * var obj = new BSTIterator(root)\n * var param_1 = obj.hasNext()\n * var param_2 = obj.next()\n * var param_3 = obj.hasPrev()\n * var param_4 = obj.prev()\n */\n\n"
    }
  },
  {
    "name": "1588-sum-of-all-odd-length-subarrays",
    "code": {
      "JS": "/**\n * @param {number[]} arr\n * @return {number}\n */\nconst sumOddLengthSubarrays = function(arr) {\n  const n = arr.length, pre = Array(n + 1).fill(0)\n  for(let i = 0; i < n; i++) pre[i + 1] = pre[i] +  arr[i]\n  \n  let res = 0\n  let len = 1\n  while(len <= n) {\n    for(let i = 0; i <= n - len; i++) {\n      res += pre[i + len] - pre[i] // len === 1: 1 - 0, 2 - 1\n                                   // len === 3: 3 - 0, 6 - 3\n    }\n    \n    len += 2\n  }\n  \n  return res\n  \n};\n"
    }
  },
  {
    "name": "1589-maximum-sum-obtained-of-any-permutation",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number[][]} requests\n * @return {number}\n */\nconst maxSumRangeQuery = function (nums, requests) {\n  let res = 0\n  const mod = 10 ** 9 + 7,\n    n = nums.length\n  const count = Array(n).fill(0)\n  for (let r of requests) {\n    count[r[0]] += 1\n    if (r[1] + 1 < n) count[r[1] + 1] -= 1\n  }\n  for (let i = 1; i < n; i++) count[i] += count[i - 1]\n  nums.sort((a, b) => a - b)\n  count.sort((a, b) => a - b)\n  for (let i = 0; i < n; ++i) res = (res + nums[i] * count[i]) % mod\n  return res\n}\n\n// another\n\n/**\n * @param {number[]} nums\n * @param {number[][]} requests\n * @return {number}\n */\nconst maxSumRangeQuery = function (nums, requests) {\n  const n = nums.length, arr = Array(n + 1).fill(0)\n  for(let [s, e] of requests) {\n    arr[s] += 1\n    arr[e + 1] -= 1\n  }\n  for(let i = 0, cur = 0; i < n; i++) {\n    cur += arr[i]\n    arr[i] = cur\n  }\n  nums.sort((a, b) => b - a)\n  arr.sort((a, b) => b - a)\n  const mod = 1e9 + 7\n  let res = 0\n  for(let i = 0; i < n; i++) {\n    if (arr[i] <= 0) break\n    res = (res + nums[i] * arr[i]) % mod\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "159-longest-substring-with-at-most-two-distinct-characters",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst lengthOfLongestSubstringTwoDistinct = function(s) {\n  const map = new Map()\n  let start = 0,\n    end = 0,\n    counter = 0,\n    len = 0\n  while (end < s.length) {\n    let c = s.charAt(end)\n    map.set(c, (map.get(c) || 0) + 1)\n    if (map.get(c) === 1) counter++\n    end++\n    while (counter > 2) {\n      let cTemp = s.charAt(start)\n      map.set(cTemp, map.get(cTemp) - 1)\n      if (map.get(cTemp) === 0) {\n        counter--\n      }\n      start++\n    }\n    len = Math.max(len, end - start)\n  }\n  return len\n}\n"
    }
  },
  {
    "name": "1590-make-sum-divisible-by-p",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} p\n * @return {number}\n */\nconst minSubarray = function(nums, p) {\n  const diff = nums.reduce((a, b) => a + b, 0) % p;\n  let res = diff === 0 ? 0 : nums.length;\n  \n  for (let i = 0, sum = 0, map = {0: -1}; i < nums.length; i++) {\n    sum += nums[i];\n    const target = (sum % p - diff + p) % p;\n    if (map[target] !== undefined) {\n      res = Math.min(res, i - map[target]);\n    }\n    map[sum % p] = i;\n  }\n  \n  return res === nums.length ? -1 : res;\n};\n\n/**\n\nLet pre[] be the prefix sum array,\nthen pre[i] is running prefix sum or prefix sum of i elements,\npre[j] is the prefix sum such that pre[i]-pre[j] is the subarray we\nneed to remove to make pre[n] (sum of all elements) divisible by p\n\n(pre[n] - (pre[i]-pre[j])) % p = 0 ... (remove a subarray to make pre[n] divisible by p)\n=> pre[n] % p = (pre[i]-pre[j]) % p ... ((a-b)%m = a%m - b%m)\n=> pre[j]%p = pre[i]%p - pre[n]%p ... (same property used above)\nsince RHS can be negative we make it positive modulus by adding p and taking modulus\n=> pre[j]%p = (pre[i]%p - pre[n]%p + p) % p\n\n*/\n"
    }
  },
  {
    "name": "1591-strange-printer-ii",
    "code": {
      "JS": "/**\n * @param {number[][]} targetGrid\n * @return {boolean}\n */\nconst isPrintable = function (targetGrid) {\n  const posMin = Array.from({ length: 61 }, () => Array(2).fill(61))\n  const posMax = Array.from({ length: 61 }, () => Array(2).fill(0))\n  const m = targetGrid.length\n  const n = targetGrid[0].length\n  let colorSet = new Set()\n\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      let c = targetGrid[i][j]\n      colorSet.add(c)\n      posMin[c][0] = Math.min(posMin[c][0], i) //Up\n      posMin[c][1] = Math.min(posMin[c][1], j) //Left\n      posMax[c][0] = Math.max(posMax[c][0], i) //Down\n      posMax[c][1] = Math.max(posMax[c][1], j) //Right\n    }\n  }\n  while (colorSet.size) {\n    const tmp = new Set()\n    for (let color of colorSet) {\n      if (!isRect(targetGrid, color)) {\n        tmp.add(color)\n      }\n    }\n\n    if (tmp.size === colorSet.size) return false\n    colorSet = tmp\n  }\n\n  return true\n\n  function isRect(A, c) {\n    for (let i = posMin[c][0]; i <= posMax[c][0]; i++) {\n      for (let j = posMin[c][1]; j <= posMax[c][1]; j++) {\n        if (A[i][j] > 0 && A[i][j] !== c) return false\n      }\n    }\n\n    for (let i = posMin[c][0]; i <= posMax[c][0]; i++) {\n      for (let j = posMin[c][1]; j <= posMax[c][1]; j++) {\n        A[i][j] = 0\n      }\n    }\n\n    return true\n  }\n}\n\n// another\n\n/**\n * @param {number[][]} targetGrid\n * @return {boolean}\n */\nconst isPrintable = function (targetGrid) {\n  /*\n     1 -> 3\n     1 -> 4\n     1 -> 5\n     3 -> 4\n    */\n\n  const dependencies = {}\n\n  /*\n    3: [mini, maxi, minj, maxj]\n    */\n  const extents = {}\n\n  for (let i = 0; i < targetGrid.length; i++) {\n    for (let j = 0; j < targetGrid[i].length; j++) {\n      const n = targetGrid[i][j]\n      let inf = Infinity\n      extents[n] = extents[n] || {\n        n,\n        mini: inf,\n        minj: inf,\n        maxi: -inf,\n        maxj: -inf,\n      }\n      extents[n].mini = Math.min(i, extents[n].mini)\n      extents[n].minj = Math.min(j, extents[n].minj)\n      extents[n].maxi = Math.max(i, extents[n].maxi)\n      extents[n].maxj = Math.max(j, extents[n].maxj)\n    }\n  }\n\n  function canRemove(obj) {\n    for (let i = obj.mini; i <= obj.maxi; i++) {\n      for (let j = obj.minj; j <= obj.maxj; j++) {\n        const val = targetGrid[i][j]\n        if (val !== null && val !== obj.n) return false\n      }\n    }\n    return true\n  }\n\n  function remove(obj) {\n    for (let i = obj.mini; i <= obj.maxi; i++) {\n      for (let j = obj.minj; j <= obj.maxj; j++) {\n        targetGrid[i][j] = null\n      }\n    }\n    delete extents[obj.n]\n  }\n\n  while (Object.keys(extents).length > 0) {\n    let found = false\n    for (const n in extents) {\n      const obj = extents[n]\n      if (canRemove(obj)) {\n        remove(obj)\n        found = true\n        break\n      }\n    }\n    if (!found) {\n      return false\n    }\n  }\n  return true\n}\n\n"
    }
  },
  {
    "name": "1592-rearrange-spaces-between-words",
    "code": {
      "JS": "/**\n * @param {string} text\n * @return {string}\n */\nconst reorderSpaces = function(text) {\n  let sc = 0\n  for(let i = 0, len = text.length; i < len; i++) {\n    if(text[i] === ' ') sc++\n  }\n  const arr = text.split(' ').filter(e => e!= '')\n  const num = arr.length - 1\n  const remain = num === 0 ? sc : sc % num\n  const split = num === 0 ? 0 : Array( (sc / num) >> 0 ).fill(0).reduce((ac, el) => ac + ' ', '')\n  let res = ''\n  res = arr.join(split) + helper(remain)\n  return res\n};\n\nfunction helper(n) {\n  let res = ''\n  for(let i = 0; i < n; i++) res += ' '\n  return res\n}\n"
    }
  },
  {
    "name": "1593-split-a-string-into-the-max-number-of-unique-substrings",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst maxUniqueSplit = function(s) {\n  return bt(s, '', 0, new Set())\n};\n\nfunction bt(str, cur, idx, useds) {\n  if(idx === str.length) return useds.size\n  cur += str[idx]\n  if(useds.has(cur)) return bt(str, cur, idx +1, useds)\n  else {\n    let ans = 0\n    useds.add(cur)\n    ans = Math.max(ans, bt(str, '', idx+1, useds))\n    useds.delete(cur)\n    ans = Math.max(ans, bt(str, cur, idx+1, useds))\n    return ans\n  }\n}\n\n// another\n\n/**\n * @param {string} s\n * @return {number}\n */\nconst maxUniqueSplit = function (s) {\n  const N = s.length\n  let ans = -1\n  let curr = new Set()\n  const backtrack = (pos) => {\n    if (pos === N) {\n      ans = Math.max(ans, curr.size)\n      return\n    }\n    if (curr.size + (N - pos) <= ans) return\n    for (let i = pos + 1; i <= N; i++) {\n      const a = s.slice(pos, i)\n      if (curr.has(a)) continue\n      curr.add(a)\n      backtrack(i)\n      curr.delete(a)\n    }\n  }\n\n  backtrack(0)\n  return ans\n}\n\n"
    }
  },
  {
    "name": "1594-maximum-non-negative-product-in-a-matrix",
    "code": {
      "JS": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nconst maxProductPath = function (grid) {\n  const m = grid.length,\n    n = grid[0].length,\n    MOD = 1e9 + 7;\n  const mx = Array.from({ length: m }, () => Array(n).fill(0));\n  const mn = Array.from({ length: m }, () => Array(n).fill(0));\n  mx[0][0] = mn[0][0] = grid[0][0];\n\n  // initialize the top and left sides\n  for (let i = 1; i < m; i++) {\n    mn[i][0] = mx[i][0] = mx[i - 1][0] * grid[i][0];\n  }\n  for (let j = 1; j < n; j++) {\n    mn[0][j] = mx[0][j] = mx[0][j - 1] * grid[0][j];\n  }\n\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      if (grid[i][j] < 0) {\n        // smallest negative * negative number = largest\n        mx[i][j] = Math.min(mn[i - 1][j], mn[i][j - 1]) * grid[i][j];\n        mn[i][j] = Math.max(mx[i - 1][j], mx[i][j - 1]) * grid[i][j];\n      } else {\n        // largest product * positive number = largest\n        mx[i][j] = Math.max(mx[i - 1][j], mx[i][j - 1]) * grid[i][j];\n        mn[i][j] = Math.min(mn[i - 1][j], mn[i][j - 1]) * grid[i][j];\n      }\n    }\n  }\n\n  let ans = mx[m - 1][n - 1] % MOD;\n  return ans < 0 ? -1 : ans;\n};\n"
    }
  },
  {
    "name": "1595-minimum-cost-to-connect-two-groups-of-points",
    "code": {
      "JS": "/**\n * @param {number[][]} cost\n * @return {number}\n */\nconst connectTwoGroups = function (cost) {\n  const min = Array(cost[0].length).fill(Infinity)\n  for (let j = 0; j < min.length; j++) {\n    for (let i = 0; i < cost.length; i++) {\n      min[j] = Math.min(min[j], cost[i][j])\n    }\n  }\n  const dp = Array.from({ length: 13 }, () => Array(4096).fill(-1))\n  return dfs(cost, min, 0, 0, dp)\n}\n\nfunction dfs(cost, min, i, mask, dp) {\n  if (dp[i][mask] !== -1) return dp[i][mask]\n  let res = i >= cost.length ? 0 : Infinity\n  if (i >= cost.length) {\n    for (let j = 0; j < cost[0].length; j++) {\n      if ((mask & (1 << j)) === 0) res += min[j]\n    }\n  } else {\n    for (let j = 0; j < cost[0].length; j++) {\n      res = Math.min(\n        res,\n        cost[i][j] + dfs(cost, min, i + 1, mask | (1 << j), dp)\n      )\n    }\n  }\n  dp[i][mask] = res\n  return res\n}\n\n// another\n\n/**\n * @param {number[][]} cost\n * @return {number}\n */\nconst connectTwoGroups = function (cost) {\n  const n = cost.length\n  const m = cost[0].length\n  const con = 1 << m\n  const dp = Array(n + 1)\n    .fill(null)\n    .map(() => Array(con).fill(0))\n  const min = Array(m).fill(Infinity)\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      min[j] = Math.min(min[j], cost[i][j])\n    }\n  }\n  function dfs(i, mask) {\n    let res\n    if (dp[i][mask]) {\n      return dp[i][mask]\n    } else if (i >= n) {\n      res = 0\n      for (let j = 0; j < m; j++) {\n        const binaryJ = 1 << j\n        if ((mask & binaryJ) === 0) res += min[j]\n      }\n    } else {\n      res = Infinity\n      for (let j = 0; j < m; j++) {\n        const binaryJ = 1 << j\n        res = Math.min(res, cost[i][j] + dfs(i + 1, mask | binaryJ))\n      }\n    }\n    dp[i][mask] = res\n    return res\n  }\n  return dfs(0, 0)\n}\n"
    }
  },
  {
    "name": "1597-build-binary-expression-tree-from-infix-expression",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function Node(val, left, right) {\n *     this.val = (val===undefined ? \" \" : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {string} s\n * @return {Node}\n */\nconst expTree = function (s) {\n  const n = s.length\n  const head = new Node()\n  let i = 0\n  const number = () => {\n    let num = ''\n    while (i < n && '0' <= s[i]) {\n      num += s[i++]\n    }\n    return new Node(Number(num))\n  }\n  const factor = () => {\n    if (s[i] === '(') {\n      i++\n      const node = expression()\n      i++\n      return node\n    }\n    return number()\n  }\n  const term = () => {\n    let left = factor()\n    while (i < n && (s[i] === '*' || s[i] === '/')) {\n      const op = new Node(s[i++])\n      const right = factor()\n      op.left = left\n      op.right = right\n      left = op\n    }\n    return left\n  }\n  const expression = () => {\n    let left = term()\n    while (i < s.length && (s[i] === '+' || s[i] === '-')) {\n      const op = new Node(s[i++])\n      const right = term()\n      op.left = left\n      op.right = right\n      left = op\n    }\n    return left\n  }\n  return expression()\n}\n\n\n// another\n\n/**\n * Definition for a binary tree node.\n * function Node(val, left, right) {\n *     this.val = (val===undefined ? \" \" : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {string} s\n * @return {Node}\n */\nconst expTree = function(s) {\n  const list = s.split('')\n  const mdSet = new Set(['*', '/'])\n  const amSet = new Set(['+', '-'])\n  return parseExpression(list)\n  \n  function parseExpression(tokens) {\n    let lhs = parseTerm(tokens)\n    while(tokens.length && amSet.has(tokens[0])) {\n      const op = tokens.shift()\n      const rhs = parseTerm(tokens)\n      lhs = new Node(op, lhs, rhs)\n    }\n    return lhs\n  }\n  function parseTerm(tokens) {\n    let lhs = parseFactor(tokens)\n    while(tokens.length && mdSet.has(tokens[0])) {\n      const op = tokens.shift()\n      const rhs = parseFactor(tokens)\n      lhs = new Node(op, lhs, rhs)\n    }\n    return lhs\n  }\n  function parseFactor(tokens) {\n    if(tokens[0] === '(') {\n      tokens.shift()\n      const node = parseExpression(tokens)\n      tokens.shift()\n      return node\n    } else {\n      const token = tokens.shift()\n      return new Node(token)\n    } \n  }\n};\n"
    }
  },
  {
    "name": "1598-crawler-log-folder",
    "code": {
      "JS": "/**\n * @param {string[]} logs\n * @return {number}\n */\nconst minOperations = function(logs) {\n  const stack = []\n  for(let i = 0, len = logs.length; i < len; i++) {\n    const e= logs[i]\n    if(e === '../') {\n      stack.pop()\n    } else if (e === './') {\n      \n    } else {\n      stack.push(e)\n    }\n  }\n  return stack.length\n};\n"
    }
  },
  {
    "name": "1599-maximum-profit-of-operating-a-centennial-wheel",
    "code": {
      "JS": "/**\n * @param {number[]} customers\n * @param {number} boardingCost\n * @param {number} runningCost\n * @return {number}\n */\nconst minOperationsMaxProfit = function(customers, boardingCost, runningCost) {\n  let remain = 0\n  let profit = 0\n  let cost = 0\n  let max = -Infinity\n  let maxNum = 0\n  for(let i = 0, len = customers.length; i < len; i++) {\n    const e = customers[i]\n    remain += e\n    const cur = (remain >= 4 ? 4 : remain)\n    remain -= cur\n    profit += cur * boardingCost - runningCost\n    if(profit > max) maxNum++\n    max = Math.max(max, profit)\n  }\n  if(remain) {\n    const r = Math.floor(remain / 4)\n    const single = 4 * boardingCost - runningCost\n    remain = remain % 4\n    // profit += (single * r + (remain > 0 ? (remain * boardingCost - runningCost) : 0))\n    profit += single * r\n    if(single > 0) maxNum += r\n    max = Math.max(max, profit)\n    if (remain < 4) {\n      const tmp = remain * boardingCost - runningCost\n      profit += tmp\n      remain = 0\n      if(profit > max) maxNum++\n      max = Math.max(max, profit)\n    }\n  }\n  if (max <=0 )return -1\n  return maxNum\n};\n"
    }
  },
  {
    "name": "16-3sum-closest",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n * @param {number} target\r\n * @return {number}\r\n */\r\nconst threeSumClosest = function(nums, target) {\r\n  const nums = nums.sort((a, b) => a - b);\r\n  let result;\r\n  let lo;\r\n  let hi;\r\n  let sum;\r\n  result = nums[0] + nums[1] + nums[nums.length - 1];\r\n  for (let i = 0; i < nums.length - 2; i++) {\r\n    lo = i + 1;\r\n    hi = nums.length - 1;\r\n    while (lo < hi) {\r\n      sum = nums[i] + nums[lo] + nums[hi];\r\n      if (sum < target) {\r\n        while (lo < hi && nums[lo] === nums[lo + 1]) {\r\n          lo += 1;\r\n        }\r\n        lo += 1;\r\n      } else if (sum > target) {\r\n        while (lo < hi && nums[hi] === nums[hi - 1]) {\r\n          hi -= 1;\r\n        }\r\n        hi -= 1;\r\n      } else {\r\n        return sum;\r\n      }\r\n\r\n      if (Math.abs(target - sum) < Math.abs(target - result)) {\r\n        result = sum;\r\n      }\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n"
    }
  },
  {
    "name": "160-intersection-of-two-linked-lists",
    "code": {
      "JS": "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nconst getIntersectionNode = function(headA, headB) {\n  let a = headA, b = headB\n  while(a !== b) {\n    a = a == null ? headB : a.next\n    b = b == null ? headA : b.next\n  }\n  return a\n};\n\n// another\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nconst getIntersectionNode = function(headA, headB) {\n    let aend = null\n    let bend = null\n    let ahead = headA\n    let bhead = headB\n    while(headA !== null && headB !== null) {\n        if (aend !== null && bend !== null && aend !== bend) {\n            return null\n        }\n\n        if (headA === headB) {\n            return headA\n        }\n\n        if (headA.next === null) {\n            if(aend === null) {\n                aend = headA\n            }\n            headA = bhead\n        } else {\n            headA = headA.next\n\n        }\n        if (headB.next === null) {\n            if(bend === null) {\n                bend = headB\n            }\n            headB = ahead\n        } else {\n            headB = headB.next\n        }\n\n    }\n\n};\n"
    }
  },
  {
    "name": "1600-throne-inheritance",
    "code": {
      "JS": "/**\n * @param {string} kingName\n */\nconst ThroneInheritance = function(kingName) {\n  this.king = kingName\n  this.m = {}\n  this.dead = {}\n};\n\n/** \n * @param {string} parentName \n * @param {string} childName\n * @return {void}\n */\nThroneInheritance.prototype.birth = function(parentName, childName) {\n  if(!this.m[parentName]) this.m[parentName] = []\n  this.m[parentName].push(childName)\n};\n\n/** \n * @param {string} name\n * @return {void}\n */\nThroneInheritance.prototype.death = function(name) {\n  this.dead[name] = 1\n};\n\n/**\n * @return {string[]}\n */\nThroneInheritance.prototype.getInheritanceOrder = function() {\n  const res = []\n  this.dfs(res, this.king)\n  return res\n};\nThroneInheritance.prototype.dfs = function(ans, root) {\n  if (!this.dead[root]) {\n    ans.push(root);\n  }\n  if(!this.m[root]) return\n  for (let child of this.m[root]) {\n    this.dfs(ans, child);\n  }\n};\n/** \n * Your ThroneInheritance object will be instantiated and called as such:\n * var obj = new ThroneInheritance(kingName)\n * obj.birth(parentName,childName)\n * obj.death(name)\n * var param_3 = obj.getInheritanceOrder()\n */\n"
    }
  },
  {
    "name": "1601-maximum-number-of-achievable-transfer-requests",
    "code": {
      "JS": "// O(n * 2 ^ r) \n// r: number of requests\n/**\n * @param {number} n\n * @param {number[][]} requests\n * @return {number}\n */\nconst maximumRequests = function(n, requests) {\n  const arr = Array(n).fill(0)\n  let res = 0\n  bt(requests, 0, arr, 0)\n  return res\n  function bt(r, idx, arr, num) {\n    if(idx === r.length) {\n      for(let i = 0; i < n; i++) {\n        if(arr[i] !== 0) return\n      }\n      res = Math.max(res, num)\n      return\n    }\n    const [from, to] = r[idx]\n    arr[from]++\n    arr[to]--\n    bt(r, idx + 1, arr, num + 1)\n    arr[from]--\n    arr[to]++\n    \n    bt(r, idx + 1, arr, num)\n  }\n};\n\n\n// another\n\n/**\n * @param {number} n\n * @param {number[][]} requests\n * @return {number}\n */\nconst maximumRequests = function (n, requests) {\n  let max = 0\n  helper(requests, 0, Array(n).fill(0), 0)\n  return max\n\n  function helper(requests, index, count, num) {\n    // Traverse all n buildings to see if they are all 0. (means balanced)\n    if (index === requests.length) {\n      for (let i of count) {\n        if (0 !== i) {\n          return\n        }\n      }\n      max = Math.max(max, num)\n      return\n    }\n    // Choose this request\n    count[requests[index][0]]++\n    count[requests[index][1]]--\n    helper(requests, index + 1, count, num + 1)\n    count[requests[index][0]]--\n    count[requests[index][1]]++\n\n    // Not Choose the request\n    helper(requests, index + 1, count, num)\n  }\n}\n"
    }
  },
  {
    "name": "1602-find-nearest-right-node-in-binary-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} u\n * @return {TreeNode}\n */\nconst findNearestRightNode = function(root, u) {\n  const q = [root]\n  while(q.length) {\n    const size = q.length\n    let target = false\n    for(let i = 0; i < size; i++) {\n      const tmp = q.shift()\n      if(target) return tmp\n      if(tmp === u) target = true\n      if(tmp.left) q.push(tmp.left)\n      if(tmp.right) q.push(tmp.right)\n    }\n  }     \n  return null\n};\n"
    }
  },
  {
    "name": "1603-design-parking-system",
    "code": {
      "JS": "/**\n * @param {number} big\n * @param {number} medium\n * @param {number} small\n */\nconst ParkingSystem = function(big, medium, small) {\n  this['3'] = small\n  this['2'] = medium\n  this['1'] = big\n};\n\n/** \n * @param {number} carType\n * @return {boolean}\n */\nParkingSystem.prototype.addCar = function(carType) {\n  this[carType]--\n  if(this[carType] < 0) {\n    this[carType] = 0\n    return false\n  }\n  return true\n};\n\n/** \n * Your ParkingSystem object will be instantiated and called as such:\n * var obj = new ParkingSystem(big, medium, small)\n * var param_1 = obj.addCar(carType)\n */\n"
    }
  },
  {
    "name": "1605-find-valid-matrix-given-row-and-column-sums",
    "code": {
      "JS": "/**\n * @param {number[]} rowSum\n * @param {number[]} colSum\n * @return {number[][]}\n */\nconst restoreMatrix = function(rowSum, colSum) {\n  const m = rowSum.length, n = colSum.length;\n  const res = Array.from({ length: m }, () => Array(n).fill(0));\n  for (let i = 0; i < m; ++i) {\n    for (let j = 0 ; j < n; ++j) {\n      res[i][j] = Math.min(rowSum[i], colSum[j]);\n      rowSum[i] -= res[i][j];\n      colSum[j] -= res[i][j];\n    }\n  }\n  return res;\n};\n\n// another\n\n/**\n * @param {number[]} rowSum\n * @param {number[]} colSum\n * @return {number[][]}\n */\nconst restoreMatrix = function(rowSum, colSum) {\n  const m = rowSum.length, n = colSum.length\n  const res = Array.from({ length: m }, () => Array(n).fill(0))\n  for(let i = 0; i < m; i++) {\n    for(let j = 0; j < n; j++) {\n      res[i][j] = Math.min(rowSum[i], colSum[j])\n      rowSum[i] -= res[i][j]\n      colSum[j] -= res[i][j]\n    }\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1606-find-servers-that-handled-most-number-of-requests",
    "code": {
      "JS": "/**\n * @param {number} k\n * @param {number[]} arrival\n * @param {number[]} load\n * @return {number[]}\n */\nconst busiestServers = function (k, arrival, load) {\n  const ark = []\n  const map = new Map()\n  let max = 0\n  for (let i = 0; i < arrival.length; i++) {\n    if (i < k) {\n      ark[i] = arrival[i] + load[i]\n      map.set(i, 1)\n      max = Math.max(max, map.get(i))\n    } else {\n      let server = i % k\n      const curr = server\n      while (server < k) {\n        if (ark[server] <= arrival[i]) {\n          ark[server] = arrival[i] + load[i]\n          map.set(server, map.has(server) ? map.get(server) + 1 : 1)\n          max = Math.max(max, map.get(server))\n          break\n        }\n        server++\n      }\n      if (server === k) {\n        let l = 0\n        while (l < curr) {\n          if (ark[l] <= arrival[i]) {\n            ark[l] = arrival[i] + load[i]\n            map.set(l, map.has(l) ? map.get(l) + 1 : 1)\n            max = Math.max(max, map.get(l))\n            break\n          }\n          l++\n        }\n      }\n    }\n  }\n\n  const result = []\n  const entries = map[Symbol.iterator]()\n  for (let en of entries) {\n    if (en[1] === max) {\n      result.push(en[0])\n    }\n  }\n  return result\n}\n"
    }
  },
  {
    "name": "1608-special-array-with-x-elements-greater-than-or-equal-x",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst specialArray = function(nums) {\n  let l = -1, r = 1001\n  while(l <= r) {\n    const mid = r - Math.floor((r - l) / 2)\n    const tmp = valid(mid)\n    if(tmp === mid) return mid\n    else if(tmp > mid) l = mid + 1\n    else r = mid - 1\n  }\n  return -1\n  \n  function valid(mid) {\n    let res = 0\n    for(let e of nums) {\n      if(e >= mid) res++\n    }\n    return res\n  }\n};\n\n// another \n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst specialArray = function (nums) {\n    nums.sort((a, b) => b - a)\n    let i = 0\n    while(i < nums.length && nums[i] >= i) {\n      i++\n    }\n    if(nums[i - 1] < i) return -1\n    return i\n};\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst specialArray = function(nums) {\n  nums.sort((a, b) => b - a)\n  let left = 0, right = nums.length\n  while(left <= right) {\n    const mid = left + ((right - left) >> 1)\n    if(mid < nums[mid]) left = mid + 1\n    else right = mid - 1\n  }\n  // if we found i == nums[i], there will be i + 1 items\n  // larger or equal to i, which makes array not special.\n  return left < nums.length && left === nums[left] ? -1 : left\n};\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst specialArray = function(nums) {\n  const n = nums.length\n  nums.sort((a, b) => b - a)\n  let l = 0, r = n\n  while(l < r) {\n    const mid = l + ((r - l) >> 1)\n    if(nums[mid] > mid) l = mid + 1\n    else r = mid\n  }\n  return l < n && l === nums[l] ? -1 : l\n}\n"
    }
  },
  {
    "name": "1609-even-odd-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nconst isEvenOddTree = function(root) {\n  const q = [root]\n  const v = []\n  let l = 0\n  while(q.length) {\n    const size = q.length\n    const row = []\n    for(let i = 0; i < size; i++) {\n      const cur = q.shift()\n      row.push(cur.val)\n      if(l % 2 === 0 && cur.val % 2 === 0) return false\n      if(l % 2 === 1 && cur.val % 2 === 1) return false\n      if(row.length > 1) {\n        if(l % 2 === 0 && row[row.length - 1] <= row[row.length - 2]) return false\n        if(l % 2 === 1 && row[row.length - 1] >= row[row.length - 2]) return false\n      }\n      if(cur.left) q.push(cur.left)\n      if(cur.right) q.push(cur.right)\n    }\n    l++\n  }\n  return true\n};\n"
    }
  },
  {
    "name": "161-one-edit-distance",
    "code": {
      "JS": "/**\n\nGiven two strings s and t, determine if they are both one edit distance apart.\n\nNote: \n\nThere are 3 possiblities to satisify one edit distance apart:\n\nInsert a character into s to get t\nDelete a character from s to get t\nReplace a character of s to get t\nExample 1:\n\nInput: s = \"ab\", t = \"acb\"\nOutput: true\nExplanation: We can insert 'c' into s to get t.\nExample 2:\n\nInput: s = \"cab\", t = \"ad\"\nOutput: false\nExplanation: We cannot get t from s by only one step.\nExample 3:\n\nInput: s = \"1203\", t = \"1213\"\nOutput: true\nExplanation: We can replace '0' with '1' to get t.\n\n*/\n\n/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nconst isOneEditDistance = function(s, t) {\n  const m = s.length,\n    n = t.length;\n  if (m > n) {\n    return isOneEditDistance(t, s);\n  }\n  for (let i = 0; i < m; i++) {\n    if (s[i] !== t[i]) {\n      if (m === n) {\n        return s.slice(i + 1) === t.slice(i + 1);\n      }\n      return s.slice(i) === t.slice(i + 1);\n    }\n  }\n  return m + 1 === n;\n};\n"
    }
  },
  {
    "name": "1610-maximum-number-of-visible-points",
    "code": {
      "JS": "/**\n * @param {number[][]} points\n * @param {number} angle\n * @param {number[]} location\n * @return {number}\n */\nconst visiblePoints = function (points, angle, location) {\n  const angles = [];\n  let count = 0;\n  for (let p of points) {\n    let dx = p[0] - location[0];\n    let dy = p[1] - location[1];\n    if (dx == 0 && dy == 0) {\n      // edge case of same point\n      count++;\n      continue;\n    }\n    angles.push(Math.atan2(dy, dx) * (180 / Math.PI));\n  }\n  angles.sort();\n  const tmp = angles.slice();\n  for (let d of angles) tmp.push(d + 360); // concatenate to handle edge case\n  let res = count;\n  for (let i = 0, j = 0; i < tmp.length; i++) {\n    while (tmp[i] - tmp[j] > angle) {\n      j++;\n    }\n    res = Math.max(res, count + i - j + 1);\n  }\n  return res;\n};\n"
    }
  },
  {
    "name": "1611-minimum-one-bit-operations-to-make-integers-zero",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst minimumOneBitOperations = function (n) {\n  let sign = 1,\n    res = 0;\n  while (n) {\n    res += n ^ ((n - 1) * sign);\n    n &= n - 1;\n    sign = -sign;\n  }\n  return Math.abs(res);\n};\n\n// another\n\n/**\n * @param {number} n\n * @return {number}\n */\nconst minimumOneBitOperations = function(n) {\n  let mask = n;\n  while (mask) {\n    mask >>= 1;\n    n   ^= mask;\n  }\n  return n;\n};\n\n// another\n\n/**\n * @param {number} n\n * @return {number}\n */\nconst minimumOneBitOperations = function(n) {\n  n ^= n >> 16\n  n ^= n >>  8\n  n ^= n >>  4\n  n ^= n >>  2\n  n ^= n >>  1\n  return n\n};\n"
    }
  },
  {
    "name": "1612-check-if-two-expression-trees-are-equivalent",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function Node(val, left, right) {\n *     this.val = (val===undefined ? \" \" : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {Node} root1\n * @param {Node} root2\n * @return {boolean}\n */\nconst checkEquivalence = function(root1, root2) {\n  const q = {}\n  const helper = (node) => {\n    if (node == null) return\n    if(node.val !== '+') {\n      if(q[node.val] == null) q[node.val] = 0\n      q[node.val]++      \n    }\n    helper(node.left)\n    helper(node.right)\n  }\n  helper(root1)\n  const h = node => {\n    if(node == null) return\n    if(node.val !== '+') {\n      if(q[node.val] == null) return false\n      q[node.val]--\n      if(q[node.val] <= 0) delete q[node.val]\n    }\n    h(node.left)\n    h(node.right)\n  }\n  h(root2)\n  if(Object.keys(q).length > 0) return false\n  return true\n};\n"
    }
  },
  {
    "name": "1614-maximum-nesting-depth-of-the-parentheses",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst maxDepth = function(s) {\n  const stack = []\n  let res = 0\n  for(let i = 0, len = s.length; i < len; i++) {\n    if(s[i] === '(') {\n      stack.push('(')\n      res = Math.max(res, stack.length)\n    } else if(s[i] === ')') {\n      stack.pop()\n    }\n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "1615-maximal-network-rank",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[][]} roads\n * @return {number}\n */\nconst maximalNetworkRank = function (n, roads) {\n  const edgeCount = new Array(n).fill(0);\n  const m = roads.length;\n  const map = new Map();\n  for (let i = 0; i < m; i++) {\n    edgeCount[roads[i][0]]++;\n    edgeCount[roads[i][1]]++;\n    if (!map.has(roads[i][0])) {\n      map.set(roads[i][0], new Set());\n    }\n    if (!map.has(roads[i][1])) {\n      map.set(roads[i][1], new Set());\n    }\n    const A = map.get(roads[i][0]);\n    A.add(roads[i][1]);\n    const B = map.get(roads[i][1]);\n    B.add(roads[i][0]);\n  }\n\n  let maxRank = 0;\n  for (let i = 0; i < m; i++) {\n    let rank = edgeCount[roads[i][0]] + edgeCount[roads[i][1]] - 1;\n    if (rank > maxRank) {\n      maxRank = rank;\n    }\n  }\n  const keys = [];\n  for (let k of map.keys()) keys.push(k);\n  // console.log(keys, map)\n  for (let i = 0, len = keys.length; i < m - 1; i++) {\n    const tmp = map.get(keys[i]);\n    for (let j = i + 1; j < m; j++) {\n      // console.log(tmp, i, j, tmp.has(keys[j]))\n      if (tmp && !tmp.has(keys[j])) {\n        let rank = edgeCount[keys[i]] + edgeCount[keys[j]];\n        if (rank > maxRank) {\n          maxRank = rank;\n        }\n      }\n    }\n  }\n  \n\n  return maxRank;\n};\n"
    }
  },
  {
    "name": "1616-split-two-strings-to-make-palindrome",
    "code": {
      "JS": "/**\n * @param {string} a\n * @param {string} b\n * @return {boolean}\n */\nconst checkPalindromeFormation = function (a, b) {\n  return check(a, b) || check(b, a)\n}\n\nfunction isPalindrome(s, i, j) {\n  for (; i < j; ++i, --j) {\n    if (s[i] != s[j]) return false\n  }\n  return true\n}\n\nfunction check(a, b) {\n  for (let i = 0, j = a.length - 1; i < j; ++i, --j) {\n    if (a[i] !== b[j]) return isPalindrome(a, i, j) || isPalindrome(b, i, j)\n  }\n  return true\n}\n"
    }
  },
  {
    "name": "1617-count-subtrees-with-max-distance-between-cities",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {number[]}\n */\nconst countSubgraphsForEachDiameter = function (n, edges) {\n  const graph = {};\n  for (let [u, v] of edges) {\n    if (!graph[u - 1]) graph[u - 1] = [];\n    if (!graph[v - 1]) graph[v - 1] = [];\n    graph[u - 1].push(v - 1);\n    graph[v - 1].push(u - 1);\n  }\n  let ans = Array(n - 1).fill(0);\n  for (let i = 1, len = 2 ** n; i < len; i++) {\n    const d = maxDistance(i);\n    if (d > 0) ans[d - 1] += 1;\n  }\n  return ans;\n  function bfs(src, cities) {\n    const visited = new Set();\n    visited.add(src);\n    const q = [[src, 0]]; // Pair of (vertex, distance)\n    let farthestDist = 0; // Farthest distance from src to other nodes\n    while (q.length > 0) {\n      const [u, d] = q.shift();\n      farthestDist = d;\n      for (let v of graph[u]) {\n        if (!visited.has(v) && cities.has(v)) {\n          visited.add(v);\n          q.push([v, d + 1]);\n        }\n      }\n    }\n    return [farthestDist, visited];\n  }\n  function maxDistance(state) {\n    // return: maximum distance between any two cities in our subset. O(n^2)\n    const cities = new Set();\n    for (let i = 0; i < n; i++) {\n      if ((state >> i) & (1 === 1)) cities.add(i);\n    }\n    let ans = 0;\n    for (let i of cities) {\n      const [farthestDist, visited] = bfs(i, cities);\n      if (visited.size < cities.size) return 0; // Can't visit all nodes of the tree -> Invalid tree\n      ans = Math.max(ans, farthestDist);\n    }\n    return ans;\n  }\n};\n"
    }
  },
  {
    "name": "1619-mean-of-array-after-removing-some-elements",
    "code": {
      "JS": "/**\n * @param {number[]} arr\n * @return {number}\n */\nconst trimMean = function(arr) {\n  const n = arr.length\n  arr.sort((a, b) => a - b)\n  const idx = n / 20\n  let tmp = arr.slice(idx, n - idx)\n  const sum = tmp.reduce((ac, cur) => ac + cur, 0)\n  return sum / (n -idx * 2)\n};\n"
    }
  },
  {
    "name": "162-find-peak-element",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst findPeakElement = function(nums) {\n  let low = 0;\n  let high = nums.length-1;\n\n  while(low < high) {\n    let mid1 = low + ((high - low) >> 1);\n    let mid2 = mid1 + 1;\n    if(nums[mid1] < nums[mid2]) low = mid2;\n    else high = mid1;\n  }\n  return low;\n};\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst findPeakElement = function(nums) {\n  if(nums == null) return -1\n  const len = nums.length\n  if(len === 1) return 0\n  for(let i = 1; i < len; i++) {\n    if(i === 1 && nums[i] < nums[i - 1]) return 0\n    else if(i === len - 1 && nums[i] > nums[i - 1]) return len - 1\n    else if(nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) return i\n  }\n  return -1\n};\n"
    }
  },
  {
    "name": "1621-number-of-sets-of-k-non-overlapping-line-segments",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number} k\n * @return {number}\n */\nconst numberOfSets = function (n, k) {\n  let res = BigInt(1)\n  const mod = BigInt(10 ** 9 + 7)\n  for (let i = 1; i < k * 2 + 1; i++) {\n    res = res * BigInt(n + k - i)\n    res = res / BigInt(i)\n  }\n  res = res % mod\n  return res\n}\n\n// another\n\n/**\n * @param {number} n\n * @param {number} k\n * @return {number}\n */\nconst numberOfSets = function (n, k) {\n  // dp[i][k] as: the number of ways to generate\n  // k non-overlapping segments you can make using [0 ~ i].\n  const dp = Array.from({ length: n }, () => Array(k + 1).fill(0))\n  const MOD = 10 ** 9 + 7\n  dp[1][1] = 1\n  for (let i = 2; i < n; i++) dp[i][1] = ((i + 1) * i) / 2\n  // sum[i][j] as: the number of ways to generate\n  // j - 1 segments from i - 1 points.\n  const sum = Array.from({ length: n }, () => Array(k + 1).fill(0))\n  for (let i = 2; i < n; i++) {\n    for (let j = 2; j <= k; j++) {\n      if (j <= i) sum[i][j] = (sum[i - 1][j] + dp[i - 1][j - 1]) % MOD\n      dp[i][j] = (sum[i][j] + dp[i - 1][j]) % MOD\n    }\n  }\n  return dp[n - 1][k]\n}\n\n"
    }
  },
  {
    "name": "1622-fancy-sequence",
    "code": {
      "JS": "const mod = 10 ** 9 + 7;\nconst Fancy = function () {\n  this.seq = [];\n  this.mods = [];\n};\nFancy.prototype.append = function (val) {\n  this.seq.push(val);\n};\nFancy.prototype.addAll = function (inc) {\n  this.mods.push([\"p\", inc, this.seq.length]);\n};\nFancy.prototype.multAll = function (m) {\n  this.mods.push([\"m\", m, this.seq.length]);\n};\nFancy.prototype.getIndex = function (idx) {\n  if (idx >= this.seq.length) return -1;\n  let x = this.seq[idx];\n\n  for (let i = 0; i < this.mods.length; i++) {\n    if (this.mods[i][2] > idx) {\n      if (\"m\" === this.mods[i][0]) {\n        x = (x * this.mods[i][1]) % mod;\n      } else {\n        x = (x + this.mods[i][1]) % mod;\n      }\n    }\n  }\n  return x;\n};\n"
    }
  },
  {
    "name": "1624-largest-substring-between-two-equal-characters",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst maxLengthBetweenEqualCharacters = function(s) {\n  const m = {}\n  if(s ==null || s.length <= 1) return -1\n  let res  = -1\n  for(let i = 0, len = s.length; i< len;i++) {\n    if(m[s[i]] != null) {\n      res = Math.max(res, i - m[s[i]] - 1)\n    } else {\n      m[s[i]] = i\n    }\n    \n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1625-lexicographically-smallest-string-after-applying-operations",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {number} a\n * @param {number} b\n * @return {string}\n */\nconst findLexSmallestString = function(s, a, b) {\n  let res = s\n  const set = new Set()\n  const q = [s]\n  set.add(res)\n  while(q.length) {\n    const len = q.length\n    for(let i = 0; i < len; i++) {\n      const tmp = q.shift()\n      const t1 = podd(tmp, a)\n      const t2 = rotate(tmp, b)\n      if(!set.has(t1)) {\n        set.add(t1)\n        q.push(t1)\n      }\n      if(!set.has(t2)) {\n        set.add(t2)\n        q.push(t2)\n      }\n      if(t1 < res) res = t1\n      if(t2 < res) res = t2\n    }\n  }\n  return res\n};\n\nfunction podd(s, num) {\n  const arr = s.split('')\n  for(let i = 1, len = s.length; i < len; i += 2) {\n    const tmp = (+s[i] + num) % 10\n    arr[i] = tmp\n  }\n  return arr.join('')\n}\n\nfunction rotate(s, num) {\n  const len = s.length\n  num = num % len\n  const idx = len - num\n  return s.slice(idx) + s.slice(0, idx)\n}\n"
    }
  },
  {
    "name": "1626-best-team-with-no-conflicts",
    "code": {
      "JS": "/**\n * @param {number[]} scores\n * @param {number[]} ages\n * @return {number}\n */\nconst bestTeamScore = function(scores, ages) {\n  const len = ages.length\n  const arr = Array(len)\n  for(let i = 0; i < len; i++) {\n    arr[i] = [scores[i], ages[i]]    \n  }\n  arr.sort((a, b) => {\n    if(a[1] > b[1]) return 1\n    else if(a[1] === b[1]) return a[0] - b[0]\n    else return -1\n  })\n  const dp = Array(len)\n  let res = 0\n  for(let i = 0; i < len; i++) {\n    dp[i] = arr[i][0]\n    for(let j = i - 1; j >= 0; j--) {\n      if(arr[j][0] > arr[i][0] && arr[j][1] < arr[i][1]) {\n         continue\n      }\n      dp[i] = Math.max(dp[i], dp[j] + arr[i][0])\n    }\n    res = Math.max(res, dp[i])\n  }\n  return res\n};\n\n"
    }
  },
  {
    "name": "1627-graph-connectivity-with-threshold",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number} threshold\n * @param {number[][]} queries\n * @return {boolean[]}\n */\nconst areConnected = function (n, threshold, queries) {\n  const arr = []\n  const uf = new UnionFind(n)\n  setup(n, threshold, uf)\n  for (let i = 0, len = queries.length; i < len; i++) {\n    arr.push(uf.check(queries[i][0], queries[i][1]))\n  }\n  return arr\n}\n\nfunction setup(n, t, uf) {\n  t++\n  for (let i = t; i <= n; i++) {\n    let m = 1\n    while (i * m <= n) {\n      uf.union(i, i * m)\n      m += 1\n    }\n  }\n}\nclass UnionFind {\n  constructor(n) {\n    this.parents = Array(n + 1)\n      .fill(0)\n      .map((e, i) => i)\n    this.ranks = Array(n + 1).fill(0)\n  }\n  root(x) {\n    while (x !== this.parents[x]) {\n      this.parents[x] = this.parents[this.parents[x]]\n      x = this.parents[x]\n    }\n    return x\n  }\n  find(x) {\n    return this.root(x)\n  }\n  check(x, y) {\n    return this.root(x) === this.root(y)\n  }\n  union(x, y) {\n    const [rx, ry] = [this.find(x), this.find(y)]\n    if (this.ranks[rx] >= this.ranks[ry]) {\n      this.parents[ry] = rx\n      this.ranks[rx] += this.ranks[ry]\n    } else if (this.ranks[ry] > this.ranks[rx]) {\n      this.parents[rx] = ry\n      this.ranks[ry] += this.ranks[rx]\n    }\n  }\n}\n"
    }
  },
  {
    "name": "1629-slowest-key",
    "code": {
      "JS": "/**\n * @param {number[]} releaseTimes\n * @param {string} keysPressed\n * @return {character}\n */\nconst slowestKey = function(releaseTimes, keysPressed) {\n  const m = {}\n  const n = keysPressed.length\n  const set = new Set()\n  set.add(keysPressed[0])\n  m[releaseTimes[0]] = set\n  for(let i = 1; i < n; i++) {\n    const k = releaseTimes[i] - releaseTimes[i - 1]\n    if(m[k] == null) m[k] = new Set()\n    m[k].add(keysPressed[i])\n  }\n  const keys = Object.keys(m).sort((a, b) => a - b)\n  const last = keys[keys.length - 1]\n  const arr = Array.from(m[last])\n  arr.sort()\n  return arr[arr.length - 1]\n};\n"
    }
  },
  {
    "name": "163-missing-ranges",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} lower\n * @param {number} upper\n * @return {string[]}\n */\nconst findMissingRanges = function(nums, lower, upper) {\n  const list = []\n  for (let n of nums) {\n    let justBelow = n - 1\n    if (lower === justBelow) list.push(lower + '')\n    else if (lower < justBelow) list.push(lower + '->' + justBelow)\n    lower = n + 1\n  }\n  if (lower === upper) list.push(lower + '')\n  else if (lower < upper) list.push(lower + '->' + upper)\n  return list\n}\n\n// another\n\n/**\n * @param {number[]} nums\n * @param {number} lower\n * @param {number} upper\n * @return {string[]}\n */\nconst findMissingRanges = function(nums, lower, upper) {\n  const res = [];\n  let next = lower;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < next) continue;\n    if (nums[i] === next) {\n      next++;\n      continue;\n    }\n    range(next, nums[i] - 1, res);\n    next = nums[i] + 1;\n  }\n  if (next <= upper) range(next, upper, res);\n  return res;\n  function range(l, r, a) {\n    a.push(l < r ? `${l}->${r}` : `${l}`)\n  }\n};\n    \n"
    }
  },
  {
    "name": "1630-arithmetic-subarrays",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number[]} l\n * @param {number[]} r\n * @return {boolean[]}\n */\nconst checkArithmeticSubarrays = function(nums, l, r) {\n  const len = l.length\n  const res = []\n  for(let i = 0; i < len; i++) {\n    res.push(chk(nums.slice(l[i], r[i] + 1)))\n  }\n  return res\n};\n\nfunction chk(arr) {\n  if(arr.length === 0 || arr.length === 1 || arr.length === 2) return true\n  arr.sort((a, b) => a - b)\n  const diff = arr[1] - arr[0]\n  for(let i = 2, len = arr.length; i < len; i++) {\n    if(arr[i] - arr[i - 1] !== diff) return false\n  }\n  return true\n}\n"
    }
  },
  {
    "name": "1631-path-with-minimum-effort",
    "code": {
      "JS": "/**\n * @param {number[][]} heights\n * @return {number}\n */\nconst minimumEffortPath = function (heights) {\n  const d = [0, 1, 0, -1, 0]\n  let lo = 0,\n    hi = 10 ** 6 + 1\n  while (lo < hi) {\n    let effort = lo + ((hi - lo) >> 1)\n    if (isPath(heights, effort)) {\n      hi = effort\n    } else {\n      lo = effort + 1\n    }\n  }\n  return lo\n  function isPath(h, effort) {\n    const m = h.length,\n      n = h[0].length\n    const q = []\n    q.push([0, 0])\n    const seen = new Set()\n    seen.add(0)\n    while (q.length) {\n      const cur = q.shift()\n      const x = cur[0],\n        y = cur[1]\n      if (x === m - 1 && y === n - 1) {\n        return true\n      }\n      for (let k = 0; k < 4; k++) {\n        const r = x + d[k],\n          c = y + d[k + 1]\n        if(seen.has(r * n + c)) continue\n        if (\n          0 <= r &&\n          r < m &&\n          0 <= c &&\n          c < n &&\n          effort >= Math.abs(h[r][c] - h[x][y])\n        ) {\n          seen.add(r * n + c)\n          q.push([r, c])\n        }\n      }\n    }\n    return false\n  }\n}\n\n// another\n\n/**\n * @param {number[][]} heights\n * @return {number}\n */\nconst minimumEffortPath = function(heights) {\n  const rows = heights.length\n  const cols = heights[0].length\n  const dirs = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n  const dist = Array.from({ length: rows }, () => Array(cols).fill(Infinity))\n  const pq = new PriorityQueue()\n  pq.push([0, 0, 0])\n  dist[0][0] = 0\n  while(pq.size) {\n    const cur = pq.pop()\n    if(cur[1] === rows - 1 && cur[2] === cols - 1) return cur[0]\n    for(let dir of dirs) {\n      const nr = cur[1] + dir[0]\n      const nc = cur[2] + dir[1]\n      if(nr < 0 || nr >= rows || nc < 0 || nc >= cols) continue\n      const diff = Math.max(cur[0], Math.abs(heights[nr][nc] - heights[cur[1]][cur[2]]))\n      if(dist[nr][nc] > diff) {\n        dist[nr][nc] = diff\n        pq.push([diff, nr, nc])\n      }\n    }\n  }\n  return 0\n};\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a[0] < b[0]) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n\n"
    }
  },
  {
    "name": "1632-rank-transform-of-a-matrix",
    "code": {
      "JS": "/**\n * @param {number[][]} matrix\n * @return {number[][]}\n */\nconst matrixRankTransform = function (matrix) {\n  function find(UF, x) {\n    if (x !== UF.get(x)) UF.set(x, find(UF, UF.get(x)))\n    return UF.get(x)\n  }\n  function union(UF, x, y) {\n    if (!UF.has(x)) UF.set(x, x)\n    if (!UF.has(y)) UF.set(y, y)\n    UF.set(find(UF, x), find(UF, y))\n  }\n  const m = matrix.length\n  const n = matrix[0].length\n  const UFs = new Map()\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      const v = matrix[i][j]\n      if (!UFs.has(v)) UFs.set(v, new Map())\n      union(UFs.get(v), i, ~j)\n    }\n  }\n  const value2index = {}\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      let v = matrix[i][j]\n      if (!value2index.hasOwnProperty(v)) value2index[v] = new Map()\n      const indexes = value2index[v]\n      let f = find(UFs.get(v), i)\n      if (!indexes.has(f)) indexes.set(f, [])\n      indexes.get(f).push([i, j])\n    }\n  }\n  const answer = Array.from({ length: m }, () => Array(n).fill(0))\n  const rowMax = Array(m).fill(0), colMax = Array(n).fill(0)\n  const keys = Object.keys(value2index)\n  keys.sort((a, b) => a - b)\n  for (let v of keys) {\n    for (let points of value2index[v].values()) {\n      let rank = 1\n      for (let point of points) {\n        rank = Math.max(rank, Math.max(rowMax[point[0]], colMax[point[1]]) + 1)\n      }\n      for (let point of points) {\n        answer[point[0]][point[1]] = rank\n        rowMax[point[0]] = Math.max(rowMax[point[0]], rank)\n        colMax[point[1]] = Math.max(colMax[point[1]], rank)\n      }\n    }\n  }\n  return answer\n}\n\n// another\n\n/**\n * @param {number[][]} matrix\n * @return {number[][]}\n */\nconst matrixRankTransform = function (matrix) {\n  const m = matrix.length\n  const n = matrix[0].length\n  const rowIndex = Array.from({ length: m }, () => Array(n).fill(0))\n  const colIndex = Array.from({ length: m }, () => Array(n).fill(0))\n  for (let i = 0; i < m; i++) {\n    let row = []\n    for (let j = 0; j < n; j++) {\n      row.push([matrix[i][j], j])\n    }\n\n    row.sort((a, b) => a[0] - b[0])\n    for (let j = 0; j < n; j++) {\n      rowIndex[i][j] = row[j][1]\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    const col = []\n    for (let j = 0; j < m; j++) {\n      col.push([matrix[j][i], j])\n    }\n    col.sort((a, b) => a[0] - b[0])\n    for (let j = 0; j < m; j++) {\n      colIndex[j][i] = col[j][1]\n    }\n  }\n  const result = Array.from({ length: m }, () => Array(n).fill(0))\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      result[i][j] = 1\n    }\n  }\n  let changed = true\n  while (changed) {\n    changed = shakeRow(matrix, rowIndex, result)\n    changed = shakeCol(matrix, colIndex, result) || changed\n  }\n  return result\n}\n\nfunction shakeCol(matrix, colIndex, result) {\n  let changed = false\n  for (let i = 0; i < matrix[0].length; i++) {\n    for (let j = 1; j < matrix.length; j++) {\n      if (matrix[colIndex[j][i]][i] == matrix[colIndex[j - 1][i]][i]) {\n        if (result[colIndex[j][i]][i] != result[colIndex[j - 1][i]][i])\n          changed = true\n        result[colIndex[j][i]][i] = Math.max(\n          result[colIndex[j][i]][i],\n          result[colIndex[j - 1][i]][i]\n        )\n        result[colIndex[j - 1][i]][i] = Math.max(\n          result[colIndex[j][i]][i],\n          result[colIndex[j - 1][i]][i]\n        )\n      } else {\n        if (result[colIndex[j][i]][i] < result[colIndex[j - 1][i]][i] + 1) {\n          changed = true\n          result[colIndex[j][i]][i] = result[colIndex[j - 1][i]][i] + 1\n        }\n      }\n    }\n  }\n  return changed\n}\n\nfunction shakeRow(matrix, rowIndex, result) {\n  let changed = false\n  for (let i = 0; i < matrix.length; i++) {\n    let rowInd = rowIndex[i]\n    let resu = result[i]\n    for (let j = 1; j < matrix[0].length; j++) {\n      if (matrix[i][rowInd[j]] == matrix[i][rowInd[j - 1]]) {\n        if (resu[rowInd[j]] != resu[rowInd[j - 1]]) changed = true\n        resu[rowInd[j]] = Math.max(resu[rowInd[j - 1]], resu[rowInd[j]])\n        resu[rowInd[j - 1]] = Math.max(resu[rowInd[j - 1]], resu[rowInd[j]])\n      } else {\n        if (resu[rowInd[j]] < resu[rowInd[j - 1]] + 1) {\n          changed = true\n          resu[rowInd[j]] = resu[rowInd[j - 1]] + 1\n        }\n      }\n    }\n  }\n  return changed\n}\n\n// another\n\n/**\n * @param {number[][]} matrix\n * @return {number[][]}\n */\nconst matrixRankTransform = function (matrix) {\n  const r = matrix.length,\n    c = matrix[0].length;\n  const t = r * c;\n  const arr = Array(t);\n  const root = Array(t + 1);\n  const rk = Array(t + 1).fill(0);\n  const find = (a) => {\n    let ra = root[a];\n    if (ra == a) return a;\n    return (root[a] = find(ra));\n  };\n  const union = (a, b) => {\n    let ra = find(a);\n    let rb = find(b);\n    if (ra !== rb) {\n      if (rk[ra] > rk[rb]) root[rb] = ra;\n      else root[ra] = rb;\n    }\n  };\n  let k = 0;\n  const ans = Array(r)\n    .fill(0)\n    .map(() => Array(c));\n  for (let i = 0; i < r; ++i) {\n    for (let j = 0; j < c; ++j) {\n      arr[k] = [matrix[i][j], i, j];\n      root[k] = k;\n      ++k;\n    }\n  }\n  root[k] = k;\n  arr.sort((a, b) => a[0] - b[0]);\n  const X = Array(r)\n    .fill(0)\n    .map(() => [-Infinity, t]);\n  const Y = Array(c)\n    .fill(0)\n    .map(() => [-Infinity, t]);\n  for (let i = 0; i < t; ++i) {\n    const [v, x, y] = arr[i];\n    const id = x * c + y;\n    const [xv, rx] = X[x],\n      [yv, ry] = Y[y];\n    if (v > xv) rk[id] = rk[find(rx)] + 1;\n    else root[id] = rx;\n    if (v > yv) rk[find(id)] = Math.max(rk[find(id)], rk[find(ry)] + 1);\n    else union(id, ry);\n    X[x] = [v, id];\n    Y[y] = [v, id];\n  }\n  for (let i = 0; i < r; ++i) {\n    for (let j = 0; j < c; ++j) {\n      ans[i][j] = rk[find(i * c + j)];\n    }\n  }\n  return ans;\n};\n"
    }
  },
  {
    "name": "1636-sort-array-by-increasing-frequency",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nconst frequencySort = function(nums) {\n  const hash = {}\n  for(let e of nums) {\n    if(hash[e] == null) hash[e] = 0\n    hash[e]++\n  }\n  nums.sort((a, b) => hash[a] === hash[b] ? b - a : hash[a] - hash[b])\n  return nums\n};\n"
    }
  },
  {
    "name": "1637-widest-vertical-area-between-two-points-containing-no-points",
    "code": {
      "JS": "/**\n * @param {number[][]} points\n * @return {number}\n */\nconst maxWidthOfVerticalArea = function(points) {\n  const arr = points.map(e => e[0])\n  arr.sort((a, b) => a - b)\n  let res = -Infinity\n  for(let i = 1, len = arr.length; i < len; i++) {\n    if(arr[i] - arr[i - 1] > res) res = arr[i] - arr[i - 1]\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1638-count-substrings-that-differ-by-one-character",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {string} t\n * @return {number}\n */\nconst countSubstrings = function (s, t) {\n  const m = s.length\n  const n = t.length\n  const matrix = (m, n, v) => Array.from({ length: m }, () => Array(n).fill(v))\n  // number of exact same substrings ending at s[i] and t[j].\n  const same = matrix(m + 1, n + 1, 0)\n  // number of substrings having 1 different character ending at s[i] and t[j].\n  const one = matrix(m + 1, n + 1, 0)\n  let result = 0\n  for (let i = 1; i <= m; ++i) {\n    for (let j = 1; j <= n; ++j) {\n      if (s[i - 1] == t[j - 1]) {\n        same[i][j] = same[i - 1][j - 1] + 1\n        one[i][j] = one[i - 1][j - 1]\n      } else {\n        one[i][j] = same[i - 1][j - 1] + 1\n      }\n      result += one[i][j]\n    }\n  }\n  return result\n}\n"
    }
  },
  {
    "name": "1639-number-of-ways-to-form-a-target-string-given-a-dictionary",
    "code": {
      "JS": "/**\n * @param {string[]} words\n * @param {string} target\n * @return {number}\n */\nconst numWays = function (words, target) {\n  const m = words[0].length, len = words.length\n  const n = target.length, a = 'a'.charCodeAt(0)\n  const mod = 10 ** 9 + 7\n  const dp = Array(n).fill(0)\n  for(let i = 0; i < m; i++) {\n    const freq = Array(26).fill(0)\n    for(let j = 0; j < len; j++) {\n      freq[words[j].charCodeAt(i) - a]++\n    }\n    for(let j = Math.min(i, n - 1); j >= 0; j--) {\n      const code = target[j].charCodeAt(0) - a\n      if(freq[code] > 0) {\n        dp[j] += (j === 0 ? freq[code] : dp[j - 1] * freq[code])\n        dp[j] %= mod\n      }\n    }\n  }\n  return dp[n - 1]\n}\n\n// another\n\n/**\n * @param {string[]} words\n * @param {string} target\n * @return {number}\n */\nconst numWays = function (words, target) {\n  const m = words[0].length\n  const n = target.length\n  const memo = Array.from({ length: m }, () => Array(n))\n  const charAtIndexCnt = Array.from({ length: 128 }, () => Array(m).fill(0))\n  const mod = 10 ** 9 + 7\n  for (let word of words) {\n    for (let i = 0; i < m; i++) {\n      charAtIndexCnt[word.charCodeAt(i)][i] += 1\n    }\n  }\n\n  return dp(0, 0)\n  function dp(k, i) {\n    // found one\n    if (i == n) return 1\n    // not found\n    if (k == m) return 0\n    if (memo[k][i] != null) return memo[k][i]\n    const c = target.charCodeAt(i)\n    // skip k_th char\n    let ans = dp(k + 1, i)\n    if (charAtIndexCnt[c][k] > 0) {\n      ans += dp(k + 1, i + 1) * charAtIndexCnt[c][k]\n      ans %= mod\n    }\n    return (memo[k][i] = ans)\n  }\n}\n"
    }
  },
  {
    "name": "164-maximum-gap",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst maximumGap = function (nums) {\n  if (nums.length < 2) return\n  let max = 0\n  nums = nums.sort(function (a, b) {\n    return a - b\n  })\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] - nums[i - 1] > max) max = nums[i] - nums[i - 1]\n  }\n  return max\n}\n"
    }
  },
  {
    "name": "1640-check-array-formation-through-concatenation",
    "code": {
      "JS": "/**\n * @param {number[]} arr\n * @param {number[][]} pieces\n * @return {boolean}\n */\nconst canFormArray = function(arr, pieces) {\n  const m = new Map()\n  for(let i = 0, len = arr.length; i < len; i++) {\n    m.set(arr[i], i)\n  }\n  for(let p of pieces) {\n    let idx = m.get(p[0])\n    if(idx == null) return false\n    for(let i = 1, len = p.length; i < len; i++) {\n      console.log(m.has(p[i]))\n      if(!m.has(p[i]) || arr[++idx] !== p[i]) return false\n    }\n  }\n  return true\n};\n"
    }
  },
  {
    "name": "1641-count-sorted-vowel-strings",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst countVowelStrings = function (n) {\n  return (n + 4) * (n + 3) * (n + 2) * (n + 1) / 24\n};\n\n// another\n\n/**\n * @param {number} n\n * @return {number}\n */\nconst countVowelStrings = function (n) {\n  let mem = [1, 1, 1, 1, 1];\n  for (let i = 1; i < n; ++i) {\n    const next = [0, 0, 0, 0, 0];\n    let tmp = 0;\n    for (let j = 4; j >= 0; --j) {\n      tmp += mem[j];\n      next[j] = tmp;\n    }\n    mem = next;\n  }\n  let sum = 0;\n  for (let i of mem) {\n    sum += i;\n  }\n  return sum;\n};\n\n// another\n\n/**\n * @param {number} n\n * @return {number}\n */\nconst countVowelStrings = function (n) {\n  const dp = Array.from({ length: n + 1 }, () => Array(5))\n  recur(n, 0)\n  return dp[n][0]\n  function recur(r, i) {\n    if(r === 0) return 1\n    if(i === 5) return 0\n    if(dp[r][i] != null) return dp[r][i]\n    let res = recur(r, i + 1)\n    res += recur(r - 1, i)\n    return dp[r][i] = res\n  }\n};\n"
    }
  },
  {
    "name": "1642-furthest-building-you-can-reach",
    "code": {
      "JS": "/**\n * @param {number[]} heights\n * @param {number} bricks\n * @param {number} ladders\n * @return {number}\n */\nconst furthestBuilding = function(heights, bricks, ladders) {\n  const pq = new PriorityQueue((a, b) => a < b)\n  const len = heights.length\n  for(let i = 0; i < len - 1; i++) {\n    const diff = heights[i + 1] - heights[i]\n    if(diff > 0) pq.push(diff)\n    if(pq.size() > ladders) {\n      bricks -= pq.pop()\n    }\n    if(bricks < 0) return i\n  }\n  return len - 1\n};\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n"
    }
  },
  {
    "name": "1643-kth-smallest-instructions",
    "code": {
      "JS": "/**\n * @param {number[]} destination\n * @param {number} k\n * @return {string}\n */\nconst kthSmallestPath = function (destination, k) {\n  let v = destination[0],\n    h = destination[1]\n  const mu = (c, n) => {\n    let res = ''\n    for (let i = 0; i < n; i++) {\n      res += c\n    }\n    return res\n  }\n\n  let res = ''\n  while (h > 0 && v > 0) {\n    let pre = comb(h + v - 1, v)\n    if (k <= pre) {\n      res += 'H'\n      h -= 1\n    } else {\n      res += 'V'\n      v -= 1\n      k -= pre\n    }\n  }\n  if (h == 0) res += mu('V', v)\n  if (v == 0) res += mu('H', h)\n  return res\n}\n\nfunction product(a, b) {\n  let prd = a,\n    i = a\n\n  while (i++ < b) {\n    prd *= i\n  }\n  return prd\n}\n\nfunction comb(n, r) {\n  if (n == r) {\n    return 1\n  } else {\n    r = r < n - r ? n - r : r\n    return product(r + 1, n) / product(1, n - r)\n  }\n}\n\n// another\n\n/**\n * @param {number[]} destination\n * @param {number} k\n * @return {string}\n */\nconst kthSmallestPath = function (destination, k) {\n  const [r, c] = destination;\n  const ret = [];\n  let remDown = r;\n  for (let i = 0; i < r + c; i++) {\n    const remSteps = r + c - (i + 1);\n    const com = comb(remSteps, remDown);\n    if (com >= k) ret.push(\"H\");\n    else {\n      remDown -= 1;\n      k -= com;\n      ret.push(\"V\");\n    }\n  }\n  return ret.join(\"\");\n};\n\nfunction comb(n, r) {\n  if (n < r) return 0;\n  let res = 1;\n  if (n - r < r) r = n - r;\n  for (let i = n, j = 1; i >= 1 && j <= r; --i, ++j) {\n    res = res * i;\n  }\n  for (let i = r; i >= 2; --i) {\n    res = res / i;\n  }\n  return res;\n}\n\n"
    }
  },
  {
    "name": "1644-lowest-common-ancestor-of-a-binary-tree-ii",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {TreeNode}\n */\nconst lowestCommonAncestor = function (root, p, q) {\n  let cn = null\n  const dfs = function (node) {\n    let mid = 0\n    if (!node) return false\n    let left = dfs(node.left)\n    let right = dfs(node.right)\n    if (node === p || node === q) {\n      mid = 1\n    } else {\n      mid = 0\n    }\n    if (mid + left + right >= 2) {\n      cn = node\n    } else {\n      if (mid) return mid\n      return left || right\n    }\n  }\n  dfs(root)\n  return cn\n}\n"
    }
  },
  {
    "name": "1646-get-maximum-in-generated-array",
    "code": {
      "JS": "const arr = [0, 1, 1]\n/**\n * @param {number} n\n * @return {number}\n */\nconst getMaximumGenerated = function(n) {\n  if(arr[n] != null) return Math.max(...arr.slice(0, n + 1))\n  const oddOrEven = num => num % 2 === 0 ? 'even' : 'odd'\n  const hi = arr.length - 1\n  for(let i = hi + 1; i <= n; i++) {\n    let tmp, chk = oddOrEven(i)\n    if(chk === 'odd') tmp = arr[Math.floor(i / 2)] + arr[Math.floor(i / 2) + 1]\n    else tmp = arr[Math.floor(i / 2)]\n    arr[i] = tmp\n  }\n  return Math.max(...arr.slice(0, n + 1))\n};\n"
    }
  },
  {
    "name": "1647-minimum-deletions-to-make-character-frequencies-unique",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst minDeletions = function(s) {\n      if (s == null || s.length <= 1) {\n         return 0;\n      }\n\n      const map = new Map();\n      for (let ch of s) {\n        map.set(ch, (map.get(ch) || 0) + 1);\n      }\n\n\n      const frequencies = new Set();\n      let minDeletions = 0;\n      \n      const vals = map.values()\n      for (let frequency of vals) {\n         if (!frequencies.has(frequency)) {\n            frequencies.add(frequency);\n            continue;\n         }\n\n         let curr = frequency;\n         while (curr > 0 && frequencies.has(curr)) {\n            curr--;\n            minDeletions++;\n         }\n\n         if (curr > 0) {\n            frequencies.add(curr);\n         }\n      }\n\n      return minDeletions;\n};\n"
    }
  },
  {
    "name": "1648-sell-diminishing-valued-colored-balls",
    "code": {
      "JS": "/**\n * @param {number[]} inventory\n * @param {number} orders\n * @return {number}\n */\nfunction maxProfit(inventory, orders) {\n  inventory.sort((a, b) => a - b)\n  inventory = inventory.map(e => BigInt(e))\n  let ans = 0n, n = inventory.length - 1, count = 1n\n  const mod = BigInt(10 ** 9 + 7)\n  orders = BigInt(orders)\n  while(orders > 0n) {\n    if(n > 0 && inventory[n] > inventory[n - 1] && orders >= count * (inventory[n] - inventory[n - 1])) {\n      ans += count * sum(inventory[n - 1], inventory[n])\n      orders -= count * (inventory[n] - inventory[n - 1])\n    } else if(n === 0 || inventory[n] > inventory[n - 1]) {\n      const num = orders / count\n      ans += count * sum(inventory[n] - num, inventory[n])\n      const remain = orders % count\n      ans += remain * (inventory[n] - num)\n      orders = 0n\n    }\n    ans %= mod\n    n--\n    count++\n  }\n  return ans\n}\n\nfunction sum(lo, hi) {\n  return (hi - lo) * (lo + hi + 1n) / 2n\n}\n\n// another\n\n/**\n * @param {number[]} inventory\n * @param {number} orders\n * @return {number}\n */\nconst maxProfit = function (inventory, orders) {\n  let Max = 1e9 + 7,\n    Min = 0\n  let mod = BigInt(1e9 + 7)\n  while (Max > Min + 1) {\n    let tot = 0\n    let mid = ((Max + Min) >> 1)\n    for (let it of inventory) {\n      if (it > mid) tot += it - mid\n    }\n    if (tot > orders) Min = mid\n    else Max = mid\n  }\n  let sum = BigInt(0)\n  Max = BigInt(Max)\n  orders = BigInt(orders)\n  for (let it of inventory) {\n    it = BigInt(it)\n    if (it > Max) {\n      sum += ((it + Max + BigInt(1)) * (it - Max)) / BigInt(2)\n      orders -= it - Max\n    }\n  }\n  sum += orders * Max\n  \n  return sum % mod\n}\n"
    }
  },
  {
    "name": "1649-create-sorted-array-through-instructions",
    "code": {
      "JS": "const lowBit = (x) => x & -x\nclass FenwickTree {\n  constructor(n) {\n    if (n < 1) return\n    this.sum = Array(n + 1).fill(0)\n  }\n  update(i, delta) {\n    if (i < 1) return\n    while (i < this.sum.length) {\n      this.sum[i] += delta\n      i += lowBit(i)\n    }\n  }\n  query(i) {\n    if (i < 1) return 0\n    let sum = 0\n    while (i > 0) {\n      sum += this.sum[i]\n      i -= lowBit(i)\n    }\n    return sum\n  }\n}\n/**\n * @param {number[]} instructions\n * @return {number}\n */\nconst createSortedArray = function(instructions) {\n  let res = 0, n = instructions.length, mod = 10 ** 9 + 7\n  const bit = new FenwickTree(10 ** 5)\n  for(let i = 0; i < n; i++) {\n    res = (res + Math.min(bit.query(instructions[i] - 1), i - bit.query(instructions[i]))) % mod\n    bit.update(instructions[i], 1)\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "165-compare-version-numbers",
    "code": {
      "JS": "/**\n * @param {string} version1\n * @param {string} version2\n * @return {number}\n */\nconst compareVersion = function(version1, version2) {\n  const fa = version1.split(\".\");\n  const sa = version2.split(\".\");\n  const len = Math.max(fa.length, sa.length);\n  if (fa.length < len) {\n    while (fa.length < len) {\n      fa.push(\"0\");\n    }\n  }\n  if (sa.length < len) {\n    while (sa.length < len) {\n      sa.push(\"0\");\n    }\n  }\n  while (sa.length > 0 && fa.length > 0) {\n    let fe = +fa.shift();\n    let se = +sa.shift();\n    if (fe > se) {\n      return 1;\n    }\n    if (fe < se) {\n      return -1;\n    }\n  }\n  return 0;\n};\n"
    }
  },
  {
    "name": "1650-lowest-common-ancestor-of-a-binary-tree-iii",
    "code": {
      "JS": "/**\n * // Definition for a Node.\n * function Node(val) {\n *    this.val = val;\n *    this.left = null;\n *    this.right = null;\n *    this.parent = null;\n * };\n */\n\n/**\n * @param {Node} node\n * @return {Node}\n */\nconst lowestCommonAncestor = function(p, q) {\n  const pa = [], qa = []\n  if(up(p, q, pa)) return q\n  if(up(q, p, qa)) return p\n  const set = new Set(pa)\n  for(let i = 0; i < qa.length; i++) {\n    if(set.has(qa[i])) return qa[i]\n  }\n  \n  function up(node, target, arr) {\n    if(node == null) return null\n    if(node === target) return target\n    arr.push(node)\n    return up(node.parent, target, arr)\n  }\n};\n\n// another\n\n/**\n * // Definition for a Node.\n * function Node(val) {\n *    this.val = val;\n *    this.left = null;\n *    this.right = null;\n *    this.parent = null;\n * };\n */\n\n/**\n * @param {Node} node\n * @return {Node}\n */\nconst lowestCommonAncestor = function(p, q) {\n  let a = p, b = q;\n\twhile (a !== b) {\n\t\ta = a == null? q : a.parent;\n\t\tb = b == null? p : b.parent;    \n\t}\n\treturn a;\n};\n"
    }
  },
  {
    "name": "1652-defuse-the-bomb",
    "code": {
      "JS": "/**\n * @param {number[]} code\n * @param {number} k\n * @return {number[]}\n */\nconst decrypt = function(code, k) {\n  const res = new Array(code.length).fill(0);\n  if (k === 0) return res;\n  let start = 1, end = k, sum = 0;\n  if (k < 0) {\n    k = -k;\n    start = code.length - k;\n    end = code.length - 1;\n  }\n  for (let i = start; i <= end; i++) sum += code[i];\n  for (let i = 0; i < code.length; i++) {\n    res[i] = sum;\n    sum -= code[(start++) % code.length];\n    sum += code[(++end) % code.length];\n  }\n  return res;\n};\n"
    }
  },
  {
    "name": "1653-minimum-deletions-to-make-string-balanced",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst minimumDeletions = function(s) {\n  let res = 0\n  let cnt = 0\n  for(let c of s) {\n    if(c === 'a' && cnt > 0) {\n      res++\n      cnt--\n    } else if(c === 'b') {\n      cnt++\n    }\n  }\n  \n  return res\n};\n\n// another\n\n/**\n * @param {string} s\n * @return {number}\n */\nconst minimumDeletions = function(s) {\n  const len = s.length\n  const dp = Array(len + 1).fill(0)\n  let bcount = 0\n  for(let i = 1; i <= len; i++) {\n    if(s[i - 1] === 'a') {\n      dp[i] = Math.min(dp[i - 1] + 1, bcount)\n    } else {\n      dp[i] = dp[i - 1]\n      bcount++\n    }\n  }\n  \n  return dp[len]\n};\n\n// another\n\n/**\n * @param {string} s\n * @return {number}\n */\nconst minimumDeletions = function(s) {\n  const len = s.length\n  const stack = []\n  let res = 0\n  for(let i = 0; i < len; i++) {\n    if(stack.length && stack[stack.length - 1] > s[i]) {\n      res++\n      stack.pop()\n    } else {\n      stack.push(s[i])\n    }\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1654-minimum-jumps-to-reach-home",
    "code": {
      "JS": "/**\n * @param {number[]} forbidden\n * @param {number} a\n * @param {number} b\n * @param {number} x\n * @return {number}\n */\nconst minimumJumps = function (forbidden, a, b, x) {\n  const bad = new Set()\n  const set = new Set()\n  for (let i of forbidden) {\n    bad.add(i)\n  }\n  const q = []\n  q.push([0, 0, 0])\n  set.add('0,0')\n  while (q.length) {\n    const pair = q.shift()\n    let pos = pair[0],\n      level = pair[1],\n      state = pair[2]\n    if (pos == x) return level\n    if (state >= 0) {\n      if (pos <= 4000 && !set.has(pos + a + ',0') && !bad.has(pos + a)) {\n        set.add(pos + a + ',0')\n        q.push([pos + a, level + 1, 0])\n      }\n      if (!set.has(pos - b + ',-1') && !bad.has(pos - b) && pos - b >= 0) {\n        set.add(pos - b + ',-1')\n        q.push([pos - b, level + 1, -1])\n      }\n    } else if (state < 0) {\n      if (pos <= 4000 && !set.has(pos + a + ',0') && !bad.has(pos + a)) {\n        set.add(pos + a + ',0')\n        q.push([pos + a, level + 1, 0])\n      }\n    }\n  }\n  return -1\n}\n"
    }
  },
  {
    "name": "1655-distribute-repeating-integers",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number[]} quantity\n * @return {boolean}\n */\nconst canDistribute = function (nums, quantity) {\n  const mp = {}\n  for (let x of nums) {\n    mp[x] = (mp[x] || 0) + 1\n  }\n  const values = Object.values(mp)\n  quantity.sort((a, b) => b - a)\n  let res = false\n  dfs(0)\n  return res\n\n  function dfs(idx) {\n    if(idx === quantity.length || res) {\n      res = true\n      return\n    }\n    for(let i = 0, len = values.length; i < len; i++) {\n      if(values[i] >= quantity[idx]) {\n        values[i] -= quantity[idx]\n        dfs(idx + 1)\n        values[i] += quantity[idx]\n      }\n    }\n  }\n}\n\n// another\n\n/**\n * @param {number[]} nums\n * @param {number[]} quantity\n * @return {boolean}\n */\nconst canDistribute = function (nums, quantity) {\n  const mp = {}\n  for (let x of nums) {\n    mp[x] = (mp[x] || 0) + 1\n  }\n  const a = []\n  for (let p in mp) a.push(mp[p])\n  const b = quantity\n  const m = quantity.length\n  const n = a.length\n  const dp = Array.from({ length: n }, () => Array(1 << m).fill(-1))\n  return solve(0, 0)\n\n  function solve(idx, mask) {\n    if (mask === (1 << m) - 1) return 1\n    if (idx === n) return 0\n    if (dp[idx][mask] !== -1) return dp[idx][mask]\n    let ans = solve(idx + 1, mask)\n    for (let i = 0, up = 1 << m; i < up; i++) {\n      if (mask !== (mask & i)) continue\n      let nm = mask\n      let sum = 0\n      for (let j = 0; j < m; j++) {\n        if (mask & (1 << j)) continue\n        if (i & (1 << j)) {\n          sum += b[j]\n          nm |= 1 << j\n        }\n      }\n      if (sum <= a[idx]) ans |= solve(idx + 1, nm)\n    }\n    return (dp[idx][mask] = ans)\n  }\n}\n\n// another\n\n/**\n * @param {number[]} nums\n * @param {number[]} quantity\n * @return {boolean}\n */\nconst canDistribute = function(nums, quantity) {\n  const freq = {}\n  for(let e of nums) freq[e] = (freq[e] || 0) + 1\n  const fArr = Object.values(freq)\n\n  const m = quantity.length, n = fArr.length\n  const dp = Array.from({ length: n }, () => Array(1 << m).fill(-1))\n  \n  return solve(0, 0)\n  \n  function solve(idx, mask) {\n    if(mask === (1 << m) - 1) return 1\n    if(idx === n) return 0\n    if(dp[idx][mask] !== -1) return dp[idx][mask]\n    \n    let res = solve(idx + 1, mask)\n    for(let i = 0; i < (1 << m); i++) {\n      if(mask !== (mask & i)) continue\n      let tmp = mask\n      let sum = 0\n      for(let j = 0; j < m; j++) {\n        if(mask & (1 << j)) continue\n        if(i & (1 << j)) {\n          sum += quantity[j]\n          tmp |= (1 << j)\n        }\n      }\n      if(sum <= fArr[idx]) res |= solve(idx + 1, tmp)\n    }\n    \n    return dp[idx][mask] = res\n  }\n};\n\n// another\n\n/**\n * @param {number[]} nums\n * @param {number[]} quantity\n * @return {boolean}\n */\nconst canDistribute = function (nums, quantity) {\n  const hash = {}\n  for(const e of nums) {\n    if(hash[e] == null) hash[e] = 0\n    hash[e]++\n  }\n  const cnts = Object.values(hash), m = quantity.length, n = cnts.length\n  const dp = Array.from({ length: n }, () => Array(1 << m).fill(null))\n  \n  return helper(0, 0)\n\n  function helper(idx, mask) {\n    // mask are already selected candidates\n    if(mask == (1 << m) - 1) {\n        return true;\n    }\n    if(idx == n) {\n        return false;\n    }\n    if(dp[idx][mask] != null) {\n        return dp[idx][mask];\n    }\n    let ans = helper(idx + 1, mask);\n    \n    for(let i = 1; i < (1 << m); ++i) {\n        // i are potential candidates in addition to already selected ones (from mask)\n        // if i == mask, we can skip as the candidate is selected already\n        // if mask != (mask & i) means that this candidate does not include selected ones e.g\n        // mask = 3 (i.e 2 elements 1,2 in binary) and i = 4 (the third element in binary as 4 does not include 1 & 2), there we skip\n        if(mask == i || mask != (mask & i)) continue;\n        let sum = 0;\n        for(let j = 0; j < m; ++j) {\n            // mask << ~j is just a fancy way to do: if(mask & (1 << j)) that i've learned from @Uwi and this way you don't have to use \"(\", \")\"\n            // what it does is simply pushing the jth bit to the 2^31 bit which is negative\n            // thus if the jth bit is 1 then the value is less than zero and if its 0 then its greater or equal to zero\n            if(mask << ~j >= 0 && i << ~j < 0) {  // check that mask does not contain the new candidate and that the candidate is part of the potential candidate i\n                sum += quantity[j];\n            }\n        }\n        if(sum <= cnts[idx]) {\n            ans |= helper(idx + 1, i);\n        }\n        if(ans) break; // if ans is true, then a solution exists and no further computation is required\n    }\n    dp[idx][mask] = ans;\n    return ans;\n  }\n}\n"
    }
  },
  {
    "name": "1656-design-an-ordered-stream",
    "code": {
      "JS": "/**\n * @param {number} n\n */\nconst OrderedStream = function(n) {\n  this.arr = Array(n + 1)\n  this.ptr = 1\n};\n\n/** \n * @param {number} id \n * @param {string} value\n * @return {string[]}\n */\nOrderedStream.prototype.insert = function(id, value) {\n  \n  this.arr[id] = value\n  const res = []\n  let i\n  for(i = this.ptr, len = this.arr.length; i < len; i++) {\n    if (this.arr[i] != null) res.push(this.arr[i])\n    else {\n      break\n    }\n  }\n  this.ptr = i\n    \n  return res\n};\n\n/** \n * Your OrderedStream object will be instantiated and called as such:\n * var obj = new OrderedStream(n)\n * var param_1 = obj.insert(id,value)\n */\n"
    }
  },
  {
    "name": "1657-determine-if-two-strings-are-close",
    "code": {
      "JS": "/**\n * @param {string} word1\n * @param {string} word2\n * @return {boolean}\n */\nconst closeStrings = function(word1, word2) {\n  const len1 = word1.length, len2 = word2.length\n  if(len1 !== len2) return false\n  const a = ('a').charCodeAt(0)\n  const arr1 = Array(26).fill(0)\n  const arr2 = Array(26).fill(0)\n  for(let i = 0; i < len1; i++) {\n    arr1[word1.charCodeAt(i) - a]++\n    arr2[word2.charCodeAt(i) - a]++\n  }\n  return chk1(arr1, arr2)\n  function chk1(a1, a2) {\n    const a11 = a1.slice(0)\n    a11.sort()\n    const a22 = a2.slice(0)\n    a22.sort()\n    for(let i = 0, len = a1.length; i < len; i++) {\n      if((a1[i] !== 0 && a2[i] === 0) || (a1[i] === 0 && a2[i] !== 0) ) return false\n    }\n    for(let i = 0, len = a1.length; i < len; i++) {\n      if(a11[i] !== a22[i]) return false\n    }\n    return true\n  }\n};\n"
    }
  },
  {
    "name": "1658-minimum-operations-to-reduce-x-to-zero",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} x\n * @return {number}\n */\nconst minOperations = function (nums, x) {\n  let l = 0,\n    r = nums.length - 1;\n  while (x >= 0 && r >= l) {\n    x -= nums[r];\n    r -= 1;\n  }\n  if (r < 0 && x > 0) {\n    return -1;\n  } else if (r < 0 && x == 0) {\n    return nums.length;\n  }\n\n  let ans = Number.MAX_VALUE;\n  while (r < nums.length) {\n    while (x <= 0 && r + 1 < nums.length) {\n      if (x == 0) ans = Math.min(ans, nums.length - (r - l + 1));\n      x += nums[r + 1];\n      r += 1;\n    }\n    if (r + 1 >= nums.length) {\n      if (x == 0) ans = Math.min(ans, nums.length - (r - l + 1));\n      break;\n    }\n    while (x >= 0) {\n      if (x == 0) ans = Math.min(ans, nums.length - (r - l + 1));\n      x -= nums[l];\n      l += 1;\n    }\n  }\n  return ans != Number.MAX_VALUE ? ans : -1;\n};\n"
    }
  },
  {
    "name": "1659-maximize-grid-happiness",
    "code": {
      "JS": "/**\n * @param {number} m\n * @param {number} n\n * @param {number} introvertsCount\n * @param {number} extrovertsCount\n * @return {number}\n */\nconst getMaxGridHappiness = (m, n, introvertsCount, extrovertsCount) => {\n  const state = '0'.repeat(n)\n  const memo = new Map()\n  return helper(state, 0, n, m, introvertsCount, extrovertsCount, memo)\n}\nfunction helper(state, idx, n, m, inCount, exCount, memo) {\n  if ((inCount === 0 && exCount === 0) || idx === m * n) return 0\n  let key = idx + state + inCount + exCount\n  if (memo.has(key)) return memo.get(key)\n  const r = (idx / n) >> 0,\n    c = idx % n\n  let best = 0\n  if (inCount !== 0) {\n    let score = 120\n    if (r > 0) score = calc(state.charAt(0) - '0', 1, score)\n    if (c !== 0) score = calc(state.charAt(state.length - 1) - '0', 1, score)\n    best =\n      score +\n      helper(state.slice(1) + '1', idx + 1, n, m, inCount - 1, exCount, memo)\n  }\n  if (exCount !== 0) {\n    let score = 40\n    if (r > 0) score = calc(state.charAt(0) - '0', 2, score)\n    if (c !== 0) score = calc(state.charAt(state.length - 1) - '0', 2, score)\n    best = Math.max(\n      best,\n      score +\n        helper(state.slice(1) + '2', idx + 1, n, m, inCount, exCount - 1, memo)\n    )\n  }\n  best = Math.max(\n    best,\n    helper(state.slice(1) + '0', idx + 1, n, m, inCount, exCount, memo)\n  )\n  memo.set(key, best)\n  return best\n}\n\nfunction calc(p1, p2, score) {\n  if (p1 === 1 && p2 === 1) return score - 60\n  else if (p1 === 2 && p2 === 2) return score + 40\n  else if (p1 === 1 && p2 === 2) return score - 10\n  else if (p1 === 2 && p2 === 1) return score - 10\n  return score\n}\n"
    }
  },
  {
    "name": "166-fraction-to-recurring-decimal",
    "code": {
      "JS": "/**\n * @param {number} numerator\n * @param {number} denominator\n * @return {string}\n */\nconst fractionToDecimal = function (numerator, denominator) {\n  if (numerator === 0) return '0'\n  let s = ''\n  if (Math.sign(numerator) !== Math.sign(denominator)) s += '-'\n  let n = Math.abs(numerator)\n  const d = Math.abs(denominator)\n  s += Math.floor(n / d)\n  n %= d\n  if (n === 0) return s\n  s += '.'\n  const map = {}\n  while (n !== 0) {\n    map[n] = s.length\n    n *= 10\n    s += Math.floor(n / d)\n    n %= d\n    const i = map[n] // repeat starting index\n    if (i != null) return `${s.slice(0, i)}(${s.slice(i)})`\n  }\n  return s\n}\n"
    }
  },
  {
    "name": "1660-correct-a-binary-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} from\n * @param {number} to\n * @return {TreeNode}\n */\nconst correctBinaryTree = (root, seen = new Set(), found = false) => {\n  const go = (root) => {\n    seen.add(root)\n    if (root.right && seen.has(root.right)) {\n      found = true\n      return null\n    }\n    if (!found && root.right) root.right = go(root.right)\n    if (!found && root.left) root.left = go(root.left)\n    return root\n  }\n  return go(root)\n}\n\n// another\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} from\n * @param {number} to\n * @return {TreeNode}\n */\nconst correctBinaryTree = function(root) {\n  let q = [root]\n  let target\n  while(q.length) {\n    const size = q.length\n    const next = new Set()\n    const row = new Set()\n    for(let i = 0; i < size; i++) {\n      const cur = q.shift()\n      row.add(cur)\n      if(cur.left) next.add(cur.left)\n      if(cur.right) next.add(cur.right)\n    }\n    for(let e of next) {\n      if(next.has(e.right)) {\n        target = e\n        for(let el of row) {\n          if(el.left && el.left === target) {\n            el.left = null\n            return root\n          }\n          if(el.right && el.right === target) {\n            el.right = null\n            return root\n          }\n        }\n      }\n    }\n    q = Array.from(next)\n  }\n  return root\n};\n"
    }
  },
  {
    "name": "1662-check-if-two-string-arrays-are-equivalent",
    "code": {
      "JS": "/**\n * @param {string[]} word1\n * @param {string[]} word2\n * @return {boolean}\n */\nconst arrayStringsAreEqual = function(word1, word2) {\n  return word1.join('') === word2.join('')\n};\n"
    }
  },
  {
    "name": "1663-smallest-string-with-a-given-numeric-value",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number} k\n * @return {string}\n */\nconst getSmallestString = function(n, k) {\n  let arr = Array(n).fill(1)\n  k -= n \n  for(let i = n - 1; i >= 0; i--) {\n    if(k > 0) {\n      const delta = 26 - arr[i]\n      if(k >= delta) {\n        k -= delta\n        arr[i] = arr[i] + delta\n      } else {\n        arr[i] = arr[i] + k\n        k = 0\n      }\n    } else break\n  }\n  const str = 'abcdefghijklmnopqrstuvwxyz'\n  const m = {}\n  for(let i = 0; i < 26; i++) {\n    m[i + 1] = str[i]\n  }\n  const res = []\n  for(let i = 0; i < n; i++) {\n    res[i] = m[arr[i]]\n  }\n  return res.join('')\n};\n"
    }
  },
  {
    "name": "1664-ways-to-make-a-fair-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst waysToMakeFair = function(nums) {\n  const n = nums.length, right = Array(2).fill(0), left = Array(2).fill(0)\n  let res = 0\n  for(let i = 0; i < n; i++) right[i % 2] += nums[i]\n  for(let i = 0; i < n; i++) {\n    right[i % 2] -= nums[i]\n    if(left[0] + right[1] === left[1] + right[0]) res++\n    left[i % 2] += nums[i]\n  }\n  return res\n};\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst waysToMakeFair = function (nums) {\n  const n = nums.length\n  const preOddSum = new Array(n + 1).fill(0)\n  const preEvenSum = new Array(n + 1).fill(0)\n  for (let i = 0; i < n; i++) {\n    if (i % 2 === 0) {\n      preEvenSum[i + 1] = nums[i] + preEvenSum[i]\n      preOddSum[i + 1] = preOddSum[i]\n    } else {\n      preOddSum[i + 1] = nums[i] + preOddSum[i]\n      preEvenSum[i + 1] = preEvenSum[i]\n    }\n  }\n  let ret = 0\n  for (let i = 0; i < n; i++) {\n    if (\n      preEvenSum[i] + preOddSum[n] - preOddSum[i + 1] ===\n      preOddSum[i] + preEvenSum[n] - preEvenSum[i + 1]\n    )\n      ret++\n  }\n  return ret\n}\n"
    }
  },
  {
    "name": "1665-minimum-initial-energy-to-finish-tasks",
    "code": {
      "JS": "/**\n * @param {number[][]} tasks\n * @return {number}\n */\nconst minimumEffort = function (tasks) {\n  tasks.sort((a, b) => a[1] - a[0] > b[1] - b[0] ? 1 : -1)\n  let res = 0\n  for(let e of tasks) {\n    res = Math.max(res + e[0], e[1])\n  }\n  return res\n}\n\n// another\n\n/**\n * @param {number[][]} tasks\n * @return {number}\n */\nconst minimumEffort = function (a) {\n  let low = 0,\n    high = 1e9\n  for (let x of a) low = Math.max(low, x[1])\n  a.sort((lhs, rhs) => (lhs[1] - lhs[0] > rhs[1] - rhs[0] ? -1 : 1))\n  let n = a.length\n  while (low != high) {\n    let mid = low + ((high - low) >> 1)\n    let found = false\n    let rem = mid\n    for (let i = 0; i < n; ++i) {\n      if (rem < a[i][1]) {\n        found = true\n        break\n      }\n      rem -= a[i][0]\n    }\n    if (found) {\n      low = mid + 1\n    } else {\n      high = mid\n    }\n  }\n  return high\n}\n"
    }
  },
  {
    "name": "1666-change-the-root-of-a-binary-tree",
    "code": {
      "JS": "/**\n * // Definition for a Node.\n * function Node(val) {\n *    this.val = val;\n *    this.left = null;\n *    this.right = null;\n *    this.parent = null;\n * };\n */\n\n/**\n * @param {Node} node\n * @return {Node}\n */\nconst flipBinaryTree = function(root, leaf) {\n  function flip(node, from_node){\n    // set and break pointers between node and from_node\n    const p = node.parent\n    node.parent = from_node\n    if (node.left === from_node) node.left = null\n    if (node.right === from_node) node.right = null\n\n    // stopping condition\n    if (node === root) return node\n\n    // set right child\n    if (node.left) node.right = node.left\n    // set left child\n    node.left = flip(p, node)\n    return node\n  }\n  return flip(leaf, null)\n};\n"
    }
  },
  {
    "name": "1668-maximum-repeating-substring",
    "code": {
      "JS": "/**\n * @param {string} sequence\n * @param {string} word\n * @return {number}\n */\nconst maxRepeating = function(sequence, word) {\n  let count = 1;\n  while (sequence.includes(word.repeat(count))) count += 1\n  return count - 1;\n};\n\n// another\n\n/**\n * @param {string} sequence\n * @param {string} word\n * @return {number}\n */\nconst maxRepeating = function(sequence, word) {\n  const s = sequence.length, w = word.length\n  const max_repeat = (s / w) >> 0\n  const failure = Array(w * max_repeat + 1).fill(0)\n  const repeat_words = word.repeat(max_repeat) + '$'\n  let result = 0, j = 0\n  \n  for(let i = 1, hi = repeat_words.length; i < hi; i++) {\n    while(j > 0 && repeat_words[j] !== repeat_words[i]) j = failure[j - 1]\n    j += (repeat_words[j] === repeat_words[i] ? 1 : 0)\n    failure[i] = j\n  }\n\n  j = 0\n  for(let i = 0, len = sequence.length; i < len; i++) {\n    while(j > 0 && repeat_words[j] !== sequence[i]) j = failure[j - 1]\n    j += (repeat_words[j] === sequence[i] ? 1 : 0)\n    result = Math.max(result, (j / w) >> 0)\n  }\n  return result\n};\n\n"
    }
  },
  {
    "name": "167-two-sum-II-input-array-is-sorted",
    "code": {
      "JS": "/**\r\n * @param {number[]} numbers\r\n * @param {number} target\r\n * @return {number[]}\r\n */\r\nconst twoSum = function(numbers, target) {\r\n  const res = [];\r\n  let remaining;\r\n  let next = 0;\r\n  for (let i = 0; i < numbers.length; i++) {\r\n    remaining = target - numbers[i];\r\n    next = i + 1;\r\n    while (next < numbers.length && numbers[next] <= remaining) {\r\n      if (numbers[next] === remaining) {\r\n        res.push(i + 1, next + 1);\r\n        break;\r\n      }\r\n      next += 1;\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n"
    }
  },
  {
    "name": "1670-design-front-middle-back-queue",
    "code": {
      "JS": "\nconst FrontMiddleBackQueue = function() {\n  this.arr = []\n};\n\n/** \n * @param {number} val\n * @return {void}\n */\nFrontMiddleBackQueue.prototype.pushFront = function(val) {\n  this.arr.unshift(val)\n};\n\n/** \n * @param {number} val\n * @return {void}\n */\nFrontMiddleBackQueue.prototype.pushMiddle = function(val) {\n  const len = this.arr.length\n  const mid = Math.floor(len / 2)\n  this.arr.splice(mid, 0, val)\n};\n\n/** \n * @param {number} val\n * @return {void}\n */\nFrontMiddleBackQueue.prototype.pushBack = function(val) {\n  this.arr.push(val)\n};\n\n/**\n * @return {number}\n */\nFrontMiddleBackQueue.prototype.popFront = function() {\n  const tmp = this.arr.shift()\n  return tmp == null ? -1 : tmp\n};\n\n/**\n * @return {number}\n */\nFrontMiddleBackQueue.prototype.popMiddle = function() {\n  const len = this.arr.length\n  const mid = len % 2 === 0 ? Math.floor(len / 2) - 1 : ((len / 2) >> 0)\n  if(len === 2) return this.arr.shift()\n  const [tmp] = this.arr.splice(mid, 1)\n  return tmp == null ? -1 : tmp\n};\n\n/**\n * @return {number}\n */\nFrontMiddleBackQueue.prototype.popBack = function() {\n  const tmp = this.arr.pop()\n  return tmp == null ? -1 : tmp\n};\n\n/** \n * Your FrontMiddleBackQueue object will be instantiated and called as such:\n * var obj = new FrontMiddleBackQueue()\n * obj.pushFront(val)\n * obj.pushMiddle(val)\n * obj.pushBack(val)\n * var param_4 = obj.popFront()\n * var param_5 = obj.popMiddle()\n * var param_6 = obj.popBack()\n */\n"
    }
  },
  {
    "name": "1671-minimum-number-of-removals-to-make-mountain-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst minimumMountainRemovals = function(nums) {\n  const inc = LIS(nums)\n  const dec = LIS(nums.slice().reverse()).reverse()\n  let res = 0\n  for(let i = 0, len = nums.length; i < len; i++) {\n    if(inc[i] > 1 && dec[i] > 1) res = Math.max(res, inc[i] + dec[i] - 1)\n  }\n  return nums.length - res\n};\n\nfunction LIS(arr) {\n  const stack = []\n  const res = []\n  for(let e of arr) {\n    if((stack.length && e > stack[stack.length - 1]) || stack.length === 0) {\n      stack.push(e)\n      res.push(stack.length)\n      continue\n    }\n    let l = 0, r = stack.length - 1\n    while(l < r) {\n      const mid = l + ((r - l) >> 1)\n      if(stack[mid] < e) l = mid + 1\n      else r = mid\n    }\n    stack[l] = e\n    res.push(stack.length)\n  }\n  \n  return res\n}\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst minimumMountainRemovals = function (nums) {\n  if (nums.length <= 3) return 0\n  const n = nums.length\n  const inc = Array(n).fill(0)\n  const dec = Array(n).fill(0)\n  const { max, min } = Math\n  for (let i = 1; i < n; i++) {\n    for (let j = 0; j < i; j++) {\n      if (nums[i] > nums[j]) inc[i] = max(inc[i], inc[j] + 1)\n    }\n  }\n  for (let i = n - 2; i >= 0; i--) {\n    for (let j = n - 1; j > i; j--) {\n      if (nums[i] > nums[j]) dec[i] = max(dec[i], dec[j] + 1)\n    }\n  }\n  let res = 0\n  for (let i = 0; i < n; i++) {\n    if (inc[i] > 0 && dec[i] > 0) res = max(res, inc[i] + dec[i])\n  }\n  return n - res - 1\n}\n"
    }
  },
  {
    "name": "1672-richest-customer-wealth",
    "code": {
      "JS": "/**\n * @param {number[][]} accounts\n * @return {number}\n */\nconst maximumWealth = function(accounts) {\n  let max = -Infinity\n  const m = accounts.length, n = accounts[0].length\n  for(let i = 0; i < m; i++) {\n    let tmp = 0\n    for(let j = 0; j < n; j++) {\n      tmp += accounts[i][j]\n    }\n    max = Math.max(max, tmp)\n  }\n  return max\n};\n"
    }
  },
  {
    "name": "1673-find-the-most-competitive-subsequence",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nconst mostCompetitive = function (nums, k) {\n  const res = new Array(k).fill(0)\n  let start = -1\n  let idx = 0\n  for (let i = k; i > 0; i--) {\n    let min = Number.MAX_VALUE\n    for (let j = start + 1; j < nums.length - i + 1; j++) {\n      if (nums[j] < min) {\n        start = j\n        min = nums[j]\n      }\n    }\n    res[idx++] = min\n  }\n  return res\n}\n\n// another\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nconst mostCompetitive = function (nums, k) {\n  const stack = [],\n    n = nums.length\n  let i = 0\n  while (i < n) {\n    while (\n      stack.length &&\n      stack[stack.length - 1] > nums[i] &&\n      n - i + stack.length > k\n    )\n      stack.pop()\n    if (stack.length < k) stack.push(nums[i])\n    i++\n  }\n  return stack\n}\n\n// another\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nconst mostCompetitive = function (nums, k) {\n  const n = nums.length, stack = []\n  for(let i = 0; i < n; i++) {\n    const ch = nums[i]\n    while(\n      stack.length &&\n      ch < stack[stack.length - 1] &&\n      stack.length + (n - 1 - i) >= k\n    ) {\n      stack.pop()\n    }\n    if(stack.length < k) stack.push(ch)\n  }\n  return stack\n}\n\n"
    }
  },
  {
    "name": "1674-minimum-moves-to-make-array-complementary",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} limit\n * @return {number}\n */\nconst minMoves = function (nums, limit) {\n  const { min, max } = Math\n  const n = nums.length\n  const delta = Array(limit * 2 + 2).fill(0)\n  for (let i = 0; i < n / 2; i++) {\n    const lo = 1 + min(nums[i], nums[n - i - 1])\n    const hi = limit + max(nums[i], nums[n - i - 1])\n    const sum = nums[i] + nums[n - i - 1]\n    delta[lo]--\n    delta[sum]--\n    delta[sum + 1]++\n    delta[hi + 1]++\n  }\n  let now = n\n  let ans = n\n  for (let i = 2; i <= limit * 2; i++) {\n    now += delta[i]\n    ans = min(ans, now)\n  }\n  return ans\n}\n\n// another\n\n/**\n * @param {number[]} nums\n * @param {number} limit\n * @return {number}\n */\nconst minMoves = function (nums, limit) {\n  const n = nums.length, { max, min } = Math\n  const delta = Array(2 * limit + 2).fill(0)\n  for(let i = 0; i < n / 2; i++) {\n    const a = nums[i], b = nums[n - 1 - i]\n    // [2, min(a, b) + 1)\n    delta[2] += 2\n    // [min(a, b) + 1, a + b)\n    delta[min(a, b) + 1] -= 1\n    delta[a + b]--\n    // [a + b + 1, max(a, b) + limit]\n    delta[a + b + 1] += 1\n    // (max(a, b) + limit, 2 * limit]\n    delta[max(a, b) + limit + 1] +=1\n  }\n  \n  let res = n, cur = 0\n  for(let i = 2; i <= limit * 2; i++) {\n    cur += delta[i]\n    res = min(cur, res)\n  }\n  \n  return res\n}\n"
    }
  },
  {
    "name": "1675-minimize-deviation-in-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst minimumDeviation = function (A) {\n  const pq = new PriorityQueue()\n  let n = A.length,\n    mi = Number.MAX_VALUE,\n    res = Number.MAX_VALUE\n  for (let a of A) {\n    if (a % 2 === 1) a *= 2\n    pq.push(-a)\n    mi = Math.min(mi, a)\n  }\n  while (true) {\n    let a = -pq.pop()\n    res = Math.min(res, a - mi)\n    if (a % 2 === 1) break\n    mi = Math.min(mi, a / 2)\n    pq.push(-a / 2)\n  }\n  return res\n}\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a < b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n"
    }
  },
  {
    "name": "1676-lowest-common-ancestor-of-a-binary-tree-iv",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode[]} nodes\n * @return {TreeNode}\n */\nconst lowestCommonAncestor = function(root, nodes) {\n  if (root == null) return root\n  for(let e of nodes) {\n    if(root === e) return root\n  }\n  const left = lowestCommonAncestor(root.left, nodes)\n  const right = lowestCommonAncestor(root.right, nodes)\n  if(left && right) return root\n  return left ? left : right\n};\n"
    }
  },
  {
    "name": "1678-goal-parser-interpretation",
    "code": {
      "JS": "/**\n * @param {string} command\n * @return {string}\n */\nconst interpret = function(c) {\n  const stack = [c[0]]\n  const n = c.length\n  let i = 1\n  while(i < n) {\n    if(c[i] === ')') {\n      if(stack[stack.length - 1] === '(') {\n        stack.pop()\n        stack.push('o')\n        i++\n      } else {\n        let res = ''\n        while(stack[stack.length - 1] !== '(') {\n          const tmp = stack.pop()\n          res = tmp + res\n        }\n        stack.pop()\n        stack.push(res)\n        i++\n      }\n    } else {\n      stack.push(c[i])\n      i++\n    }\n  }\n  return stack.join('')\n};\n"
    }
  },
  {
    "name": "1679-max-number-of-k-sum-pairs",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nconst maxOperations = function(nums, k) {\n   const m = new Map()\n   let res = 0\n   for(let e of nums) {\n     if(!m.has(e)) m.set(e, 0)\n     if(m.has(k - e) && m.get(k - e)) {\n       res++\n       m.set(k - e, m.get(k - e) - 1)\n     } else {\n       m.set(e, m.get(e) + 1)\n     }\n   }\n   return res;\n};\n"
    }
  },
  {
    "name": "168-excel-sheet-column-title",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {string}\n */\nconst convertToTitle = function(n) {\n    if (n === 0) {\n        return ''\n    }\n    const res = [];\n    const hash = {};\n    ('ABCDEFGHIJKLMNOPQRSTUVWXYZ').split('').forEach((el,idx) => {\n        hash[idx] = el\n    })\n \n    while(n > 0) {\n        n--;\n        res.unshift(hash[n % 26]);\n        n = Math.floor(n / 26);\n    }\n\n    return res.join('')\n};\n"
    }
  },
  {
    "name": "1680-concatenation-of-consecutive-binary-numbers",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst concatenatedBinary = function(n) {\n  let res = ''\n  const mod = 10 ** 9 + 7\n  for(let i = 1; i <= n; i++) {\n    res += dec2bin(i)\n    res = dec2bin(parseInt(res, 2) % mod)\n  }\n  return parseInt(res, 2) % mod\n};\nfunction dec2bin(dec){\n  return (dec >>> 0).toString(2);\n}\n\n// another\n\n/**\n * @param {number} n\n * @return {number}\n */\nconst concatenatedBinary = function (n) {\n  const mod = BigInt(1e9 + 7)\n  let res = 0n\n  for (let i = 1n, shift = 0n; i <= n; i++) {\n    let singleBit = (i & (i - 1n)) == 0\n    if (singleBit) shift++\n    res <<= shift\n    res += i\n    res %= mod\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "1681-minimum-incompatibility",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minimumIncompatibility = function (nums, k) {\n  if (k === nums.length) {\n    return 0\n  }\n  const counts = Array(nums.length + 1).fill(0)\n  for (let num of nums) {\n    counts[num]++\n    if (counts[num] > k) {\n      return -1\n    }\n  }\n  const size = nums.length / k\n  let ans = Number.MAX_VALUE\n  const backtracking = (groupIdx, index, sum, lowIndex, curIndex) => {\n    if (index === size) {\n      sum += curIndex - lowIndex\n      if (sum > ans) {\n        return\n      }\n      if (groupIdx === k - 1) {\n        ans = sum\n        return\n      } else {\n        groupIdx++\n        index = 0\n      }\n    }\n    if (index === 0) {\n      for (let i = 0; i < counts.length; i++) {\n        if (counts[i]) {\n          counts[i]--\n          backtracking(groupIdx, index + 1, sum, i, i)\n          counts[i]++\n        }\n      }\n    } else {\n      for (let i = curIndex + 1; i < counts.length; i++) {\n        if (counts[i]) {\n          counts[i]--\n          backtracking(groupIdx, index + 1, sum, lowIndex, i)\n          counts[i]++\n        }\n      }\n    }\n  }\n  backtracking(0, 0, 0, 0, 0)\n  return ans\n}\n\n// another\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nconst minimumIncompatibility = function (nums, k) {\n  if (nums.length === k) return 0\n  const maxInBucket = nums.length / k\n  const freqCount = {}\n  for (const n of nums) {\n    if (freqCount[n]) {\n      if (freqCount[n] === k) {\n        return -1\n      } else {\n        freqCount[n]++\n      }\n    } else {\n      freqCount[n] = 1\n    }\n  }\n  const cache = {}\n  const allIndiciesUsedMask = 2 ** nums.length - 1\n  const dfs = (usedIndicesBitMask) => {\n    if (usedIndicesBitMask === allIndiciesUsedMask) {\n      return 0\n    }\n    if (cache[usedIndicesBitMask]) {\n      return cache[usedIndicesBitMask]\n    }\n    const valsToIndices = {}\n    for (let i = 0; i < nums.length; i++) {\n      const indexMask = 1 << i\n      if (usedIndicesBitMask & indexMask) continue\n      const value = nums[i]\n      if (!valsToIndices.hasOwnProperty(value)) {\n        valsToIndices[value] = i\n      }\n    }\n    const indicesAvailable = Object.values(valsToIndices)\n    let minIncompatibilityCost = Infinity\n    const combinations = createCombinations(indicesAvailable, maxInBucket)\n    for (const indices of combinations) {\n      let nextMask = usedIndicesBitMask\n      let minVal = Infinity\n      let maxVal = -Infinity\n      for (const index of indices) {\n        minVal = Math.min(minVal, nums[index])\n        maxVal = Math.max(maxVal, nums[index])\n        nextMask = nextMask | (1 << index)\n      }\n      const incompatibilityCost = maxVal - minVal\n      minIncompatibilityCost = Math.min(\n        minIncompatibilityCost,\n        dfs(nextMask) + incompatibilityCost\n      )\n    }\n    return (cache[usedIndicesBitMask] = minIncompatibilityCost)\n  }\n  return dfs(0)\n}\n\nfunction createCombinations(indices, len) {\n  const combinations = []\n  if (indices.length < len) {\n    return combinations\n  }\n  const stack = [[[], 0]]\n  while (stack.length > 0) {\n    let [combi, i] = stack.pop()\n    for (; i < indices.length; i++) {\n      const combination = [...combi, indices[i]]\n      if (combination.length === len) {\n        combinations.push(combination)\n      } else {\n        stack.push([combination, i + 1])\n      }\n    }\n  }\n  return combinations\n}\n"
    }
  },
  {
    "name": "1684-count-the-number-of-consistent-strings",
    "code": {
      "JS": "/**\n * @param {string} allowed\n * @param {string[]} words\n * @return {number}\n */\nvar countConsistentStrings = function(allowed, words) {\n  const set = new Set()\n  for(let c of allowed) set.add(c)\n  let res = 0\n  for(let i = 0, len = words.length; i < len; i++) {\n    const cur = words[i]\n    let b = true\n    for(let c of cur) {\n      if(!set.has(c)) {\n        b = false\n        break\n      }\n    }\n    if(b) res++\n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "1685-sum-of-absolute-differences-in-a-sorted-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nconst getSumAbsoluteDifferences = function(nums) {\n  const res = [], n = nums.length\n  let sum = 0\n  for(let first = nums[0], i = 1; i < n; i++) {\n    sum += nums[i] - first\n  }\n  res[0] = sum\n  for(let i = 1; i < n; i++) {\n    res[i] = res[i - 1] - (nums[i] - nums[i - 1]) * (n - i - 1) + (nums[i] - nums[i - 1]) * (i - 1)\n  }\n\n  return res\n};\n"
    }
  },
  {
    "name": "1686-stone-game-vi",
    "code": {
      "JS": "/**\n * @param {number[]} aliceValues\n * @param {number[]} bobValues\n * @return {number}\n */\nconst stoneGameVI = function (aliceValues, bobValues) {\n  let data = []\n  const length = aliceValues.length\n  for (let i = 0; i < length; i++) {\n    data.push([aliceValues[i] + bobValues[i], aliceValues[i], bobValues[i]])\n  }\n  data.sort((a, b) => a[0] - b[0])\n  data = data.reverse()\n\n  let aScore = 0\n  let bScore = 0\n  for (let i = 0; i < length; i++) {\n    if (i % 2 == 0) aScore += data[i][1]\n    else bScore += data[i][2]\n  }\n\n  if (aScore > bScore) return 1\n  else if (aScore == bScore) return 0\n  else return -1\n}\n"
    }
  },
  {
    "name": "1687-delivering-boxes-from-storage-to-ports",
    "code": {
      "JS": "/**\n * @param {number[][]} boxes\n * @param {number} portsCount\n * @param {number} maxBoxes\n * @param {number} maxWeight\n * @return {number}\n */\nvar boxDelivering = function (boxes, portsCount, maxBoxes, maxWeight) {\n  const n = boxes.length\n  const diff = Array(n).fill(0)\n  for (let i = 0; i < n - 1; i++) {\n    if (boxes[i][0] != boxes[i + 1][0]) diff[i] = 1\n  }\n  const dp = Array(n).fill(0)\n  let cur = 0\n  let cbox = 0\n  let start = 0\n  for (let i = 0; i < n; i++) {\n    if (i - start == maxBoxes) {\n      cur -= boxes[start][1]\n      cbox -= diff[start]\n      start += 1\n    }\n    cur += boxes[i][1]\n    if (i > 0) cbox += diff[i - 1]\n    while (cur > maxWeight) {\n      cur -= boxes[start][1]\n      cbox -= diff[start]\n      start += 1\n    }\n    while (start < i && dp[start] == dp[start - 1]) {\n      cur -= boxes[start][1]\n      cbox -= diff[start]\n      start += 1\n    }\n    dp[i] = (start == 0 ? 0 : dp[start - 1]) + cbox + 2\n  }\n  return dp[n - 1]\n}\n"
    }
  },
  {
    "name": "1688-count-of-matches-in-tournament",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nvar numberOfMatches = function(n) {\n  const obj = { res: 0 }\n  helper(n, obj)\n  return obj.res\n};\n\nfunction helper(num, obj) {\n  if(num <= 1) return\n  const odd = num % 2 === 1\n  if(odd) {\n    const tmp = Math.floor((num - 1) / 2) \n    obj.res += tmp\n    helper(tmp + 1, obj)\n  } else {\n    const tmp = Math.floor(num / 2) \n    obj.res += tmp\n    helper(tmp, obj)\n  }\n}\n"
    }
  },
  {
    "name": "1689-partitioning-into-minimum-number-of-deci-binary-numbers",
    "code": {
      "JS": "/**\n * @param {string} n\n * @return {number}\n */\nvar minPartitions = function(n) {\n  let res = 0\n  const arr = n.split('').map(e => parseInt(e))\n  for(let i = 0, len = arr.length; i < len; i++) {\n    res = Math.max(arr[i], res)\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "169-majority-element",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nconst majorityElement = function(nums) {\r\n  const hash = {};\r\n  nums.forEach(el => {\r\n    if (hash.hasOwnProperty(el)) {\r\n      hash[el] += 1;\r\n    } else {\r\n      hash[el] = 1;\r\n    }\r\n  });\r\n  return Object.entries(hash)\r\n    .filter(el => el[1] > Math.floor(nums.length / 2))\r\n    .map(el => +el[0])\r\n    .sort((a, b) => b - a)[0];\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nconst majorityElement = function(nums) {\r\n  let cnt = 1, candidate = nums[0]\r\n  for(let i = 1, n = nums.length; i < n; i++) {\r\n    if(candidate === nums[i]) cnt++\r\n    else cnt--\r\n    if(cnt === 0) {\r\n      cnt = 1\r\n      candidate = nums[i]\r\n    }\r\n  }\r\n  return candidate\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nconst majorityElement = function(nums) {\r\n  let cnt = 1, candidate = nums[0]\r\n  for(let i = 1, n = nums.length; i < n; i++) {\r\n    if(cnt === 0) {\r\n      cnt = 1\r\n      candidate = nums[i]\r\n    }else if(candidate === nums[i]) cnt++\r\n    else cnt--\r\n  }\r\n  return candidate\r\n};\r\n"
    }
  },
  {
    "name": "1690-stone-game-vii",
    "code": {
      "JS": "/**\n * @param {number[]} stones\n * @return {number}\n */\nconst stoneGameVII = function (stones) {\n  let len = stones.length\n  const dp = Array.from({ length: len }, () => Array(len).fill(0))\n  for (let i = len - 2; i >= 0; i--) {\n    let sum = stones[i]\n    for (let j = i + 1; j < len; j++) {\n      sum += stones[j]\n      dp[i][j] = Math.max(\n        sum - stones[i] - dp[i + 1][j],\n        sum - stones[j] - dp[i][j - 1]\n      )\n    }\n  }\n  return dp[0][len - 1]\n}\n"
    }
  },
  {
    "name": "1691-maximum-height-by-stacking-cuboids",
    "code": {
      "JS": "/**\n * @param {number[][]} cuboids\n * @return {number}\n */\nvar maxHeight = function (cuboids) {\n  let n = cuboids.length\n  for (let c of cuboids) {\n    c.sort((a, b) => a - b)\n  }\n  const { max } = Math\n  cuboids.sort(compare)\n  const f = Array(n)\n  let ans = 0\n  for (let i = 0; i < n; i++) {\n    f[i] = cuboids[i][2]\n    for (let j = 0; j < i; j++) {\n      if (\n        cuboids[i][0] <= cuboids[j][0] &&\n        cuboids[i][1] <= cuboids[j][1] &&\n        cuboids[i][2] <= cuboids[j][2]\n      )\n        f[i] = max(f[i], f[j] + cuboids[i][2])\n    }\n    ans = max(ans, f[i])\n  }\n  return ans\n  function compare(a, b) {\n    if (a[0] != b[0]) return b[0] - a[0]\n    if (a[1] != b[1]) return b[1] - a[1]\n    return b[2] - a[2]\n  }\n}\n\n// another\n\n/**\n * @param {number[][]} cuboids\n * @return {number}\n */\nvar maxHeight = function(cuboids) {\n  cuboids.forEach((cuboid) => cuboid.sort((a, b) => a - b));\n  cuboids.sort((a, b) => {\n    if (a[0] !== b[0]) return b[0] - a[0];\n    if (a[1] !== b[1]) return b[1] - a[1];\n    return b[2] - a[2];\n  });\n  const n = cuboids.length;\n  const dp = Array(n).fill(0);\n  let res = 0;\n  for (let j = 0; j < n; ++j) {\n    dp[j] = cuboids[j][2];\n    for (let i = 0; i < j; ++i) {\n      if (cuboids[i][0] >= cuboids[j][0]\n        && cuboids[i][1] >= cuboids[j][1]\n        && cuboids[i][2] >= cuboids[j][2]\n      ) {\n        dp[j] = Math.max(dp[j], dp[i] + cuboids[j][2]);\n      }\n    }\n    res = Math.max(res, dp[j]);\n  }\n  return res;\n};\n"
    }
  },
  {
    "name": "1694-reformat-phone-number",
    "code": {
      "JS": "/**\n * @param {string} number\n * @return {string}\n */\nconst reformatNumber = function(number) {\n  let str = number.replace(/\\-/g, '')\n  str = str.split(' ').join('')\n  const n = str.length\n  const re = n % 3\n  let lo = 0, hi = 0\n  let tmp = []\n  if(re === 1) {\n    hi = n - 5\n    tmp.push(str.slice(n - 4, n - 2), str.slice(n - 2))\n  } else if(re === 2) {\n    hi = n - 3\n    tmp.push(str.slice(n - 2))\n  } else {\n    hi = n - 1\n  }\n  const res = []\n  for(let i = lo; i <= hi; i += 3) {\n    res.push(str.slice(i, i + 3))\n  }\n  \n res.push(...tmp)\n    \n  return res.join('-')\n};\n"
    }
  },
  {
    "name": "1695-maximum-erasure-value",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst maximumUniqueSubarray = function(nums) {\n  return maxSumSubarray(nums, nums.length)\n};\n\nfunction maxSumSubarray(arr, n) {\n\n  let i = 0, j = 1;\n  const set = new Set();\n  set.add(arr[0]);\n\n  let sum = arr[0];\n  let maxsum = sum;\n  let end = arr[0]\n \n  while (i < n - 1 && j < n) {\n    const is_in = set.has(arr[j])\n    if (!is_in) {\n      sum = sum + arr[j];\n      maxsum = Math.max(sum, maxsum);\n    \n      set.add(arr[j++]);\n    } else {\n      sum -= arr[i];\n      set.delete(arr[i++]);\n    }\n  }\n  return maxsum;\n}\n\nfunction end(s) {\n  return Array.from(s).pop();\n}\n"
    }
  },
  {
    "name": "1696-jump-game-vi",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nconst maxResult = function (nums, k) {\n  const n = nums.length\n  const f = Array(n).fill(0)\n  f[0] = nums[0]\n  const q = [0]\n  for (let i = 1; i < n; ++i) {\n    while (i - q[0] > k) {\n      q.shift()\n    }\n    f[i] = f[q[0]] + nums[i]\n    while (q.length && f[i] >= f[q[q.length - 1]]) {\n      q.pop()\n    }\n    q.push(i)\n  }\n  return f[n - 1]\n}\n"
    }
  },
  {
    "name": "1697-checking-existence-of-edge-length-limited-paths",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[][]} edgeList\n * @param {number[][]} queries\n * @return {boolean[]}\n */\nconst distanceLimitedPathsExist = function (n, edgeList, queries) {\n  edgeList.sort((a, b) => a[2] - b[2])\n  const m = queries.length\n  const ans = Array(m).fill(false)\n  const order = Array(m).fill(0)\n  for (let i = 0; i < m; ++i) order[i] = i\n  order.sort((i, j) => queries[i][2] - queries[j][2])\n  const uf = new UnionFind(n)\n  let idx = 0\n  for (let i of order) {\n    const limit = queries[i][2]\n    while (idx < edgeList.length && edgeList[idx][2] < limit) {\n      const [u, v] = edgeList[idx]\n      uf.union(u, v)\n      idx++\n    }\n    const [u0, v0] = queries[i]\n    if (uf.find(u0) === uf.find(v0)) ans[i] = true\n  }\n  return ans\n}\nclass UnionFind {\n  constructor(n) {\n    this.parents = Array(n)\n      .fill(0)\n      .map((e, i) => i)\n    this.ranks = Array(n).fill(0)\n  }\n  root(x) {\n    while (x !== this.parents[x]) {\n      this.parents[x] = this.parents[this.parents[x]]\n      x = this.parents[x]\n    }\n    return x\n  }\n  find(x) {\n    return this.root(x)\n  }\n  check(x, y) {\n    return this.root(x) === this.root(y)\n  }\n  union(x, y) {\n    const [rx, ry] = [this.find(x), this.find(y)]\n    if (this.ranks[rx] >= this.ranks[ry]) {\n      this.parents[ry] = rx\n      this.ranks[rx] += this.ranks[ry]\n    } else if (this.ranks[ry] > this.ranks[rx]) {\n      this.parents[rx] = ry\n      this.ranks[ry] += this.ranks[rx]\n    }\n  }\n}\n"
    }
  },
  {
    "name": "1698-number-of-distinct-substrings-in-a-string",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst countDistinct = function(s) {\n  const set = new Set()\n  for(let i = 0, len = s.length; i < len; i++) {\n    for(let j = i + 1; j <= len; j++) {\n      set.add(s.slice(i, j))\n    }\n  }\n  \n  return set.size\n};\n\n// another\n\n/**\n * @param {string} s\n * @return {number}\n */\nconst countDistinct = function (s, count = 0) {\n  const root = new Trie()\n  const N = s.length\n  for (let i = 0; i < N; i++) {\n    let node = root\n    for (let j = i; j < N; j++) {\n      const c = s[j]\n      if (!node.children.has(c)) {\n        node.children.set(c, new Trie())\n        count++\n      }\n      node = node.children.get(c)\n    }\n  }\n  return count\n}\nclass Trie {\n  constructor() {\n    this.children = new Map()\n  }\n}\n"
    }
  },
  {
    "name": "17-letter-combinations-of-a-phone-number",
    "code": {
      "JS": "/**\r\n * @param {string} digits\r\n * @return {string[]}\r\n */\r\nconst letterCombinations = function(digits) {\r\n  if (digits === \"\") {\r\n    return [];\r\n  }\r\n  const charMap = {\r\n    2: [\"a\", \"b\", \"c\"],\r\n    3: [\"d\", \"e\", \"f\"],\r\n    4: [\"g\", \"h\", \"i\"],\r\n    5: [\"j\", \"k\", \"l\"],\r\n    6: [\"m\", \"n\", \"o\"],\r\n    7: [\"p\", \"q\", \"r\", \"s\"],\r\n    8: [\"t\", \"u\", \"v\"],\r\n    9: [\"w\", \"x\", \"y\", \"z\"]\r\n  };\r\n  const res = [];\r\n  const matrix = [];\r\n  for (let i = 0; i < digits.length; i++) {\r\n    matrix.push(charMap[digits.charAt(i)]);\r\n  }\r\n  let tmp = matrix[0];\r\n  for (let j = 1; j < matrix.length; j++) {\r\n    tmp = helper(matrix, j, tmp);\r\n  }\r\n  return tmp;\r\n};\r\nfunction helper(matrix, rowIdx, arr) {\r\n  const res = [];\r\n  for (let i = 0; i < arr.length; i++) {\r\n    const preStr = arr[i];\r\n    for (let j = 0; j < matrix[rowIdx].length; j++) {\r\n      res.push(`${preStr}${matrix[rowIdx][j]}`);\r\n    }\r\n  }\r\n  return res;\r\n}\r\n"
    }
  },
  {
    "name": "170-two-sum-iii-data-structure-design",
    "code": {
      "JS": "/**\n * Initialize your data structure here.\n */\nconst TwoSum = function() {\n  this.hm = new Map();\n};\n\n/**\n * Add the number to an internal data structure..\n * @param {number} number\n * @return {void}\n */\nTwoSum.prototype.add = function(number) {\n  this.hm.set(number, (this.hm.get(number) || 0) + 1);\n};\n\n/**\n * Find if there exists any pair of numbers which sum is equal to the value.\n * @param {number} value\n * @return {boolean}\n */\nTwoSum.prototype.find = function(value) {\n  for (let item of this.hm) {\n    let target = value - item[0];\n    if (this.hm.has(target)) {\n      if (target !== item[0] || this.hm.get(target) > 1) return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Your TwoSum object will be instantiated and called as such:\n * var obj = new TwoSum()\n * obj.add(number)\n * var param_2 = obj.find(value)\n */\n"
    }
  },
  {
    "name": "1700-number-of-students-unable-to-eat-lunch",
    "code": {
      "JS": "/**\n * @param {number[]} students\n * @param {number[]} sandwiches\n * @return {number}\n */\nconst countStudents = function(students, sandwiches) {\n  const n = students.length\n  let res = n\n  while(helper(students, sandwiches)) {\n      const len = students.length\n      for(let i = 0; i < len; i++) {\n        if (students[0] === sandwiches[0]) {\n          students.shift()\n          sandwiches.shift()\n          res--\n        } else {\n          const tmp = students[0]\n          students.shift()\n          students.push(tmp)\n        }\n      }\n  }\n  return res\n};\n\nfunction helper(stu, san) {\n  const n = stu.length\n  let res = false\n  for(let i = 0; i < n; i++) {\n    if (stu[i] === san[0]) {\n      return true\n    }\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "1701-average-waiting-time",
    "code": {
      "JS": "/**\n * @param {number[][]} customers\n * @return {number}\n */\nconst averageWaitingTime = function(customers) {\n  const n = customers.length\n  let start = customers[0][0], end = start + customers[0][1]\n  let sum = end - start\n  for(let i = 1; i < n; i++) {\n    end = end > customers[i][0] ? end + customers[i][1] : customers[i][0] + customers[i][1]\n    sum += (end - customers[i][0])\n  }\n  \n  let res = sum / n\n  \n  return res\n};\n"
    }
  },
  {
    "name": "1703-maximum-binary-string-after-change",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nconst minMoves = function (nums, k) {\n  if (k === 1) return 0\n  let n = 0\n  const pos = []\n  for (let i = 0; i < nums.length; ++i) {\n    if (nums[i]) pos.push(i - n++)\n  }\n  const sums = []\n  sums[0] = pos[0]\n  for (let i = 1; i < n; ++i) sums[i] = pos[i] + sums[i - 1]\n  let res = Number.MAX_VALUE\n  let l = (k / 2) >> 0,\n    r = k - l - 1\n  for (let i = 0; i + k <= n; ++i) {\n    const m = i + ((k / 2) >>> 0)\n    const cur =\n      pos[m] * l -\n      (sums[m - 1] - sums[i] + pos[i]) -\n      pos[m] * r +\n      sums[i + k - 1] -\n      sums[m]\n    res = Math.min(cur, res)\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "1704-determine-if-string-halves-are-alike",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {boolean}\n */\nconst halvesAreAlike = function(s) {\n  const set = new Set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'])\n  const n = s.length\n  const mid = n / 2\n  const first = s.slice(0, mid), second = s.slice(mid)\n  return chk(first, set) === chk(second, set)\n};\n\nfunction chk(str, set) {\n  let res = 0\n  for(let i = 0, len = str.length; i < len; i++) {\n    if(set.has(str[i])) res++\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "1704-minimum-adjacent-swaps-for-k-consecutive-ones",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar minMoves = function(nums, k) {\n    if (k == 1) return 0;\n    let n = 0;\n    let pos = [];\n    for (let i = 0; i < nums.length; ++i) {\n      if (nums[i]) {\n        pos.push(i - (n++));\n      }\n    }\n    let sums = [];\n    sums[0] = pos[0];\n    for (let i = 1; i < n; ++i) {\n      sums[i] = pos[i] + sums[i - 1];\n    }\n    let res = Number.MAX_VALUE;\n    let l = (k / 2) >> 0, r = k - l - 1;\n    for (let i = 0; i + k <= n; ++i) {\n      let m = i + ((k / 2) >>> 0);\n      let cur = pos[m] * l - (sums[m - 1] - sums[i] + pos[i]) - pos[m] * r + sums[i + k - 1] - sums[m];\n      res = Math.min(cur, res);\n    }\n    return res;\n};\n\n"
    }
  },
  {
    "name": "1705-maximum-number-of-eaten-apples",
    "code": {
      "JS": "/**\n * @param {number[]} apples\n * @param {number[]} days\n * @return {number}\n */\nconst eatenApples = function (apples, days) {\n  const n = apples.length\n  let fin = 0,\n    i = 0\n  const q = new PriorityQueue()\n  while (i < n || !q.isEmpty()) {\n    if (i < n && apples[i] > 0) q.push([i + days[i], apples[i]])\n    while (!q.isEmpty() && (q.peek()[0] <= i || q.peek()[1] === 0)) q.pop()\n    if (!q.isEmpty()) {\n      q.peek()[1] -= 1\n      if(q.peek()[1] <= 0) q.pop()\n      fin += 1\n    }\n    i += 1\n  }\n  return fin\n}\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a[0] < b[0]) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n"
    }
  },
  {
    "name": "1706-where-will-the-ball-fall",
    "code": {
      "JS": "/**\n * @param {number[][]} grid\n * @return {number[]}\n */\nconst findBall = function (grid) {\n  const res = new Array(grid[0].length).fill(0)\n  for (let i = 0; i < res.length; i++) {\n    let start = i\n    let state = 1\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[j][start] === 1) {\n        if (start >= grid[0].length - 1 || grid[j][start + 1] === -1) {\n          state = -1\n          break\n        }\n        start++\n      } else {\n        if (start <= 0 || grid[j][start - 1] == 1) {\n          state = -1\n          break\n        }\n        start--\n      }\n    }\n    res[i] = state === -1 ? state : start\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "1707-maximum-xor-with-an-element-from-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number[]}\n */\nconst maximizeXor = function (nums, queries) {\n  nums.sort((a, b) => a - b)\n  const numOfBits = 1 + Math.floor(Math.log2(nums[nums.length - 1]))\n  const maxMask = (1 << numOfBits) - 1\n  return queries.map(([x, m]) => query(x, m))\n  function query(x, m) {\n    if (m < nums[0]) return -1\n    let l = 0,\n      r = nums.length\n    while (l < r) {\n      let mid = l + ((r - l) >> 1)\n      if (m < nums[mid])r = mid\n      else l = mid + 1\n    }\n    r--\n    l = 0\n    let ans = x & ~maxMask\n    for (let bit = numOfBits - 1; bit >= 0; bit--) {\n      const mask = 1 << bit\n      if (x & mask) {\n        if ((nums[l] & mask) === 0) {\n          ans |= 1 << bit\n          r = search(l, r, mask) - 1\n        }\n      } else {\n        if (nums[r] & mask) {\n          ans |= 1 << bit\n          l = search(l, r, mask)\n        }\n      }\n    }\n    return ans\n  }\n  function search(l, r, mask) {\n    while (l <= r) {\n      const m = l + ((r - l) >> 1)\n      if ((nums[m] & mask) === 0) l = m + 1 \n      else r = m - 1\n    }\n    return l\n  }\n}\n\n\n// another\n\n/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number[]}\n */\nconst maximizeXor = function (nums, queries) {\n  const n = queries.length\n  const result = new Array(n)\n  const trie = [null, null]\n  for (let num of nums) {\n    let node = trie\n    for (let i = 30; i >= 0; i--) {\n      const b = 1 << i\n      if (b & num) {\n        if (!node[1]) node[1] = [null, null]\n        node = node[1]\n      } else {\n        if (!node[0]) node[0] = [null, null]\n        node = node[0]\n      }\n    }\n  }\n  const min = Math.min(...nums)\n  const dfs = (node, num, i, val, max) => {\n    if (!node || val > max) return -1\n    if (i === -1) return val\n    const bit = 1 << i\n    i--\n    if (bit > max) return dfs(node[0], num, i, val, max)\n    if (num & bit) {\n      let x = dfs(node[0], num, i, val, max)\n      if (x > -1) return x\n      return dfs(node[1], num, i, val | bit, max)\n    } else {\n      let y = dfs(node[1], num, i, val | bit, max)\n      if (y > -1) return y\n      return dfs(node[0], num, i, val, max)\n    }\n  }\n\n  for (let i = 0; i < n; i++) {\n    const [num, max] = queries[i]\n    if (max < min) {\n      result[i] = -1\n      continue\n    }\n    result[i] = dfs(trie, num, 30, 0, max) ^ num\n  }\n  return result\n}\n"
    }
  },
  {
    "name": "1708-largest-subarray-length-k",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nconst largestSubarray = function(nums, k) {\n  const n = nums.length\n  const hi = n - k\n  let start = Number.MIN_VALUE, idx = -1\n  for(let i = 0; i <= hi; i++) {\n    if(nums[i] > start) {\n      start = nums[i]\n      idx = i\n    }\n  }\n  return nums.slice(idx, idx + k)\n};\n"
    }
  },
  {
    "name": "171-excel-sheet-column-number",
    "code": {
      "JS": "/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nconst titleToNumber = function(s) {\r\n  const arr = s.split(\"\");\r\n  const len = arr.length;\r\n  const uac = \"A\".charCodeAt(0);\r\n  return arr.reduce((ac, el, idx, arr) => {\r\n    return ac + Math.pow(26, len - idx - 1) * (`${el}`.charCodeAt(0) - uac + 1);\r\n  }, 0);\r\n};\r\n\r\nconsole.log(titleToNumber(\"A\"));\r\nconsole.log(titleToNumber(\"AA\"));\r\n\r\n// another\r\n\r\n/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nconst titleToNumber = function(s) {\r\n  let result = 0;\r\n  const A = 'A'.charCodeAt(0)\r\n  for (let i = 0; i < s.length; result = result * 26 + (s.charCodeAt(i) - A + 1), i++);\r\n  return result;\r\n};\r\n"
    }
  },
  {
    "name": "1710-maximum-units-on-a-truck",
    "code": {
      "JS": "/**\n * @param {number[][]} boxTypes\n * @param {number} truckSize\n * @return {number}\n */\nconst maximumUnits = function (boxTypes, truckSize) {\n  boxTypes.sort((a, b) => b[1] - a[1])\n  let res = 0\n\n  for (let i = 0; i < boxTypes.length && truckSize > 0; ++i) {\n    let used = Math.min(boxTypes[i][0], truckSize)\n    truckSize -= used\n    res += used * boxTypes[i][1]\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "1711-count-good-meals",
    "code": {
      "JS": "/**\n * @param {number[]} deliciousness\n * @return {number}\n */\nconst countPairs = function (deliciousness) {\n  const N = deliciousness.length\n  deliciousness.sort((a, b) => a - b)\n  const mp = {},\n    mod = 10 ** 9 + 7\n  let ret = 0\n  for (let i = 0; i < N; i++) {\n    if (deliciousness[i] !== 0) {\n      let sum = 1 << (32 - __builtin_clz(deliciousness[i]) - 1)\n      ret += mp[sum - deliciousness[i]] || 0\n      ret += mp[(sum << 1) - deliciousness[i]] || 0\n      if (ret >= mod) ret -= mod\n    }\n    if (mp[deliciousness[i]] == null) mp[deliciousness[i]] = 0\n    mp[deliciousness[i]]++\n  }\n  return ret\n}\n\nfunction __builtin_clz(num) {\n  if (num === 0) return 32\n  return 32 - dec2bin(num).length\n}\n\nfunction dec2bin(num) {\n  return (num >>> 0).toString(2)\n}\n"
    }
  },
  {
    "name": "1712-ways-to-split-array-into-three-subarrays",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst waysToSplit = function (nums) {\n  const N = nums.length\n  let ret = 0\n  const presum = Array(N + 1).fill(0), MOD = 10 ** 9 + 7\n  for (let i = 0; i < N; i++) presum[i + 1] = presum[i] + nums[i]\n  let avg = (presum[N] / 3 + 1) >> 0\n  for (let l = 1, m = 2, r = 2; l < N - 1; l++) {\n    if (presum[l] > avg) break\n    while (m < N && presum[l] > presum[m] - presum[l]) m++\n    m = Math.max(m, l + 1)\n    if (m > r) r = m\n    while (r < N && presum[N] - presum[r] >= presum[r] - presum[l]) r++\n    ret += r - m\n    if (ret >= MOD) ret -= MOD\n  }\n  return ret\n}\n"
    }
  },
  {
    "name": "1713-minimum-operations-to-make-a-subsequence",
    "code": {
      "JS": "/**\n * @param {number[]} target\n * @param {number[]} arr\n * @return {number}\n */\nconst minOperations = function(target, arr) {\n  const hash = {}\n  for (let i = 0, n = target.length; i < n; i++) {\n    hash[target[i]] = i\n  }\n  const stk = []\n  for(let e of arr) {\n    if(hash[e] == null) continue\n    let l = 0, r = stk.length\n    while(l < r) {\n      const mid = l + (~~((r - l) / 2))\n      if(stk[mid] < hash[e]) l = mid + 1\n      else r = mid\n    }\n    stk[l] = hash[e]\n  }\n  return target.length - stk.length\n};\n\n// another\n\n/**\n * @param {number[]} target\n * @param {number[]} arr\n * @return {number}\n */\nconst minOperations = function (target, arr) {\n  let length1 = target.length,\n    length2 = arr.length\n  const targetMap = new Map()\n  for (let i = 0; i < length1; i++) targetMap.set(target[i], i)\n  const list = new Array()\n  for (let i = 0; i < length2; i++) {\n    let num = arr[i]\n    if (targetMap.has(num)) list.push(targetMap.get(num))\n  }\n  let longestIncreasing = lengthOfLIS(list)\n  return target.length - longestIncreasing\n\n  function lengthOfLIS(list) {\n    let length = 1,\n      size = list.length\n    if (size == 0) return 0\n    const d = new Array(size + 1).fill(0)\n    d[length] = list[0]\n    for (let i = 1; i < size; ++i) {\n      if (list[i] > d[length]) {\n        d[++length] = list[i]\n      } else {\n        let left = 1,\n          right = length,\n          pos = 0\n        while (left <= right) {\n          let mid = (left + right) >> 1\n          if (d[mid] < list[i]) {\n            pos = mid\n            left = mid + 1\n          } else {\n            right = mid - 1\n          }\n        }\n        d[pos + 1] = list[i]\n      }\n    }\n    return length\n  }\n}\n\n// another\n\n/**\n * @param {number[]} target\n * @param {number[]} arr\n * @return {number}\n */\nconst minOperations = function(target, arr) {\n  const map = new Map()\n  for(let i = 0, len = target.length; i < len; i++) {\n    map.set(target[i], i)\n  }\n  const stack = []\n  for(let a of arr) {\n    if(!map.has(a)) continue\n    if(stack.length === 0 || map.get(a) > stack[stack.length - 1]) {\n      stack.push(map.get(a))\n      continue\n    }\n    let left = 0, right = stack.length - 1, mid\n    while(left < right) {\n      mid = left + ((right - left) >> 1)\n      if(stack[mid] < map.get(a)) left = mid + 1\n      else right = mid\n    }\n    stack[left] = map.get(a)\n  }\n\n  return target.length - stack.length\n};\n\n// another\n\n/**\n * @param {number[]} target\n * @param {number[]} arr\n * @return {number}\n */\nconst minOperations = function(target, arr) {\n  const hash = {}\n  for(let i = 0, n = target.length; i < n; i++) {\n    hash[target[i]] = i\n  }\n  const stack = []\n  \n  for(let e of arr) {\n    if(hash[e] == null) continue\n    const cur = hash[e]\n    if(stack.length && cur > stack[stack.length - 1]) {\n      stack.push(cur)\n      continue\n    }\n    \n    let l = 0, r = stack.length - 1\n    \n    while(l < r) {\n      const mid = ~~((l + r) / 2)\n      if(stack[mid] < cur) {\n        l = mid + 1\n      } else r = mid\n    }\n    \n    stack[l] = cur\n    \n  }\n  \n  return target.length - stack.length\n};\n"
    }
  },
  {
    "name": "1714-sum-of-special-evenly-spaced-elements-in-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number[]}\n */\nconst solve = function (nums, queries) {\n  const n = nums.length\n  const dividingPoint = Math.floor(Math.sqrt(n))\n  const mod = 1e9 + 7\n  const prefix = new Map()\n\n  const res = new Array(queries.length)\n  for (let i = 0; i < queries.length; i++) {\n    let x = queries[i][0],\n      y = queries[i][1]\n    if (y > dividingPoint) {\n      let sm = 0\n      while (x < n) {\n        sm += nums[x]\n        sm %= mod\n        x += y\n      }\n      res[i] = sm\n    } else {\n      let startingPoint = x % y\n      if (!prefix.has(y)) {\n        prefix.set(y, new Map())\n      }\n      if (!prefix.get(y).has(startingPoint)) {\n        const curPrefix = []\n        curPrefix.push(0)\n        let cur = startingPoint,\n          sm = 0\n        while (cur < n) {\n          sm += nums[cur]\n          sm %= mod\n          curPrefix.push(sm)\n          cur += y\n        }\n        prefix.get(y).set(startingPoint, curPrefix)\n      }\n      const curPrefix = prefix.get(y).get(startingPoint)\n      res[i] =\n        (curPrefix[curPrefix.length - 1] - curPrefix[~~(x / y)] + mod) % mod\n    }\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "1716-calculate-money-in-leetcode-bank",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst totalMoney = function(n) {\n    let total = 0\n    for(let i = 0 ; i < n; i++) {\n      const base = (i / 7) >> 0\n      const remain = i % 7 + 1\n      total += base + remain\n    }\n\n    return total\n};\n"
    }
  },
  {
    "name": "1717-maximum-score-from-removing-substrings",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {number} x\n * @param {number} y\n * @return {number}\n */\nconst maximumGain = function (s, x, y) {\n  let sb = s.split('')\n  if (x > y) {\n    return remove(sb, 'ab', x) + remove(sb, 'ba', y)\n  }\n  return remove(sb, 'ba', y) + remove(sb, 'ab', x)\n  function remove(sb, pattern, point) {\n    let i = 0,\n      res = 0\n    for (let j = 0; j < sb.length; j++) {\n      sb[i++] = sb[j]\n      if (\n        i > 1 &&\n        sb[i - 2] == pattern.charAt(0) &&\n        sb[i - 1] == pattern.charAt(1)\n      ) {\n        i -= 2\n        res += point\n      }\n    }\n    sb.splice(i)\n    return res\n  }\n}\n\n// another\n\n/**\n * @param {string} s\n * @param {number} x\n * @param {number} y\n * @return {number}\n */\nconst maximumGain = function (s, x, y) {\n  return Math.max(go(s, x, y, 'a', 'b'), go(s, y, x, 'b', 'a'))\n}\n\nfunction go(s, x, y, a, b) {\n  const n = s.length\n  const st = new Array(n)\n  let sc = 0\n  let p = 0\n  for (let c of s) {\n    if (p - 1 >= 0 && st[p - 1] === a && c === b) {\n      sc += x\n      p--\n    } else {\n      st[p++] = c\n    }\n  }\n  const st2 = new Array(p)\n  let q = 0\n  for (let u = 0; u < p; u++) {\n    let c = st[u]\n    if (q - 1 >= 0 && st2[q - 1] === b && c === a) {\n      sc += y\n      q--\n    } else {\n      st2[q++] = c\n    }\n  }\n  return sc\n}\n"
    }
  },
  {
    "name": "1718-construct-the-lexicographically-largest-valid-sequence",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number[]}\n */\nconst constructDistancedSequence = function(n) {\n  const ans = Array(2 * n - 1).fill(0)\n  const used = Array(n + 1).fill(0)\n  dfs(ans, 0)\n  return ans\n    \n  function dfs(ans, i) {\n    if(i === ans.length) return true\n    if(ans[i]) return dfs(ans, i + 1)\n    for(let j = used.length - 1; j > 0; j--) {\n      if(used[j]) continue\n      if(j !== 1 && (i + j >= ans.length || ans[i + j])) continue\n      used[j] = 1\n      ans[i] = j\n      if(j !== 1) ans[i + j] = j\n      if(dfs(ans, i + 1)) return true\n      ans[i] = 0\n      if(j !== 1) ans[i + j] = 0\n      used[j] = 0\n    }\n    return false\n  }\n};\n"
    }
  },
  {
    "name": "1719-number-of-ways-to-reconstruct-a-tree",
    "code": {
      "JS": "class PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n/**\n * @param {number[][]} pairs\n * @return {number}\n */\nconst checkWays = function (pairs) {\n  const adj = {}\n  for (let i = 0; i < pairs.length; i++) {\n    if (adj[pairs[i][0]] == null) adj[pairs[i][0]] = new Set()\n    if (adj[pairs[i][1]] == null) adj[pairs[i][1]] = new Set()\n    adj[pairs[i][0]].add(pairs[i][1])\n    adj[pairs[i][1]].add(pairs[i][0])\n  }\n\n  const q = new PriorityQueue((a, b) => a[0] < b[0])\n  Object.keys(adj).forEach((k) => {\n    q.push([-adj[k].size, +k])\n  })\n\n  const n = q.size()\n  let multiple = false\n  const seen = new Set()\n  while (!q.isEmpty()) {\n    let [sz, v] = q.peek()\n    q.pop()\n    sz = -sz\n    let u = 0\n    let usz = n + 1\n    if (seen.size) {\n      for (let x of adj[v]) {\n        if (adj[x].size < usz && seen.has(x)) {\n          u = x\n          usz = adj[x].size\n        }\n      }\n    }\n\n    seen.add(v)\n    if (u === 0) {\n      if (sz !== n - 1) {\n        return 0\n      }\n      continue\n    }\n\n    for (let x of adj[v]) {\n      if (x == u) {\n        continue\n      }\n\n      if (!adj[u].has(x)) {\n        return 0\n      }\n    }\n\n    if (usz == sz) {\n      multiple = true\n    }\n  }\n\n  if (multiple) {\n    return 2\n  }\n\n  return 1\n}\n"
    }
  },
  {
    "name": "172-factorial-trailing-zeroes",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst trailingZeroes = function(n) {\n    let result = 0;\n    for(let i = 5; Math.floor(n/i) > 0; i *= 5){\n        result += (Math.floor(n/i));\n    }\n    return result;\n};\n"
    }
  },
  {
    "name": "1720-decode-xored-array",
    "code": {
      "JS": "/**\n * @param {number[]} encoded\n * @param {number} first\n * @return {number[]}\n */\nconst decode = function(encoded, first) {\n  const res = [first]\n  \n  for(let i = 0, len = encoded.length; i < len; i++) {\n    res[i + 1] = res[i] ^ encoded[i]\n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "1721-swapping-nodes-in-a-linked-list",
    "code": {
      "JS": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nconst swapNodes = function(head, k) {\n  const dummy = new ListNode()\n  dummy.next = head\n  const arr = []\n  let cur = head\n  while(cur) {\n    arr.push(cur)\n    cur = cur.next\n  }\n  const n = arr.length\n  if(k < 1 || k > n) return dummy.next\n  let first = arr[k - 1], second = arr[n - k]\n  \n  arr[k - 1] = second\n  arr[n - k] = first\n    \n  dummy.next = arr[0]\n  let pre = arr[0]\n  for(let i = 1, len = arr.length; i < len; i++) {\n     const tmp = arr[i]\n     pre.next = tmp\n     pre = tmp\n  }\n  \n  pre.next = null\n \n  return dummy.next\n};\n"
    }
  },
  {
    "name": "1722-minimize-hamming-distance-after-swap-operations",
    "code": {
      "JS": "class UnionFind {\n  constructor(n) {\n    this.parents = Array(n)\n      .fill(0)\n      .map((e, i) => i)\n    this.ranks = Array(n).fill(0)\n  }\n  root(x) {\n    while (x !== this.parents[x]) {\n      this.parents[x] = this.parents[this.parents[x]]\n      x = this.parents[x]\n    }\n    return x\n  }\n  find(x) {\n    return this.root(x)\n  }\n  check(x, y) {\n    return this.root(x) === this.root(y)\n  }\n  union(x, y) {\n    const [rx, ry] = [this.find(x), this.find(y)]\n    if (this.ranks[rx] >= this.ranks[ry]) {\n      this.parents[ry] = rx\n      this.ranks[rx] += this.ranks[ry]\n    } else if (this.ranks[ry] > this.ranks[rx]) {\n      this.parents[rx] = ry\n      this.ranks[ry] += this.ranks[rx]\n    }\n  }\n}\n/**\n * @param {number[]} source\n * @param {number[]} target\n * @param {number[][]} allowedSwaps\n * @return {number}\n */\nconst minimumHammingDistance = function (source, target, allowedSwaps) {\n  const n = target.length\n  const uf = new UnionFind(n)\n  for (let A of allowedSwaps) {\n    const i = A[0],\n      j = A[1]\n    uf.union(i, j)\n  }\n  const M = {}\n  for (let i = 0; i < n; i++) {\n    const j = uf.find(i)\n    if (M[j] == null) M[j] = {}\n    if (M[j][source[i]] == null) M[j][source[i]] = 0\n    M[j][source[i]]++\n  }\n  let res = 0\n  for (let i = 0; i < n; i++) {\n    const j = uf.find(i)\n    if (M[j][target[i]]) {\n      if (!--M[j][target[i]]) {\n        delete M[j][target[i]]\n      }\n    } else res++\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "1723-find-minimum-time-to-finish-all-jobs",
    "code": {
      "JS": "/**\n * @param {number[]} jobs\n * @param {number} k\n * @return {number}\n */\nconst minimumTimeRequired = function (jobs, k) {\n  if (jobs.length <= k) {\n    return Math.max(...jobs)\n  }\n\n  // create a store to hold the number of hours each worker worked\n  const workers = new Array(k).fill(0)\n\n  let minLongestWorkingTime = Infinity\n  const dfs = (i) => {\n    if (i === jobs.length) {\n      // if we assigned all the jobs, see if we have a better result\n      minLongestWorkingTime = Math.min(\n        minLongestWorkingTime,\n        Math.max(...workers)\n      )\n      return\n    }\n    const lengthOfWork = jobs[i]\n\n    for (let worker = 0; worker < k; worker++) {\n      workers[worker] += lengthOfWork\n\n      // if this combination is has a chance of decreasing our\n      // answer, try it, otherwise skip it to save on time.\n      if (workers[worker] <= minLongestWorkingTime) {\n        dfs(i + 1)\n      }\n      workers[worker] -= lengthOfWork\n\n      // We want to minimize the width of the tree\n      // so if the worker has gotten their first job\n      // don't try any workers after this worker.\n      // All other workers after this worker will be 0 as well\n      // so the combination is exactly the same.\n      if (workers[worker] === 0) break\n    }\n  }\n\n  dfs(0)\n  return minLongestWorkingTime\n}\n\n// another\n\n/**\n * @param {number[]} jobs\n * @param {number} k\n * @return {number}\n */\nconst minimumTimeRequired = function(jobs, k) {\n  return solution(jobs, k)\n};\n\nfunction solution(jobs, k) {\n  const n = jobs.length\n  let res = Infinity, arr = Array(k).fill(0)\n\n  let start = 0\n  bt(0)\n  return res\n\n  function bt(idx) {\n   start++\n   if(idx === n) {\n     res = Math.min(res, Math.max(...arr))\n     return\n   }\n   const visited = new Set()\n   for(let j = start; j < start + k; j++) {\n     const i = j % k\n     if(visited.has(arr[i])) continue\n     if(arr[i] + jobs[idx] > res) continue\n     visited.add(arr[i])\n     arr[i] += jobs[idx]\n     bt(idx + 1)\n     arr[i] -= jobs[idx]\n   }\n  } \n}\n"
    }
  },
  {
    "name": "1724-checking-existence-of-edge-length-limited-paths-ii",
    "code": {
      "JS": "const DistanceLimitedPathsExist = function (n, edgeList) {\n  edgeList.sort((a, b) => a[2] - b[2])\n  this.dis = []\n  this.uf = new SnapshotUF(n)\n  let cur_dis = 0\n  for (let e of edgeList) {\n    if (e[2] > cur_dis) {\n      this.dis.push(cur_dis)\n      cur_dis = e[2]\n      this.uf.snap()\n    }\n    this.uf.union(e[0], e[1])\n  }\n  this.dis.push(cur_dis)\n  this.uf.snap()\n}\n\nDistanceLimitedPathsExist.prototype.query = function (p, q, limit) {\n  let snap_id = lower_bound(this.dis, limit) - this.dis[0] - 1\n  return this.uf.check(p, q, snap_id)\n}\n\nclass SnapshotArray {\n  constructor(length) {\n    this.tim = 0\n    this.vec = Array.from({ length: length }, () => [0])\n    this.ti = Array.from({ length: length }, () => [0])\n  }\n  set(index, val) {\n    if (this.ti[index][this.ti.length - 1] === this.tim) {\n      this.vec[index][this.vec[index].length - 1] = val\n    } else {\n      this.ti[index].push(this.tim)\n      this.vec[index].push(val)\n    }\n  }\n  get(idx, snapId) {\n    const p = lower_bound(this.ti[idx], snapId + 1) - this.ti[idx][0] - 1\n    return this.vec[idx][p]\n  }\n  snap() {\n    return this.tim++\n  }\n}\n\nclass SnapshotUF extends SnapshotArray {\n  constructor(n) {\n    super(n)\n    for (let i = 0; i < n; i++) this.set(i, -1)\n  }\n  find(x, snap_id) {\n    let rep = this.get(x, snap_id)\n    if (rep < 0) return x\n    return this.find(rep, snap_id)\n  }\n  union(x, y) {\n    let px = this.find(x, this.tim)\n    let py = this.find(y, this.tim)\n    if (px == py) return\n    let sizepx = -1 * this.get(px, this.tim)\n    let sizepy = -1 * this.get(py, this.tim)\n    if (sizepx >= sizepy) {\n      this.set(px, -1 * sizepx + -1 * sizepy)\n      this.set(py, px)\n    } else {\n      this.set(py, -1 * sizepx + -1 * sizepy)\n      this.set(px, py)\n    }\n  }\n  check(x, y, snap_id) {\n    return this.find(x, snap_id) === this.find(y, snap_id)\n  }\n}\n\nfunction lower_bound(array, arg1, arg2, arg3, arg4) {\n  let first\n  let last\n  let value\n  let less\n  if (arg3 === undefined) {\n    first = 0\n    last = array.length\n    value = arg1\n    less = arg2\n  } else {\n    first = arg1\n    last = arg2\n    value = arg3\n    less = arg4\n  }\n\n  if (less === undefined) {\n    less = function (a, b) {\n      return a < b\n    }\n  }\n\n  let len = last - first\n  let middle\n  let step\n  while (len > 0) {\n    step = Math.floor(len / 2)\n    middle = first + step\n    if (less(array[middle], value, middle)) {\n      first = middle\n      first += 1\n      len = len - step - 1\n    } else {\n      len = step\n    }\n  }\n  return first\n}\n\n/**\n * Your DistanceLimitedPathsExist object will be instantiated and called as such:\n * DistanceLimitedPathsExist* obj = new DistanceLimitedPathsExist(n, edgeList);\n * bool param_1 = obj->query(p,q,limit);\n */\n"
    }
  },
  {
    "name": "1725-number-of-rectangles-that-can-form-the-largest-square",
    "code": {
      "JS": "/**\n * @param {number[][]} rectangles\n * @return {number}\n */\nconst countGoodRectangles = function(A) {\n  const arr = []\n  let max = 0\n  A.forEach(e => {\n    const tmp = Math.min(...e)\n    if(tmp > max) max=tmp\n    arr.push(tmp)\n  })\n  let res = 0\n  for(let e of arr) {\n    if(e >= max) res++\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1726-tuple-with-same-product",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst tupleSameProduct = function(nums) {\n  const m = {}\n  const len = nums.length\n  for(let i = 0; i < len - 1; i++) {\n    for(let j = i + 1; j < len; j++) {\n      const tmp = nums[i] * nums[j]\n      if(m[tmp] == null) m[tmp] = 0\n      m[tmp]++\n    } \n  }\n  let res = 0\n  Object.keys(m).forEach(e => {\n    if(m[e] > 1) res += m[e] * (m[e] - 1)  * 4\n  })\n  \n  return res\n};\n"
    }
  },
  {
    "name": "1727-largest-submatrix-with-rearrangements",
    "code": {
      "JS": "/**\n * @param {number[][]} matrix\n * @return {number}\n */\nconst largestSubmatrix = function(matrix) {\n    const n = matrix.length;\n    const m = matrix[0].length;\n    const cols = Array(m).fill(0)\n    let res = 0\n    for(let i = 0; i < n; i++) {\n      for(let j = 0; j < m; j++) {\n        cols[j] = matrix[i][j] === 1 ? cols[j] + 1 : 0\n      }\n      const tmp = cols.slice()\n      tmp.sort((a, b) => b - a)\n      for(let j = 0; j < m; j++) {\n        res = Math.max(res, (j + 1) * tmp[j])\n      }\n    }\n    return res\n};\n\n"
    }
  },
  {
    "name": "1728-cat-and-mouse-ii",
    "code": {
      "JS": "/**\n * @param {string[]} grid\n * @param {number} catJump\n * @param {number} mouseJump\n * @return {boolean}\n */\nconst canMouseWin = function(grid, catJump, mouseJump) {\n  let n,m,k,lim,cache,mpos = -1, cpos = -1, fpos = -1\n  n = grid.length\n  m = grid[0].length\n  for(let i = 0; i < n; i++) {\n    for(let j = 0; j < m; j++) {\n      if(grid[i][j] === 'M') mpos = i * m + j\n      else if(grid[i][j] === 'C') cpos = i * m + j\n      else if(grid[i][j] === 'F') fpos = i * m + j\n    }\n  }\n  mnei = Array(n * m), cnei = Array(n * m)\n  for(let i = 0; i < n; i++) {\n    for(let j = 0; j < m; j++) {\n      mnei[i * m + j] = traj(i, j, mouseJump)\n    }\n  }\n  for(let i = 0; i < n; i++) {\n    for(let j = 0; j < m; j++) {\n      cnei[i * m + j] = traj(i, j, catJump)\n    }\n  }\n  k = m * n\n  lim = 100\n  cache = Array.from({ length: lim }, () => Array(k * k).fill(0))\n\n  for(let i = 0; i < lim; i++) {\n    for(let j = 0; j < k * k; j++) {\n      cache[i][j] = -1\n    }\n  }\n\n  return mouseWin(mpos, cpos, 0)\n\n  function traj(i, j, d) {\n    if(grid[i][j] === '#') return []\n    let pos = i * m + j\n    let change = []\n    change.push(pos)\n    for(let k = 1; k < d + 1; k++) {\n      if(i + k >= n || grid[i + k][j] === '#') break\n      change.push(pos + k * m)\n    }\n    for(let k = 1; k < d + 1; k++) {\n      if(i - k < 0 || grid[i - k][j] === '#') break\n      change.push(pos - k * m) \n    }\n    for(let k = 1; k < d + 1; k++) {\n      if(j + k >= m || grid[i][j + k] === '#') break\n      change.push(pos + k)\n    }\n    for(let k = 1; k < d + 1; k++) {\n      if(j - k < 0 || grid[i][j - k] === '#') break\n      change.push(pos - k)\n    }\n    return change\n  }\n  \n  function mouseWin(mpos, cpos, turn) {\n    if(turn === lim) return false\n    let e = mpos * k + cpos\n    if(cache[turn][e] >= 0) return cache[turn][e] === 1\n    if(cpos === fpos || cpos === mpos) return false\n    if(mpos === fpos) return true\n    if((turn & 1) !== 0) {\n      let b = 0\n      for(let newCpos of cnei[cpos]) {\n        if(!mouseWin(mpos, newCpos, turn + 1)) b = 1\n      }\n      if(b===0) cache[turn][e] = 1\n      else cache[turn][e] = 0\n    } else {\n      let b = 0\n      for(let newMpos of mnei[mpos]) {\n        if(mouseWin(newMpos, cpos, turn + 1)) b = 1\n      }\n      if(b === 1) cache[turn][e] = 1\n      else cache[turn][e] = 0\n    }\n    return cache[turn][e] === 1\n  }\n};\n"
    }
  },
  {
    "name": "173-binary-search-tree-iterator",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n */\nconst BSTIterator = function(root) {\n  this.root = root;\n  this.stack = [];\n};\n\n/**\n * @return the next smallest number\n * @return {number}\n */\nBSTIterator.prototype.next = function() {\n  while (this.root) {\n    this.stack.push(this.root);\n    this.root = this.root.left;\n  }\n  this.root = this.stack.pop();\n  const result = this.root.val;\n  this.root = this.root.right;\n  return result;\n};\n\n/**\n * @return whether we have a next smallest number\n * @return {boolean}\n */\nBSTIterator.prototype.hasNext = function() {\n  return this.root || this.stack.length;\n};\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * var obj = new BSTIterator(root)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */\n\n// another\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n */\nconst BSTIterator = function(root) {\n  this.generator = dfsGenerator(root)\n  this.root = root\n  this.nextSmall = this.generator.next().value\n}\nfunction* dfsGenerator(root) {\n  if (root === null) return\n  const stack = []\n  let current = root\n  while (true) {\n    if (current) {\n      stack.push(current)\n      current = current.left\n    } else if (stack.length) {\n      const top = stack.pop()\n      yield top.val\n      current = top.right\n    } else {\n      break\n    }\n  }\n}\n\n/**\n * @return the next smallest number\n * @return {number}\n */\nBSTIterator.prototype.next = function() {\n  const smallReturn = this.nextSmall\n  this.nextSmall = this.generator.next().value\n  return smallReturn\n}\n\n/**\n * @return whether we have a next smallest number\n * @return {boolean}\n */\nBSTIterator.prototype.hasNext = function() {\n  return this.nextSmall !== undefined ? true : false\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * var obj = new BSTIterator(root)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */\n\n\n"
    }
  },
  {
    "name": "1732-find-the-highest-altitude",
    "code": {
      "JS": "/**\n * @param {number[]} gain\n * @return {number}\n */\nconst largestAltitude = function(gain) {\n  const h = [0]\n  for(let e of gain) {\n    h.push(h[h.length - 1] + e)\n  }\n  let max = 0\n  for(let e of h) {\n    max = Math.max(max, e)\n  }\n  return max\n};\n"
    }
  },
  {
    "name": "1733-minimum-number-of-people-to-teach",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[][]} languages\n * @param {number[][]} friendships\n * @return {number}\n */\nvar minimumTeachings = function(n, languages, friendships) {\n        let cnt_people = languages.length;\n\n  const knows = Array.from({length: cnt_people}, () => Array(n).fill(0))\n        for(let who = 0; who < cnt_people; ++who) {\n            for(let x of languages[who]) {\n                knows[who][x-1] = true;\n            }\n        }\n        let req = Array(n).fill(0);\n        let s = new Set();\n        for(let edge of friendships) {\n            let a = edge[0] - 1;\n            let b = edge[1] - 1;\n            let yes = false;\n            for(let x of languages[a]) {\n                if(knows[b][x-1]) {\n                    yes = true;\n                }\n            }\n            if(yes) {\n                continue;\n            }\n            s.add(a);\n            s.add(b);\n        }\n        let best = Infinity;\n        for(let i = 0; i < n; ++i) {\n            let needed = 0;\n            for(let person of s) {\n                if(!knows[person][i]) {\n                    needed++;\n                }\n            }\n            best = Math.min(best, needed);\n        }\n        return best;    \n};\n\n"
    }
  },
  {
    "name": "1734-decode-xored-permutation",
    "code": {
      "JS": "/**\n * @param {number[]} encoded\n * @return {number[]}\n */\nconst decode = function(encoded) {\n  let a = 0\n  const n = encoded.length + 1\n  for(let i = 0; i <= n; i++) {\n    a ^= i\n    if(i < n && i % 2 === 1) a ^= encoded[i]\n  }\n  const res = [a]\n  for(let i = 0; i < n - 1; i++) {\n    res[i + 1] = res[i] ^ encoded[i]\n  }\n  \n  return res\n};\n\n// another\n\n/**\n * @param {number[]} encoded\n * @return {number[]}\n */\nconst decode = function(A) {\n  let xor = 0\n  const len = A.length\n  const permLen = len + 1\n  for(let i = 1; i <= permLen; i++) {\n    xor ^= i\n  }\n  // except first\n  for(let i = 1; i < len; i += 2) xor ^= A[i]\n  const first = xor\n  const res = [xor]\n  let pre = xor\n  for(let i = 1; i < permLen; i++) {\n    res[i] = A[i - 1] ^ pre\n    pre = res[i]\n  }\n  return res;    \n};\n"
    }
  },
  {
    "name": "1735-count-ways-to-make-array-with-product",
    "code": {
      "JS": "/**\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar waysToFillArray = function (queries) {\n  const nax = 10123\n  const C = Array.from({ length: nax }, () => Array(15).fill(0n))\n  const mod = BigInt(10 ** 9 + 7)\n  if (C[1][1] == 0n) {\n    for (let i = 0; i < nax; ++i) {\n      C[i][0] = 1n\n      if (i < 15) {\n        C[i][i] = 1n\n      }\n      for (let j = 1; j < i && j < 15; ++j) {\n        C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod\n      }\n    }\n  }\n  const answer = []\n  for (let query of queries) {\n    let n = query[0]\n    let k = query[1]\n    let total = 1n\n    const consider = (cnt) => {\n      total = (total * C[n + cnt - 1][cnt]) % mod\n    }\n    for (let i = 2; i * i <= k; ++i) {\n      if (k % i == 0) {\n        let cnt = 0\n        while (k % i == 0) {\n          k = (k / i) >> 0\n          cnt++\n        }\n        consider(cnt)\n      }\n    }\n    if (k != 1) {\n      consider(1)\n    }\n    answer.push(total)\n  }\n  return answer\n}\n"
    }
  },
  {
    "name": "1736-latest-time-by-replacing-hidden-digits",
    "code": {
      "JS": "/**\n * @param {string} time\n * @return {string}\n */\nvar maximumTime = function(time) {\n  const arr = time.split('')\n  let idx = time.indexOf('?')\n  if(idx < 0) return time\n  while(arr.indexOf('?') >= 0) {\n      idx = arr.indexOf('?')\n      let e\n      if(idx === 0) {\n        if(time[1] === '?') e = 2\n        else if(+time[1] < 4) e =2\n        else e = 1\n        arr[0] = '' + e\n\n      } else if(idx === 1) {\n        if(+arr[0] > 1) e = 3\n        else e = 9\n        arr[1] = '' + e\n      } else if(idx === 3) {\n        e = 5\n        arr[3] = '' + e\n      } else if(idx === 4) {\n        e = 9\n        arr[4] = '' + e\n      }      \n  }\n\n  return arr.join('')\n};\n"
    }
  },
  {
    "name": "1737-change-minimum-characters-to-satisfy-one-of-three-conditions",
    "code": {
      "JS": "/**\n * @param {string} a\n * @param {string} b\n * @return {number}\n */\nconst minCharacters = function (a, b) {\n  const n1 = a.length,\n    n2 = b.length\n  const cnt1 = Array(26).fill(0)\n  const cnt2 = Array(26).fill(0)\n  const aCode = 'a'.charCodeAt(0)\n  for (let c of a) ++cnt1[c.charCodeAt(0) - aCode]\n  for (let c of b) ++cnt2[c.charCodeAt(0) - aCode]\n  let res = n1 - Math.max(...cnt1) + n2 - Math.max(...cnt2)\n  for (let i = 0; i < 25; ++i) {\n    let cur1 = 0,\n      cur2 = 0\n    for (let j = 0; j < 26; ++j) {\n      if (j <= i) {\n        cur1 += cnt2[j]\n        cur2 += cnt1[j]\n      } else {\n        cur1 += cnt1[j]\n        cur2 += cnt2[j]\n      }\n    }\n    res = Math.min(Math.min(cur1, cur2), res)\n  }\n  return res\n}\n\n// another\n\n/**\n * @param {string} a\n * @param {string} b\n * @return {number}\n */\nconst minCharacters = function(a, b) {\n  return Math.min(method1(a, b), method1(b, a), method3(a, b))\n};\n\nfunction method1(str1, str2) {\n  let res = Infinity, a = 'a'.charCodeAt(0)\n  for(let i = 1; i < 26; i++) {\n    let cnt1 = 0, cnt2 = 0, mid = String.fromCharCode(a + i)\n    for(let ch of str1) {\n      if(ch >= mid) cnt1++ \n    }\n    for(let ch of str2) {\n      if(ch < mid) cnt2++\n    }\n    res = Math.min(res, cnt1 + cnt2)\n  }\n  return res\n}\n\nfunction method3(str1, str2) {\n  const a = 'a'.charCodeAt(0)\n  const cnt1 = Array(26).fill(0), cnt2 = Array(26).fill(0)\n  for(let ch of str1) cnt1[ch.charCodeAt(0) - a]++\n  for(let ch of str2) cnt2[ch.charCodeAt(0) - a]++\n  return str1.length + str2.length - Math.max(...cnt1) - Math.max(...cnt2)\n}\n\n// another\n\n/**\n * @param {string} a\n * @param {string} b\n * @return {number}\n */\nconst minCharacters = function (a, b) {\n  const m = a.length, n = b.length\n  let res = m + n\n  const cnt1 = Array(26).fill(0), cnt2 = Array(26).fill(0)\n  const ac = 'a'.charCodeAt(0)\n  for(let ch of a) cnt1[ch.charCodeAt(0) - ac]++\n  for(let ch of b) cnt2[ch.charCodeAt(0) - ac]++\n  const c3 = res - Math.max(...cnt1) - Math.max(...cnt2)\n  for(let i = 0; i < 26; i++) {\n    if(i > 0) {\n      cnt1[i] += cnt1[i - 1]\n      cnt2[i] += cnt2[i - 1]      \n    }\n\n    if(i < 25) {\n      res = Math.min(res, m - cnt1[i] + cnt2[i])\n      res = Math.min(res, n - cnt2[i] + cnt1[i])\n    }\n  }\n  \n  return Math.min(res, c3)\n}\n\n\n"
    }
  },
  {
    "name": "1738-find-kth-largest-xor-coordinate-value",
    "code": {
      "JS": "/**\n * @param {number[][]} matrix\n * @param {number} k\n * @return {number}\n */\nvar kthLargestValue = function(matrix, k) {\n    let m = matrix.length;\n    let n = matrix[0].length;\n    const v = [], d = Array(n).fill(0);\n    d[0] = matrix[0][0];\n    v.push(d[0]);\n    for (let i = 1; i < n; ++i) {\n      d[i] = matrix[0][i] ^ d[i - 1];\n      v.push(d[i]);\n    }\n    for (let i = 1; i < m; ++i) {\n      let cur = matrix[i][0];\n      d[0] ^= cur;\n      v.push(d[0]);\n      for (let j = 1; j < n; ++j) {\n        cur ^= matrix[i][j];\n        d[j] ^= cur;\n        v.push(d[j]);\n      }\n    }\n    v.sort((a, b) => b - a)\n    return v[k - 1];\n};\n\n// another\n\n/**\n * @param {number[][]} matrix\n * @param {number} k\n * @return {number}\n */\nconst kthLargestValue = function(matrix, k) {\n    const tmp = []\n    const n = matrix.length, m = matrix[0].length\n    const dp = Array.from({ length: n }, () => Array(m).fill(0))\n    dp[0][0] = matrix[0][0]\n    tmp.push(dp[0][0])\n    for(let j = 1; j < m; j++) {\n      dp[0][j] = dp[0][j - 1] ^ matrix[0][j]\n      tmp.push(dp[0][j])\n    }\n    for(let i = 1; i < n; i++) {\n      dp[i][0] = dp[i - 1][0] ^ matrix[i][0]\n      tmp.push(dp[i][0])\n    }\n    for(let i = 1; i < n; i++) {\n        for(let j = 1; j < m; j++) {\n            dp[i][j] = dp[i][j - 1] ^ dp[i - 1][j] ^ matrix[i][j] ^ dp[i - 1][j - 1]\n            tmp.push(dp[i][j])\n        }\n    }\n    tmp.sort((a, b) => b - a)\n    return tmp[k - 1]\n};\n\n\n// another\n\n/**\n * @param {number[][]} matrix\n * @param {number} k\n * @return {number}\n */\nconst kthLargestValue = function(matrix, k) {\n  if(matrix == null || matrix[0] == null) return 0\n  const m = matrix.length, n = matrix[0].length\n  const res = Array.from({ length: m }, () => Array(n).fill(0))\n  res[0][0] = matrix[0][0]\n  for(let i = 1; i < m; i++) {\n    res[i][0] = res[i - 1][0] ^ matrix[i][0]\n  }\n  for(let j = 1; j < n; j++) {\n    res[0][j] = res[0][j - 1] ^ matrix[0][j]\n  }\n  \n  for(let i = 1; i < m; i++) {\n    for(let j = 1; j < n; j++) {\n      res[i][j] = res[i][j - 1] ^ res[i - 1][j] ^ res[i - 1][j - 1] ^ matrix[i][j]\n    }\n  }\n  \n  const pq = new PriorityQueue((a, b) => a < b)\n  for(let i = 0; i < m; i++) {\n    for(let j = 0; j < n; j++) {\n      pq.push(res[i][j])\n      if(pq.size() > k) pq.pop()\n    }\n  }\n  \n  return pq.pop()\n  \n};\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n"
    }
  },
  {
    "name": "1739-building-boxes",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst minimumBoxes = function(n) {\n  let i = 1, c = 1, s = 1\n  while(s < n) {\n    i += 1, c += i, s += c\n  }\n  while(s - i >= n) {\n    s -= i, c -= 1, i -= 1\n  }\n  return c\n};\n\n// another\n\n\n/**\n * @param {number} n\n * @return {number}\n */\nconst minimumBoxes = function(n) {\n  let sum = 1n, base = 1n, row = 1n;\n  n = BigInt(n)\n  while (sum < n) {\n    base += (++row);\n    sum += base;\n  }\n  while (sum > n) {\n    --base;\n    sum -= (row--);\n    if (sum < n) return base + 1n;\n  }\n  return base;\n};\n\n"
    }
  },
  {
    "name": "174-dungeon-game",
    "code": {
      "JS": "/**\n * @param {number[][]} dungeon\n * @return {number}\n */\nconst calculateMinimumHP = function (dungeon) {\n  const M = dungeon.length\n  const N = dungeon[0].length\n  // hp[i][j] represents the min hp needed at position (i, j)\n  // Add dummy row and column at bottom and right side\n  const hp = Array.from({ length: M + 1 }, () =>\n    Array(N + 1).fill(Number.MAX_VALUE)\n  )\n  hp[M][N - 1] = 1\n  hp[M - 1][N] = 1\n  for (let i = M - 1; i >= 0; i--) {\n    for (let j = N - 1; j >= 0; j--) {\n      const need = Math.min(hp[i + 1][j], hp[i][j + 1]) - dungeon[i][j]\n      hp[i][j] = need <= 0 ? 1 : need\n    }\n  }\n  return hp[0][0]\n}\n\n\n// another\n\n/**\n * @param {number[][]} dungeon\n * @return {number}\n */\nconst calculateMinimumHP = function (dungeon) {\n  const n = dungeon.length,\n    m = dungeon[0].length\n  const dp = Array(n + 1).fill(Number.MAX_VALUE)\n  dp[n - 1] = 1\n  for (let j = m - 1; j >= 0; j--) {\n    for (let i = n - 1; i >= 0; i--) {\n      dp[i] = Math.min(dp[i], dp[i + 1]) - dungeon[i][j]\n      dp[i] = Math.max(1, dp[i])\n    }\n  }\n  return dp[0]\n}\n\n"
    }
  },
  {
    "name": "1740-find-distance-in-a-binary-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} p\n * @param {number} q\n * @return {number}\n */\nconst findDistance = function(root, p, q) {\n  if(p === q) return 0\n  return dfs(root, 0)\n\n  function dfs(node, depth) {\n    let res = depth\n    if (node == null) {\n      res = 0\n    } else if(node.val === p || node.val === q) {\n      let left = dfs(node.left, 1)\n      let right = dfs(node.right, 1)\n      res = (left > 0 || right > 0) ? Math.max(left, right) : res\n    } else {\n      let left = dfs(node.left, depth + 1)\n      let right = dfs(node.right, depth + 1)\n      res = left + right\n      if(left !== 0 && right !== 0) {\n        res -= 2 * depth\n      }\n    }\n    return res\n  }\n};\n\n// another\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} p\n * @param {number} q\n * @return {number}\n */\nconst findDistance = function (root, p, q) {\n  if (p == q) return 0\n  let result = -1\n  dfs(root, p, q)\n  return result\n\n  /**\n\t\tThe return value means the distance from root node to EITHER p OR q. If\n\t\tneither p nor q are reachable from the root, return -1.\n\t\t\n\t\tIt is either p or q but not both, because if the root node can reach both \n\t\tp and q, it is a common ancestor of p and q and the answer should already \n\t\tbe available.\n\t**/\n  function dfs(root, p, q) {\n    if (root == null) return -1\n\n    let left = dfs(root.left, p, q)\n    let right = dfs(root.right, p, q)\n\n    if (root.val == p || root.val == q) {\n      // root is p or q, but none of p or q is a descendent of root.\n      // The distance from root to one of p and q is 0 in this case.\n      if (left < 0 && right < 0) {\n        return 0\n      }\n\n      // root is p or q, and root is also the LCA of p and q.\n      result = 1 + (left >= 0 ? left : right)\n      return -1\n    }\n\n    // root is neither p nor q, but it is the LCA of p and q.\n    if (left >= 0 && right >= 0) {\n      result = left + right + 2\n      return -1\n    }\n\n    if (left >= 0) {\n      return left + 1\n    }\n\n    if (right >= 0) {\n      return right + 1\n    }\n\n    return -1\n  }\n}\n\n// another\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} p\n * @param {number} q\n * @return {number}\n */\nconst findDistance = function (root, p, q) {\n  let lca = lowestCommonAncestor(root, p, q)\n\n  const queue = []\n  queue.push(lca)\n  let dp = -1,\n    dq = -1\n  let d = 0\n  while (queue.length && (dp == -1 || dq == -1)) {\n    for (let k = queue.length; k > 0; k--) {\n      let node = queue.shift()\n      if (node.val == p) {\n        dp = d\n      }\n\n      if (node.val == q) {\n        dq = d\n      }\n\n      if (node.left != null) {\n        queue.push(node.left)\n      }\n\n      if (node.right != null) {\n        queue.push(node.right)\n      }\n    }\n    d++\n  }\n\n  return dp + dq\n\n  function lowestCommonAncestor(root, p, q) {\n    if (root == null || root.val == p || root.val == q) {\n      return root\n    }\n    let left = lowestCommonAncestor(root.left, p, q)\n    let right = lowestCommonAncestor(root.right, p, q)\n\n    return left == null ? right : right == null ? left : root\n  }\n}\n\n"
    }
  },
  {
    "name": "1742-maximum-number-of-balls-in-a-box",
    "code": {
      "JS": "/**\n * @param {number} lowLimit\n * @param {number} highLimit\n * @return {number}\n */\nconst countBalls = function(lowLimit, highLimit) {\n  const m = {}\n  for(let i = lowLimit; i <= highLimit; i++) {\n    const tmp = (i + '').split('').map(e => +e).reduce((ac, e) => ac + e, 0)\n    if(m[tmp] == null) m[tmp] = 0\n    m[tmp]++\n  }\n  const arr = Object.values(m)\n  arr.sort((a, b) => b - a)\n  return arr[0]\n};\n"
    }
  },
  {
    "name": "1743-restore-the-array-from-adjacent-pairs",
    "code": {
      "JS": "/**\n * @param {number[][]} adjacentPairs\n * @return {number[]}\n */\nconst restoreArray = function(pairs) {\n  const m = {}\n  for(let e of pairs) {\n    const [k, v] = e\n    if(m[k] == null) m[k] = new Set()\n    if(m[v] == null) m[v] = new Set()\n    m[k].add(v)\n    m[v].add(k)\n  }\n  const q = [pairs[0]]\n  let res = pairs[0]\n  m[res[0]].delete(res[1])\n  m[res[1]].delete(res[0])\n  let n = pairs.length\n  while(n) {\n    const front = res[0], rear = res[res.length - 1]\n    \n    if(m[front]) {\n        const newf = [...m[front].values()][0]\n        if(m[front].size) res.unshift(newf)\n        if(m[front]) m[front].delete(newf)\n        if(m[newf]) m[newf].delete(front)\n        if(m[front].size === 0) delete m[front]\n    }\n     \n    if(m[rear]) {\n       const newr = [...m[rear].values()][0]\n       if(m[rear].size) res.push(newr)\n       if(m[rear]) m[rear].delete(newr)\n       if(m[newr]) m[newr].delete(rear)\n       if(m[rear].size === 0) delete m[rear]\n    }\n    n--\n  }\n    \n  return res\n};\n"
    }
  },
  {
    "name": "1744-can-you-eat-your-favorite-candy-on-your-favorite-day",
    "code": {
      "JS": "/**\n * @param {number[]} candiesCount\n * @param {number[][]} queries\n * @return {boolean[]}\n */\nconst canEat = function(candiesCount, queries) {\n  const n = candiesCount.length\n  const pre = Array(n).fill(0)\n  for(let i = 1; i < n; i++) {\n    pre[i] = pre[i - 1] + candiesCount[i - 1]\n  }\n  return queries.map((e, i) => {\n    const [t, d, c] = e\n    const num = candiesCount[t]\n    const min = d, max = (d + 1) * c\n\n    if(pre[t] + num > min && pre[t] < max) {\n       return true\n    } else {\n       return false\n    }\n  })\n};\n"
    }
  },
  {
    "name": "1745-palindrome-partitioning-iv",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {boolean}\n */\nconst checkPartitioning = function(s) {\n  const map = manacher(s);\n  return checkPartitioningDfs(map, s, 0);\n};\n\nfunction checkPartitioningDfs(map, word, i, path = []) {\n  if (path.length > 3) return false;\n  if (path.length == 3 && path.join('') == word) return true;\n  let found = false;\n  const length = map.get(i);\n  path.push(word.substr(i, length));\n  found = found || checkPartitioningDfs(map, word, i + length, path);\n  path.pop();\n\n  path.push(word.substr(i, 1));\n  found = found || checkPartitioningDfs(map, word, i + 1, path);\n  path.pop();\n  \n  return found;\n}\n\nfunction manacher(s) {\n  const t = '^#' + s.split('').join('#') + '#$';\n  let r = 0;\n  let c = 0;\n  let maxC = 0;\n  const rad = new Array(t.length).fill(0);\n  for (let i = 1; i < t.length - 1; ++i) {\n    if (r > i) rad[i] = Math.min(rad[2 * c - i], r - i);\n    while (t[i - rad[i] - 1] == t[i + rad[i] + 1]) rad[i]++;\n    if (i + rad[i] > r) {\n      c = i;\n      r = i + rad[i];\n    }\n    if (rad[c] > rad[maxC]) maxC = c;\n  }\n  const ans = new Map();\n  for (let i = 0; i < rad.length; ++i) {\n    if (rad[i] > 0) {\n      ans.set((i - rad[i] - 1) >>> 1, rad[i]);\n    }\n  }\n  return ans;\n}\n\n// another\n\n/**\n * @param {string} s\n * @return {boolean}\n */\nconst checkPartitioning = function (s) {\n  const n = s.length\n  const dp = Array.from({ length: n }, () => Array(n).fill(false))\n  for(let i = n - 1; i >= 0; i--) {\n    for(let j = i; j < n; j++) {\n      if(s[i] === s[j]) {\n        dp[i][j] = i + 1 <= j - 1 ? dp[i + 1][j - 1] : true\n      } else dp[i][j] = false\n    }\n  }\n  for(let i = 1; i < n - 1; i++) {\n    for(let j = i; j < n - 1; j++) {\n      if(dp[0][i - 1] && dp[i][j] && dp[j + 1][n - 1]) return true\n    }\n  }\n  return false\n}\n\n\n// another\n\n/**\n * @param {string} s\n * @return {boolean}\n */\nconst checkPartitioning = function(s) {\n  for(let i = 1, len = s.length; i < len - 1; i++) {\n    for(let j = i + 1; j < len; j++) {\n      const s1 = s.slice(0, i), s2 = s.slice(i, j), s3 = s.slice(j)\n      if(chk(s1) && chk(s2) && chk(s3)) return true\n    }\n  }\n  return false\n};\n\nfunction chk(s) {\n  let l = 0, r = s.length - 1\n  for(;l <= r;) {\n    if(s[l] === s[r]) {\n      l++\n      r--\n    } else return false\n  }\n  return true\n}\n"
    }
  },
  {
    "name": "1746-maximum-subarray-sum-after-one-operation",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst maxSumAfterOperation = function(nums) {\n  const n = nums.length\n  const dp = Array.from({ length: n }, () => Array(2).fill(0))\n  dp[0][0] = nums[0], dp[0][1] = nums[0] * nums[0]\n  let res = dp[0][1]\n  for(let i = 1; i < n; i++) {\n    dp[i][0] = Math.max(nums[i], dp[i - 1][0] + nums[i])\n    dp[i][1] = Math.max(nums[i] * nums[i], dp[i - 1][0] + nums[i] * nums[i], dp[i - 1][1] + nums[i])\n    res = Math.max(res, dp[i][1])\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1748-sum-of-unique-elements",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst sumOfUnique = function(nums) {\n  const m = {}\n  for(let e of nums) {\n      if(m[e] == null) m[e] = 0\n      m[e]++\n  }\n  let res = 0\n  // console.log(m)\n  Object.entries(m).forEach(e => {\n      const [k, v] = e\n      if(v === 1) res += +k\n  })\n  return res\n};\n"
    }
  },
  {
    "name": "1749-maximum-absolute-sum-of-any-subarray",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst maxAbsoluteSum = function (nums) {\n  let min = 0,\n    max = 0,\n    sum = 0\n  for(let e of nums) {\n    sum += e\n    min = Math.min(sum, min)\n    max = Math.max(sum, max)\n  }\n  return max - min\n}\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst maxAbsoluteSum = function (nums) {\n  let min = Infinity,\n    max = -Infinity\n  let positiveSum = 0,\n    negativeSum = 0\n  for (let num of nums) {\n    positiveSum += num\n    if (positiveSum > max) {\n      max = positiveSum\n    }\n\n    if (positiveSum < 0) {\n      positiveSum = 0\n    }\n    negativeSum += num\n    if (negativeSum < min) {\n      min = negativeSum\n    }\n    if (negativeSum > 0) {\n      negativeSum = 0\n    }\n  }\n\n  return Math.max(Math.abs(min), max)\n}\n"
    }
  },
  {
    "name": "1750-minimum-length-of-string-after-deleting-similar-ends",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst minimumLength = function(s) {\n  const n = s.length\n  let l = 0, r = n - 1\n  while(l < r && s[l] === s[r]) {\n    while(l < r - 1 && s[r] === s[r - 1]) r--\n    while(l + 1 < r && s[l] === s[l + 1]) l++\n    l++\n    r--\n  }\n  return r - l + 1\n};\n"
    }
  },
  {
    "name": "1751-maximum-number-of-events-that-can-be-attended-ii",
    "code": {
      "JS": "/**\n * @param {number[][]} events\n * @param {number} k\n * @return {number}\n */\nconst maxValue = function (events, k) {\n  const n = events.length\n  const memo = Array.from({ length: n + 1 }, () => Array(k + 1).fill(-1))\n  events.sort((a, b) => a[0] === b[0] ? a[1] - b[1] : a[0] - b[0])\n  return helper(memo, events, n, 0, k)\n}\n\nfunction helper(memo, events, n, i, k) {\n  if(i === n || k === 0) return 0\n  if(memo[i][k] !== -1) return memo[i][k]\n  let ni = i + 1\n  for(; ni < n; ni++) {\n    if(events[ni][0] > events[i][1]) break\n  }\n\n  return memo[i][k] = Math.max(\n    helper(memo, events, n, i + 1, k),\n    events[i][2] + helper(memo, events, n, ni, k - 1)\n  )\n}\n\n// another\n\n/**\n * @param {number[][]} events\n * @param {number} k\n * @return {number}\n */\nconst maxValue = function (events, k) {\n  // d[i][j] 表示以 events[i]结尾的取最多j个最大值\n  // d[i][j-1],  Math.max( d[m][j-1] + v[i]) for m ending < start[i]\n  events.sort((a, b) => a[1] - b[1])\n  const n = events.length\n  let d = []\n  for (let j = 0; j <= k; j++) {\n    const newD = []\n    for (let i = 0; i < n; i++) {\n      if (j === 0) {\n        newD[i] = 0\n      } else if (j === 1) {\n        newD[i] = events[i][2]\n      } else if (i === 0) {\n        newD[i] = events[i][2]\n      } else {\n        newD[i] = d[i] // 以i结尾最多取j-1次的最大值\n        const v = events[i][2]\n        const start = events[i][0]\n        for (let m = 0; m < i; m++) {\n          if (events[m][1] < start) {\n            if (d[m] + v > newD[i]) {\n              newD[i] = d[m] + v\n            }\n          } else {\n            break\n          }\n        }\n      }\n    }\n    d = [...newD]\n  }\n  return Math.max(...d)\n}\n\n\n// another\n\n\n/**\n * @param {number[][]} events\n * @param {number} k\n * @return {number}\n */\nconst maxValue = function(events, k) {\n\n        cache = new Map();\n        events.sort((a,b) => a[0] - b[0]);\n        return dfs(events, 0, -1, k);\n    \n    function dfs(events, idx, end, k){\n        let key = idx + \",\" + end + \",\" + k;\n        if(cache.has(key)){\n            return cache.get(key);\n        }\n        if(idx >= events.length){\n            return 0;\n        }\n        if(k == 0) {\n            return 0;\n        }\n        let max = 0;\n        if(events[idx][0] > end){\n            max = Math.max(max, dfs(events, idx+1, events[idx][1], k-1) + events[idx][2]);\n        }\n        \n        max = Math.max(max, dfs(events, idx+1, end, k));\n        cache.set(key, max);\n        return max;\n    }\n};\n"
    }
  },
  {
    "name": "1752-check-if-array-is-sorted-and-rotated",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nconst check = function(nums) {\n  let prev = -1, mark = 0\n  for(let e of nums) {\n    \n    if(e >= prev) prev = e\n    else {\n      mark++\n      prev = e\n    }\n    if(mark > 1) return false\n  }\n  if(mark === 1 && nums[0] < nums[nums.length - 1]) {\n      return false\n  }\n  return true\n};\n"
    }
  },
  {
    "name": "1753-maximum-score-from-removing-stones",
    "code": {
      "JS": "/**\n * @param {number} a\n * @param {number} b\n * @param {number} c\n * @return {number}\n */\nconst maximumScore = function(a, b, c) {\n  const arr = [a, b, c]\n  arr.sort((a, b) => a - b)\n  \n\n    if (arr[0] + arr[1] <= arr[2]) {\n        return arr[0] + arr[1];\n    } else {\n        const min = Math.min(arr[0], Math.floor((arr[1] + arr[0] - arr[2]) / 2));\n        return arr[2] + min;\n    }\n};\n"
    }
  },
  {
    "name": "1754-largest-merge-of-two-strings",
    "code": {
      "JS": "/**\n * @param {string} word1\n * @param {string} word2\n * @return {string}\n */\nvar largestMerge = function(word1, word2) {\n    let merge = \"\";\n    \n    while(word1.length && word2.length) {\n        if (word1[0] > word2[0]) {\n            merge += word1[0];\n            word1 = word1.slice(1);\n        } else if (word1[0] < word2[0]) {\n            merge += word2[0];\n            word2 = word2.slice(1);\n        } else {\n            if (word1 > word2) {\n                merge += word1[0];\n                word1 = word1.slice(1);\n            } else {\n                merge += word2[0];\n                word2 = word2.slice(1);\n            }\n        }\n    }\n    \n    if (word1.length) {\n        merge += word1;\n    } else if (word2.length) {\n        merge += word2;\n    }\n    \n    return merge;  \n};\n\n// another\n\n/**\n * @param {string} word1\n * @param {string} word2\n * @return {string}\n */\nconst largestMerge = function(word1, word2) {\n  const stack1 = word1.split(''), stack2 = word2.split('')\n  const arr = []\n  \n  while(stack1.length && stack2.length) {\n    const c1 = stack1[0], c2 = stack2[0]\n    if(c1 > c2) {\n      stack1.shift()\n      arr.push(c1)\n    } else if(c1 < c2) {\n      stack2.shift()\n      arr.push(c2)\n    } else {\n      if(stack1.join('') > stack2.join('')) {\n        stack1.shift()\n        arr.push(c1)\n      } else {\n        stack2.shift()\n          arr.push(c2)\n      }\n    }\n  }\n  if(stack1.length) {\n    arr.push(...stack1)\n  }\n  if(stack2.length) {\n    arr.push(...stack2)\n  } \n  \n  return arr.join('')\n};\n"
    }
  },
  {
    "name": "1755-closest-subsequence-sum",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} goal\n * @return {number}\n */\nconst minAbsDifference = function (nums, goal) {\n  let min = Math.abs(goal)\n  if (!nums.length) return min\n  const generateSums = (a) => {\n    let sums = []\n    for (let i = 0; i < a.length; i++) {\n      const l = sums.length\n      for (let j = 0; j < l; j++) {\n        sums.push(sums[j] + a[i])\n        min = Math.min(min, Math.abs(sums[j] + a[i] - goal))\n        if (min === 0) return\n      }\n      sums.push(a[i])\n      min = Math.min(min, Math.abs(a[i] - goal))\n      if (min === 0) return\n    }\n    return sums\n  }\n\n  const n1 = nums.slice(0, Math.ceil(nums.length / 2))\n  const n2 = nums.slice(Math.ceil(nums.length / 2), nums.length)\n  const sums1 = generateSums(n1)\n  if (min === 0) return min\n  const sums2 = generateSums(n2)\n  if (min === 0) return min\n\n  sums2.sort((a, b) => a - b)\n  for (let i = 0; i < sums1.length; i++) {\n    if (min === 0) return min\n    let l = 0\n    let r = sums2.length\n    let sum\n    while (l < r) {\n      const h = Math.floor((l + r) / 2)\n      sum = sums1[i] + sums2[h]\n      min = Math.min(min, Math.abs(sum - goal))\n      if (min === 0) return min\n      if (sum - goal < 0) {\n        l = h + 1\n      } else {\n        r = h\n      }\n    }\n  }\n  return min\n}\n\n\n// another\n\n/**\n * @param {number[]} nums\n * @param {number} goal\n * @return {number}\n */\nvar minAbsDifference = function(a, b) {\n        let n = a.length, m = (n / 2) >> 0, r = n - m;\n        let ans = 2e9;\n        const {max, min, abs} = Math\n        const va = [], vb = [];\n        for(let i=0;i<1<<m;++i) {\n            let tmp=0;\n            for(let j=0;j<m;++j) {\n                if(i>>j&1) tmp+=a[j];\n            }\n            ans=min(ans,abs(tmp-b));\n            va.push(tmp);\n        }\n        // sort(va.begin(), va.end());\n        va.sort((a, b) => a - b)\n        for(let i=0;i<1<<r;++i) {\n            let tmp=0;\n            for(let j=0;j<r;++j) {\n                if(i>>j&1) tmp+=a[j+m];\n            }\n            ans=min(ans,abs(tmp-b));\n            let k=b-tmp;\n            let pos=lower_bound(va, k);\n            for(let j=pos-1;j<=pos+1;++j) {\n                if(j>=0 && j<va.length) {\n                    ans=min(ans, abs(va[j]+tmp-b));\n                }\n            }\n        }\n        return ans;\n};\n\nfunction lower_bound(array, arg1, arg2, arg3, arg4) {\n    let first;\n    let last;\n    let value;\n    let less;\n    if (arg3 === undefined) {\n        first = 0;\n        last = array.length;\n        value = arg1;\n        less = arg2;\n    } else {\n        first = arg1;\n        last = arg2;\n        value = arg3;\n        less = arg4;\n    }\n\n    if (less === undefined) {\n        less = function (a, b) { return a < b; };\n    }\n\n    let len = last - first;\n    let middle;\n    let step;\n    while (len > 0) {\n        step = Math.floor(len / 2);\n        middle = first + step;\n        if (less(array[middle], value, middle)) {\n            first = middle;\n            first += 1;\n            len = len - step - 1;\n        } else {\n            len = step;\n        }\n    }\n    return first;\n};\n\n"
    }
  },
  {
    "name": "1758-minimum-changes-to-make-alternating-binary-string",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst minOperations = function(s) {\n  const arr = s.split('')\n  return Math.min(helper(arr, 0, '0'), helper(arr, 0, '1'))\n    \n  function helper(arr, idx, ch) {\n    if(idx === arr.length) return 0\n    if(arr[idx] !== ch) return 1 + helper(arr, idx + 1, ch === '0' ? '1' : '0')\n    else return helper(arr, idx + 1, ch === '0' ? '1' : '0')\n  }\n};\n"
    }
  },
  {
    "name": "1759-count-number-of-homogenous-substrings",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst countHomogenous = function(s) {\n  const mod = 10 ** 9 + 7\n  let pre = s[0], res = 0, curL = 1\n  for(let i = 1, len = s.length; i < len; i++) {\n    if(s[i] === pre) {\n      curL++\n    } else {\n      res = (res + helper(curL)) % mod\n      pre = s[i]\n      curL = 1\n    }\n  }\n  if(curL === 1) res = (res + 1) % mod\n  else res = (res + helper(curL)) % mod\n  return res\n\n  function helper(num) {\n     return (num * (num + 1)) / 2\n  }\n};\n\n"
    }
  },
  {
    "name": "1760-minimum-limit-of-balls-in-a-bag",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} maxOperations\n * @return {number}\n */\nconst minimumSize = function(nums, maxOperations) {\n        let L = 1, R = 10 ** 9;\n        while(L < R){\n            let M = (L + (R - L) / 2) >> 0, cnt = 0;\n            for(let x of nums) cnt += ((x + M - 1) / M - 1) >> 0;\n            if(cnt > maxOperations) L = M + 1;\n            else R = M;\n        }\n        return L;\n};\n\n"
    }
  },
  {
    "name": "1761-minimum-degree-of-a-connected-trio-in-a-graph",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {number}\n */\nconst minTrioDegree = function (n, edges) {\n  let ans = 10 ** 8\n  const adj = []\n  const deg = {}\n\n  function incDeg(u) {\n    if (deg[u] == null) deg[u] = 0\n    deg[u]++\n  }\n  for (let i = 0; i < n; i++) {\n    adj.push(Array(n).fill(false))\n  }\n\n  for (let [u, v] of edges) {\n    adj[u - 1][v - 1] = true\n    adj[v - 1][u - 1] = true\n    incDeg(u - 1)\n    incDeg(v - 1)\n  }\n  for (let u1 = 0; u1 < n; u1++) {\n    for (let u2 = u1 + 1; u2 < n; u2++) {\n      for (let u3 = u2 + 1; u3 < n; u3++) {\n        if (adj[u1][u2] && adj[u2][u3] && adj[u3][u1]) {\n          let tmp = deg[u1] + deg[u2] + deg[u3] - 6\n          ans = Math.min(ans, tmp)\n        }\n      }\n    }\n  }\n\n  if (ans > 10000000) ans = -1\n  return ans\n}\n"
    }
  },
  {
    "name": "1763-longest-nice-substring",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {string}\n */\nconst longestNiceSubstring = function(s) {\n  let res = ''\n  const n = s.length\n  \n  const arr = Array(26).fill(null)\n  for(let i = 0; i < n - 1; i++) {\n    for(let j = i + 1; j < n; j++) {\n      const tmp = s.slice(i, j + 1)\n      if(helper(tmp)) {\n        if(tmp.length > res.length) res = tmp\n      }\n    }\n  }\n  \n  \n  return res\n};\n\nfunction helper(s) {\n  const arr = Array(26).fill(null)\n  const a = 'a'.charCodeAt(0), A = 'A'.charCodeAt(0)\n  for(let e of s) {\n    const ecode = e.charCodeAt(0)\n    if(arr[ecode - a] === 0 || arr[ecode - A] === 0) continue\n    if(ecode - a < 26 && ecode - a >= 0) arr[ecode - a] = arr[ecode - a] === 1 ? 0 : -1\n    if(ecode - A < 26 && ecode - A >= 0) arr[ecode - A] = arr[ecode - A] === -1 ? 0 : 1\n  }\n  for(let e of arr) {\n    if(e === -1 || e === 1) return false\n  }\n  \n  return true\n}\n"
    }
  },
  {
    "name": "1764-form-array-by-concatenating-subarrays-of-another-array",
    "code": {
      "JS": "/**\n * @param {number[][]} groups\n * @param {number[]} nums\n * @return {boolean}\n */\nconst canChoose = function (groups, nums) {\n  const m = nums.length\n  let index = 0\n  for (let group of groups) {\n    const n = group.length\n    // Step-1 Generate LPS\n    const lps = Array(n).fill(0)\n    for (let i = 1; i < n; i++) {\n      let j = lps[i - 1]\n      while (j > 0 && group[i] !== group[j]) {\n        j = lps[j - 1]\n      }\n      if (group[i] === group[j]) {\n        j++\n      }\n      lps[i] = j\n    }\n\n    // Step-2 - Matching\n    let j = 0\n    while (index < m) {\n      if (nums[index] === group[j]) {\n        j++\n        index++\n      }\n      if (j === n) break\n      else if (index < m && nums[index] != group[j]) {\n        if (j > 0) {\n          j = lps[j - 1]\n        } else {\n          index++\n        }\n      }\n    }\n    if (j !== n) return false\n  }\n  return true\n}\n\n\n// another\n\n\n/**\n * @param {number[][]} groups\n * @param {number[]} nums\n * @return {boolean}\n */\nconst canChoose = function(groups, nums) {\n  let gi = 0, ni = 0\n  const n = groups.length, m = nums.length\n  while(gi < n && ni < m) {\n    const len = groups[gi].length\n    let pass = true\n    if(nums[ni] !== groups[gi][0]) {\n      ni++\n      continue\n    }\n    for(let i = 1; i < len; i++) {\n      if(nums[ni + i] !== groups[gi][i]) {\n        pass = false\n        break\n      }\n    }\n    if(pass) {\n      gi++\n      ni += len\n    } else {\n      ni++\n    }\n  }\n  if(gi >= n) return true\n\n  return false\n\n};\n"
    }
  },
  {
    "name": "1765-map-of-highest-peak",
    "code": {
      "JS": "/**\n * @param {number[][]} isWater\n * @return {number[][]}\n */\nconst highestPeak = function(isWater) {\n  let q = []\n  const visited = new Set()\n  const m = isWater.length, n = isWater[0].length\n  for(let i = 0; i < m; i++) {\n    for(let j = 0; j < n; j++) {\n      if(isWater[i][j] === 1) {\n          q.push([i, j, 0])\n          visited.add(`${i},${j}`)\n      }\n    }\n  }\n  const res = Array.from({ length: m }, () => Array(n).fill(0))\n  const dirs = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n  \n  while(q.length) {\n    const size = q.length\n    const next = []\n    // Array.shift time complexity: O(n)\n    for(let i = 0; i < size; i++) {\n      const cur = q[i]\n      const [row, col, val] = cur\n      for(let dir of dirs) {\n        const newRow = row + dir[0], newCol = col + dir[1]\n        const key = `${newRow},${newCol}`\n        if(newRow < 0 || newRow >= m || newCol < 0 || newCol >= n || visited.has(key) || res[newRow][newCol] !== 0) continue\n        next.push([newRow, newCol, val + 1])\n        res[newRow][newCol] = val + 1\n        visited.add(key)\n      }\n    }\n    q = next\n\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1766-tree-of-coprimes",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number[][]} edges\n * @return {number[]}\n */\nconst getCoprimes = function (nums, edges) {\n  const output = Array(nums.length).fill(null)\n  const graph = new Map()\n  for (let [u, v] of edges) {\n    if (!graph.has(u)) graph.set(u, [])\n    if (!graph.has(v)) graph.set(v, [])\n    graph.get(u).push(v)\n    graph.get(v).push(u)\n  }\n\n  function getGCD(a, b) {\n    if (!b) return a\n    return getGCD(b, a % b)\n  }\n\n  // ancestors is an array of unique ancestors from the recent to the farthest\n  // indices maps the index of each ancestor\n  function dfs(i, ancestors, indices) {\n    for (let num of ancestors) {\n      const gcd = getGCD(nums[i], num)\n      if (gcd === 1) {\n        output[i] = indices[num]\n        break\n      }\n    }\n\n    if (output[i] === null) output[i] = -1\n    ancestors = [nums[i], ...ancestors.filter((x) => x !== nums[i])]\n    indices[nums[i]] = i\n    for (let next of graph.get(i)) {\n      if (output[next] === null) {\n        dfs(next, ancestors, [...indices])\n      }\n    }\n  }\n\n  dfs(0, [], Array(51))\n  return output\n}\n"
    }
  },
  {
    "name": "1768-merge-strings-alternately",
    "code": {
      "JS": "/**\n * @param {string} word1\n * @param {string} word2\n * @return {string}\n */\nvar mergeAlternately = function(word1, word2) {\n  let res = '', mark = 0, i = 0, j = 0\n  while(i < word1.length && j < word2.length) {\n    if(mark === 0) {\n      res += word1[i++]\n      mark = 1\n    } else {\n      res += word2[j++]\n      mark = 0\n    }\n  }\n  while(i < word1.length) res += word1[i++]\n  while(j < word2.length) res += word2[j++]\n  \n  return res\n};\n"
    }
  },
  {
    "name": "1769-minimum-number-of-operations-to-move-all-balls-to-each-box",
    "code": {
      "JS": "/**\n * @param {string} boxes\n * @return {number[]}\n */\nconst minOperations = function(boxes) {\n  const n = boxes.length\n  const res = Array(n).fill(0)\n  let cum = 0, sum = 0\n  for(let i = 0; i < n; i++) {\n    res[i] += sum\n    cum += +boxes[i]\n    sum += cum\n  }\n  cum = 0, sum = 0\n  for(let i = n - 1; i >= 0; i--) {\n    res[i] += sum\n    cum += +boxes[i]\n    sum += cum\n  }\n  return res\n};\n\n\n// another\n\n\n/**\n * @param {string} boxes\n * @return {number[]}\n */\nconst minOperations = function(boxes) {\n  const res = []\n  for(let i = 0, len = boxes.length; i < len; i++) {\n    res[i] = helper(boxes, i)\n  }\n\n  return res\n};\n\nfunction helper(str, idx) {\n  let res = 0\n  for(let i = 0, len = str.length; i < len; i++) {\n    if(i === idx || str[i] === '0') continue\n    res += Math.abs(i - idx)\n  }\n  return res\n}\n\n// another\n\n/**\n * @param {string} boxes\n * @return {number[]}\n */\n const minOperations = function(boxes) {\n  const n = boxes.length\n  const res = Array(n).fill(0)\n  let cnt = 0, sum = 0\n  for(let i = 0; i < n; i++) {\n    res[i] = sum\n    cnt += boxes[i] === '1' ? 1 : 0\n    sum += cnt\n  }\n  cnt = 0, sum = 0\n  for(let i = n - 1; i >= 0; i--) {\n    res[i] += sum\n    cnt += boxes[i] === '1' ? 1 : 0\n    sum += cnt\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1770-maximum-score-from-performing-multiplication-operations",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number[]} multipliers\n * @return {number}\n */\nconst maximumScore = function(nums, multipliers) {\n  const n = nums.length, m = multipliers.length\n  const { max } = Math\n  const dp = Array.from({ length: m + 1 }, () => Array(m + 1).fill(-Infinity))\n  return helper(0, 0)\n  function helper(l, i) {\n    if(i === m) return 0\n    if(dp[l][i] !== -Infinity) return dp[l][i]\n    const pickLeft = helper(l + 1, i + 1) + nums[l] * multipliers[i]\n    const pickRight = helper(l, i + 1) + nums[n - (i - l) - 1] * multipliers[i]\n    return dp[l][i] = max(pickLeft, pickRight)\n  }\n\n};\n"
    }
  },
  {
    "name": "1771-maximize-palindrome-length-from-subsequences",
    "code": {
      "JS": "/**\n * @param {string} word1\n * @param {string} word2\n * @return {number}\n */\nconst longestPalindrome = function(word1, word2) {\n  const str = word1 + word2\n  const len = str.length, m = word1.length, n = word2.length\n  const dp = LPS(str)\n  let res = 0\n  for(let i = 0; i < m; i++) {\n    for(let j = 0; j < n; j++) {\n      if(word1[i] !== word2[j]) continue\n      res = Math.max(res, 2 + dp[i + 1][j + m - 1])\n    }\n  }\n  return res\n}\n\nfunction LPS(str) {\n  const n = str.length\n  const dp = Array.from({ length: n }, () => Array(n).fill(0))\n  for(let i = n - 1; i >= 0; i--) {\n    dp[i][i] = 1\n    for(let j = i + 1; j < n; j++) {\n      if(str[i] === str[j]) dp[i][j] = 2 + dp[i + 1][j - 1]\n      else dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1])\n    }\n  }\n  return dp\n}\n\n\n// another\n\n/**\n * @param {string} word1\n * @param {string} word2\n * @return {number}\n */\nconst longestPalindrome = function(word1, word2) {\n    const sz = word1.length + word2.length\n    let res = 0;\n    const dp = Array.from({ length: sz + 1 }, () => Array(sz + 1).fill(0))\n    longestPalindromeSubseq(word1 + word2, dp);\n    for (let i = 0; i < word1.length; ++i)\n        for (let j = word2.length - 1; j >= 0; --j)\n            if (word1[i] == word2[j]) {\n                res = Math.max(res, dp[i][word1.length + j + 1]);\n                break;\n            }\n    return res;\n\n}\nfunction longestPalindromeSubseq( s, dp) {\n    for (let len = 1; len <= s.length; ++len) \n        for (let i = 0; i + len <= s.length; ++i) \n            dp[i][i + len] = s[i] == s[i + len - 1] ? \n                dp[i + 1][i + len - 1] + (len == 1 ? 1 : 2) : \n                    Math.max(dp[i][i + len - 1],  dp[i + 1][i + len]);\n    return dp[0][s.length];\n}    \n\n\n"
    }
  },
  {
    "name": "1773-count-items-matching-a-rule",
    "code": {
      "JS": "/**\n * @param {string[][]} items\n * @param {string} ruleKey\n * @param {string} ruleValue\n * @return {number}\n */\nconst countMatches = function(items, ruleKey, ruleValue) {\n  let res = 0\n  for(let e of items) {\n    if(helper(e, ruleKey, ruleValue)) res++\n  }\n  return res\n};\n\nfunction helper(e, k, v) {\n  const [t, c, n] = e\n  if(k === 'type' && v === t) {\n    return true\n  } else if(k === 'color' && v === c) {\n    return true\n  } else if(k === 'name' && v === n) {\n    return true\n  }\n  \n  return false\n  \n}\n"
    }
  },
  {
    "name": "1774-closest-dessert-cost",
    "code": {
      "JS": "/**\n * @param {number[]} baseCosts\n * @param {number[]} toppingCosts\n * @param {number} target\n * @return {number}\n */\nconst closestCost = function(baseCosts, toppingCosts, target) {\n  let res = baseCosts[0], n = baseCosts.length, m = toppingCosts.length\n  const { abs } = Math\n  for (let i = 0; i < n; i++) {\n    helper(0, baseCosts[i])\n  }\n  return res\n  function helper(i, cur) {\n    if(\n      abs(cur - target) < abs(res - target)\n      || (abs(cur - target) === abs(res - target) && cur < res)\n    ) {\n      res = cur\n    }\n    if(i === m || cur > target) return\n    helper(i + 1, cur)\n    helper(i + 1, cur + toppingCosts[i])\n    helper(i + 1, cur + toppingCosts[i] * 2)\n  }\n};\n\n// another\n\n\n/**\n * @param {number[]} baseCosts\n * @param {number[]} toppingCosts\n * @param {number} target\n * @return {number}\n */\nconst closestCost = function(baseCosts, toppingCosts, target) {\n    let n = baseCosts.length, m = toppingCosts.length;\n    const { abs } = Math\n    const costs = new Set();\n    for (let i = 0; i < n; i++) {\n      dfs(toppingCosts, 0, m, baseCosts[i], costs);\n    }\n    const nums = [];\n    for (let x of costs) nums.push(x);\n    nums.sort((a, b) => abs(a - target) == abs(b - target) ? a - b : abs(a - target) - abs(b - target))\n    return nums[0];\n  \n};\n\nfunction dfs(toppingCosts, ind, m, cost, costs) {\n    costs.add(cost);\n    if (ind >= m) return;\n    dfs(toppingCosts, ind + 1, m, cost, costs);\n    dfs(toppingCosts, ind + 1, m, cost + toppingCosts[ind], costs);\n    dfs(toppingCosts, ind + 1, m, cost + toppingCosts[ind] * 2, costs);\n}\n"
    }
  },
  {
    "name": "1775-equal-sum-arrays-with-minimum-number-of-operations",
    "code": {
      "JS": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nconst minOperations = function(nums1, nums2) {\n  const m = nums1.length, n = nums2.length\n  if(m > n * 6 || n > m * 6) return -1\n  let sum1 = sum(nums1), sum2 = sum(nums2)\n  if(sum1 > sum2) return minOperations(nums2, nums1)\n\n  const arr = Array(6).fill(0)\n  nums1.forEach(e => arr[6 - e]++)\n  nums2.forEach(e => arr[e - 1]++)\n\n  let res = 0, i = 5\n  while(sum1 < sum2) {\n    while(arr[i] === 0) i--\n    sum1 += i\n    res++\n    arr[i]--\n  }\n\n  return res\n};\n\nfunction sum(arr) {\n  return arr.reduce((ac, e) => ac + e, 0)\n}\n\n// another\n\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nconst minOperations = function(nums1, nums2) {\n  const m = nums1.length, n = nums2.length\n  if(m > n * 6 || n > m * 6) return -1\n  const sum1 = nums1.reduce((ac, e) => ac + e, 0)\n  const sum2 = nums2.reduce((ac, e) => ac + e, 0)\n  let largerArr, smallerArr\n  if(sum1 === sum2) return 0\n  if(sum1 > sum2) {\n    largerArr = nums1\n    smallerArr = nums2\n  } else {\n    largerArr = nums2\n    smallerArr = nums1\n  }\n  \n  const gain = []\n  for(let e of largerArr) gain.push(e - 1)\n  for(let e of smallerArr) gain.push(6 - e)\n  gain.sort((a, b) => b - a)\n  let diff = Math.abs(sum2 - sum1)\n  let cnt = 0\n  for(let e of gain) {\n    diff -= e\n    cnt++\n    if(diff <= 0) return cnt\n  }\n  return -1\n};\n\n\n\n\n// another\n\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nconst minOperations = function(nums1, nums2) {\n    const len1 = nums1.length, len2 = nums2.length;\n    if (len1 > 6 * len2 || len2 > 6 * len1) return -1;\n    let sum1 = 0, sum2 = 0;\n    for (let x of nums1) sum1 += x;\n    for (let x of nums2) sum2 += x;\n    if (sum1 === sum2) return 0;\n    nums1.sort((a, b) => a - b)\n    nums2.sort((a, b) => a - b)\n    let cnt = 0;\n    if (sum1 > sum2) {\n        let ind1 = len1 - 1, ind2 = 0;\n        while (sum1 > sum2) { \n            if (ind2 === len2 || nums1[ind1] - 1 > 6 - nums2[ind2]) sum1 -= nums1[ind1--] - 1;\n            else sum2 += 6 - nums2[ind2++];\n            cnt++;\n        }\n        return cnt;\n    }\n    let ind1 = 0, ind2 = len2 - 1;\n    while (sum1 < sum2) {\n        if (ind1 === len1 || nums2[ind2] - 1 > 6 - nums1[ind1]) sum2 -= nums2[ind2--] - 1;\n        else sum1 += 6 - nums1[ind1++];\n        cnt++;\n    }\n    return cnt;\n};\n"
    }
  },
  {
    "name": "1776-car-fleet-ii",
    "code": {
      "JS": "/**\n * @param {number[][]} cars\n * @return {number[]}\n */\nconst getCollisionTimes = function(cars) {\n  const n = cars.length;\n  const stack = [];\n  const res = Array(n)\n  for(let i = n - 1; i >= 0; i--) {\n    const [p, s] = cars[i]\n    res[i] = -1\n    while(stack.length) {\n      const j = stack[stack.length - 1]\n      const [p2, s2] = cars[j]\n      if(s2 >= s || res[j] > 0 && (p2 - p) / (s - s2) >= res[j]) stack.pop()\n      else break\n    }\n    if(stack.length) {\n      const j = stack[stack.length - 1]\n      const [p2, s2] = cars[j]\n      res[i] = (p2 - p) / (s - s2)\n    }\n    stack.push(i)\n  }\n  \n  return res\n};\n\n// another\n\n\n/**\n * @param {number[][]} cars\n * @return {number[]}\n */\nvar getCollisionTimes = function(cars) {\n  //这道题必须想清楚一点，那就是如果ans[i]有正值，那么一定是cars[i]和某个cars[j]（j>i且speed[j]<speed[i]）\n  //相撞之后，所谓的融合，其实可以理解为cars[i]消失了，cars[j]状态不变\n  //所以我们只关注一辆车后面，不关注其前面，它的前面对它没有任何影响。可以考虑从后往前遍历\n  const n = cars.length\n  const ans = Array(n).fill(0)\n  //设立一个类似单调栈的栈，栈底最慢，栈顶最快\n  const stack = []\n  for(let i = n - 1; i >= 0; i--) {\n    while(stack.length) {\n      //如果栈顶比我快，我追不上它，可以考虑等它消失之后我去撞它前面的，所以将它pop\n      if(cars[stack[stack.length - 1]][1] >= cars[i][1]) stack.pop()\n      //如果栈顶比我慢，我就决定去碰它了\n      else {\n        //如果它不会消失，那我肯定能碰它，break\n        if(ans[stack[stack.length - 1]] < 0) break\n        //如果它会消失，我需要计算一下在它消失之前能否追上它\n        const d = ans[stack[stack.length - 1]] * (cars[i][1] - cars[stack[stack.length - 1]][1])\n        //能追上，那我肯定碰它，break\n        if(d > cars[stack[stack.length - 1]][0] - cars[i][0]) break\n        //追不上，那算了，追它前面的车\n        else stack.pop()\n      }\n    }\n    if(stack.length === 0) ans[i] = -1\n    else {\n      //相对距离除以相对速度\n      const t = (cars[stack[stack.length - 1]][0]-cars[i][0])/(cars[i][1]-cars[stack[stack.length - 1]][1])\n      ans[i] = t\n    }\n    stack.push(i)\n  }\n  return ans\n};\n\n\n// another\n\n/**\n * @param {number[][]} cars\n * @return {number[]}\n */\nvar getCollisionTimes = function (cars) {\n  let n = cars.length,\n    t = 0,\n    i\n  const ans = Array(n)\n  for (let i = 0; i < n; i++) ans[i] = -1\n  const s = []\n  s[++t] = n - 1\n  for (let i = n - 2; ~i; i--) {\n    while (t && cars[s[t]][1] >= cars[i][1]) t--\n    while (\n      t > 1 &&\n      (cars[s[t]][0] - cars[i][0]) * (cars[i][1] - cars[s[t - 1]][1]) >\n        (cars[s[t - 1]][0] - cars[i][0]) * (cars[i][1] - cars[s[t]][1])\n    )\n      t--\n    if (t) ans[i] = (cars[s[t]][0] - cars[i][0]) / (cars[i][1] - cars[s[t]][1])\n    s[++t] = i\n  }\n  return ans\n}\n"
    }
  },
  {
    "name": "1779-find-nearest-point-that-has-the-same-x-or-y-coordinate",
    "code": {
      "JS": "/**\n * @param {number} x\n * @param {number} y\n * @param {number[][]} points\n * @return {number}\n */\nconst nearestValidPoint = function(x, y, points) {\n  let idx = -1, dis = Infinity\n  const {min, max, abs} = Math\n  for(let i = 0; i < points.length; i++) {\n    const e = points[i]\n    const [tx, ty] = e\n    if(tx === x || ty === y) {\n      const tmp = abs(tx - x) + abs(ty - y)\n      if(tmp < dis) {\n        idx = i\n        dis = tmp\n      }\n    }\n  }\n  \n  return idx === -1 ? -1 : idx\n};\n"
    }
  },
  {
    "name": "1780-check-if-number-is-a-sum-of-powers-of-three",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {boolean}\n */\nconst checkPowersOfThree = function(n) {\n  const num = ~~(n / 3)\n  const rem = n % 3\n  if(num === 0 && rem === 1) return true\n  if(rem === 2) return false\n  return checkPowersOfThree(num)\n};\n"
    }
  },
  {
    "name": "1781-sum-of-beauty-of-all-substrings",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst beautySum = function(s) {\n  let ans = 0\n  const a = 'a'.charCodeAt(0)\n  const min = arr => {\n    let res = Infinity\n    for(let e of arr) {\n      if(e !== 0) res = Math.min(e, res)\n    }\n    return res\n  }\n  for(let i = 0, n = s.length; i < n; i++) {\n    let freq = Array(26).fill(0)\n    for(let j = i; j < n; j++) {\n      freq[s.charCodeAt(j) - a]++\n      ans += Math.max(...freq) - min(freq)\n    }\n  }\n  return ans \n};\n"
    }
  },
  {
    "name": "1784-check-if-binary-string-has-at-most-one-segment-of-ones",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {boolean}\n */\nconst checkOnesSegment = function(s) {\n  let res = 1\n  for(let i = 1, len = s.length; i < len; i++) {\n    if(s[i] === '1' && s[i - 1] === '0') res++\n    if(s[i] === '1' && s[i - 1] === '1') continue\n  }\n  return res <= 1\n};\n"
    }
  },
  {
    "name": "1785-minimum-elements-to-add-to-form-a-given-sum",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} limit\n * @param {number} goal\n * @return {number}\n */\nconst minElements = function(nums, limit, goal) {\n  const sum = nums.reduce((ac, e) => ac + e, 0)\n  let delta = goal - sum\n  if(delta === 0) return 0\n  const op = delta > 0 ? '+' : '-'\n  let res = 0\n  delta = Math.abs(delta)\n  return  Math.floor(delta / limit) + (delta % limit > 0 ? 1 : 0)\n};\n"
    }
  },
  {
    "name": "1786-number-of-restricted-paths-from-first-to-last-node",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {number}\n */\nconst countRestrictedPaths = function(n, edges) {\n  const adj = {}\n  const MOD = 10 ** 9 + 7\n  for(let edge of edges) {\n    const [u,v,d] = edge\n    if(adj[u] == null) adj[u] = []\n    if(adj[v] == null) adj[v] = []\n    adj[u].push([v, d])\n    adj[v].push([u, d])\n  }\n  const dist = Array(n + 1).fill(Infinity)\n  dist[n] = 0\n  const pq = new PriorityQueue((a, b) => a[0] < b[0])\n  pq.push([0, n])\n  while(!pq.isEmpty()) {\n    const [d, u] = pq.peek()\n    pq.pop()\n    if(d > dist[u]) continue\n    for(let [v, c] of adj[u]) {\n      if(d + c < dist[v]) {\n        dist[v] = d + c\n        pq.push([dist[v], v])\n      }\n    }\n  }\n    \n  const order = Array(n).fill(0)\n  for(let i = 0; i < n; i++) {\n    order[i] = i + 1\n  }\n    \n  order.sort((u, v) => dist[u] - dist[v])\n  const ans = Array(n + 1).fill(0)\n  ans[n] = 1\n  for(let u of order) {\n    for(let [v, c] of adj[u]) {\n      if(dist[v] > dist[u]) {\n        ans[v] = (ans[v] + ans[u]) % MOD\n      }\n    }\n  }\n    \n  return ans[1]\n};\n\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n\n// another\n\n/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {number}\n */\nconst countRestrictedPaths = function(n, edges) {\n  if (n === 1) return 0\n  const graph = {}\n  for(const [u, v, t] of edges) {\n    if(graph[u] == null) graph[u] = {}\n    if(graph[v] == null) graph[v] = {}\n    graph[u][v] = t\n    graph[v][u] = t\n  }\n  const dist = dijkstra(n, graph)\n  const memo = Array(n + 1).fill(null)\n  const res = dfs(1)\n  return res\n\n  function dijkstra(n, graph) {\n    const dist = Array(n + 1).fill(Infinity)\n    dist[n] = 0\n    const pq = new PriorityQueue((a, b) => a[0] < b[0])\n    pq.push([0, n])\n    while(!pq.isEmpty()) {\n      const [d, cur] = pq.pop()\n      if(d !== dist[cur]) continue\n      for(const next of Object.keys(graph[cur] || {})) {\n        const delta = graph[cur][next]\n        if(dist[next] > d + delta) {\n          dist[next] = d + delta\n          pq.push([d + delta, next])\n        } \n      }\n    }\n    return dist\n  }\n\n  function dfs(src) {\n    if(memo[src] != null) return memo[src]\n    if(src === n) return 1\n    let res = 0\n    for(let next of Object.keys(graph[src] || {})) {\n      next = +next\n      if(dist[src] > dist[next]) {\n        res = ((res + dfs(next)) % (1e9 + 7))\n      }\n    }\n    return memo[src] = res\n  }\n}\n"
    }
  },
  {
    "name": "1787-make-the-xor-of-all-segments-equal-to-zero",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nconst L = 2 ** 10;\nconst MAX = Number.MAX_SAFE_INTEGER;\nconst mi = Math.min;\nconst minChanges = (a, k) => {\n    let n = a.length;\n    let dp = Array(L).fill(MAX);\n    dp[0] = 0;\n    for (let i = 0; i < k; i++) {\n        let tmp = Array(L).fill(0);\n        let tot = 0;\n        for (let j = i; j < n; j += k) {\n            tmp[a[j]]++; // frequency count of starting points from each kth continuous subarray\n            tot++; // total count of starting points from each kth continuous subarray\n        }\n        let ndp = Array(L).fill(0);\n        let min = MAX;\n        for (let j = 0; j < L; j++) {\n            min = mi(min, dp[j]);\n        }\n        min += tot;\n        ndp = ndp.map(x => x = min); // updated nested dp array with min value\n        for (let j = 0; j < L; j++) {\n            if (tmp[j] != 0) {\n                for (let m = 0; m < L; m++) {\n                    ndp[m ^ j] = mi(ndp[m ^ j], dp[m] + tot - tmp[j]);\n                }\n            }\n        }\n        dp = ndp;  // reset dp\n    }\n    return dp[0];\n};\n"
    }
  },
  {
    "name": "179-largest-number",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {string}\n */\nconst largestNumber = function(nums) {\n  const arr = nums\n    .map(v => v.toString())\n    .sort((a, b) => (a + b < b + a ? 1 : -1))\n    .join(\"\");\n\n  return arr[0] === \"0\" ? \"0\" : arr;\n};\n"
    }
  },
  {
    "name": "1790-check-if-one-string-swap-can-make-strings-equal",
    "code": {
      "JS": "/**\n * @param {string} s1\n * @param {string} s2\n * @return {boolean}\n */\nconst areAlmostEqual = function(s1, s2) {\n  if (s1 === s2) return true\n  let arr = []\n  for(let i = 0, len = s1.length; i < len; i++) {\n    if(s1[i] !== s2[i]) arr.push(i)\n    \n    if(arr.length > 2) return false\n  }\n  \n  if(arr.length === 1) return false\n  const [i1, i2] = arr\n  if(s1[i2] === s2[i1] && s1[i1] === s2[i2]) return true\n  return false\n};\n"
    }
  },
  {
    "name": "1791-find-center-of-star-graph",
    "code": {
      "JS": "/**\n * @param {number[][]} edges\n * @return {number}\n */\nconst findCenter = function(edges) {\n  return edges[0][0] === edges[1][0] || edges[0][0] === edges[1][1] ? edges[0][0] : edges[0][1]\n};\n\n// another\n\n/**\n * @param {number[][]} edges\n * @return {number}\n */\nconst findCenter = function(edges) {\n  const map = {}\n  for(let e of edges) {\n    const [u, v] = e\n    if(map[u] == null) map[u] = []\n    if(map[v] == null) map[v] = []\n    map[u].push(v)\n    map[v].push(u)\n  }\n  \n  const keys = Object.keys(map)\n  let res, max = -Infinity\n  keys.forEach(e => {\n    if(map[e].length > max) {\n      res = e\n      max = map[e].length\n    }\n  })\n  \n  return res\n  \n};\n"
    }
  },
  {
    "name": "1792-maximum-average-pass-ratio",
    "code": {
      "JS": "/**\n * @param {number[][]} classes\n * @param {number} extraStudents\n * @return {number}\n */\nconst maxAverageRatio = function (classes, extraStudents) {\n  const pq = new PriorityQueue((a, b) => a.delta > b.delta)\n  const n = classes.length\n  for (let e of classes) {\n    pq.push({\n      pass: e[0],\n      total: e[1],\n      ratio: e[0] / e[1],\n      delta: (e[0] + 1) / (e[1] + 1) - e[0] / e[1],\n    })\n  }\n\n  while (extraStudents) {\n    const tmp = pq.pop()\n    tmp.pass++\n    tmp.total++\n    tmp.ratio = tmp.pass / tmp.total\n    tmp.delta = (tmp.pass + 1) / (tmp.total + 1) - tmp.ratio\n    pq.push(tmp)\n    extraStudents--\n  }\n\n  let res = 0\n  while (!pq.isEmpty()) {\n    const tmp = pq.pop()\n    res += tmp.ratio\n  }\n\n  return res / n\n}\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n\n\n\n// another\n\n/**\n * @param {number[][]} classes\n * @param {number} extraStudents\n * @return {number}\n */\nconst maxAverageRatio = function(classes, extraStudents) {\n  const pq = new PriorityQueue((a, b) => a.up > b.up);\n  for (let x of classes) pq.push(new Node(x[0], x[1]));\n  while (extraStudents--) {\n    let temp = pq.peek();\n    pq.pop();\n    temp.pass++, temp.total++;\n    temp.calUp();\n    pq.push(temp);\n  }\n    let total = 0.0;\n    let n = classes.length;\n    while (!pq.isEmpty()) {\n        let temp = pq.peek();\n        pq.pop();\n        total += temp.pass / temp.total;\n    }\n    return total / n;\n};\n\nclass Node {\n  constructor(pass, total) {\n    this.pass = pass\n    this.total = total\n    this.calUp()\n  }\n  calUp() {\n    this.up = (this.pass + 1) / (this.total + 1) - this.pass / this.total\n  }\n}\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n"
    }
  },
  {
    "name": "1793-maximum-score-of-a-good-subarray",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nconst maximumScore = function(nums, k) {\n  const n = nums.length, {min, max} = Math\n  let mini = nums[k];\n  let ans = mini;\n  let i = k;\n  let j = k;\n\n  while (i > 0 || j < n - 1) {\n    if (i === 0 || (j + 1 < n && nums[i - 1] <= nums[j + 1])) {\n      j++;\n      mini = min(mini, nums[j]);\n    } else {\n      i--;\n      mini = min(mini, nums[i]);\n    }\n    ans = max(ans, mini * (j - i + 1));\n  }\n\n  return ans;\n};\n\n// another\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nconst maximumScore = function(nums, k) {\n  const n = nums.length, { max, min } = Math\n  let l = k, r = k, mi = nums[k]\n  let res = nums[k]\n  while(l > 0 || r < n - 1) {\n    if(l === 0) r++\n    else if(r === n - 1) l--\n    else if(nums[l - 1] < nums[r + 1]) r++\n    else l--\n    mi = min(mi, nums[l], nums[r])\n    res = max(res, mi * (r - l + 1))\n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "1798-maximum-number-of-consecutive-values-you-can-make",
    "code": {
      "JS": "/**\n * @param {number[]} coins\n * @return {number}\n */\nconst getMaximumConsecutive = function(coins) {\n  coins.sort((a, b) => a - b);\n  let res = 1;\n  for (let a of coins) {\n    if (a > res) break;\n    res += a;\n  }\n  return res; \n};\n"
    }
  },
  {
    "name": "1799-maximize-score-after-n-operations",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst maxScore = function (nums) {\n  const gcd = (a, b) => (b === 0 ? a : gcd(b, a % b))\n  const n = nums.length / 2\n  const memo = {}\n  const traverse = (op, mask) => {\n    if (op > n) {\n      return 0\n    }\n    const idx = op * 100000 + mask\n    if (memo[idx] === undefined) {\n      let res = 0\n      for (let i = 0; i < 2 * n - 1; i++) {\n        if (mask & (1 << i)) continue\n        for (let j = i + 1; j < 2 * n; j++) {\n          if (mask & (1 << j)) continue\n          const newMask = mask | (1 << i) | (1 << j)\n          res = Math.max(\n            res,\n            traverse(op + 1, newMask) + op * gcd(nums[i], nums[j])\n          )\n        }\n      }\n      memo[idx] = res\n    }\n    return memo[idx]\n  }\n  const res = traverse(1, 0)\n  return res\n}\n"
    }
  },
  {
    "name": "18-4sum",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[][]}\n */\nconst fourSum = function (nums, target) {\n  nums.sort((a, b) => a - b)\n  const results = []\n  kSum(nums, target, 4, 0, [], results)\n  return results\n}\n\nfunction kSum(nums, target, k, i, acc, results) {\n  if (nums[i] * k > target || nums[nums.length - 1] * k < target) return\n  if (k > 2) {\n    for (let j = i; j <= nums.length - k; j++) {\n      if (j == i || nums[j] > nums[j - 1])\n        kSum(nums, target - nums[j], k - 1, j + 1, [...acc, nums[j]], results)\n    }\n  } else {\n    twoSum(nums, target, i, acc, results)\n  }\n}\n\nfunction twoSum(nums, target, i, acc, results) {\n  let lo = i\n  let hi = nums.length - 1\n  while (lo < hi) {\n    const sum = nums[lo] + nums[hi]\n    if (sum == target) {\n      results.push([...acc, nums[lo], nums[hi]])\n      while (nums[lo] == nums[lo + 1]) lo++\n      while (nums[hi] == nums[hi - 1]) hi--\n      lo++\n      hi--\n    } else if (sum < target) {\n      lo++\n    } else {\n      hi--\n    }\n  }\n}\n\n\n// another\n\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[][]}\n */\nconst fourSum = function(nums, target) {\n  return nSum(nums.sort((a, b) => a - b), target, 4, 0);\n};\n\nfunction nSum(nums, target, k, start) {\n  const res = [];\n  if (nums.length < k || k < 2 || target < nums[0] * k || target > nums[-1] * k)\n    return res;\n  if (k == 2) {\n    // 2 sum; ( improved to O(n) )\n    let r = nums.length - 1;\n    let l = start;\n    while (l < r) {\n      if (nums[l] + nums[r] === target) {\n        res.push([nums[l], nums[r]]);\n        //skip duplication\n        while (l < r && nums[l] === nums[l + 1]) l++;\n        while (l < r && nums[r] === nums[r - 1]) r--;\n        l++;\n        r--;\n      } else if (nums[l] + nums[r] < target) {\n        l++;\n      } else {\n        r--;\n      }\n    }\n  } else {\n    for (let i = start; i < nums.length - k + 1; i++) {\n      if (i === start || (i > start && nums[i] !== nums[i - 1])) {\n        let temp = nSum(nums, target - nums[i], k - 1, i + 1);\n        temp.forEach(t => {\n          t.push(nums[i]);\n          res.push(t);\n        });\n      }\n    }\n  }\n  return res;\n}\n"
    }
  },
  {
    "name": "1800-maximum-ascending-subarray-sum",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst maxAscendingSum = function(nums) {\n  let res = -Infinity\n  \n  const n = nums.length\n  let cur = 0\n  for(let i = 0; i < n; i++) {\n    if(i === 0) cur = nums[i]\n    if(i > 0) {\n      if(nums[i] > nums[i - 1]) {\n        cur += nums[i]\n        res = Math.max(res, cur)\n      } else {\n        res = Math.max(res, cur)\n        cur = nums[i]\n      } \n    }\n  }\n  res = Math.max(res, cur)  \n  return res\n};\n"
    }
  },
  {
    "name": "1801-number-of-orders-in-the-backlog",
    "code": {
      "JS": "/**\n * @param {number[][]} orders\n * @return {number}\n */\nconst getNumberOfBacklogOrders = function (orders) {\n  const h0 = new PriorityQueue((a, b) => a[0] > b[0])\n  const h1 = new PriorityQueue((a, b) => a[0] > b[0])\n  const P = 10 ** 9 + 7\n  const { min } = Math\n\n  while (!h0.isEmpty()) h0.pop()\n  while (!h1.isEmpty()) h1.pop()\n  let i,\n    j,\n    i1,\n    j1,\n    ans = 0\n  for (let c of orders) {\n    i = c[0]\n    j = c[1]\n    if (c[2]) {\n      while (!h0.isEmpty() && h0.peek()[0] >= i) {\n        i1 = h0.peek()[0]\n        j1 = h0.peek()[1]\n        h0.pop()\n        if (j > j1) j -= j1\n        else {\n          j1 -= j\n          j = 0\n          if (j1) h0.push([i1, j1])\n          break\n        }\n      }\n      if (j) h1.push([-i, j])\n    } else {\n      while (!h1.isEmpty() && -h1.peek()[0] <= i) {\n        i1 = h1.peek()[0]\n        j1 = h1.peek()[1]\n        h1.pop()\n        if (j > j1) j -= j1\n        else {\n          j1 -= j\n          j = 0\n          if (j1) h1.push([i1, j1])\n          break\n        }\n      }\n      if (j) h0.push([i, j])\n    }\n  }\n  while (!h0.isEmpty()) {\n    ans += h0.peek()[1]\n    h0.pop()\n    if (ans >= P) ans -= P\n  }\n  while (!h1.isEmpty()) {\n    ans += h1.peek()[1]\n    h1.pop()\n    if (ans >= P) ans -= P\n  }\n  return ans\n}\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n"
    }
  },
  {
    "name": "1802-maximum-value-at-a-given-index-in-a-bounded-array",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number} index\n * @param {number} maxSum\n * @return {number}\n */\nconst maxValue = function(n, index, maxSum) {\n  let res = 1, l = index, r = index\n  maxSum -= n\n\n  while(l > 0 || r < n - 1) {\n    const len = r - l + 1\n    if(maxSum >= len) {\n      maxSum -= len \n      res++\n    } else break\n    if(l > 0) l--\n    if(r < n - 1) r++\n  }\n  res += ~~(maxSum / n)\n\n  return res\n}\n\n// another\n\n\n/**\n * @param {number} n\n * @param {number} index\n * @param {number} maxSum\n * @return {number}\n */\nconst maxValue = function(n, index, maxSum) {\n  maxSum -= n;\n  let level = 1;\n  let left = index;\n  let right = index;\n\n  while (maxSum - (right - left + 1) >= 0) {\n    if (left === 0 && right === n - 1) break\n    maxSum -= right - left + 1;\n    if (left - 1 >= 0) left--\n    if (right + 1 <= n - 1) right++;\n    level++;\n  }\n\n  if (maxSum) level += ~~(maxSum / n)\n\n  return level;\n}\n\n// another\n\n\n/**\n * @param {number} n\n * @param {number} index\n * @param {number} maxSum\n * @return {number}\n */\nconst maxValue = function(n, index, maxSum) {\n  const { floor, sqrt } = Math\n  maxSum -= n\n  if(index < Math.floor(n / 2)) index = n - 1 - index\n  let left = index // number of element to the left of the index\n  let right = n - 1 - index // number of element to the right of the index\n  // the triangle area for the left side if not hitting the boundary\n  let leftSum = floor((left * (left + 1)) / 2)\n  // the triangle area for the right side if not hitting the boundary\n  let rightSum = floor((right * (right + 1)) / 2)\n  // case: perfect pyramid\n  if (maxSum <= (rightSum * 2 + right + 1)) return floor(sqrt(maxSum) + 1)\n  // case: right side hits the boundary\n  if (maxSum <= (leftSum + rightSum + (left - right) * right + left + 1)) {\n    const b = 3 + 2 * right\n    return floor((-b + sqrt(b * b - 8 * (rightSum + 1 - right * right - maxSum))) / 2) + 1 + 1\n  }\n  // case: both sides hit boundaries\n  maxSum -= (leftSum + rightSum + (left - right) * right + left + 1)\n  return left + 1 + 1 + floor(maxSum / n)\n};\n\n// another\n\n/**\n * @param {number} n\n * @param {number} index\n * @param {number} maxSum\n * @return {number}\n */\nconst maxValue = function (n, index, maxSum) {\n  let ret = 0\n  const { max } = Math\n  for (let i = 30; i >= 0; i--) {\n    const tmp = ret + (1 << i)\n    const L = max(0, tmp - index)\n    let sum = ((L + tmp) * (tmp - L + 1)) / 2\n    const R = max(0, tmp - (n - 1 - index))\n    sum += ((R + tmp) * (tmp - R + 1)) / 2 - tmp\n\n    if (sum <= maxSum - n) ret += 1 << i\n  }\n  return ret + 1\n}\n"
    }
  },
  {
    "name": "1803-count-pairs-with-xor-in-a-range",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} low\n * @param {number} high\n * @return {number}\n */\nconst countPairs = function (nums, low, high) {\n  const trie = new Trie()\n\n  let ans = 0\n  for (let x of nums) {\n    ans += trie.count(x, high + 1) - trie.count(x, low)\n    trie.insert(x)\n  }\n  return ans\n}\n\nclass Trie {\n  constructor() {\n    this.root = {}\n  }\n  insert(val) {\n    let node = this.root\n    for (let i = 14; i >= 0; i--) {\n      let bit = (val >> i) & 1\n      if (!(bit in node)) node[bit] = { cnt: 1 }\n      else node[bit]['cnt'] += 1\n      node = node[bit]\n    }\n  }\n  count(val, high) {\n    let ans = 0\n    let node = this.root\n    for (let i = 14; i >= 0; i--) {\n      if (!node) break\n      const bit = (val >> i) & 1\n      const cmp = (high >> i) & 1\n      if (cmp) {\n        if (node[bit]) ans += node[bit]['cnt']\n        node = node[1 ^ bit]\n      } else node = node[bit]\n    }\n\n    return ans\n  }\n}\n"
    }
  },
  {
    "name": "1805-number-of-different-integers-in-a-string",
    "code": {
      "JS": "/**\n * @param {string} word\n * @return {number}\n */\nconst numDifferentIntegers = function(word) {\n  let cur = ''\n  const n = word.length\n  const set = new Set()\n  for(let i = 0; i < n; i++ ) {\n    if(word[i] >= '0' && word[i] <= '9') cur += word[i]\n    else {\n      if(cur) set.add(+cur)\n      cur = ''\n    }\n    if(i === n - 1 && cur) set.add(+cur)\n  }\n\n  return set.size\n};\n"
    }
  },
  {
    "name": "1806-minimum-number-of-operations-to-reinitialize-a-permutation",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst reinitializePermutation = function(n) {\n  let perm = []\n  for(let i = 0; i < n; i++) {\n    perm[i] = i\n  }\n  let clone = perm.slice()\n  let res = 0\n  \n  while(true) {\n    res++\n    let arr = clone.slice()\n    for(let i = 0; i < clone.length; i++) {\n      if(i % 2 === 0) arr[i] = clone[i / 2]\n      else arr[i] = clone[n / 2 + (i - 1) / 2]\n    }\n    \n    if(chk(perm, arr)) break\n    clone = arr\n  }\n  \n  \n  return res\n  \n  function chk(a1, a2) {\n    for(let i = 0, len = a1.length; i < len; i++) {\n      if(a1[i] !== a2[i]) return false\n    }\n    return true\n  }\n};\n\n// another\n\n/**\n * @param {number} n\n * @return {number}\n */\nconst reinitializePermutation = function(n) {\n  let res = 0, i = 1;\n  while (res === 0 || i > 1) {\n    i = i * 2 % (n - 1);\n    res++;\n  }\n  return res;\n};\n\n// another\n\n/**\n * @param {number} n\n * @return {number}\n */\nconst reinitializePermutation = function(n) {\n\tif (n === 2) return 1\n\tconst mod = n - 1\n\tlet curr_power = 2\n\tlet cnt = 1\n\t// Find multiplicative order modulo n-1\n\twhile (curr_power !== 1) {\n\t\tcurr_power = (2 * curr_power) % mod\n\t\tcnt++\n  }\n\treturn cnt\n};\n"
    }
  },
  {
    "name": "1807-evaluate-the-bracket-pairs-of-a-string",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {string[][]} knowledge\n * @return {string}\n */\nconst evaluate = function(s, knowledge) {\n  const map = {}\n  for(let e of knowledge) {\n    const [k, v] = e\n    map[k] = v\n  }\n  const n = s.length\n  let start = -1, end = 0\n  let cur = ''\n  const arr = []\n  for(let i = 0; i < n; i++) {\n    if(s[i] === '(') {\n      start = i\n      if(cur) {\n        arr.push(cur)\n        cur = ''\n      }\n      continue\n    }\n    else if(start !== -1 && s[i] !== ')') {\n      cur += s[i]\n    }\n    else if(s[i] === ')') {\n      if(cur in map) arr.push(map[cur])\n      else arr.push('?')\n      start = -1\n      cur = ''\n    } else {\n      cur += s[i]\n    }\n    if(i === n - 1 && cur) arr.push(cur)\n  }\n  \n  return arr.join('')\n  \n};\n"
    }
  },
  {
    "name": "1808-maximize-number-of-nice-divisors",
    "code": {
      "JS": "/**\n * @param {number} primeFactors\n * @return {number}\n */\nconst MOD = BigInt(1e9 + 7)\nconst maxNiceDivisors = (pf) => {\n  if (pf == 1) return 1\n  let bpf = BigInt(pf)\n  let res\n  if (pf % 3 == 0) {\n    res = powmod(3n, bpf / 3n, MOD)\n  } else if (pf % 3 == 1) {\n    res = (powmod(3n, bpf / 3n - 1n, MOD) * 4n) % MOD\n  } else {\n    res = (powmod(3n, bpf / 3n, MOD) * 2n) % MOD\n  }\n  return Number(res)\n}\n\nconst powmod = (a, b, mod) => {\n  let r = 1n\n  while (b > 0n) {\n    if (b % 2n == 1) r = (r * a) % mod\n    b >>= 1n\n    a = (a * a) % mod\n  }\n  return r\n}\n"
    }
  },
  {
    "name": "1815-maximum-number-of-groups-getting-fresh-donuts",
    "code": {
      "JS": "/**\n * @param {number} batchSize\n * @param {number[]} groups\n * @return {number}\n */\nconst maxHappyGroups = function (batchSize, groups) {\n  const arr = new Array(batchSize + 1).fill(0)\n  let result = 0\n  // reduce group to groups of size  group%n\n  for (let gSize of groups) {\n    arr[gSize % batchSize]++\n  }\n\n  // Only need 1 step\n  result += arr[0]\n  arr[0] = 0\n\n  // Only need 2 step\n  for (let i = 1; i < batchSize / 2; i++) {\n    let min = Math.min(arr[i], arr[batchSize - i])\n    arr[i] -= min\n    arr[batchSize - i] -= min\n    result += min\n  }\n  result += dfs(arr, 0, new Map())\n  return result\n}\n\nfunction dfs(arr, remain, cache) {\n  let n = arr.length - 1\n  const key = arr.join(',')\n  if (cache.has(key)) return cache.get(key)\n  let result = 0\n  // greedy and short cut when we can finish the current round\n  if (remain > 0 && arr[n - remain] > 0) {\n    arr[n - remain]--\n    result = dfs(arr, 0, cache)\n    arr[n - remain]++\n  } else {\n    for (let i = 1; i < arr.length; i++) {\n      if (arr[i] > 0) {\n        arr[i]--\n        result = Math.max(\n          result,\n          dfs(arr, (remain + i) % n, cache) + (remain == 0 ? 1 : 0)\n        )\n        arr[i]++\n      }\n    }\n  }\n  cache.set(key, result)\n  return result\n}\n"
    }
  },
  {
    "name": "1816-truncate-sentence",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {number} k\n * @return {string}\n */\nconst truncateSentence = function(s, k) {\n  const arr = s.split(' ')\n  const sli = arr.slice(0, k)\n  return sli.join(' ')\n};\n"
    }
  },
  {
    "name": "1817-finding-the-users-active-minutes",
    "code": {
      "JS": "/**\n * @param {number[][]} logs\n * @param {number} k\n * @return {number[]}\n */\nconst findingUsersActiveMinutes = function(logs, k) {\n  const hash = {}, map = {}\n  logs.forEach(l => {\n    const [id, mi] = l\n    if(hash[mi] == null) hash[mi] = new Set()\n    if(map[id] == null) map[id] = new Set()\n    hash[mi].add(id)\n    map[id].add(mi)\n  })\n\n  const res = Array(k).fill(0)\n  Object.keys(map).forEach(k => {\n     const num = map[k].size\n     res[num - 1]++\n  })\n  \n  return res\n  \n};\n"
    }
  },
  {
    "name": "1818-minimum-absolute-sum-difference",
    "code": {
      "JS": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nconst minAbsoluteSumDiff = function (A, B) {\n  const mod = 10 ** 9 + 7\n  const sA = [...A].sort((a, b) => a - b)\n  let res = 0\n  let gain = 0\n\n  for (let i = 0; i < A.length; i++) {\n    const delta = Math.abs(A[i] - B[i])\n    res += delta\n    // if delta <= gain, delta - newDelta is not possbile to be better than gain\n    if (delta <= gain) continue\n    // Find closest to B[i] in A\n    const idx = binaryS(sA, B[i])\n    // Double check l, l + 1, l - 1\n    const newDelta = Math.min(\n      Math.abs(sA[idx] - B[i]),\n      idx >= 1 ? Math.abs(sA[idx - 1] - B[i]) : Infinity,\n      idx + 1 < A.length ? Math.abs(sA[idx + 1] - B[i]) : Infinity\n    )\n    gain = Math.max(gain, delta - newDelta)\n  }\n  return (res - gain) % mod\n}\nfunction binaryS(A, b) {\n  let [l, r] = [0, A.length - 1]\n  while (l < r) {\n    const mid = l + ((r - l) >> 1)\n    const midV = A[mid]\n    if (midV === b) return mid\n    if (midV < b) l = mid + 1\n    else r = mid - 1\n  }\n  return l\n}\n"
    }
  },
  {
    "name": "1819-number-of-different-subsequences-gcds",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst countDifferentSubsequenceGCDs = function(nums) {\n    const MAX = 2e5 + 1;\n     const cnt = Array(MAX).fill(0)\n    for (let x of nums) cnt[x] = true;\n    let ret = 0;\n    for (let x=1; x<MAX; x++) {\n        let g = 0;\n        for (let y=x; y<MAX; y+=x) {\n            if (cnt[y]) g = gcd(g, y);\n        }\n        if (g == x) ret++;\n    }\n    return ret;\n};\n\nfunction gcd(x,y){\n    if(y === 0) return x\n    return gcd(y, x % y)\n}\n\n\n"
    }
  },
  {
    "name": "1822-sign-of-the-product-of-an-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst arraySign = function(nums) {\n  let pos = 0, neg = 0, zero = 0\n  for(let e of nums) {\n    if(e > 0) pos++\n    else if(e < 0) neg++\n    else zero++\n  }\n  if(zero > 0) return 0\n  if(neg % 2 === 1) return -1\n  else return 1\n};\n"
    }
  },
  {
    "name": "1823-find-the-winner-of-the-circular-game",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number} k\n * @return {number}\n */\nconst findTheWinner = function(n, k) {\n  const arr = Array(n).fill(0)\n  for(let i = 0; i < n; i++) arr[i] = i + 1\n  let idx = 0\n  while(arr.length > 1) {\n    idx = (idx + k - 1) % arr.length\n    arr.splice(idx, 1)\n  }\n  return arr.length ? arr[0] : -1\n};\n\n"
    }
  },
  {
    "name": "1824-minimum-sideway-jumps",
    "code": {
      "JS": "/**\n * @param {number[]} obstacles\n * @return {number}\n */\nconst minSideJumps = function(obstacles) {\n  const n = obstacles.length\n  const { max, min } = Math\n    const dp = [10000000, 1, 0, 1];\n    for (let i of obstacles) {\n        dp[i] = dp[0];\n        for (let j = 1; j <= 3; ++j)\n            if (i !== j)\n                dp[j] = min(dp[1] + (j != 1 ? 1 : 0), dp[2] + (j != 2 ? 1 : 0), dp[3] + (j != 3 ? 1 : 0));\n    }\n    return min(dp[1], dp[2], dp[3]);\n};\n\n"
    }
  },
  {
    "name": "1827-minimum-operations-to-make-the-array-increasing",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst minOperations = function(nums) {\n  let res = 0\n  let pre = nums[0]\n  for(let i = 1, n = nums.length; i < n; i++) {\n    const e = nums[i]\n    if(e <= pre) {\n      res += pre - e + 1\n      pre++\n    } else {\n      pre = e\n    }\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1830-minimum-number-of-operations-to-make-string-sorted",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst makeStringSorted = function (s) {\n  const mod = BigInt(10 ** 9 + 7),\n    n = s.length\n  const a = 'a'.charCodeAt(0)\n  let ans = 0n\n  const freq = Array(26).fill(0n)\n  for (let c of s) {\n    freq[c.charCodeAt(0) - a]++\n  }\n  const fact = Array(n + 1).fill(1n)\n  for (let i = 1n; i <= n; i++) {\n    fact[i] = (fact[i - 1n] * i) % mod\n  }\n  let l = n\n  for (let c of s) {\n    l--\n    let t = 0n,\n      rev = 1n\n    for (let i = 0; i < 26; i++) {\n      if (i < c.charCodeAt(0) - a) t += freq[i]\n      rev = (rev * fact[freq[i]]) % mod\n    }\n    ans += ((t * fact[l]) % mod) * modpow(rev, mod - 2n)\n    ans %= mod\n    freq[c.charCodeAt(0) - a]--\n  }\n  return Number(ans)\n  function modpow(b, p) {\n    let ans = 1n\n    for (; p; p >>= 1n) {\n      if (p & 1n) ans = (ans * b) % mod\n      b = (b * b) % mod\n    }\n    return ans\n  }\n}\n"
    }
  },
  {
    "name": "1832-check-if-the-sentence-is-pangram",
    "code": {
      "JS": "/**\n * @param {string} sentence\n * @return {boolean}\n */\nconst checkIfPangram = function(sentence) {\n  const hash = new Map()\n  for(let ch of sentence) {\n    if(!hash.has(ch)) hash.set(ch, 0)\n    hash.set(ch, hash.get(ch) + 1)\n  }\n  return hash.size >= 26\n};\n"
    }
  },
  {
    "name": "1833-maximum-ice-cream-bars",
    "code": {
      "JS": "/**\n * @param {number[]} costs\n * @param {number} coins\n * @return {number}\n */\nconst maxIceCream = function(costs, coins) {\n  costs.sort((a, b) => a - b)\n  let res = 0, idx = 0\n  while(coins >= costs[idx]) {\n    res++\n    coins -= costs[idx++]\n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "1834-single-threaded-cpu",
    "code": {
      "JS": "/**\n * @param {number[][]} tasks\n * @return {number[]}\n */\nconst getOrder = function(tasks) {\n  const pq = new PriorityQueue(compare), n = tasks.length\n  const res = []\n  let time = 0, i = 0\n  for(let i = 0; i < n; i++) tasks[i].push(i)\n  tasks.sort((a, b) => a[0] - b[0])\n  \n  time = tasks[0][0]\n  while(i < n || !pq.isEmpty()) {\n    while ((i < n) && (tasks[i][0] <= time)) {\n      pq.push([tasks[i][1], tasks[i][2]])\n      i++\n    }\n    if(!pq.isEmpty()) {\n      const [dur, idx] = pq.pop()\n      time += dur\n      res.push(idx)\n    } else if(i < n) {\n      time = tasks[i][0]\n    }\n\n  }\n\n  return res\n};\n\nfunction compare(a, b) {\n  if(a[0] < b[0]) return true\n  else if (a[0] > b[0]) return false\n  else {\n    return a[1] < b[1]\n  }\n}\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n\n\n// another\n\n/**\n * @param {number[][]} tasks\n * @return {number[]}\n */\nconst getOrder = function(tasks) {\n  const pq = new PriorityQueue(compare), n = tasks.length\n  const res = []\n  let time = 0, i = 0\n  for(let i = 0; i < n; i++) tasks[i].push(i)\n  tasks.sort((a, b) => a[0] - b[0])\n  \n  while(i < n || !pq.isEmpty()) {\n    if(pq.isEmpty()) {\n      time = Math.max(time, tasks[i][0])\n    }\n    while(i < n && time >= tasks[i][0]) {\n      pq.push([tasks[i][1], tasks[i][2]])\n      i++\n    }\n    const [dur, idx] = pq.pop()\n    time += dur\n    res.push(idx)\n  }\n\n  return res\n};\n\nfunction compare(a, b) {\n  if(a[0] < b[0]) return true\n  else if (a[0] > b[0]) return false\n  else {\n    return a[1] < b[1]\n  }\n}\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n\n// another\n/**\n * @param {number[][]} tasks\n * @return {number[]}\n */\nconst getOrder = function(tasks) {\n  const n = tasks.length\n  const pq = new PriorityQueue((a, b) => a[0] === b[0] ? a[1] < b[1] : a[0] < b[0])\n  tasks.forEach((e, i) => e.push(i))\n  tasks.sort((a, b) => a[0] - b[0])\n  let idx = 0, time = 0\n  const res = []\n\n  while(idx < n || !pq.isEmpty()) {\n    while(idx < n && tasks[idx][0] <= time) {\n      pq.push([tasks[idx][1], task[idx][2]])\n      idx++\n    }\n    if(!pq.isEmpty()) {\n      const tmp = pq.pop()\n      time += tmp[0]\n      res.push(tmp[1])\n    } else if(idx < n) {\n      time = tasks[idx][0]\n    }\n  }\n  return res\n\n};\n\n// another\n\n/**\n * @param {number[][]} tasks\n * @return {number[]}\n */\nconst getOrder = function (tasks) {\n  tasks = tasks.map((e, idx) => [e[0], e[1], idx])\n  tasks.sort((a, b) => a[0] - b[0])\n  const pq = new PriorityQueue(compare)\n  const res = []\n  let i = 0,\n    t = 0\n  while (i < tasks.length) {\n    while (i < tasks.length && tasks[i][0] <= t) {\n      let [ent, pt, ind] = tasks[i]\n      i += 1\n      pq.push([pt, ind])\n    }\n    if (pq.size() == 0) {\n      if (i < tasks.length) t = tasks[i][0]\n      continue\n    }\n    let [pt, ind] = pq.pop()\n    res.push(ind)\n    t += pt\n  }\n  while (pq.size()) {\n    let [pt, index] = pq.pop()\n    res.push(index)\n  }\n  return res\n}\n\nfunction compare(a, b) {\n  if (a[0] < b[0]) return true\n  else if (a[0] > b[0]) return false\n  else {\n    return a[1] < b[1]\n  }\n}\n\n"
    }
  },
  {
    "name": "1835-find-xor-sum-of-all-pairs-bitwise-and",
    "code": {
      "JS": "// On every bit XOR acts as modulo 2 addition and AND acts as modulo 2 multiplication.\n// The set {0,1} with modulo 2 addition and multiplication is the field GF(2) and the distributive property holds in every field.\n\n/**\n * @param {number[]} arr1\n * @param {number[]} arr2\n * @return {number}\n */\nconst getXORSum = function(arr1, arr2) {\n  const bits = Array(32).fill(0)\n  for (let v of arr2) {\n      let pos = 0;\n      while (v > 0) {\n        if (v & 1) {\n          bits[pos]++;\n        }\n        v = v >> 1;\n        pos++;\n      }\n    }\n\n    let res = 0;\n\n    for (let v of arr1) {\n      let pos = 0;\n      let tmp = 0;\n      while (v > 0) {\n        if (v & 1) {\n          if (bits[pos] % 2 == 1) {\n            tmp |= (1 << pos);\n          }\n        }\n        v = v >> 1;\n        pos++;\n      }\n\n      res ^= tmp;\n    }\n\n    return res;\n};\n\n// another\n\n/**\n * @param {number[]} arr1\n * @param {number[]} arr2\n * @return {number}\n */\nconst getXORSum = function(arr1, arr2) {\n  let x1 = arr1[0], x2 = arr2[0]\n  for(let i = 1; i < arr1.length; i++) x1 ^= arr1[i]\n  for(let i = 1; i < arr2.length; i++) x2 ^= arr2[i]\n  return x1 & x2\n};\n"
    }
  },
  {
    "name": "1837-sum-of-digits-in-base-k",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number} k\n * @return {number}\n */\nconst sumBase = function(n, k) {\n  let str = n.toString(k)\n  let res = 0\n  for(let ch of str) res += +ch\n  \n  return res\n};\n"
    }
  },
  {
    "name": "1838-frequency-of-the-most-frequent-element",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nconst maxFrequency = function(nums, k) {\n  let res = 1, i = 0, j = 0, sum = 0\n  const n = nums.length\n  nums.sort((a, b) => a - b)\n  for(j = 0; j < n; j++) {\n    sum += nums[j]\n    while(sum + k < (j - i + 1)  * nums[j]) {\n      sum -= nums[i]\n      i++\n    }\n    res = Math.max(res, j - i + 1)\n  } \n  return res\n};\n\n// another\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nconst maxFrequency = function(nums, k) {\n  nums.sort((a, b) => a - b)\n  let i = 0, sum = 0, res = 1\n  for(let j = 0; j < nums.length; j++) {\n    sum += nums[j]\n    while(sum + k < (j - i + 1) * nums[j]) {\n      sum -= nums[i]\n      i++\n    }\n    res = Math.max(res, j - i + 1)\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1839-longest-substring-of-all-vowels-in-order",
    "code": {
      "JS": "/**\n * @param {string} word\n * @return {number}\n */\nfunction longestBeautifulSubstring(word) {\n  let res = 0, cur = 'a', cnt = 0\n  const set = new Set()\n  for(let ch of word) {\n    if(ch < cur) {\n      set.clear()\n      cnt = 0\n      cur = 'a'\n      if(ch === cur) {\n        cnt++\n        set.add(cur)\n      }\n    } else {\n      cnt++\n      set.add(ch)\n      cur = ch\n      if(set.size === 5) res = Math.max(res, cnt)\n    }\n  }\n  return res\n}\n\n// another\n\n/**\n * @param {string} word\n * @return {number}\n */\nfunction longestBeautifulSubstring(word) {\n  let res = 0, cur = 'a', cnt = 0\n  const set = new Set()\n  for (let ch of word) {\n    if (ch >= cur) {\n      cnt++\n      cur = ch\n      set.add(ch)\n    } else {\n      set.clear()\n      cnt = 0\n      cur = 'a'\n      if(ch === cur) {\n        set.add(ch)\n        cnt++\n      }\n    }\n    if (set.size === 5) {\n      res = Math.max(res, cnt)\n    }\n  }\n\n  return res\n}\n\n// another\n\n/**\n * @param {string} word\n * @return {number}\n */\nfunction longestBeautifulSubstring(word) {\n  let result = 0,\n    current = 0\n  let currentVowel = \"a\"\n  const set = new Set()\n  for (let i = 0; i < word.length; i++)\n    if (word.charAt(i) < currentVowel) {\n      set.clear()\n      if (word.charAt(i) == \"a\") {\n        set.add(\"a\")\n        current = 1\n      } else current = 0\n      currentVowel = \"a\"\n    } else {\n      current++\n      currentVowel = word.charAt(i)\n      set.add(currentVowel)\n      if (set.size == 5) result = Math.max(result, current)\n    }\n  return result\n}\n"
    }
  },
  {
    "name": "1840-maximum-building-height",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[][]} restrictions\n * @return {number}\n */\nvar maxBuilding = function (n, restrictions) {\n  restrictions.sort((a, b) => a[0] - b[0]);\n  let prevInd = 1,\n    prevH = 0;\n  for (let i = 0; i < restrictions.length; i++) {\n    restrictions[i][1] = Math.min(\n      restrictions[i][1],\n      prevH + (restrictions[i][0] - prevInd)\n    );\n    prevInd = restrictions[i][0];\n    prevH = restrictions[i][1];\n  }\n\n  for (let i = restrictions.length - 2; i >= 0; i--) {\n    restrictions[i][1] = Math.min(\n      restrictions[i][1],\n      restrictions[i + 1][1] + (restrictions[i + 1][0] - restrictions[i][0])\n    );\n  }\n\n  let ph = 0,\n    pInd = 1,\n    highest = 0;\n  for (let i = 0; i < restrictions.length; i++) {\n    let ind = restrictions[i][0];\n    let h = restrictions[i][1];\n    if (ph < h) {\n      h = Math.min(h, ph + (ind - pInd));\n\n      let remains = Math.max(0, ind - pInd - (h - ph));\n      highest = Math.max(highest, h + ~~(remains / 2));\n    } else {\n      let remains = ind - pInd - (ph - h);\n      highest = Math.max(highest, ph + ~~(remains / 2));\n    }\n    ph = h;\n    pInd = ind;\n  }\n  highest = Math.max(highest, ph + (n - pInd));\n  return highest;\n};\n"
    }
  },
  {
    "name": "1844-replace-all-digits-with-characters",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {string}\n */\nconst replaceDigits = function(s) {\n  let arr = s.split('')\n  for(let i = 1; i < s.length; i += 2) {\n    arr[i] = shift(s[i - 1], +s[i])\n  }\n\n  return arr.join('')\n\n  function shift(ch, x) {\n    return String.fromCharCode(ch.charCodeAt(0) + x)\n  }\n};\n"
    }
  },
  {
    "name": "1846-maximum-element-after-decreasing-and-rearranging",
    "code": {
      "JS": "/**\n * @param {number[]} arr\n * @return {number}\n */\nconst maximumElementAfterDecrementingAndRearranging = function(arr) {\n    arr.sort((a, b) => a - b);\n    arr[0] = 1;\n    for(let i = 1; i < arr.length; i++) {\n        if(arr[i] <= arr[i - 1] + 1) continue;\n        arr[i] = arr[i - 1] + 1;\n    }\n    return arr[arr.length - 1];\n};\n"
    }
  },
  {
    "name": "1847-closest-room",
    "code": {
      "JS": "\n/**\n * @param {number[][]} rooms\n * @param {number[][]} queries\n * @return {number[]}\n */\n const closestRoom = function (rooms, queries) {\n  rooms.sort((a, b) => b[1] - a[1])\n  const n = queries.length\n  const minSize = Array(n).fill(0).map((_, i) => i)\n    .sort((a, b) => queries[b][1] - queries[a][1])\n\n  const res = new Array(queries.length).fill(-1)\n  const bst = new BinarySearchTree()\n  let currentRoom = 0\n\n  minSize.forEach((query) => {\n    const [preferredRoom, minimumSize] = queries[query]\n    if (rooms[0][1] < minimumSize) return\n\n    while (currentRoom < rooms.length && rooms[currentRoom][1] >= minimumSize) {\n      bst.add(rooms[currentRoom][0])\n      currentRoom++\n    }\n\n    res[query] = bst.search(preferredRoom)\n  })\n\n  return res\n}\n\nclass BinarySearchTree {\n  constructor() {\n    this.root = null\n  }\n\n  add(val) {\n    this.root = this.insert(this.root, val)\n  }\n\n  insert(node, val) {\n    if (!node) return new TreeNode(val)\n    if (node.val < val) {\n      node.right = this.insert(node.right, val)\n    } else {\n      node.left = this.insert(node.left, val)\n    }\n    return node\n  }\n\n  search(val, node = this.root) {\n    if (node.val === val) return val\n    const currentDistance = Math.abs(node.val - val)\n    const nextChild = node.val < val ? node.right : node.left\n    if (!nextChild) return node.val\n    const closestChild = this.search(val, nextChild)\n    const childDistance = Math.abs(closestChild - val)\n    if (childDistance < currentDistance) return closestChild\n    if (childDistance === currentDistance)\n      return Math.min(closestChild, node.val)\n    return node.val\n  }\n}\n\nclass TreeNode {\n  constructor(val) {\n    this.val = val\n    this.left = null\n    this.right = null\n  }\n}\n"
    }
  },
  {
    "name": "1848-minimum-distance-to-the-target-element",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} target\n * @param {number} start\n * @return {number}\n */\nconst getMinDistance = function(nums, target, start) {\n  let min = Infinity, res = -1\n  for(let i = 0; i < nums.length; i++) {\n    if(nums[i] === target) {\n      if(min > Math.abs(i - start)) {\n        res = i\n        min = Math.abs(i - start)\n      }\n    }\n  }\n  \n  return min\n  \n};\n"
    }
  },
  {
    "name": "1849-splitting-a-string-into-descending-consecutive-values",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {boolean}\n */\nconst splitString = function(s) {\n  return helper(s, null)\n};\n\nfunction helper(str, previous) {\n  for(let i = 0, n = str.length; i < n; i++) {\n    const tmp = +(str.slice(0, i + 1))\n    if(previous == null) {\n      if(helper(str.slice(i + 1), tmp)) return true\n    } else if(previous - tmp === 1 && (i === n - 1 || helper(str.slice(i + 1), tmp))) return true\n  }\n  \n  return false\n}\n\n\n// another\n\n\n/**\n * @param {string} s\n * @return {boolean}\n */\nconst splitString = function(s) {\n  return dfs(s, 0, [Infinity])\n};\n\nfunction dfs(str, idx, arr) {\n  if(idx >= str.length && arr.length > 2) return true\n  for(let i = idx; i < str.length; i++) {\n    const tmp = str.slice(idx, i + 1)\n    const num = parseInt(tmp, 10)\n    const pre = arr[arr.length - 1]\n    if(num < pre && (pre === Infinity || pre - num === 1)) {\n      arr.push(num)\n      if(dfs(str, i + 1, arr)) return true      \n      arr.pop()\n    }\n  }\n  return false\n}\n"
    }
  },
  {
    "name": "1850-minimum-adjacent-swaps-to-reach-the-kth-smallest-number",
    "code": {
      "JS": "/**\n * @param {string} num\n * @param {number} k\n * @return {number}\n */\n const getMinSwaps = function (num, k) {\n  const temp = num.split('')\n  for (let i = 0; i < k; i++) nextPermutation(temp)\n  return count(num.split(''), temp, temp.length)\n}\n\nfunction nextPermutation(a) {\n  let i = a.length - 2\n  //Find the first element which isn't in increasing order fom behind\n  while (i >= 0 && a[i] >= a[i + 1]) i--\n  //If we found an element\n  if (i >= 0) {\n    // Find the rightmost element such that a[j] > a[i]\n    const j = bSearch(a, i + 1, a.length - 1, a[i])\n    // swap a[i] and a[j]\n    a[i] = a[i] ^ a[j] ^ (a[j] = a[i])\n  }\n  //reverse array from i + 1 till end\n  reverse(a, i + 1, a.length - 1)\n}\n\nfunction bSearch(a, i, j, key) {\n  while (i <= j) {\n    const mid = (i + j) >>> 1\n    if (key < a[mid]) i = mid + 1\n    else j = mid - 1\n  }\n  return i - 1\n}\n\nfunction reverse(a, i, j) {\n  while (i < j) a[i] = a[i] ^ a[j] ^ (a[j--] = a[i++])\n}\n\nfunction count(s1, s2, n) {\n  let i = 0,\n    j = 0,\n    res = 0\n\n  while (i < n) {\n    j = i\n    while (s1[j] != s2[i]) j++\n    while (i < j) {\n      const temp = s1[j]\n      s1[j] = s1[j - 1]\n      s1[j-- - 1] = temp\n      ++res\n    }\n    ++i\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "1851-minimum-interval-to-include-each-query",
    "code": {
      "JS": "/**\n * @param {number[][]} intervals\n * @param {number[]} queries\n * @return {number[]}\n */\nconst minInterval = function (intervals, queries) {\n  const n = intervals.length\n  const m = queries.length\n  const sortedQueryIdx = [...Array(m).keys()].sort(\n    (a, b) => queries[a] - queries[b]\n  )\n  intervals.sort((a, b) => a[0] - b[0]) // sort by start & ascending\n  const minHeap = new BinaryHeap((c, p) => c.size >= p.size)\n  const res = Array(m).fill(0)\n  let i = 0\n  for (const idx of sortedQueryIdx) {\n    const query = queries[idx]\n    while (i < n && intervals[i][0] <= query) {\n      minHeap.push({\n        size: intervals[i][1] - intervals[i][0] + 1,\n        start: intervals[i][0],\n        end: intervals[i][1],\n      })\n      i++\n    }\n    while (!minHeap.isEmpty() && minHeap.peek().end < query) {\n      minHeap.pop()\n    }\n    res[idx] = minHeap.isEmpty() ? -1 : minHeap.peek().size\n  }\n  return res\n}\n\nclass BinaryHeap {\n  /**\n   * @param {compareFunction} compareFn\n   */\n  constructor(compareFn) {\n    this.content = []\n    this.compareFn = compareFn // Min-Heap: (c, p) => c > p\n  }\n\n  /**\n   * @return {number} - Current heap size.\n   */\n  size() {\n    return this.content.length\n  }\n\n  /**\n   * @return {boolean} - True if heap size is empty.\n   */\n  isEmpty() {\n    return this.size() === 0\n  }\n\n  /**\n   * @return {*} - Root node of the heap.\n   */\n  peek() {\n    return this.size() > 0 ? this.content[0] : null\n  }\n\n  /**\n   * @param {*} node - New node to add.\n   */\n  push(node) {\n    this.content.push(node)\n    this._bubbleUp(this.content.length - 1)\n  }\n\n  /**\n   * @return {*} - Root node of the heap.\n   */\n  pop() {\n    if (this.content.length === 0) return null\n    const root = this.content[0]\n    const last = this.content.pop()\n    if (this.content.length > 0) {\n      this.content[0] = last\n      this._sinkDown(0)\n    }\n    return root\n  }\n\n  /**\n   * @param {*} node - Node to delete.\n   */\n  remove(node) {\n    const length = this.content.length\n    for (let i = 0; i < length; i++) {\n      if (this.content[i] !== node) continue\n      const last = this.content.pop()\n      if (i === length - 1) break\n      this.content[i] = last\n      this._bubbleUp(i)\n      this._sinkDown(i)\n      break\n    }\n  }\n\n  /**\n   * @param {number} idx - Index of the node to bubble up\n   */\n  _bubbleUp(idx) {\n    const node = this.content[idx]\n    while (idx > 0) {\n      const parentIdx = Math.floor((idx + 1) / 2) - 1\n      const parent = this.content[parentIdx]\n      if (this.compareFn(node, parent)) break\n      this.content[parentIdx] = node\n      this.content[idx] = parent\n      idx = parentIdx\n    }\n  }\n\n  /**\n   * @param {number} idx - Index of the node to sink down\n   */\n  _sinkDown(idx) {\n    const node = this.content[idx]\n    while (true) {\n      const child2Idx = (idx + 1) * 2\n      const child1Idx = child2Idx - 1\n      let swapIdx = -1\n      if (child1Idx < this.content.length) {\n        const child1 = this.content[child1Idx]\n        if (!this.compareFn(child1, node)) swapIdx = child1Idx\n      }\n      if (child2Idx < this.content.length) {\n        const child2 = this.content[child2Idx]\n        const compareNode = swapIdx === -1 ? node : this.content[child1Idx]\n        if (!this.compareFn(child2, compareNode)) swapIdx = child2Idx\n      }\n      if (swapIdx === -1) break\n      this.content[idx] = this.content[swapIdx]\n      this.content[swapIdx] = node\n      idx = swapIdx\n    }\n  }\n}\n\n\n// another\n\n/**\n * @param {number[][]} intervals\n * @param {number[]} queries\n * @return {number[]}\n */\nconst minInterval = function (A, Q) {\n  const QQ = []\n  for (let idx = 0; idx < Q.length; idx++) QQ.push([Q[idx], idx])\n  QQ.sort((a, b) => a[0] - b[0])\n  A.sort((a, b) => a[0] - b[0])\n  let i = 0,\n    N = A.length\n  const ans = Array(Q.length).fill(-1)\n  const m = new TreeMap()\n  const pq = new PriorityQueue((a, b) => a[0] < b[0])\n  for (let [q, index] of QQ) {\n    for (; i < N && A[i][0] <= q; i++) {\n      let len = A[i][1] - A[i][0] + 1\n      if (m.get(len) == null) m.set(len, 0)\n      m.set(len, m.get(len) + 1)\n      pq.push([A[i][1], len])\n    }\n    while (pq.size() > 0 && pq.peek()[0] < q) {\n      let [right, len] = pq.peek()\n      m.set(len, m.get(len) - 1)\n      if (m.get(len) === 0) m.remove(len)\n      pq.pop()\n    }\n    const first = m.getMinKey()\n    if (m.getLength()) ans[index] = first\n  }\n  return ans\n}\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n\nfunction TreeMap() {\n  var root = null\n  var keyType = void 0\n  var length = 0\n\n  return {\n    each: each,\n    set: set,\n    get: get,\n    getTree: getTree,\n    getLength: getLength,\n    getMaxKey: getMaxKey,\n    getMinKey: getMinKey,\n    remove: remove,\n  }\n\n  function checkKey(key, checkKeyType) {\n    var localKeyType = typeof key\n\n    if (\n      localKeyType !== 'number' &&\n      localKeyType !== 'string' &&\n      localKeyType !== 'boolean'\n    ) {\n      throw new Error(\"'key' must be a number, a string or a boolean\")\n    }\n\n    if (checkKeyType === true && localKeyType !== keyType) {\n      throw new Error('All keys must be of the same type')\n    }\n\n    return localKeyType\n  }\n\n  function call(callback) {\n    var args = Array.prototype.slice.call(arguments, 1)\n\n    if (typeof callback === 'function') {\n      callback.apply(void 0, args)\n    }\n  }\n\n  function getTree() {\n    return root\n  }\n\n  function getLength() {\n    return length\n  }\n\n  function each(callback) {\n    internalEach(root, callback)\n  }\n\n  function internalEach(node, callback, internalCallback) {\n    if (node === null) {\n      return call(internalCallback)\n    }\n\n    internalEach(node.left, callback, function () {\n      call(callback, node.value, node.key)\n\n      internalEach(node.right, callback, function () {\n        call(internalCallback)\n      })\n    })\n  }\n\n  function get(key) {\n    checkKey(key)\n\n    return internalGet(key, root)\n  }\n\n  function internalGet(key, node) {\n    if (node === null) {\n      return void 0\n    }\n\n    if (key < node.key) {\n      return internalGet(key, node.left)\n    } else if (key > node.key) {\n      return internalGet(key, node.right)\n    } else {\n      return node.value\n    }\n  }\n\n  function set(key, value) {\n    if (root === null) {\n      keyType = checkKey(key)\n    } else {\n      checkKey(key, true)\n    }\n\n    root = internalSet(key, value, root)\n  }\n\n  function internalSet(key, value, node) {\n    if (node === null) {\n      length++\n\n      return {\n        key: key,\n        value: value,\n        left: null,\n        right: null,\n      }\n    }\n\n    if (key < node.key) {\n      node.left = internalSet(key, value, node.left)\n    } else if (key > node.key) {\n      node.right = internalSet(key, value, node.right)\n    } else {\n      node.value = value\n    }\n\n    return node\n  }\n\n  function getMaxKey() {\n    var maxNode = getMaxNode(root)\n\n    if (maxNode !== null) {\n      return maxNode.key\n    }\n\n    return maxNode\n  }\n\n  function getMinKey() {\n    var minNode = getMinNode(root)\n\n    if (minNode !== null) {\n      return minNode.key\n    }\n\n    return minNode\n  }\n\n  function getMaxNode(node) {\n    while (node !== null && node.right !== null) {\n      node = node.right\n    }\n\n    return node\n  }\n\n  function getMinNode(node) {\n    while (node !== null && node.left !== null) {\n      node = node.left\n    }\n\n    return node\n  }\n\n  function remove(key) {\n    checkKey(key)\n\n    root = internalRemove(key, root)\n  }\n\n  function internalRemove(key, node) {\n    if (node === null) {\n      return null\n    }\n\n    if (key < node.key) {\n      node.left = internalRemove(key, node.left)\n    } else if (key > node.key) {\n      node.right = internalRemove(key, node.right)\n    } else {\n      if (node.left !== null && node.right !== null) {\n        var maxNode = getMaxNode(node.left)\n\n        var maxNodeKey = maxNode.key\n        var maxNodeValue = maxNode.value\n\n        maxNode.key = node.key\n        maxNode.value = node.value\n        node.key = maxNodeKey\n        node.value = maxNodeValue\n\n        node.left = internalRemove(key, node.left)\n      } else if (node.left !== null) {\n        length--\n        return node.left\n      } else if (node.right !== null) {\n        length--\n        return node.right\n      } else {\n        length--\n        return null\n      }\n    }\n\n    return node\n  }\n}\n"
    }
  },
  {
    "name": "1854-maximum-population-year",
    "code": {
      "JS": "/**\n * @param {number[][]} logs\n * @return {number}\n */\nconst maximumPopulation = function(logs) {\n  const n = logs.length\n  const arr = Array(101).fill(0)\n  const base = 1950\n  for(let log of logs) {\n    const [start, end] = log\n    arr[start - base]++\n    arr[end - base]--\n  }\n  \n  let res = 0, tmp = -Infinity\n  for(let i = 1; i < 101; i++) {\n    arr[i] += arr[i - 1]\n  }\n  for(let i = 0; i < 101; i++) {\n    if(arr[i] > tmp) {\n      res = i\n      tmp = arr[i]\n    }\n  }\n  return res + base\n};\n\n\n// another\n\n/**\n * @param {number[][]} logs\n * @return {number}\n */\nconst maximumPopulation = function(logs) {\n  logs.sort((a, b) => {\n    if(a[0] === b[0]) return a[1] - b[1]\n    return a[0] - b[0]\n  })\n  const arr = Array(101).fill(0)\n  const bit = new FenwickTree(101)\n  for(let i = 0, len = logs.length; i < len; i++) {\n    const [start, end] = logs[i]\n    const idx = start - 1950\n    bit.update(idx + 1, 1)\n  }\n  for(let i = 0, len = logs.length; i < len; i++) {\n    const [start, end] = logs[i]\n    const idx = end - 1950\n    bit.update(idx + 1, -1)\n  }\n  let max = 0\n  for(let i = 1; i <= 101; i++) {\n    max = Math.max(max, bit.query(i))\n  }\n  let tmp\n  for(let i = 1; i <= 101; i++) {\n    if(bit.query(i) === max) {\n      tmp = i\n      break\n    }\n  }\n  \n  return 1950 + tmp - 1\n};\n\nconst lowBit = (x) => x & -x\nclass FenwickTree {\n  constructor(n) {\n    if (n < 1) return\n    this.sum = Array(n + 1).fill(0)\n  }\n  update(i, delta) {\n    if (i < 1) return\n    while (i < this.sum.length) {\n      this.sum[i] += delta\n      i += lowBit(i)\n    }\n  }\n  query(i) {\n    if (i < 1) return\n    let sum = 0\n    while (i > 0) {\n      sum += this.sum[i]\n      i -= lowBit(i)\n    }\n    return sum\n  }\n}\n"
    }
  },
  {
    "name": "1855-maximum-distance-between-a-pair-of-values",
    "code": {
      "JS": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nconst maxDistance = function(nums1, nums2) {\n  let res = 0\n  const m = nums1.length, n = nums2.length\n  for(let i = 0; i < m; i++) {\n    const idx = bSearch(nums2, i, n - 1, nums1[i])\n    res = Math.max(res, idx - i)\n  }\n  return res\n};\n\nfunction bSearch(a, i, j, key) {\n  while (i <= j) {\n    let mid = (i + j) >>> 1\n    if (key <= a[mid]) i = mid + 1\n    else if(key > a[mid]) j = mid - 1\n  }\n  return i - 1\n}\n"
    }
  },
  {
    "name": "1856-maximum-subarray-min-product",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst maxSumMinProduct = function (nums) {\n  const n = nums.length\n  const mod = BigInt(10 ** 9 + 7)\n  const preSum = Array(n + 1).fill(0n)\n  for (let i = 0; i < n; i++) {\n    preSum[i + 1] = preSum[i] + BigInt(nums[i])\n  }\n  const l = Array(n).fill(0) // l[i] stores index of farthest element greater or equal to nums[i]\n  const r = Array(n).fill(0) // r[i] stores index of farthest element greater or equal to nums[i]\n  let st = []\n\n  for (let i = 0; i < n; i++) {\n    while (st.length && nums[st[st.length - 1]] >= nums[i]) st.pop()\n    if (st.length) l[i] = st[st.length - 1] + 1\n    else l[i] = 0\n    st.push(i)\n  }\n  \n  st = []\n  for (let i = n - 1; i >= 0; i--) {\n    while (st.length && nums[st[st.length - 1]] >= nums[i]) st.pop()\n    if (st.length) r[i] = st[st.length - 1] - 1\n    else r[i] = n - 1\n    st.push(i)\n  }\n  function getSum(left, right) {\n    // inclusive\n    return preSum[right + 1] - preSum[left]\n  }\n\n  let maxProduct = 0n\n  for (let i = 0; i < n; i++) {\n    maxProduct = bigint_max(maxProduct, BigInt(nums[i]) * getSum(l[i], r[i]))\n  }\n  return maxProduct % mod\n}\nfunction bigint_max(...args){\n    if (args.length < 1){ throw 'Max of empty list'; }\n    m = args[0];\n    args.forEach(a=>{if (a > m) {m = a}});\n    return m;\n}\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst maxSumMinProduct = function(nums) {\n  const n = nums.length, s1 = [], s2 = [],\n    left = Array(n), right = Array(n), mod = BigInt(1e9 + 7)\n  for(let i = 0; i < n; i++) {\n    while(s1.length && nums[s1[s1.length - 1]] >= nums[i]) s1.pop()\n    if(s1.length) left[i] = s1[s1.length - 1] + 1\n    else left[i] = 0\n    s1.push(i)\n  }\n  \n  for(let i = n - 1; i >= 0; i--) {\n    while(s2.length && nums[s2[s2.length - 1]] >= nums[i]) s2.pop()\n    if(s2.length) right[i] = s2[s2.length - 1] - 1\n    else right[i] = n - 1\n    s2.push(i)\n  }\n  \n  const preSum = Array(n)\n  for(let i = 0; i < n; i++) {\n    preSum[i] = (i === 0 ? 0n : preSum[i - 1]) + BigInt(nums[i])\n  }\n  let res = 0n\n  for(let i = 0; i < n; i++) {\n    res = max(res, getSum(preSum, left[i], right[i]) * BigInt(nums[i]))\n  }\n  return res % mod\n  \n};\n\nfunction getSum(arr, l, r) {\n  return arr[r] - (l === 0 ? 0n : arr[l - 1])\n}\n\nfunction max(...args) {\n  let res = -Infinity\n  for(let e of args) {\n    if(e > res) res = e\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "1857-largest-color-value-in-a-directed-graph",
    "code": {
      "JS": "/**\n * @param {string} colors\n * @param {number[][]} edges\n * @return {number}\n */\n const largestPathValue = function(colors, edges) {\n  const graph = {}, n = colors.length, a = 'a'.charCodeAt(0)\n  const indegree = Array(n).fill(0)\n  for (const [from, to] of edges) {\n    if (graph[from] == null) graph[from] = []\n    graph[from].push(to)\n    indegree[to]++\n  }\n  const cnt = Array.from({ length: n }, () => Array(26).fill(0))\n  const code = idx => colors.charCodeAt(idx) - a\n  const q = []\n  for (let i = 0; i < n; i++) {\n    if(indegree[i] === 0) {\n      q.push(i)\n      cnt[i][code(i)] = 1\n    }\n  }\n  let res = 0, seen = 0\n\n  while(q.length) {\n    const u = q.pop()\n    const val = cnt[u][code(u)]\n    res = Math.max(res, val)\n    seen++\n    for(const next of (graph[u] || [])) {\n      for(let i = 0; i < 26; i++) {\n        cnt[next][i] = Math.max(cnt[next][i], cnt[u][i] + (i === code(next) ? 1 : 0))\n      }\n      if(--indegree[next] === 0) {\n        q.push(next)\n      }\n    }\n  }\n  return seen < n ? -1 : res\n};\n\n// another\n\n\n/**\n * @param {string} colors\n * @param {number[][]} edges\n * @return {number}\n */\nconst largestPathValue = function (colors, edges) {\n  const graph = {}\n  const n = colors.length,\n    a = 'a'.charCodeAt(0)\n  const indegree = Array(colors.length).fill(0)\n  for (let e of edges) {\n    if (graph[e[0]] == null) graph[e[0]] = []\n    graph[e[0]].push(e[1])\n    indegree[e[1]]++\n  }\n  const cnt = Array.from({ length: n }, () => Array(26).fill(0))\n  const q = []\n  for (let i = 0; i < n; i++) {\n    if (indegree[i] === 0) {\n      q.push(i)\n      cnt[i][colors.charCodeAt(i) - a] = 1\n    }\n  }\n  let res = 0,\n    seen = 0\n  while (q.length) {\n    const u = q[0]\n    q.shift()\n    const val = Math.max(...cnt[u])\n    res = Math.max(res, val)\n    seen++\n    if (graph[u] == null) continue\n    for (let v of graph[u]) {\n      for (let i = 0; i < 26; i++) {\n        cnt[v][i] = Math.max(\n          cnt[v][i],\n          cnt[u][i] + (i === colors.charCodeAt(v) - a)\n        )\n      }\n      if (--indegree[v] === 0) q.push(v)\n    }\n  }\n  return seen < colors.length ? -1 : res\n}\n"
    }
  },
  {
    "name": "1859-sorting-the-sentence",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {string}\n */\nconst sortSentence = function(s) {\n  const arr = s.split(' ')\n  const n = arr.length, res = Array(n)\n  for(let e of arr) {\n    const idx = +e[e.length - 1]\n    res[idx - 1] = e.slice(0, e.length - 1)\n  }\n  return res.join(' ')\n};\n"
    }
  },
  {
    "name": "186-reverse-words-in-a-string-ii",
    "code": {
      "JS": "/**\n * @param {character[]} s\n * @return {void} Do not return anything, modify s in-place instead.\n */\nconst reverseWords = function(s) {\n  reverse(s, 0, s.length - 1)\n  for (let i = 0, j = 0; i <= s.length; i++) {\n    if (i == s.length || s[i] == ' ') {\n      reverse(s, j, i - 1)\n      j = i + 1\n    }\n  }\n}\nfunction reverse(s, begin, end) {\n  while (begin < end) {\n    let c = s[begin]\n    s[begin] = s[end]\n    s[end] = c\n    begin++\n    end--\n  }\n}\n"
    }
  },
  {
    "name": "1860-incremental-memory-leak",
    "code": {
      "JS": "/**\n * @param {number} memory1\n * @param {number} memory2\n * @return {number[]}\n */\nconst memLeak = function(memory1, memory2) {\n  let i = 1\n  const res = Array(3).fill(0)\n  res[0] = 1\n  res[1] = memory1\n  res[2] = memory2\n  while(true) {\n    if(res[1] >= i || res[2] >= i) {\n      if(res[1] >= i && res[2] >= i) {\n        if(res[1] === res[2]) {\n           res[1] -= i\n        } else if(res[1] > res[2]) {\n          res[1] -= i\n        } else {\n          res[2] -= i\n        }\n      } else if(res[1] >= i) {\n        res[1] -= i\n      } else if(res[2] >= i){\n        res[2] -= i\n      }\n    } else {\n      res[0] = i\n      return res\n    }\n    \n    i++\n  }\n};\n"
    }
  },
  {
    "name": "1861-rotating-the-box",
    "code": {
      "JS": "/**\n * @param {character[][]} box\n * @return {character[][]}\n */\nconst rotateTheBox = function(box) {\n  const m = box.length, n = box[0].length\n  const res = Array.from({ length: n }, () => Array(m).fill('.'))\n  for(let i = 0; i < m; i++) {\n    for(let j = n - 1, pos = n - 1; j >= 0; j--) {\n      if(box[i][j] === '.') continue\n      if(box[i][j] === '#') {\n        res[pos][m - 1 - i] = '#'\n        pos--\n      } else {\n        res[j][m - 1 - i] = '*'\n        pos = j - 1\n      }\n    }\n  }\n  return res\n};\n\n// another\n\n/**\n * @param {character[][]} box\n * @return {character[][]}\n */\nconst rotateTheBox = function(box) {\n  const m = box.length, n = box[0].length\n  const res = Array.from({ length: n }, () => Array(m).fill('.'))\n  for(let i = 0; i < m; i++) {\n    let j = n - 1\n    let pos = j\n    while(j >= 0) {\n      if(box[i][j] === '*') {\n        pos = j - 1\n      } else if(box[i][j] === '#') {\n        box[i][j] = '.'\n        box[i][pos] = '#'\n        res[pos][m - 1 - i] = '#'\n        pos--\n      }\n      res[j][m - 1 - i] = box[i][j]\n      j--\n    }\n    \n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1862-sum-of-floored-pairs",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst sumOfFlooredPairs = function (nums) {\n  const MAX = Math.max(...nums)\n  const countsGreaterOrEqualTo = new Array(MAX + 1).fill(0)\n  const numCounts = new Map()\n  const MOD = 1e9 + 7\n  nums.forEach((num) => {\n    countsGreaterOrEqualTo[num]++\n    numCounts.set(num, (numCounts.get(num) || 0) + 1)\n  })\n\n  for (let num = MAX - 1; num >= 0; num--) {\n    countsGreaterOrEqualTo[num] += countsGreaterOrEqualTo[num + 1]\n  }\n  \n  let totalCount = 0\n  numCounts.forEach((count, num) => {\n    let current = num\n    while (current <= MAX) {\n      totalCount = (totalCount + countsGreaterOrEqualTo[current] * count) % MOD\n      current += num\n    }\n  })\n\n  return totalCount\n}\n"
    }
  },
  {
    "name": "1863-sum-of-all-subset-xor-totals",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst subsetXORSum = function(nums) {\n  let res = {sum: 0}\n  \n  helper(nums, 0, [], res)\n  return res.sum\n};\n\nfunction helper(arr, idx, cur, res) {\n  if(idx === arr.length) {\n    res.sum += calc(cur)\n    return\n  }\n  const clone = cur.slice()\n  helper(arr, idx + 1, clone, res)\n  const c2 = cur.slice()\n  c2.push(arr[idx])\n  helper(arr, idx + 1, c2, res)\n}\n\nfunction calc(arr) {\n  let res = 0\n  for(let e of arr) res ^= e\n  return res\n}\n"
    }
  },
  {
    "name": "1864-minimum-number-of-swaps-to-make-the-binary-string-alternating",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst minSwaps = function(s) {\n  const valid = chk(s)\n  if(valid === -1) return -1\n  const [zeroNum, oneNum] = valid\n  let res = Infinity\n  if(zeroNum === oneNum) {\n    // zero start\n    let tmpZero = 0\n    let cur = '0'\n    for(let i = 0; i < s.length; i++) {\n      if(i % 2 === 0 && s[i] !== '0') tmpZero++\n    }\n    \n    res = Math.min(tmpZero, res)\n    // one start\n    let tmpOne = 0\n    cur = '1'\n    for(let i = 0; i < s.length; i++) {\n      if(i % 2 === 0 && s[i] !== '1') tmpOne++\n    }\n    res = Math.min(tmpOne, res)\n  } else if(zeroNum > oneNum) {\n    let tmpZero = 0\n    let cur = '0'\n    for(let i = 0; i < s.length; i++) {\n      if(i % 2 === 0 && s[i] !== '0') tmpZero++\n    }\n    \n    res = Math.min(tmpZero, res)     \n  } else {\n    let tmpOne = 0\n    cur = '1'\n    for(let i = 0; i < s.length; i++) {\n      if(i % 2 === 0 && s[i] !== '1') tmpOne++\n    }\n    res = Math.min(tmpOne, res)\n  }\n  return res\n};\n\nfunction chk(str) {\n  let oneNum = 0, zeroNum = 0\n  for(let ch of str) {\n    if(ch === '0') zeroNum++\n    else oneNum++\n  } \n  return Math.abs(zeroNum - oneNum) <= 1 ? [zeroNum, oneNum] : -1\n}\n\n"
    }
  },
  {
    "name": "1865-finding-pairs-with-a-certain-sum",
    "code": {
      "JS": "\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n */\nconst FindSumPairs = function(nums1, nums2) {\n  this.nums1 = nums1\n  this.nums2 = nums2\n  const m = nums1.length, n = nums2.length\n  this.mp = {}\n  for(let x of nums2) {\n    if(this.mp[x] == null) this.mp[x] = 0\n    this.mp[x]++\n  }\n};\n\n/** \n * @param {number} index \n * @param {number} val\n * @return {void}\n */\nFindSumPairs.prototype.add = function(index, val) {\n  if(val !== 0) {\n    if(!(--this.mp[this.nums2[index]])) delete this.mp[this.nums2[index]]    \n  }\n  this.nums2[index] += val\n  if(this.mp[this.nums2[index]] == null) this.mp[this.nums2[index]] = 0\n  if(val !== 0)this.mp[this.nums2[index]]++\n};\n\n/** \n * @param {number} tot\n * @return {number}\n */\nFindSumPairs.prototype.count = function(tot) {\n  let ans = 0;\n  for (let x of this.nums1) {\n    let res = tot - x;\n    if (!this.mp[res]) continue;\n    ans += this.mp[res];\n  }\n  return ans;\n};\n\n/** \n * Your FindSumPairs object will be instantiated and called as such:\n * var obj = new FindSumPairs(nums1, nums2)\n * obj.add(index,val)\n * var param_2 = obj.count(tot)\n */\n"
    }
  },
  {
    "name": "1866-number-of-ways-to-rearrange-sticks-with-k-sticks-visible",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number} k\n * @return {number}\n */\nconst rearrangeSticks = function(n, k) {\n  const mod = BigInt(1e9 + 7)\n  const g = Array.from({ length: 1001 }, () => Array(1001).fill(0n))\n  g[1][1] = 1n\n  for(let i = 2; i <= 1000; i++) {\n    for(let j = 1; j <= i; j++ ) {\n      g[i][j] = (g[i - 1][j - 1] + BigInt(i - 1) * g[i - 1][j] % mod) % mod\n    }\n  }\n  return g[n][k]\n};\n\n// another\n\n/**\n * @param {number} n\n * @param {number} k\n * @return {number}\n */\nconst rearrangeSticks = function(n, k) {\n    const MOD = 1e9 + 7;\n    // first # can be smallest # in which case we recurse for (n - 1, k - 1) \n    // or it can not be and smallest can be in any of n - 1 otehr positions for recursed(n - 1, k)\n    const dp = new Array(n + 1).fill().map( _ => new Array(k + 1).fill(0) );\n    for (let i = 1; i <= n; ++i) {\n        for (let j = 1; j <= k; ++j) {\n            if (j === i) {\n                dp[i][j] = 1;\n            } else if (j < i) {\n                dp[i][j] = (dp[i - 1][j - 1] + (i - 1) * dp[i - 1][j]) % MOD;\n            }\n        }\n    }\n    return dp[n][k] % MOD;\n    \n};\n"
    }
  },
  {
    "name": "1869-longer-contiguous-segments-of-ones-than-zeros",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {boolean}\n */\nconst checkZeroOnes = function(s) {\n  const stack = []\n  let zl = 0, ol = 0\n  for(let e of s) {\n    let tmp = 0, zo = ''\n    while(stack.length && stack[stack.length - 1] !== e) {\n      if(zo === '') zo = stack[stack.length - 1]\n      tmp++\n      stack.pop()\n    }\n    if(zo === '1') ol = Math.max(tmp, ol)\n    if(zo === '0') zl = Math.max(tmp, zl)\n    stack.push(e)\n  } \n  if(stack.length) {\n    let zo = stack[stack.length - 1]\n    if(zo === '1') ol = Math.max(stack.length, ol)\n    if(zo === '0') zl = Math.max(stack.length, zl)\n  }\n  return ol > zl\n};\n"
    }
  },
  {
    "name": "187-repeated-dna-sequences",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {string[]}\n */\nconst findRepeatedDnaSequences = function(s) {\n  if (!s || s.length < 10) {\n    return [];\n  }\n  const map = new Map([[\"A\", 0], [\"C\", 1], [\"G\", 2], [\"T\", 3]]);\n  const dna = new Set();\n  const repeated = new Set();\n  const mask = 0xfffff;\n  let cur = 0;\n  for (let i = 0, n = s.length; i < n; i++) {\n    cur <<= 2;\n    cur = cur | map.get(s[i]);\n    cur = cur & mask;\n    if (i >= 9) {\n      if (dna.has(cur)) {\n        const seq = s.slice(i - 9, i + 1);\n        if (!repeated.has(seq)) {\n          repeated.add(seq);\n        }\n      } else {\n        dna.add(cur);\n      }\n    }\n  }\n  return Array.from(repeated);\n};\n\n// another\n\n/**\n * @param {string} s\n * @return {string[]}\n */\nconst findRepeatedDnaSequences = function(s) {\n    let store = new Set(), result = new Set()\n    for(let i = 0; i < s.length - 9; i++) {\n        const str = s.substring(i, i + 10)\n        if(store.has(str)) {\n            result.add(str)\n        } else {\n            store.add(str)\n        }\n    }\n    return Array.from(result)\n};\n"
    }
  },
  {
    "name": "1870-minimum-speed-to-arrive-on-time",
    "code": {
      "JS": "/**\n * @param {number[]} dist\n * @param {number} hour\n * @return {number}\n */\nconst minSpeedOnTime = function(dist, hour) {\n  let n = dist.length, l = 1, r = 1e7 + 1\n  while(l < r) {\n    const mid = l + ((r - l) >> 1)\n    let time = 0\n    for(let i = 0; i < n - 1; i++) time += Math.ceil(dist[i] / mid)\n    time += dist[dist.length - 1] / mid\n    if(time > hour) l = mid + 1\n    else r = mid\n  }\n  return l > 1e7 ? -1 : l\n};\n\n// another\n\n/**\n * @param {number[]} dist\n * @param {number} hour\n * @return {number}\n */\nconst minSpeedOnTime = function(dist, hour) {\n  let l = 1, r = 1e7\n  while(l <= r) {\n    let mid = (l + r) >> 1\n    if(valid(mid)) r = mid -1\n    else l = mid + 1\n  }\n  return l > 1e7 ? -1 : l\n  \n  function valid(speed) {\n    let sum = 0\n    for(let e of dist) {\n      sum = Math.ceil(sum)\n      sum += e / speed\n      if(sum > hour) return \n    }\n    \n    return true\n  }\n};\n\n// another\n\n/**\n * @param {number[]} dist\n * @param {number} hour\n * @return {number}\n */\nconst minSpeedOnTime = function(dist, hour) {\n  const sum = dist.reduce((ac, e) => ac + e, 0)\n  let l = 1, r = 10 ** 7\n  while(l < r) {\n    let mid = l + ((r - l) >> 1)\n    if(chk(mid)) r = mid\n    else l = mid + 1\n  }\n\n  return chk(l) ? l : -1\n  \n  function chk(speed) {\n    let res = 0\n    for(let i = 0, len = dist.length; i < len - 1; i++) {\n      res += Math.ceil(dist[i] / speed)\n    }\n    if (dist.length) res += dist[dist.length - 1] / speed \n    return res <= hour\n  }\n  \n};\n\n"
    }
  },
  {
    "name": "1871-jump-game-vii",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {number} minJump\n * @param {number} maxJump\n * @return {boolean}\n */\nconst canReach = function(s, minJump, maxJump) {\n  const n = s.length\n  const queue = [0]\n  let mx = 0\n  const { max, min } = Math\n  while(queue.length) {\n    const i = queue.shift()\n    for(let j = max(i + minJump, mx + 1); j < min(s.length, i + maxJump + 1); j++) {\n      if(s[j] === '0') {\n        if(j === n - 1) return true\n        queue.push(j)\n      }\n    }\n    mx = i + maxJump\n  }\n  \n  return false\n};\n\n\n// another\n\n/**\n * @param {string} s\n * @param {number} minJump\n * @param {number} maxJump\n * @return {boolean}\n */\nconst canReach = function(s, minJump, maxJump) {\n  let n = s.length;\n  const {max, min} = Math\n  if (s[n - 1] != '0') return false;\n  const pre_sum = Array(n + 1).fill(0);\n  const check = Array(n + 1).fill(0);\n  check[1] = 1;\n  pre_sum[1] = 1;\n  for (let i = 1; i < n; i++) {\n      pre_sum[i + 1] = pre_sum[i];\n      if (s[i] == '1') continue;\n      if (i < minJump) continue;\n      let r = i - minJump;\n      let l = max(0, i - maxJump);\n      if (pre_sum[r + 1] - pre_sum[l] == 0) continue;\n      check[i + 1] = true;\n      pre_sum[i + 1]++;\n  }\n  return check[n];\n};\n\n// another\n\n/**\n * @param {string} s\n * @param {number} minJump\n * @param {number} maxJump\n * @return {boolean}\n */\nconst canReach = function(s, minJump, maxJump) {\n  const n = s.length, dp = Array(n).fill(0)\n  dp[0] = 1\n  let pre = 0\n  for(let i = 1; i < n; i++) {\n    if(i >= minJump) {\n      pre += dp[i - minJump]\n    }\n    if(i > maxJump) pre -= dp[i - maxJump - 1]\n    dp[i] = pre > 0 && s[i] === '0' ? 1 : 0\n  }\n  return dp[n - 1]\n};\n"
    }
  },
  {
    "name": "1872-stone-game-viii",
    "code": {
      "JS": "/**\n * @param {number[]} stones\n * @return {number}\n */\nconst stoneGameVIII = function (A) {\n  let N = A.length,\n    ans = -Infinity\n  for (let i = 1; i < N; ++i) A[i] += A[i - 1] // now A[i] becomes prefix[i]\n  let mx = A[N - 1] // dp[N - 1] = prefix[N - 1]\n  for (let i = N - 2; i >= 0; --i) {\n    ans = Math.max(ans, mx) // since dp[i] = mx, we try to use dp[i] to update ans.\n    mx = Math.max(mx, A[i] - mx) // try to update mx using prefix[i] - dp[i]\n  }\n  return ans\n}\n"
    }
  },
  {
    "name": "1876-substrings-of-size-three-with-distinct-characters",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\n const countGoodSubstrings = function(s) {\n  let res = 0\n  for(let i = 2; i < s.length; i++) {\n    if(chk(s, i)) res++\n  }\n  \n  return res\n};\n\nfunction chk(s, i) {\n  return s[i - 2] !== s[i - 1] &&\n    s[i - 2] !== s[i] &&\n    s[i - 1] !== s[i]\n}\n"
    }
  },
  {
    "name": "1878-get-biggest-three-rhombus-sums-in-a-grid",
    "code": {
      "JS": "/**\n * @param {number[][]} grid\n * @return {number[]}\n */\nconst getBiggestThree = function (grid) {\n  const rows = grid.length\n  const cols = grid[0].length\n  const res = []\n  for(let i = 0; i < rows; i++) {\n    for(let j = 0; j < cols; j++) {\n      for(let size = 0; i - size >= 0 && i + size < rows && j + size * 2 < cols; size++) {\n        let tmp = 0, r = i, c = j\n        do {tmp += grid[r++][c++]} while(r < rows && c < cols && r < i + size)\n        if(size > 0) {\n          do {tmp += grid[r--][c++]} while(c < cols && c < j + 2 * size)\n          do {tmp += grid[r--][c--]} while(r > 0 && r > i - size)\n          do {tmp += grid[r++][c--]} while(c > 0 && r < i)\n        }\n        if(res.indexOf(tmp) === -1) res.push(tmp)\n        if(res.length > 3) {\n          res.sort((a, b) => b - a)\n          res.splice(3)\n        }\n      }\n    }\n  }\n  res.sort((a, b) => b - a)\n  return res\n}\n"
    }
  },
  {
    "name": "1879-minimum-xor-sum-of-two-arrays",
    "code": {
      "JS": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nconst minimumXORSum = function (nums1, nums2) {\n  const n = nums1.length, dp = Array(1 << n).fill(Infinity)\n  return dfs(0, 0)\n  function dfs(i, mask) {\n    if(i === n) return 0\n    if(dp[mask] !== Infinity) return dp[mask]\n    for(let j = 0; j < n; j++) {\n      if((mask & (1 << j)) === 0) {\n        dp[mask] = Math.min(\n          dp[mask], \n          (nums1[i] ^ nums2[j]) + dfs(i + 1, mask | (1 << j))\n        )\n      }\n    }\n    return dp[mask]\n  }\n}\n\n// another\n\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nconst minimumXORSum = function(nums1, nums2) {\n  const dp = Array(1 << nums2.length).fill(Infinity)\n  return dfs(dp, nums1, nums2, 0, 0)\n};\n\nfunction dfs(dp, a, b, i, mask) {\n  if(i >= a.length) return 0\n  if(dp[mask] === Infinity) {\n    for(let j = 0; j < b.length; j++) {\n      if((mask & (1 << j)) === 0) {\n        dp[mask] = Math.min(dp[mask], (a[i] ^ b[j]) + dfs(dp, a, b, i + 1, mask + (1 << j)))\n      }\n    }\n  }\n  return dp[mask]\n}\n\n// another\n\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nconst minimumXORSum = function (nums1, nums2) {\n  const dp = Array(1 << nums2.length).fill(Infinity)\n  return dfs(0, 0)\n  \n  function dfs(i, mask) {\n    if(i >= nums2.length) return 0\n    if(dp[mask] != Infinity) return dp[mask]\n    for(let j = 0; j < nums2.length; j++) {\n      if((mask & (1 << j)) === 0) {\n        dp[mask] = Math.min(dp[mask], (nums1[i] ^ nums2[j]) + dfs(i + 1, mask + (1 << j)) )   \n      }\n    } \n    return dp[mask]\n  }\n}\n\n// another\n\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nconst minimumXORSum = function (nums1, nums2) {\n  const n = nums1.length, dp = Array(1 << n).fill(Infinity)\n  return dfs(0, 0)\n\n  function dfs(i, mask) {\n    if(i >= n) return 0\n    if(dp[mask] !== Infinity) return dp[mask]\n    for(let j = 0; j < n; j++) {\n      if((mask & (1 << j)) === 0) {\n        dp[mask] = Math.min(dp[mask], (nums1[i] ^ nums2[j]) + dfs(i + 1, mask | (1 << j)))\n      }\n    }\n    return dp[mask]\n  }\n}\n\n"
    }
  },
  {
    "name": "188-best-time-to-buy-and-sell-stock-iv",
    "code": {
      "JS": "/**\n * @param {number} k\n * @param {number[]} prices\n * @return {number}\n */\nconst maxProfit = function(k, prices) {\n  if (!prices.length) return 0\n  let len = prices.length,\n    res = 0\n  if (k >= ~~(len / 2)) {\n    for (let i = 1; i < len; i++) {\n      res += Math.max(prices[i] - prices[i - 1], 0)\n    }\n    return res\n  }\n  const buy = new Array(k + 1).fill(Number.MIN_SAFE_INTEGER)\n  const sell = new Array(k + 1).fill(0)\n\n  for (let p of prices) {\n    for (let i = 1; i <= k; i++) {\n      buy[i] = Math.max(sell[i - 1] - p, buy[i])\n      sell[i] = Math.max(buy[i] + p, sell[i])\n    }\n  }\n  return sell[k]\n}\n\n// another\n\n/**\n * @param {number} k\n * @param {number[]} prices\n * @return {number}\n */\nconst maxProfit = function(k, prices) {\n    if(prices.length === 0) return 0\n    \n    if(k > (prices.length/2)) {\n        let profit = 0\n        for(let i = 1; i < prices.length; i++) {\n            if(prices[i] > prices[i-1]) profit += prices[i] - prices[i-1]\n        }\n        return profit\n    } else {\n        let dp = new Array(prices.length).fill(0)\n        let length = prices.length\n        for(let j = 0; j < k; j++) {\n            let min = prices[0], max = 0\n            for(let i = 0; i < length; i++) {\n                min = Math.min(min, prices[i] - dp[i])\n                max = Math.max(max, prices[i] - min)\n                dp[i] = max\n            }\n        }\n        return dp.pop()\n    }\n}\n\n // another\n\n/**\n * @param {number} k\n * @param {number[]} prices\n * @return {number}\n */\nconst maxProfit = function(k, prices) {\n  if (k >= prices.length / 2) {\n    let max = 0;\n    for(let i = 1; i < prices.length; i++) {\n      if (prices[i] > prices[i - 1]) {\n        max += prices[i] - prices[i - 1];\n      }\n    }\n    return max;\n  }\n  if (prices.length === 0) return 0;\n  let dp = new Array(k + 1);\n  dp[0] = new Array(prices.length).fill(0);\n  for (let t = 1; t <= k; t++) {\n    dp[t] = [0];\n    let max = dp[t - 1][0] - prices[0];\n    for (let day = 1; day < prices.length; day++) {\n      dp[t][day] = Math.max(dp[t][day - 1], max + prices[day]);\n      max = Math.max(max, dp[t - 1][day] - prices[day]);\n    }\n  }\n  return dp[k][prices.length - 1];\n}\n"
    }
  },
  {
    "name": "1880-check-if-word-equals-summation-of-two-words",
    "code": {
      "JS": "/**\n * @param {string} firstWord\n * @param {string} secondWord\n * @param {string} targetWord\n * @return {boolean}\n */\nconst isSumEqual = function(firstWord, secondWord, targetWord) {\n  let str = 'abcdefghij'\n  const hash = {}, reverse = {}\n  for(let i = 0; i < str.length; i++) {\n    hash[str[i]] = i\n    reverse[i] = str[i]\n  }\n  let len1 = firstWord.length, len2 = secondWord.length\n  if (len1 < len2) return isSumEqual(secondWord, firstWord, targetWord)\n  // len1 >= len2\n  if (len1 > len2) {\n    for(let i = len1 - len2; i > 0; i--) {\n      secondWord = 'a' + secondWord\n    }\n  }\n  let res = '', inc = 0\n  for(let i = len1 - 1; i >= 0; i--) {\n    const tmp = hash[firstWord[i]] + hash[secondWord[i]] + inc\n    if (tmp > 9) {\n      inc = 1\n    } else {\n      inc = 0\n    }\n    const cur = tmp % 10\n    res = reverse[cur] + res\n  }\n  \n  if(inc) res = 'b' + res\n  // console.log(res)\n  let r1 = '', r2 = ''\n  for(let i = 0; i < targetWord.length; i++) {\n    r1 = r1 + hash[targetWord[i]]\n  }\n  for(let i = 0; i < res.length; i++) {\n    r2 = r2 + hash[res[i]]\n  }\n  return (+r1) === (+r2)\n};\n"
    }
  },
  {
    "name": "1881-maximum-value-after-insertion",
    "code": {
      "JS": "/**\n * @param {string} n\n * @param {number} x\n * @return {string}\n */\nconst maxValue = function(n, x) {\n  const neg = n[0] === '-'\n  if (neg) {\n    for(let i = 1; i < n.length; i++) {\n      if(+n[i] > x) {\n        return n.slice(0, i) + x + n.slice(i)\n      }\n    }\n    return n + x\n  } else {\n    for(let i = 0; i < n.length; i++) {\n      if(+n[i] < x) {\n        \n        return n.slice(0, i) + x + n.slice(i)\n      }\n    }\n    return n + x\n  }\n};\n"
    }
  },
  {
    "name": "1882-process-tasks-using-servers",
    "code": {
      "JS": "/**\n * @param {number[]} servers\n * @param {number[]} tasks\n * @return {number[]}\n */\nconst assignTasks = function(servers, tasks) {\n  const freePQ = new PriorityQueue((a, b) => a.w === b.w ? a.i < b.i : a.w < b.w)\n  const runningPQ = new PriorityQueue((a, b) => a.e === b.e ? (a.w === b.w ? a.i < b.i : a.w < b.w) : a.e < b.e)\n  const m = servers.length, n = tasks.length\n  for(let i = 0; i < m; i++) freePQ.push({w: servers[i], i, e: 0})\n  const res = []\n  for(let i = 0; i < n; i++) {\n    const cur = tasks[i]\n    while(!runningPQ.isEmpty() && runningPQ.peek().e <= i) {\n      const tmp = runningPQ.pop()\n      tmp.e = i\n      freePQ.push(tmp)\n    }\n    if(freePQ.isEmpty()) {\n      const tmp = runningPQ.pop()\n      res[i] = tmp.i\n      tmp.e += cur\n      runningPQ.push(tmp)\n    } else {\n      const tmp = freePQ.pop()\n      res[i] = tmp.i\n      tmp.e = i + cur\n      runningPQ.push(tmp)\n    }\n  }\n  return res\n};\n\n// another\n\n/**\n * @param {number[]} servers\n * @param {number[]} tasks\n * @return {number[]}\n */\nconst assignTasks = function(servers, tasks) {\n  let i = 0\n  const freePQ = new PriorityQueue((a, b) => {\n    if(a.w < b.w) return true\n    else if(a.w > b.w) return false\n    else {\n      if(a.idx < b.idx) return true\n      return false\n    }\n  })\n  const runningPQ = new PriorityQueue((a, b) => {\n    return a.end < b.end\n  })\n  const res = []\n  for(let i = 0; i < servers.length; i++) {\n    freePQ.push({\n      w: servers[i],\n      idx: i\n    })\n  }\n  let taskIdx = 0\n  while(taskIdx < tasks.length) {\n    while(!runningPQ.isEmpty() && runningPQ.peek().end <= i) {\n      let server = runningPQ.pop()\n      freePQ.push({\n        w: server.w,\n        idx: server.idx\n      })\n    }\n    \n    while(taskIdx <= i && !freePQ.isEmpty() && taskIdx < tasks.length) {\n      const server = freePQ.pop()\n      res[taskIdx] = server.idx\n      runningPQ.push({\n        end: i + tasks[taskIdx],\n        w: server.w,\n        idx: server.idx\n      })\n      taskIdx++\n    }\n    if(i < tasks.length || !freePQ.isEmpty()) i++\n    else i = Math.max(i + 1, runningPQ.peek().end)\n  }\n  return res\n};\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n\n// another\n\n/**\n * @param {number[]} servers\n * @param {number[]} tasks\n * @return {number[]}\n */\nconst assignTasks = function(servers, tasks) {\n  const freePQ = new PriorityQueue((a, b) => {\n    if(a.w < b.w) return true\n    else if(a.w > b.w) return false\n    else {\n      if(a.idx < b.idx) return true\n      return false\n    }\n  })\n  const runningPQ = new PriorityQueue((a, b) => {\n    return a.end === b.end ? (a.w === b.w ? a.idx < b.idx : a.w < b.w) : a.end < b.end\n  })\n  const res = []\n  for(let i = 0; i < servers.length; i++) {\n    freePQ.push({\n      w: servers[i],\n      idx: i\n    })\n  }\n  for(let i = 0, n = tasks.length; i < n; i++) {\n    const cur = tasks[i]\n    while(runningPQ.size() && runningPQ.peek().end <= i) {\n      const el = runningPQ.pop()\n      freePQ.push({\n        w: el.w,\n        idx: el.idx,\n      })\n    }\n    \n    if(freePQ.isEmpty()) {\n      const el = runningPQ.pop()\n      res[i] = el.idx\n      el.end += cur\n      runningPQ.push(el)\n    } else {\n      const el = freePQ.pop()\n      res[i] = el.idx\n      el.end = i + cur\n      runningPQ.push(el)\n    }\n  }\n\n  return res\n};\n\n"
    }
  },
  {
    "name": "1883-minimum-skips-to-arrive-at-meeting-on-time",
    "code": {
      "JS": "/**\n * @param {number[]} dist\n * @param {number} speed\n * @param {number} hoursBefore\n * @return {number}\n */\nconst minSkips = function (dist, speed, hoursBefore) {\n  let left = 0\n  let right = dist.length\n\n  while (left < right) {\n    let mid = ~~(left + (right - left) / 2)\n    if (dfs(dist, speed, mid) > 1.0 * hoursBefore) {\n      left = mid + 1\n    } else {\n      right = mid\n    }\n  }\n  return dfs(dist, speed, left) <= 1.0 * hoursBefore ? left : -1\n  function dfs(dist, speed, skips) {\n    const dp = Array.from({ length: dist.length }, () =>\n      Array(skips + 1).fill(0)\n    )\n    let eps = 1e-9\n    for (let i = 0; i <= skips; i++) {\n      dp[0][i] = (dist[0] * 1.0) / speed - eps\n    }\n\n    for (let i = 1; i < dist.length; i++) {\n      dp[i][0] = Math.ceil(dp[i - 1][0]) + (dist[i] * 1.0) / speed - eps\n      for (let j = 1; j <= skips; j++) {\n        let time = dp[i - 1][j - 1] + (dist[i] * 1.0) / speed - eps\n        dp[i][j] = Math.min(\n          time,\n          Math.ceil(dp[i - 1][j]) + (dist[i] * 1.0) / speed - eps\n        )\n      }\n    }\n    return dp[dist.length - 1][skips]\n  }\n}\n"
    }
  },
  {
    "name": "1886-determine-whether-matrix-can-be-obtained-by-rotation",
    "code": {
      "JS": "/**\n * @param {number[][]} mat\n * @param {number[][]} target\n * @return {boolean}\n */\nconst findRotation = function(mat, target) {\n  if(chk(mat, target)) return true\n  for(let i = 0; i < 3; i++) {\n    rotate(mat)\n    if(chk(mat, target)) return true\n  }\n  return false\n};\n\nfunction chk(m1, m2) {\n  for(let i = 0; i < m1.length; i++) {\n    for(let j = 0; j < m1.length; j++) {\n      if(m1[i][j] !== m2[i][j]) return false\n    }\n  }\n  return true\n}\n\nfunction rotate(matrix) {\n  matrix.reverse()\n  for (let i = 0; i < matrix.length; ++i) {\n    for (let j = matrix[i].length - 1; j > i; j--) swap(matrix, i, j)\n  }\n}\n\nfunction swap(matrix, i, j) {\n  const tmp = matrix[j][i]\n  matrix[j][i] = matrix[i][j]\n  matrix[i][j] = tmp\n}\n"
    }
  },
  {
    "name": "1887-reduction-operations-to-make-the-array-elements-equal",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst reductionOperations = function(nums) {\n  nums.sort((a, b) => a - b)\n  const n = nums.length\n  const arr = Array(n).fill(0)\n  for(let i = 1; i < n; i++) {\n    if(nums[i] > nums[i - 1]) arr[i] = 1\n  }\n  let res = 0, pre = 0\n  \n  for(let i = 1; i < n; i++) {\n    if(arr[i] === 0) arr[i] = arr[i - 1]\n    else arr[i] += arr[i - 1]\n  }\n\n  for(let e of arr) {\n    res += e\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1888-minimum-number-of-flips-to-make-the-binary-string-alternating",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst minFlips = function (s) {\n  let n = s.length\n  let t = s + s\n  let a0 = 0\n  let a1 = 0\n  let b0 = 0\n  let b1 = 0\n  let ans = Infinity\n  for (let i = 0; i < t.length; i++) {\n      if (t[i] == '0') {\n          if (i % 2 == 0) {\n              a0++\n          } else {\n              b0++\n          }\n      } else {\n          if (i % 2 == 0) {\n              a1++\n          } else {\n              b1++\n          }\n      }\n\n      if (i >= n) {\n          if (t[i - n] == '0') {\n              if ((i - n) % 2 == 0) {\n                  a0--\n              } else {\n                  b0--\n              }\n          } else {\n              if ((i - n) % 2 == 0) {\n                  a1--\n              } else {\n                  b1--\n              }\n          }\n      }\n      ans = Math.min(ans, Math.min(n - a0 - b1, n - a1 - b0))\n  }\n\n  return ans\n}\n\n// another\n\n/**\n * @param {string} s\n * @return {number}\n */\nconst minFlips = function (s) {\n  const n = s.length\n  s += s\n  let s1 = '', s2 = ''\n  for(let i = 0;i < s.length; i++) {\n    s1 += i % 2 === 0 ? '0' : '1'\n    s2 += i % 2 === 0 ? '1' : '0'\n  }\n  let res1 = 0, res2 = 0, res = Infinity\n  for(let i = 0; i < s.length; i++) {\n    if(s1[i] !== s[i]) res1++\n    if(s2[i] !== s[i]) res2++\n    if(i >= n) {\n      if(s1[i - n] !== s[i - n]) res1--\n      if(s2[i - n] !== s[i - n]) res2--\n    }\n    if(i >= n - 1) {\n      res = Math.min(res, res1, res2)\n    }\n  }\n  \n  return res\n}\n\n// another\n\n/**\n * @param {string} s\n * @return {number}\n */\nconst minFlips = function (s) {\n  const n = s.length\n  const ss = s + s\n  let s1 = '', s2 = ''\n  for(let i = 0; i < 2 * n; i++) {\n    if(i % 2 === 0) {\n      s1 += '0'\n      s2 += '1'\n    }else{\n      s1 += '1'\n      s2 += '0'\n    }\n  }\n\n  let res = Infinity, res1 = 0, res2 = 0\n\n  for (let i = 0; i < 2 * n; i++) {\n    if(ss[i] !== s1[i]) res1++\n    if(ss[i] !== s2[i]) res2++\n    if(i >= n) {\n      if(ss[i - n] !== s1[i - n]) res1--\n      if(ss[i - n] !== s2[i - n]) res2--\n    }\n    if(i >= n - 1) {\n      res = Math.min(res, res1, res2)\n    }\n  }\n\n  return res\n}\n\n"
    }
  },
  {
    "name": "1889-minimum-space-wasted-from-packaging",
    "code": {
      "JS": "/**\n * @param {number[]} packages\n * @param {number[][]} boxes\n * @return {number}\n */\nconst minWastedSpace = function (packages, boxes) {\n  const mod = 1e9 + 7\n  const n = packages.length\n  packages.sort((a, b) => a - b)\n  const preSum = packages.reduce(\n    (acc, cur) => {\n      acc.push(acc[acc.length - 1] + cur)\n      return acc\n    },\n    [0]\n  )\n\n  const upperBound = (target) => {\n    let lo = 0,\n      hi = n\n    while (lo < hi) {\n      const mi = (lo + hi) >> 1\n      const val = packages[mi]\n      if (val <= target) {\n        lo = mi + 1\n      } else {\n        hi = mi\n      }\n    }\n    return lo\n  }\n\n  let res = Infinity\n  for (const bs of boxes) {\n    bs.sort((a, b) => b - a)\n    if (bs[0] < packages[n - 1]) continue\n    let wastes = bs[0] * n - preSum[n]\n    let last = bs[0]\n    for (let i = 1; i < bs.length; i++) {\n      const b = bs[i]\n      const j = upperBound(b)\n      if (j <= 0) {\n        break\n      }\n      wastes -= (last - b) * j\n      last = b\n    }\n    res = Math.min(res, wastes)\n  }\n  return res === Infinity ? -1 : res % mod\n}\n\n// another\n\n/**\n * @param {number[]} packages\n * @param {number[][]} boxes\n * @return {number}\n */\nvar minWastedSpace = function (packages, boxes) {\n  packages.sort(function (a, b) {\n    return a - b\n  })\n  let count = 0,\n    b,\n    wastage,\n    minWastage = Number.MAX_SAFE_INTEGER,\n    flag = false\n  for (let i = 0; i < boxes.length; i++) {\n    boxes[i].sort(function (a, b) {\n      return a - b\n    })\n    b = 0\n    wastage = 0\n    count = 0\n    if (boxes[i][boxes[i].length - 1] < packages[packages.length - 1]) {\n      //This supplier's largest box is smaller than our larget package, this supplier can't be used\n      continue\n    }\n    while (count < packages.length && b < boxes[i].length) {\n      if (packages[count] <= boxes[i][b]) {\n        wastage += boxes[i][b] - packages[count]\n        if (wastage > minWastage) {\n          //Need not to porcess this supplier if wastage has already been more than minWastage\n          break\n        }\n        count++\n      } else {\n        b++\n      }\n    }\n    if (count === packages.length) {\n      flag = true //We have found atleas 1 answer\n      if (wastage < minWastage) {\n        minWastage = wastage\n      }\n    }\n  }\n  if (flag === false) {\n    return -1\n  }\n  return minWastage % 1000000007\n}\n"
    }
  },
  {
    "name": "189-rotate-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nconst rotate = function(nums, k) {\n  nums.unshift(...nums.splice(nums.length - k))\n};\n\n// another\n\nconst rotate = function(nums, k) {\n  let i = k\n  while (i > 0) {\n    nums.unshift(nums.pop())\n    i--\n  }\n};\n\n// another\n\nconst rotate = function(nums, k) {\n  k %= nums.length\n  reverse(nums, 0, nums.length - 1)\n  reverse(nums, 0, k - 1)\n  reverse(nums, k, nums.length - 1)\n}\n\nfunction reverse(nums, start, end) {\n  while (start < end) {\n    var temp = nums[start]\n    nums[start] = nums[end]\n    nums[end] = temp\n    start++\n    end--\n  }\n}\n"
    }
  },
  {
    "name": "1891-cutting-ribbons",
    "code": {
      "JS": "/**\n * @param {number[]} ribbons\n * @param {number} k\n * @return {number}\n */\nconst maxLength = function(ribbons, k) {\n  let l = 0, r = Math.max(...ribbons)\n  while(l < r) {\n    const mid = r - Math.floor((r - l) / 2)\n    if(valid(mid)) {\n      l = mid\n    } else r = mid - 1\n  }\n  return l\n  \n  function valid(mid) {\n    let res = 0\n    for(let e of ribbons) {\n      res += ~~(e / mid)\n    }\n    return res >= k\n  }\n};\n"
    }
  },
  {
    "name": "1893-check-if-all-the-integers-in-a-range-are-covered",
    "code": {
      "JS": "/**\n * @param {number[][]} ranges\n * @param {number} left\n * @param {number} right\n * @return {boolean}\n */\nconst isCovered = function(ranges, left, right) {\n  const arr = Array(52).fill(0)\n  for(let [s, e] of ranges) {\n    arr[s]++\n    arr[e + 1]--\n  }\n  for(let i = 1; i < 52; i++) {\n    arr[i] += arr[i - 1]\n  }\n  for(let i = left; i <= right; i++) {\n    if(arr[i] === 0) return false\n  }\n  \n  return true\n};\n\n// another\n\n/**\n * @param {number[][]} ranges\n * @param {number} left\n * @param {number} right\n * @return {boolean}\n */\nconst isCovered = function(ranges, left, right) {\n\tfor(let i = left; i <= right; i++) {\n\t\tlet seen = false;\n\t\tfor(let j = 0; j < ranges.length && !seen; j++) \n\t\t\tif(i >= ranges[j][0] && i <= ranges[j][1]) \n\t\t\t\tseen = true;\n\t\tif(!seen) return false;\n\t}\n\treturn true;\n};\n"
    }
  },
  {
    "name": "1896-minimum-cost-to-change-the-final-value-of-expression",
    "code": {
      "JS": "/**\n * @param {string} expression\n * @return {number}\n */\nfunction minOperationsToFlip (s) {\n  const nums = []\n  const ops = []\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === '0') nums.push([0, 0, 1])\n    else if (s[i] === '1') nums.push([1, 1, 0])\n    else if (s[i] === '(') ops.push('(')\n    else if (s[i] === ')') {\n      while (ops.length && ops[ops.length - 1] !== '(') {\n        const op = ops.pop()\n        calc(op)\n      }\n      if (ops.length) ops.pop()\n    } else {\n      while (ops.length && grade(ops[ops.length - 1]) >= grade(s[i])) {\n        const op = ops.pop()\n        calc(op)\n      }\n      ops.push(s[i])\n    }\n  }\n\n  while (ops.length && nums.length >= 2) {\n    const op = ops.pop()\n    calc(op)\n  }\n  const val = nums[0][0]\n  return nums[0][2 - val]\n\n  function calc (op) {\n    const [x, y] = [nums.pop(), nums.pop()]\n    let [z, a0, a1] = [0, 0, 0]\n    switch (op) {\n      case '&':\n        z = x[0] & y[0]\n        if (x[0] === 0 && y[0] === 0) {\n          a0 = 0\n          a1 = Math.min(x[2] + 1, y[2] + 1)\n        }\n        if (x[0] === 0 && y[0] === 1) {\n          a0 = 0\n          a1 = 1\n        }\n        if (x[0] === 1 && y[0] === 0) {\n          a0 = 0\n          a1 = 1\n        }\n        if (x[0] === 1 && y[0] === 1) {\n          a0 = Math.min(x[1], y[1])\n          a1 = 0\n        }\n        break\n      case '|':\n        z = x[0] | y[0]\n        if (x[0] === 0 && y[0] === 0) {\n          a0 = 0\n          a1 = Math.min(x[2], y[2])\n        }\n        if (x[0] === 0 && y[0] === 1) {\n          a0 = 1\n          a1 = 0\n        }\n        if (x[0] === 1 && y[0] === 0) {\n          a0 = 1\n          a1 = 0\n        }\n        if (x[0] === 1 && y[0] === 1) {\n          a0 = Math.min(x[1] + 1, y[1] + 1)\n          a1 = 0\n        }\n        break\n    }\n    nums.push([z, a0, a1])\n  }\n  function grade (op) {\n    switch (op) {\n      case '(':\n        return 1\n      case '&':\n      case '|':\n        return 2\n    }\n    return 0\n  }\n};\n"
    }
  },
  {
    "name": "1897-redistribute-characters-to-make-all-strings-equal",
    "code": {
      "JS": "/**\n * @param {string[]} words\n * @return {boolean}\n */\nconst makeEqual = function(words) {\n  const arr = Array(26).fill(0)\n  const a = 'a'.charCodeAt(0)\n  for(let w  of words) {\n    for(let ch of w) {\n      arr[ch.charCodeAt(0) - a]++\n    }\n  }\n  const n = words.length\n  for(let i = 0; i < 26; i++) {\n    if(arr[i] % n !== 0) return false\n  }\n  return true\n};\n"
    }
  },
  {
    "name": "1898-maximum-number-of-removable-characters",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {string} p\n * @param {number[]} removable\n * @return {number}\n */\nconst maximumRemovals = function (s, p, removable) {\n  const n = removable.length\n  let l = 0,\n    r = n\n  while (l < r) {\n    let mid = (l + r + 1) >> 1\n    if (is_valid(s, p, removable, mid)) l = mid\n    else r = mid - 1\n  }\n  return l\n}\n\nfunction is_valid(s, p, removable, cnt) {\n  let len1 = s.length,\n    len2 = p.length\n  const check = Array(len1).fill(0)\n  for (let i = 0; i < cnt; i++) check[removable[i]] = 1\n  let ind1 = 0,\n    ind2 = 0\n  while (ind1 < len1 && ind2 < len2) {\n    if (s[ind1] != p[ind2] || check[ind1]) {\n      ind1++\n      continue\n    }\n    ind1++, ind2++\n  }\n  return ind2 == len2\n}\n"
    }
  },
  {
    "name": "1899-merge-triplets-to-form-target-triplet",
    "code": {
      "JS": "/**\n * @param {number[][]} triplets\n * @param {number[]} target\n * @return {boolean}\n */\nconst mergeTriplets = function (triplets, target) {\n  let n = triplets.length\n  const ans = Array(3).fill(0)\n  const { max } = Math\n  for (let i = 0; i < n; i++) {\n    if (\n      triplets[i][0] <= target[0] &&\n      triplets[i][1] <= target[1] &&\n      triplets[i][2] <= target[2]\n    ) {\n      ans[0] = max(ans[0], triplets[i][0])\n      ans[1] = max(ans[1], triplets[i][1])\n      ans[2] = max(ans[2], triplets[i][2])\n    }\n  }\n  return ans[0] == target[0] && ans[1] == target[1] && ans[2] == target[2]\n}\n"
    }
  },
  {
    "name": "19-remove-nth-node-from-end-of-list",
    "code": {
      "JS": "/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} n\r\n * @return {ListNode}\r\n */\r\nconst removeNthFromEnd = (head, n) => {\r\n  if (head.next === null) return null;\r\n\r\n  let ptrBeforeN = head;\r\n  let count = 1;\r\n\r\n  // While there are more elements\r\n  let el = head.next;\r\n  while (el !== null) {\r\n    if (count > n) ptrBeforeN = ptrBeforeN.next;\r\n    el = el.next;\r\n    count++;\r\n  }\r\n\r\n  if (count === n) return head.next;\r\n\r\n  ptrBeforeN.next = ptrBeforeN.next.next;\r\n  return head;\r\n};\r\n"
    }
  },
  {
    "name": "190-reverse-bits",
    "code": {
      "JS": "/**\n * @param {number} n - a positive integer\n * @return {number} - a positive integer\n */\nconst reverseBits = function(n) {\n  let r = 0;\n  for (let i = 0; i < 32; i++) {\n    if (n & 1) {\n      r = r | 1;\n    } \n    if (i !== 31) {\n       r = r << 1;\n       n = n >> 1;\n    }\n  }\n  return r >>> 0;\n};\n\n// another\n\n/**\n * @param {number} n - a positive integer\n * @return {number} - a positive integer\n */\nconst reverseBits = function(n) {\n  let s = '';\n  let count = 0;\n  let index = 31;\n  while (n > 0) {\n    if (n % 2 !== 0) count += Math.pow(2, index);\n    index--;\n    n = Math.floor(n / 2);\n  }\n  return count;\n};\n\n// another\n\n/**\n * @param {number} n - a positive integer\n * @return {number} - a positive integer\n */\nconst reverseBits = function(n) {\n  const b = n.toString(2)\n  const leadingZeroes = b.padStart(32,'0')\n  const rev = leadingZeroes.split('')\n  rev.reverse()\n  return parseInt(rev.join(''), 2)\n};\n"
    }
  },
  {
    "name": "1900-the-earliest-and-latest-rounds-where-players-compete",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number} firstPlayer\n * @param {number} secondPlayer\n * @return {number[]}\n */\nconst earliestAndLatest = function (n, firstPlayer, secondPlayer) {\n  const { max, min } = Math\n  const hash = {}\n  function dp(l, r, m) {\n    const key = `${l}${r}${m}`\n    if (hash[key] != null) return hash[key]\n    if (l > r) return dp(r, l, m)\n    if (l === r) return [1, 1]\n    let nxt_m = (m + 1) >> 1\n    let ans = [n, 0]\n    for (let i = 1; i < l + 1; i++) {\n      let l_win = i - 1,\n        l_lose = l - i\n      for (\n        let j = max(r - ~~(m / 2) - 1, 0) + l_lose + 1;\n        j < min(r - 1 - l_win, nxt_m - i) + 1;\n        j++\n      ) {\n        let tmp = dp(i, j, nxt_m)\n        ans = [min(ans[0], tmp[0]), max(ans[1], tmp[1])]\n      }\n    }\n    hash[key] = [ans[0] + 1, ans[1] + 1]\n    return hash[key]\n  }\n\n  return dp(firstPlayer, n - secondPlayer + 1, n)\n}\n"
    }
  },
  {
    "name": "1901-find-a-peak-element-ii",
    "code": {
      "JS": "/**\n * @param {number[][]} mat\n * @return {number[]}\n */\nconst findPeakGrid = function(mat) {\n    let lowCol = 0;\n    let highCol = mat[0].length - 1;\n\n    while(lowCol <= highCol) {\n        let midCol = lowCol + ~~((highCol - lowCol) / 2);\n        let maxRow = 0;\n        for(let i = 0; i < mat.length; i++) {\n            maxRow = mat[i][midCol] > mat[maxRow][midCol] ? i : maxRow;\n        }\n\n        let isLeftElementBig = midCol - 1 >= lowCol && mat[maxRow][midCol - 1] > mat[maxRow][midCol];\n        let isRightElementBig = midCol + 1 <= highCol && mat[maxRow][midCol + 1] > mat[maxRow][midCol];\n\n        if(!isLeftElementBig && !isRightElementBig) {\n            return [maxRow, midCol];\n        } else if(isRightElementBig) {\n            lowCol = midCol + 1;\n        } else {\n            highCol = midCol - 1;\n        }\n    }\n    return null;\n};\n"
    }
  },
  {
    "name": "1903-largest-odd-number-in-string",
    "code": {
      "JS": "/**\n * @param {string} num\n * @return {string}\n */\nconst largestOddNumber = function(num) {\n  let idx= -1\n  for(let i = 0, n = num.length; i < n; i++) {\n    if((+num[i]) % 2 === 1) idx = i\n  }\n  return num.slice(0, idx+1)\n};\n"
    }
  },
  {
    "name": "1904-the-number-of-full-rounds-you-have-played",
    "code": {
      "JS": "/**\n * @param {string} startTime\n * @param {string} finishTime\n * @return {number}\n */\nconst numberOfRounds = function(startTime, finishTime) {\n  let start = 60 * parseInt(startTime.slice(0, 2)) + parseInt(startTime.slice(3))\n  let finish = 60 * parseInt(finishTime.slice(0, 2)) + parseInt(finishTime.slice(3));\n  if (start > finish) finish += 60 * 24; // If `finishTime` is earlier than `startTime`, add 24 hours to `finishTime`.\n  return Math.max(0, Math.floor(finish / 15) - Math.ceil(start / 15)); // floor(finish / 15) - ceil(start / 15)\n};\n\n// another\n\n/**\n * @param {string} startTime\n * @param {string} finishTime\n * @return {number}\n */\nconst numberOfRounds = function(startTime, finishTime) {\n  const { ceil, floor } = Math\n  const start = new Node(startTime), finish = new Node(finishTime)\n  if(finish.compare(start)) finish.hour += 24\n  let cnt = 0\n  if(start.hour === finish.hour) {\n    const r = floor(finish.minute / 15)\n    const l = ceil(start.minute / 15)\n    if(l >= r) return 0\n    return r - l\n  }\n  cnt += 4 - ceil(start.minute / 15) + floor(finish.minute / 15)\n  start.hour++\n  cnt += (finish.hour - start.hour) * 4\n  return cnt\n};\n\nclass Node {\n  constructor(str) {\n    this.hour = +str.slice(0, 2)\n    this.minute = +str.slice(3)\n  }\n  compare(node) {\n    return this.hour === node.hour ? this.minute < node.minute : this.hour < node.hour\n  }\n}\n"
    }
  },
  {
    "name": "1905-count-sub-islands",
    "code": {
      "JS": "/**\n * @param {number[][]} grid1\n * @param {number[][]} grid2\n * @return {number}\n */\nconst countSubIslands = function(grid1, grid2) {\n    let m = grid2.length, n = grid2[0].length, res = 0;\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (grid2[i][j] === 1) res += dfs(grid1, grid2, i, j);                 \n        }\n    }\n    return res;  \n};\n\nfunction dfs(B, A, i, j) {\n    let m = A.length, n = A[0].length, res = 1;\n    if (i < 0 || i == m || j < 0 || j == n || A[i][j] == 0) return 1;\n    A[i][j] = 0;\n    res &= dfs(B, A, i - 1, j);\n    res &= dfs(B, A, i + 1, j);\n    res &= dfs(B, A, i, j - 1);\n    res &= dfs(B, A, i, j + 1);\n    return res & B[i][j];\n}\n"
    }
  },
  {
    "name": "1906-minimum-absolute-difference-queries",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number[][]} queries\n * @return {number[]}\n */\nconst minDifference = function (nums, queries) {\n  const res = [],\n    cnt = Array.from({ length: nums.length + 1 }, () => Array(101).fill(0))\n\n  for (let i = 0; i < nums.length; ++i) {\n    for (let j = 1; j <= 100; ++j) {\n      cnt[i + 1][j] = cnt[i][j] + (nums[i] == j)\n    }\n  }\n\n  for (let i = 0; i < queries.length; ++i) {\n    let prev = 0,\n      delta = Infinity\n    for (let j = 1; j <= 100; ++j)\n      if (cnt[queries[i][1] + 1][j] - cnt[queries[i][0]][j]) {\n        delta = Math.min(delta, prev == 0 ? Infinity : j - prev)\n        prev = j\n      }\n    res.push(delta == Infinity ? -1 : delta)\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "1909-remove-one-element-to-make-the-array-strictly-increasing",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nconst canBeIncreasing = function(nums) {\n\tlet previous = nums[0];\n\tlet used = false;\n\tfor (let i = 1; i < nums.length; i++){\n\t\tif (nums[i] <= previous) {\n      if (used) return false;\n      used = true;\n      if (i === 1 || nums[i] > nums[i - 2]) previous = nums[i];\n\t\t} else previous = nums[i];\n\t}\n\treturn true;\n};\n"
    }
  },
  {
    "name": "191-number-of-1-bits",
    "code": {
      "JS": "/**\n * @param {number} n - a positive integer\n * @return {number}\n */\nconst hammingWeight = function(n) {\n  let res = 0\n  while(n > 0) {\n    if(n & 1) res++\n    n = n >>> 1\n  }\n  return res\n};\n\n// another\n\n/**\n * @param {number} n - a positive integer\n * @return {number}\n */\nconst hammingWeight = function(n) {\n  const str = (n >>> 0).toString(2)\n  let res = 0\n  for(let c of str) {\n    if(c === '1') res++\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1911-maximum-alternating-subsequence-sum",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst maxAlternatingSum = function(nums) {\n  let odd = 0, even = 0;\n  for (let a of nums) {\n    even = Math.max(even, odd + a);\n    odd = even - a;\n  }\n  return even;\n};\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst maxAlternatingSum = function(nums) {\n  let res = nums[0]\n  for(let i = 1; i < nums.length; i++) {\n    res += Math.max(nums[i] - nums[i - 1], 0)\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1913-maximum-product-difference-between-two-pairs",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst maxProductDifference = function(nums) {\n  nums.sort((a, b) => a - b)\n  const n = nums.length\n  return nums[n - 1] * nums[n - 2] - nums[0] * nums[1]\n};\n"
    }
  },
  {
    "name": "1914-cyclically-rotating-a-gridsubmissions",
    "code": {
      "JS": "/**\n * @param {number[][]} grid\n * @param {number} k\n * @return {number[][]}\n */\nconst rotateGrid = function(grid, k) {\n  const m = grid.length, n = grid[0].length\n  let top = 0, left = 0, right = n - 1, bottom = m - 1\n  while(top < bottom && left < right) {\n    const num = (right - left + 1) * 2 + (bottom - top + 1) * 2 - 4\n    let rem = k % num\n    while(rem) {\n      const tmp = grid[top][left]\n      // top\n      for(let i = left; i < right; i++) {\n        grid[top][i] = grid[top][i + 1]\n      }\n      // right\n      for(let i = top; i < bottom; i++) {\n        grid[i][right] = grid[i + 1][right]\n      }\n      // bottom\n      for(let i = right; i > left; i--) {\n        grid[bottom][i] = grid[bottom][i - 1]\n      }\n      // left\n      for(let i = bottom; i > top; i--) {\n        grid[i][left] = grid[i - 1][left]\n      }\n      grid[top + 1][left] = tmp\n      rem--\n    }\n    left++\n    top++\n    right--\n    bottom--\n  }\n  return grid\n};\n\n// another\n\n/**\n * @param {number[][]} grid\n * @param {number} k\n * @return {number[][]}\n */\nvar rotateGrid = function(grid, k) {\n    var m = grid.length;\n    var n = grid[0].length;\n\t\n\t  // step1: loop each layer\n    var layer = Math.min(n/2, m/2);\n    for(l = 0; l<layer; l++) {\n\t     // step2: flat layer \"l\" into one-dimension array\n        var cur = [];\n        // top\n        for(var j = l; j<n-l; j++)\n        {\n            cur.push(grid[l][j]);\n        }\n        // right\n        for(var i = l+1; i<m-l; i++)\n        {\n            cur.push(grid[i][n-l-1]);\n        }\n        // bottom\n        for(var j = n-l-2; j>=l; j--)\n        {\n            cur.push(grid[m-l-1][j]);\n        }\n        // left\n        for(var i = m-l-2; i>l; i--)\n        {\n            cur.push(grid[i][l]);\n        }\n\t\t\n        // step3: rotation (k%len) on one-dimension array\n        var d = cur.length;\n        var offset = k % d;\n        cur = [...cur.slice(offset, d), ...cur.slice(0, offset)];\n\t\t\n        // step4: refill rotated array back to 2D array at current layer\n        var index = 0;\n        // top\n        for(var j = l; j<n-l; j++)\n        {\n            grid[l][j] = cur[index++];\n        }\n        // right\n        for(var i = l+1; i<m-l; i++)\n        {\n            grid[i][n-l-1] = cur[index++];\n        }\n        // bottom\n        for(var j = n-l-2; j>=l; j--)\n        {\n            grid[m-l-1][j] = cur[index++];\n        }\n        // left\n        for(var i = m-l-2; i>l; i--)\n        { \n            grid[i][l] = cur[index++];\n        }\n    }\n    return grid;\n};\n"
    }
  },
  {
    "name": "1915-number-of-wonderful-substrings",
    "code": {
      "JS": "/**\n * @param {string} word\n * @return {number}\n */\nconst wonderfulSubstrings = (word) => {\n  let res = 0, count = Array(1024).fill(0);\n  let cur = 0;\n  count[0] = 1;\n  for (let i = 0; i < word.length; ++i) {\n    const num = word[i].charCodeAt() - 97;\n    cur ^= 1 << (num);\n    res += count[cur];\n    ++count[cur];\n    \n    for (let j = 0; j < 10; ++j) {\n      res += count[cur ^ (1 << j)];\n    }\n  }\n  \n  return res;\n};\n\n// another\n\n/**\n * @param {string} word\n * @return {number}\n */\nconst asi = (c) => c.charCodeAt();\nconst wonderfulSubstrings = (s) => {\n    let res = 0;\n    let f = Array(2 ** 10).fill(0);\n    f[0] = 1; // count array\n    let cur = res = 0;\n    for (const c of s) {\n        cur ^= 1 << asi(c) - 97; // get Hash (the set bit for a character.), update prefix parity\n        res += f[cur];\n        for (let i = 0; i < 10; i++) { // a ~ j\n            res += f[cur ^ 1 << i]; // 1 << i get Hash\n        }\n        f[cur]++;\n    }\n    return res;\n};\n"
    }
  },
  {
    "name": "1916-count-ways-to-build-rooms-in-an-ant-colony",
    "code": {
      "JS": "/**\n * @param {number[]} prevRoom\n * @return {number}\n */\nconst waysToBuildRooms = function (prevRoom) {\n  return brute(prevRoom);\n};\nfunction brute(prevRoom) {\n  const power = function (a, b, n) {\n    a = a % n;\n    let result = 1n;\n    let x = a;\n    while (b > 0) {\n      let leastSignificantBit = b % 2n;\n      b = b / 2n;\n      if (leastSignificantBit == 1n) {\n        result = result * x;\n        result = result % n;\n      }\n      x = x * x;\n      x = x % n;\n    }\n    return result;\n  };\n  const modInverse = function (aa, mm) {\n    return power(BigInt(aa), BigInt(mm - 2), BigInt(mm));\n  };\n  const mod = Math.pow(10, 9) + 7;\n  let nodes = {};\n  for (let i = 0; i < prevRoom.length; i++) {\n    nodes[i] = { val: i, edges: {} };\n  }\n  for (let i = 1; i < prevRoom.length; i++) {\n    nodes[prevRoom[i]].edges[i] = true;\n  }\n  let memo = {};\n  const numNodes = function (root) {\n    var key = root.val;\n    if (memo[key] !== undefined) {\n      return memo[key];\n    }\n    var res = 1;\n    for (var x in root.edges) {\n      res += numNodes(nodes[x]);\n    }\n    memo[key] = res;\n    return res;\n  };\n  let den = 1;\n  for (let x in nodes) {\n    let size = numNodes(nodes[x]);\n    den = (den * size) % mod;\n  }\n  let numerator = 1;\n  for (let i = 1; i < prevRoom.length; i++) {\n    numerator = (numerator * (i + 1)) % mod;\n  }\n  let denInverse = modInverse(den, mod);\n  return (BigInt(numerator) * denInverse) % BigInt(mod);\n}\n"
    }
  },
  {
    "name": "1918-kth-smallest-subarray-sum",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nconst kthSmallestSubarraySum = function(nums, k) {\n  const sum = nums.reduce((ac, e) => ac + e, 0), n = nums.length\n  let l = 0, r = sum\n  while(l < r) {\n    const mid = l + ((r - l) >> 1)\n    let cnt = 0\n    for(let i = 0, j = 0, tmp = 0; i < n; i++) {\n      tmp += nums[i]\n      while(tmp > mid) tmp -= nums[j++]\n      cnt += i - (j - 1)\n    }\n    if (cnt < k) l = mid + 1\n    else r = mid\n  }\n  return l\n};\n"
    }
  },
  {
    "name": "1920-build-array-from-permutation",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nconst buildArray = function(nums) {\n  const res = []\n  for(let i = 0, n = nums.length; i < n; i++) {\n    res[i] = nums[nums[i]]\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1921-eliminate-maximum-number-of-monsters",
    "code": {
      "JS": "/**\n * @param {number[]} dist\n * @param {number[]} speed\n * @return {number}\n */\nconst eliminateMaximum = function(dist, speed) {\n  const pq = new PriorityQueue((a, b) => a[0] / a[1] < b[0] / b[1])\n  const n = dist.length\n  for(let i = 0; i < n; i++) {\n    pq.push([dist[i], speed[i]])\n  }\n  let res = 0\n  while(true) {\n    if(pq.isEmpty()) break\n    if(pq.peek()[0] < 0) break\n    const tmp = pq.pop()\n    if(tmp[0] <= res * tmp[1]) break\n    res++\n  }\n  \n  return res\n};\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n"
    }
  },
  {
    "name": "1922-count-good-numbers",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst countGoodNumbers = function (n) {\n  n = BigInt(n)\n  const MOD = BigInt(10 ** 9 + 7)\n  let res =\n    quick_pow(5n, (n + 1n) / 2n ) * quick_pow(4n, n / 2n)\n  res %= MOD\n  return res\n\n  function quick_pow(b, m) {\n    let ans = 1n\n    while (m) {\n      if (m % 2n === 1n) ans = (ans * b) % MOD\n      m = m / 2n\n      b = (b * b) % MOD\n    }\n    return ans\n  }\n}\n\n"
    }
  },
  {
    "name": "1923-longest-common-subpath",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[][]} paths\n * @return {number}\n */\nconst longestCommonSubpath = function(n, paths) {\n  if (!paths.length) return 0\n  let arr = paths[0]\n  for (const path of paths) if (path.length < arr.length) arr = path\n  return new Sam(arr).longestCommonSubpath(paths)  \n};\n\nclass State {\n  constructor(len, link, next) {\n    this.len = len\n    this.link = link\n    this.next = new Map(next)\n    this.ans = len\n    this.revLink = []\n    this.max = 0\n  }\n}\n\n/**\n * @param p {State}\n * @return boolean\n */\nfunction dfs(p) {\n  let hasNext = false\n  for (const q of p.revLink) {\n    hasNext = dfs(q) || hasNext\n  }\n  if (hasNext) p.max = p.len\n  return p.max > 0\n}\n\nclass Sam {\n  newState(len, link, next) {\n    const state = new State(len, link, next)\n    this.container.push(state)\n    return state\n  }\n\n  constructor(path) {\n    this.container = []\n    const root = this.newState(0, null)\n    let last = root\n    for (const x of path) {\n      const cur = this.newState(last.len + 1, root)\n      for (let p = last; p; p = p.link) {\n        const q = p.next.get(x)\n        if (!q) {\n          p.next.set(x, cur)\n          continue\n        }\n        if (q.len === p.len + 1) {\n          cur.link = q\n        } else {\n          const clone = this.newState(p.len + 1, q.link, q.next)\n          for (; p && p.next.get(x) === q; p = p.link) p.next.set(x, clone)\n          cur.link = q.link = clone\n        }\n        break\n      }\n      last = cur\n    }\n    for (const state of this.container)\n      if (state.link) state.link.revLink.push(state)\n  }\n\n  visit(path) {\n    for (const state of this.container) state.max = 0\n    const root = this.container[0]\n    let p = root\n    let len = 0\n    for (const x of path) {\n      for (; ; p = p.link, len = p.len) {\n        const q = p.next.get(x)\n        if (q) {\n          p = q\n          p.max = Math.max(p.max, ++len)\n          break\n        }\n        if (!p.link) break\n      }\n    }\n    dfs(root)\n    for (const state of this.container)\n      state.ans = Math.min(state.ans, state.max)\n  }\n\n  longestCommonSubpath(paths) {\n    for (const path of paths) this.visit(path)\n    let ans = 0\n    for (const state of this.container) ans = Math.max(ans, state.ans)\n    return ans\n  }\n}\n"
    }
  },
  {
    "name": "1925-count-square-sum-triples",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst countTriples = function(n) {\n  let res = 0\n  const hash = {}\n  for(let i = 1; i<= n; i++) {\n    hash[i * i] = 1\n  }\n  \n  for(let i = 1; i <= n; i++) {\n    for(let j = i; i * i + j * j <= n * n; j++)  {\n      res += (hash[i * i + j * j] || 0) * 2\n    }\n  }\n\n  return res\n};\n"
    }
  },
  {
    "name": "1928-minimum-cost-to-reach-destination-in-time",
    "code": {
      "JS": "/**\n * @param {number} maxTime\n * @param {number[][]} edges\n * @param {number[]} passingFees\n * @return {number}\n */\nconst minCost = function(maxTime, edges, passingFees) {\n  const n = passingFees.length\n  const pq = new PriorityQueue((a, b) => a[0] < b[0])\n  const graph = {}\n  for(let [s, e, t] of edges) {\n    if(graph[s] == null) graph[s] = []\n    if(graph[e] == null) graph[e] = []\n    graph[s].push([e, t])\n    graph[e].push([s, t])\n  }\n  \n  const times = {}\n  \n  pq.push([passingFees[0], 0, 0])\n  while(!pq.isEmpty()) {\n    const [cost, node, time] = pq.pop()\n    \n    if(time > maxTime) continue\n    if(node === n - 1) return cost\n    \n    if(times[node] == null || times[node] > time) {\n      times[node] = time\n      for(let [nxt, ext] of graph[node]) {\n        pq.push([cost + passingFees[nxt], nxt, time + ext])\n      }\n    }\n    \n  }\n  \n  return -1\n};\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n"
    }
  },
  {
    "name": "1929-concatenation-of-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nconst getConcatenation = function(nums) {\n  return nums.concat(nums)\n};\n"
    }
  },
  {
    "name": "1930-unique-length-3-palindromic-subsequences",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst countPalindromicSubsequence = function(s) {\n  const first = Array(26).fill(Infinity), last = Array(26).fill(0)\n  let res = 0\n  const n = s.length, a = 'a'.charCodeAt(0)\n  for(let i = 0; i < n; i++) {\n    const code = s[i].charCodeAt(0)\n    first[code - a] = Math.min(i, first[code - a])\n    last[code - a] = i\n  }\n\n  for(let i = 0; i < 26; i++) {\n    if(last[i] - 1 > first[i]) {\n      const tmp = s.slice(first[i] + 1, last[i])\n      const set = new Set()\n      for(let ch of tmp) set.add(ch)\n      res += set.size\n    }\n  }\n\n  return res\n};\n\n// another\n\n\n/**\n * @param {string} s\n * @return {number}\n */\nconst countPalindromicSubsequence = (s) => {\n    let res = 0;\n    for (let i = 0; i < 26; i++) {\n        for (let j = 0; j < 26; j++) {\n            let len = 0;\n            for (const c of s) {\n                if(len === 3) break\n                if (len == 0) {\n                    if (c.charCodeAt() - 97 == i) len++; // first char\n                } else if (len == 1) {\n                    if (c.charCodeAt() - 97 == j) len++; // second char\n                } else if (len == 2) {\n                    if (c.charCodeAt() - 97 == i) len++; // third char\n                }\n            }\n            if (len == 3) res++;\n        }\n    }\n    return res;\n};\n"
    }
  },
  {
    "name": "1931-painting-a-grid-with-three-different-colors",
    "code": {
      "JS": "/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nconst colorTheGrid = function(m, n) {\n  // Get color of the `mask` at `pos`, 2 bit store 1 color\n  function getColor(mask, pos) {\n    return (mask >> (2 * pos)) & 3\n  }\n  // Set `color` to the `mask` at `pos`, 2 bit store 1 color\n  function setColor(mask, pos, color) {\n    return mask | (color << (2 * pos))\n  }\n  function dfs(r, curColMask, prevColMask, out) {\n    // Filled full color for a row\n    if(r === m) {\n      out.push(curColMask)\n      return\n    }\n    // Try colors i in [1=RED, 2=GREEN, 3=BLUE]\n    for(let i = 1; i <= 3; i++) {\n      if(getColor(prevColMask, r) !== i && (r === 0 || getColor(curColMask, r - 1) !== i)) {\n        dfs(r + 1, setColor(curColMask, r, i), prevColMask, out)\n      }\n    }\n  }\n  // Generate all possible columns we can draw, if the previous col is `prevColMask`\n  function neighbor(prevColMask) {\n    let out = []\n    dfs(0, 0, prevColMask, out)\n    return out\n  }\n  const mod = 10 ** 9 + 7\n  const memo = {}\n  function dp(c, prevColMask) {\n    // Found a valid way\n    if(c === n) return 1\n    if(memo[`${c},${prevColMask}`] != null) return memo[`${c},${prevColMask}`]\n    let res = 0\n    const arr = neighbor(prevColMask)\n    for(let e of arr) {\n      res = (res + dp(c + 1, e)) % mod\n    }\n    memo[`${c},${prevColMask}`] = res\n    return res\n  }\n  \n  return dp(0, 0)\n  \n};\n\n// another\n\n/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nconst colorTheGrid = function(m, n) {\n  const mod = 10 ** 9 + 7\n  const colors = [1, 2, 3]\n  const memoDp = {}, memoOpts = {}\n  function getColor(pos, preMask) {\n    return (preMask >> (pos * 2)) & 3\n  }\n  function setColor(pos, color, curMask) {\n    return curMask | (color << (pos * 2))\n  }\n  function dfs(pos, curMask, preMask, res) {\n    if(pos === m) {\n      res.push(curMask)\n      return\n    }\n    for(let c of colors) {\n      if(getColor(pos, preMask) !== c && (pos === 0 || getColor(pos - 1, curMask) !== c)) {\n        dfs(pos + 1, setColor(pos, c, curMask), preMask, res)\n      }\n    }\n  }\n  function curOpts(preMask) {\n    if (memoOpts[preMask]) return memoOpts[preMask]\n    const res = []\n    dfs(0, 0, preMask, res)\n    memoOpts[preMask] = res\n    return res\n  }\n  function dp(col, preMask) {\n    const k = `${col},${preMask}`\n    if(col === n) return 1\n    if(memoDp[k]) return memoDp[k]\n    let res = 0\n    const cur = curOpts(preMask)\n    for(let mask of cur) {\n      res = (res + dp(col + 1, mask)) % mod\n    }\n    memoDp[k] = res\n    return res\n  }\n\n  return dp(0, 0)\n};\n"
    }
  },
  {
    "name": "1932-merge-bsts-to-create-single-bst",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode[]} trees\n * @return {TreeNode}\n */\nconst canMerge = function (trees) {\n  const mapRoots = {}\n  const mapLeaves = {}\n  let prev\n\n  //check all trees and hashMap all available roots and leaves\n  for (let node of trees) {\n    mapRoots[node.val] = node\n    if (node.left != null) {\n      if (mapLeaves[node.left.val] != null)\n        //different nodes can't refer to the same node -> abnormal BST\n        return null\n      mapLeaves[node.left.val] = node.left\n    }\n    if (node.right != null) {\n      if (mapLeaves[node.right.val] != null)\n        //different nodes can't refer to the same node -> abnormal BST\n        return null\n      mapLeaves[node.right.val] = node.right\n    }\n  }\n\n  let rootRes = null\n  let count = trees.length\n\n  //find potential root-result of the merged entire tree\n  //that is node without any references from the parent leaf nodes\n  for (let node of trees) {\n    if (mapLeaves[node.val] == null) {\n      rootRes = node\n      break\n    }\n  }\n\n  //if there are no nodes like that -> abnormal BST\n  if (rootRes == null) return rootRes\n\n  const q = []\n\n  //put root-result leaves into queue\n  if (rootRes.left != null) q.push(rootRes.left)\n  if (rootRes.right != null) q.push(rootRes.right)\n  count--\n\n  while (q.length) {\n    //get leaf from the queue and check if there is correponding available root\n    let leaf = q.pop()\n    let root = mapRoots[leaf.val]\n    if (root != null) {\n      //there is root matched to leaf, so let's merge it\n      count--\n      leaf.left = root.left\n      leaf.right = root.right\n      //add new leaves into the queue\n      if (root.left != null) q.push(root.left)\n      if (root.right != null) q.push(root.right)\n    }\n  }\n\n  prev = 0\n  //if we have merged all inputed trees and that is valid BST by values, then return rootRes\n  return count == 0 && recSanity(rootRes) ? rootRes : null\n\n  function recSanity(node) {\n    if (node == null) return true\n\n    if (!recSanity(node.left)) return false\n\n    if (prev >= node.val) return false\n    prev = node.val\n\n    return recSanity(node.right)\n  }\n}\n"
    }
  },
  {
    "name": "1935-maximum-number-of-words-you-can-type",
    "code": {
      "JS": "/**\n * @param {string} text\n * @param {string} brokenLetters\n * @return {number}\n */\nconst canBeTypedWords = function(text, brokenLetters) {\n  const set = new Set(brokenLetters.split(''))\n  const arr = text.split(' ')\n  let res = 0\n  for(let e of arr) {\n    let ok = true\n    for(let c of e) {\n      if(set.has(c)) {\n        ok = false\n        break\n      }\n    }\n    if(ok) res++\n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "1936-add-minimum-number-of-rungs",
    "code": {
      "JS": "/**\n * @param {number[]} rungs\n * @param {number} dist\n * @return {number}\n */\nconst addRungs = function(rungs, dist) {\n  let res = 0\n  let pre = 0\n  const { floor, ceil } = Math\n  for(let r of rungs) {\n    if(r - pre > dist) {\n      // console.log(r, pre)\n      res += ceil((r - pre) / dist) - 1\n    }\n    pre = r\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "1937-maximum-number-of-points-with-cost",
    "code": {
      "JS": "/**\n * @param {number[][]} points\n * @return {number}\n */\nconst maxPoints = function(points) {\n  const m = points.length, n = points[0].length\n  let prev = points[0].slice()\n  for(let i = 1; i < m; i++) {\n    const left = []\n    left[0] = prev[0]\n    // left to right\n    for(let j = 1; j < n; j++) {\n      left[j] = Math.max(prev[j], left[j - 1] - 1)\n    }\n    const right = []\n    right[n - 1] = prev[n - 1]\n    // right to left\n    for(let j = n - 2; j >= 0; j--) {\n      right[j] = Math.max(prev[j], right[j + 1] - 1)\n    }\n\n    const cur = []\n    for(let j = 0; j < n; j++) {\n      cur[j] = Math.max(left[j], right[j]) + points[i][j]\n    }\n    prev = cur\n  }\n\n  return Math.max(...prev)\n};\n\n// another\n\n/**\n * @param {number[][]} points\n * @return {number}\n */\nconst maxPoints = function(points) {\n    let m = points.length, n = points[0].length;\n    let result = 0;\n    // dp\n    const dp = Array.from({ length: m }, () => Array(n).fill(0));\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (i == 0) {\n                dp[i][j] = points[i][j];\n            } else {\n                dp[i][j] = Math.max(points[i][j] + dp[i - 1][j], dp[i][j]);\n            }\n        }\n        for (let j = 0; j < n; j++) {\n            // right\n            for (let k = 1; k < n - j; k++) {\n                if (dp[i][j + k] >= dp[i][j] - k) {\n                    break;\n                }\n                dp[i][j + k] = dp[i][j] - k;\n            }\n            for (let k = 1; k <= j; k++) {\n                if (dp[i][j - k] >= dp[i][j] - k) {\n                    break;\n                }\n                dp[i][j - k] = dp[i][j] - k;\n            }\n        }\n    }\n    for (let j = 0; j < n; j++) {\n        result = Math.max(result, dp[m - 1][j]);\n    }\n    return result;\n};\n"
    }
  },
  {
    "name": "1938-maximum-genetic-difference-query",
    "code": {
      "JS": "/**\n * @param {number[]} parents\n * @param {number[][]} queries\n * @return {number[]}\n */\nconst maxGeneticDifference = function (parents, queries) {\n  let pn = parents.length,\n    qn = queries.length\n  let root = parents.indexOf(-1)\n  let children = initializeGraph(pn)\n  for (let i = 0; i < pn; i++) {\n    if (i != root) {\n      children[parents[i]].push(i)\n    }\n  }\n  let freq = Array(1 << 20).fill(0)\n  let queriesByNode = initializeGraph(pn)\n  for (let i = 0; i < qn; i++) {\n    let query = queries[i]\n    queriesByNode[query[0]].push(new Query(i, query[1]))\n  }\n\n  let res = Array(qn).fill(0)\n  const dfs = (idx) => {\n    let y = (1 << 19) + idx\n    while (y > 0) {\n      freq[y]++\n      y >>= 1\n    }\n    for (const qnode of queriesByNode[idx]) {\n      let j = qnode.index,\n        x = qnode.val\n      let cum = 0\n      let bit = 1 << 18\n      while (bit > 0) {\n        let ii = (((1 << 19) ^ cum ^ x ^ bit) / bit) >> 0\n        if (freq[ii] > 0) cum += bit\n        bit >>= 1\n      }\n      res[j] = cum\n    }\n    for (const child of children[idx]) dfs(child)\n    y = (1 << 19) + idx\n    while (y > 0) {\n      freq[y]--\n      y >>= 1\n    }\n  }\n  dfs(root)\n  return res\n}\n\nconst initializeGraph = (n) => {\n  let G = []\n  for (let i = 0; i < n; i++) G.push([])\n  return G\n}\n\nfunction Query(index, val) {\n  this.index = index\n  this.val = val\n}\n"
    }
  },
  {
    "name": "1941-check-if-all-characters-have-equal-number-of-occurrences",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {boolean}\n */\nvar areOccurrencesEqual = function(s) {\n  const n = s.length\n  const arr = Array(26).fill(0), a = 'a'.charCodeAt(0)\n  for(const ch of s) {\n    arr[ch.charCodeAt(0) - a]++\n  }\n  const set = new Set()\n  for(const e of arr) {\n    if(e !== 0) set.add(e)\n    if(set.size > 1) return false\n  }\n  return true\n};\n"
    }
  },
  {
    "name": "1942-the-number-of-the-smallest-unoccupied-chair",
    "code": {
      "JS": "/**\n * @param {number[][]} times\n * @param {number} targetFriend\n * @return {number}\n */\nvar smallestChair = function (times, targetFriend) {\n  const [targetArrival] = times[targetFriend]\n  const arrivalQueue = times\n  const leavingQueue = [...times]\n  arrivalQueue.sort((a, b) => a[0] - b[0])\n  leavingQueue.sort((a, b) => a[1] - b[1] || a[0] - b[0])\n  const chairsByLeaveTime = new Map()\n  let chairsCount = 0\n  let arriving = 0,\n    leaving = 0\n\n  while (arriving < arrivalQueue.length) {\n    let chairIdx\n    const arrival = arrivalQueue[arriving][0]\n    const leave = leavingQueue[leaving][1]\n    if (arrival < leave) {\n      chairIdx = chairsCount++\n    } else {\n      let freeChairIdx = leaving\n      chairIdx = chairsByLeaveTime.get(leavingQueue[freeChairIdx++][0])\n      while (arrival >= leavingQueue[freeChairIdx][1]) {\n        const nextChair = chairsByLeaveTime.get(leavingQueue[freeChairIdx][0])\n        if (chairIdx > nextChair) {\n          ;[leavingQueue[leaving], leavingQueue[freeChairIdx]] = [\n            leavingQueue[freeChairIdx],\n            leavingQueue[leaving],\n          ]\n          chairIdx = nextChair\n        }\n        ++freeChairIdx\n      }\n      ++leaving\n    }\n    if (targetArrival === arrival) {\n      return chairIdx\n    }\n    chairsByLeaveTime.set(arrival, chairIdx)\n    arriving++\n  }\n}\n"
    }
  },
  {
    "name": "1943-describe-the-painting",
    "code": {
      "JS": "/**\n * @param {number[][]} segments\n * @return {number[][]}\n */\nconst splitPainting = function(segments) {\n  const hash = {}\n  for(let [s, e, c] of segments) {\n    if(hash[s] == null) hash[s] = 0\n    if(hash[e] == null) hash[e] = 0\n    hash[s] += c\n    hash[e] -= c\n  }\n  const keys = Object.keys(hash)\n  keys.sort((a, b) => a - b)\n  let prev, color = 0\n  const res = []\n  for(let k of keys) {\n    if(prev != null && color !== 0) res.push([prev,k,color])\n\n    prev = k\n    color += hash[k]\n  } \n  return res\n};\n"
    }
  },
  {
    "name": "1944-number-of-visible-people-in-a-queue",
    "code": {
      "JS": "/**\n * @param {number[]} heights\n * @return {number[]}\n */\nconst canSeePersonsCount = function(heights) {\n    const ans = new Uint32Array(heights.length);\n    \n    const stack = [];\n    for (let i = heights.length - 1; i >= 0; i--) {\n        const h = heights[i];\n        \n        let del = 0;\n        while (stack.length && stack[stack.length - 1] <= h) {\n            del++;\n            stack.pop();\n        }\n        \n        ans[i] = del + (stack.length ? 1 : 0);\n        stack.push(h);\n    }\n\n    return ans;\n};\n\n// another\n\n/**\n * @param {number[]} heights\n * @return {number[]}\n */\nconst canSeePersonsCount = function(heights) {\n  const stack = [], n = heights.length, res = Array(n)\n  for(let i = n - 1; i >= 0; i--) {\n    const h = heights[i]\n    let del = 0\n    while(stack.length && stack[stack.length - 1] <= h) {\n      stack.pop()\n      del++\n    }\n    res[i] = stack.length ? del + 1 : del\n    stack.push(h)\n  }\n\n  return res\n};\n"
    }
  },
  {
    "name": "1945-sum-of-digits-of-string-after-convert",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nconst getLucky = function(s, k) {\n  let res = 0\n  const a = 'a'.charCodeAt(0)\n  const arr = []\n  for(let ch of s) {\n    arr.push(ch.charCodeAt(0) - a  + 1)\n  }\n  let str = arr.join('').split('').map(e => +e)\n  let prev = str, sum = 0\n  while(k > 0) {\n    // let tmp = 0\n    let tmp = prev.reduce((ac, e) => ac + e, 0)\n    // console.log(tmp)\n    prev = `${tmp}`.split('').map(e => +e)\n    sum = tmp\n    k--\n  }\n  \n  return sum\n};\n"
    }
  },
  {
    "name": "1946-largest-number-after-mutating-substring",
    "code": {
      "JS": "/**\n * @param {string} num\n * @param {number[]} change\n * @return {string}\n */\nconst maximumNumber = function(num, change) {\n  let res = ''\n  const arr = num.split('')\n  let prev = false, cnt = 0\n  for(let i = 0, n = num.length; i < n; i++) {\n    const cur = +num[i]\n    if(change[cur] > cur) {\n      cnt++\n      prev = true\n      arr[i] = change[cur]\n    }\n    if(change[cur] < cur) {\n      if(cnt <= 0) continue\n      else break\n    }\n  }\n  \n  return arr.join('')\n};\n"
    }
  },
  {
    "name": "1947-maximum-compatibility-score-sum",
    "code": {
      "JS": "/**\n * @param {number[][]} students\n * @param {number[][]} mentors\n * @return {number}\n */\nconst maxCompatibilitySum = function(students, mentors) {\n  const n = students.length, dp = Array(1 << n).fill(-Infinity)\n  const m = students[0].length\n  return dfs(0, 0)\n  \n  function dfs(i, mask) {\n    if(i === n) return 0\n    if(dp[mask] !== -Infinity) return dp[mask]\n    for(let j = 0; j < n; j++) {\n      if((mask & (1 << j)) === 0) {\n         dp[mask] = Math.max(dp[mask], calc(i, j) + dfs(i + 1, mask | (1 << j)))\n      }\n    }\n    \n    return dp[mask]\n  }\n  \n  function calc(i, j) {\n    let res = 0\n    const a = students[i], b = mentors[j]\n    for(let k = 0; k < m; k++) {\n      if(a[k] === b[k]) res++\n    }\n    return res\n  }\n};\n\n\n// another\n\n/**\n * @param {number[][]} students\n * @param {number[][]} mentors\n * @return {number}\n */\nconst maxCompatibilitySum = function(students, mentors) {\n  const obj = { res: 0 }, hash = {}\n  bt(students, mentors, 0, 0, obj, hash)\n\n  return obj.res\n};\n\nfunction bt(stu, men, i, score, obj, hash) {\n\n  if(i === stu.length) {\n    if(score > obj.res) {\n      obj.res = score\n    }\n    return\n  }\n  \n  for(let j = 0; j < men.length; j++) {\n    const k = `${j}`\n    if(hash[k] === 1) continue\n    hash[k] = 1\n    bt(stu, men, i + 1, score + calc(stu[i], men[j]), obj, hash)\n    delete hash[k]\n  }\n}\n\nfunction calc(a1, a2) {\n  const n = a1.length\n  let res = 0\n  for(let i = 0; i < n; i++) {\n    if(a1[i] === a2[i]) res++\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "1948-delete-duplicate-folders-in-system",
    "code": {
      "JS": "/**\n * @param {string[][]} paths\n * @return {string[][]}\n */\nconst deleteDuplicateFolder = function(paths) {\n  const trie = new Trie()\n  for (const path of paths) {\n    let cur = trie.trie\n    cur.countPrefix++\n    for (const name of path) {\n      if(cur.children[name] == null) cur.children[name] = new TrieNode(name)\n      cur = cur.children[name]\n      cur.countPrefix++\n    }\n  }\n  const folders = new Map()\n  dfs1(trie.trie)\n  for (const value of folders.values()) {\n    if (value.length > 1) {\n      // found the same dir, mark as to be deleted\n      for (const node of value) {\n        node.countPrefix = 0\n      }\n    }\n  }\n  const ans = []\n  // traverse un-deleted dir, put them to result\n  dfs2(trie.trie, [])\n  return ans\n  function dfs1 (node) {\n    if (Object.keys(node.children).length === 0) {\n      return `(${node.char})`\n    }\n    const childrenExp = []\n    for (const key in node.children) {\n      childrenExp.push(dfs1(node.children[key]))\n    }\n    const exp = childrenExp.sort((a, b) => a.localeCompare(b)).join('')\n    if (!folders.has(exp)) {\n      folders.set(exp, [])\n    }\n    folders.get(exp).push(node)\n    return `(${node.char}${childrenExp.join('')})`\n  }\n  function dfs2 (node, path) {\n    // already deleted, no need go further\n    if (node.countPrefix === 0) {\n      return\n    }\n    if (node.char !== '/') { path.push(node.char) }\n    if (path.length) ans.push([...path])\n    for (const key in node.children) {\n      dfs2(node.children[key], path)\n    }\n    path.pop()\n  } \n};\nclass TrieNode {\n  constructor (char) {\n    this.char = char\n    this.count = 0\n    this.countPrefix = 0\n    this.children = {}\n  }\n};\nclass Trie {\n  /**\n   * @description Initialize the trie\n   */\n  constructor () {\n    this.trie = new TrieNode('/')\n  }\n\n  /**\n   * @description Insert strings into the trie\n   * @param str the string to be inserted\n   * @param count number of `str` to be inserted, can be negative for deleting x from the trie\n   */\n  insert (str, count = 1) {\n    let cur = this.trie\n    for (const char of str) {\n      cur.children[char] ??= new TrieNode(char)\n      cur = cur.children[char]\n      cur.countPrefix += count\n    }\n    cur.count += count\n  }\n\n  /**\n   * Traverse the trie with a callback function\n   * @param str An input string\n   * @param callbackfn A callback function. traverse calls the callbackfn function one time for each char in `str`, however it may skip ending chars in str if the trie has no children to go deeper, the returned char from callbackfn will be used as the direction of traversing\n   * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value\n   */\n  traverse (str, callbackfn, thisArg) {\n    let cur = this.trie\n    for (let i = 0; i < str.length; i++) {\n      const retChar = callbackfn.call(thisArg, str[i], i, cur)\n      const tmp = cur.children[retChar]\n      if (!tmp || tmp.countPrefix <= 0) return\n      cur = tmp\n    }\n  }\n\n  /**\n   * @description Search a string in the trie\n   * @returns Number of `str` in the trie\n   */\n  count (str) {\n    let ans = 0\n    this.traverse(str, (char, idx, node) => {\n      const nextNode = node.children[char]\n      if (idx === str.length - 1 && nextNode) {\n        ans = nextNode.count\n      }\n      return char\n    })\n    return ans\n  }\n\n  /**\n   * @description Search a string in the trie\n   * @returns Number of prefix of `str` in the trie\n   */\n  countPrefix (str) {\n    let ans = 0\n    this.traverse(str, (char, idx, node) => {\n      const nextNode = node.children[char]\n      ans += nextNode?.countPrefix ?? 0\n      return char\n    })\n    return ans\n  }\n};\n"
    }
  },
  {
    "name": "1952-three-divisors",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {boolean}\n */\nconst isThree = function(n) {\n  if(n == 1) return false;\n  let a = ~~Math.sqrt(n);\n  if(n != a * a) return false;\n  for(let i = 2; i < a; i++) {\n      if (n % i == 0)\n          return false;\n  }\n  return true;\n};\n"
    }
  },
  {
    "name": "1953-maximum-number-of-weeks-for-which-you-can-work",
    "code": {
      "JS": "/**\n * @param {number[]} milestones\n * @return {number}\n */\nconst numberOfWeeks = function(milestones) {\n    let sum = 0;\n    for (let i = 0; i < milestones.length; i++) {\n        sum += milestones[i];\n    }\n\n    let cantWork = 0;\n    for (let i = 0; i < milestones.length; i++) {\n        cantWork = Math.max(cantWork, milestones[i] - (sum - milestones[i]) - 1);\n    }\n\n    return sum - cantWork;\n};\n\n// another\n\n/**\n * @param {number[]} milestones\n * @return {number}\n */\nconst numberOfWeeks = function(milestones) {\n  const max = Math.max(...milestones)\n  let sum = 0\n  for(let i = 0; i < milestones.length; i++) {\n    sum += milestones[i]\n  }\n  const res = sum - max\n  \n  return Math.min(sum, res * 2 + 1)\n};\n"
    }
  },
  {
    "name": "1954-minimum-garden-perimeter-to-collect-enough-apples",
    "code": {
      "JS": "/**\n * @param {number} neededApples\n * @return {number}\n */\nvar minimumPerimeter = function(neededApples) {\n    let l = 0, r = 100000;\n    while (l + 1 < r) {\n        let w = (l + r) >> 1;\n        let apples = 2 * w * (w + 1) * (2 * w + 1);\n        if (apples >= neededApples) {\n            r = w;\n        } else {\n            l = w;\n        }\n    }\n\n    return r * 8;  \n};\n"
    }
  },
  {
    "name": "1955-count-number-of-special-subsequences",
    "code": {
      "JS": "/*\n * @lc app=leetcode id=1955 lang=javascript\n *\n * [1955] Count Number of Special Subsequences\n */\n\n// @lc code=start\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst countSpecialSubsequences = function (nums) {\n  const dp = Array(3).fill(0),\n    mod = 10 ** 9 + 7\n  for (let e of nums) {\n    dp[e] = (((dp[e] + dp[e]) % mod) + (e > 0 ? dp[e - 1] : 1)) % mod\n  }\n  return dp[2]\n}\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst countSpecialSubsequences = function(nums) {\n  const mod = 10 ** 9 + 7\n  const dp = Array.from({length: 10 **5 + 1}, () => Array(4).fill(-1))\n  let n = nums.length, a = nums\n  return f(0, 0)\n  function f(index, firstMandatory) {\n      if (index == n && firstMandatory == 3) {\n          return 1;\n      }\n      if (index == n) {\n          return 0;\n      }\n      if (dp[index][firstMandatory] >= 0) {\n          return dp[index][firstMandatory];\n      }\n      let result = 0;\n      if (a[index] == firstMandatory) {\n          result = (result +\n                  f(index + 1, firstMandatory) +\n                  f(index + 1, firstMandatory + 1)\n          ) % mod;\n      }\n      result = (result + f(index + 1, firstMandatory)) % mod;\n\n      return dp[index][firstMandatory] = result;\n  }\n};\n\n\n\n\n\n"
    }
  },
  {
    "name": "1959-minimum-total-space-wasted-with-k-resizing-operations",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nconst minSpaceWastedKResizing = function(nums, k) {\n  const n = nums.length, INF = 200 * 1e6\n  const memo = Array.from({length: n}, () => Array(k))\n  return dp(0, k)\n  \n  function dp(i, k) {\n    if(i === n) return 0\n    if(k < 0) return INF\n    if(memo[i][k] != null) return memo[i][k]\n    let res = INF, max = nums[i], sum = 0\n    for(let j = i; j < n; j++) {\n      max = Math.max(max, nums[j])\n      sum += nums[j]\n      const waste = max * (j - i + 1) - sum\n      res = Math.min(res, dp(j + 1, k - 1) + waste)\n    }\n    return memo[i][k] = res\n  }\n};\n"
    }
  },
  {
    "name": "1960-maximum-product-of-the-length-of-two-palindromic-substrings",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst maxProduct = function (s) {\n  const t1 = helper(s),\n    t2 = helper(reverse(s))\n  let res = 0\n  for (let n = s.length, i = 0, j = n - 2; i < n - 1; ++i, --j)\n    res = Math.max(res, t1[i] * t2[j])\n\n  return res\n}\nfunction reverse(s) {\n  return [...s].reverse().join('')\n}\nfunction helper(s) {\n  const man = manachers(s).filter(\n    (e, i, ar) => i >= 2 && i < ar.length - 2 && i % 2 === 0\n  )\n  const n = s.length,\n    { max } = Math\n  const ints = man.map((e, i) => [i - ~~(e / 2), i + ~~(e / 2)])\n  const arr = Array(n).fill(0)\n  for (const [a, b] of ints) {\n    arr[b] = max(arr[b], b - a + 1)\n  }\n  for (let i = n - 2; i >= 0; i--) {\n    arr[i] = max(arr[i], arr[i + 1] - 2)\n  }\n  let tmp = 0\n  for (let i = 0; i < n; i++) {\n    if (arr[i] > tmp) {\n      tmp = arr[i]\n    } else arr[i] = tmp\n  }\n  return arr\n}\nfunction manachers(s) {\n  const str = `@#${s.split('').join('#')}#$`\n  const arr = Array(str.length).fill(0)\n\n  let center = 0,\n    right = 0\n  for (let i = 1, n = str.length; i < n - 1; i++) {\n    if (i < right) {\n      arr[i] = Math.min(right - i, arr[2 * center - i])\n    }\n    while (str[i + arr[i] + 1] === str[i - arr[i] - 1]) {\n      arr[i] += 1\n    }\n    if (i + arr[i] > right) {\n      center = i\n      right = i + arr[i]\n    }\n  }\n\n  return arr\n}\n"
    }
  },
  {
    "name": "1961-check-if-string-is-a-prefix-of-array",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {string[]} words\n * @return {boolean}\n */\nconst isPrefixString = function(s, words) {\n  let tmp = ''\n  for(let w of words) {\n    tmp += w\n    if(tmp === s) return true\n  }\n  return false\n};\n"
    }
  },
  {
    "name": "1962-remove-stones-to-minimize-the-total",
    "code": {
      "JS": "/**\n * @param {number[]} piles\n * @param {number} k\n * @return {number}\n */\nconst minStoneSum = function(piles, k) {\n  const pq = new PriorityQueue((a, b) => a > b)\n  for(let e of piles) pq.push(e)\n  while(k > 0) {\n    const tmp = pq.pop()\n    const e = tmp - (~~(tmp / 2))\n    pq.push(e)\n    k--\n  }\n  let res = 0\n  while(!pq.isEmpty()) {\n    res += pq.pop()\n  }\n  return res\n};\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n"
    }
  },
  {
    "name": "1963-minimum-number-of-swaps-to-make-the-string-balanced",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst minSwaps = function(s) {\n  const stk = []\n  for (let e of s) {\n    if(e === '[') stk.push(e)\n    else {\n      if(stk.length) {\n        stk.pop()\n      } else stk.push(e)\n    }\n  }\n  return Math.ceil(stk.length / 2)\n};\n\n// another\n\n/**\n * @param {string} s\n * @return {number}\n */\nconst minSwaps = function(s) {\n  const stack = []\n  let num = 0\n  for(let e of s) {\n    if(e === '[') {\n      stack.push(e)\n      num++\n    }\n    if(e === ']') {\n      if(stack[stack.length - 1] === '[') {\n        stack.pop()\n        num--\n      }\n    }\n  }\n  // console.log(num)\n  return Math.ceil(num / 2)\n};\n\n// another\n\n/**\n * @param {string} s\n * @return {number}\n */\nconst minSwaps = function(s) {\n  let num = 0\n  for(let e of s) {\n    if(e === '[') {\n      num++\n    }\n    if(e === ']') {\n      if(num > 0) {\n        num--\n      }\n    }\n  }\n  return Math.ceil(num / 2)\n};\n"
    }
  },
  {
    "name": "1964-find-the-longest-valid-obstacle-course-at-each-position",
    "code": {
      "JS": "/**\n * @param {number[]} obstacles\n * @return {number[]}\n */\nconst longestObstacleCourseAtEachPosition = function(obstacles) {\n  const n = obstacles.length, res = [], stk = []\n  for (let i = 0; i < n; i++) {\n    const cur = obstacles[i]\n    let idx = chk(cur)\n    if (idx === stk.length) {\n      stk.push(cur)\n    } else {\n      stk[idx] = cur\n    }\n    res.push(++idx)\n  }\n\n  return res\n\n  function chk(val) {\n    let l = 0, r = stk.length\n    while(l < r) {\n      const mid = ~~((l + r) / 2)\n      if(stk[mid] <= val) l = mid + 1\n      else r = mid\n    }\n    return l\n  }\n};\n\n// another\n\n/**\n * @param {number[]} obstacles\n * @return {number[]}\n */\nconst longestObstacleCourseAtEachPosition = function(obstacles) {\n  const n = obstacles.length\n  const stack = [], res = []\n  let len = 0\n  \n  for(let i = 0; i < n; i++) {\n    const cur = obstacles[i]\n    const idx = chk(cur)\n    if(idx === len) {\n      stack.push(cur)\n      len++\n      res.push(len)\n    }else {\n      stack[idx] = cur\n      res.push(idx + 1)\n    }\n  }\n\n  return res\n  \n  function chk(x) {\n    if(len && stack[len - 1] <= x) return len\n    let l = 0, r = len - 1\n    while(l < r) {\n      const mid = ~~((l + r) / 2)\n      if(stack[mid] <= x) {\n        l = mid + 1\n      } else {\n        r = mid\n      }\n    }\n    return l\n  }\n};\n\n\n\n\n// another\n\n/**\n * @param {number[]} obstacles\n * @return {number[]}\n */\nconst longestObstacleCourseAtEachPosition = function(obstacles) {\n  const n = obstacles.length\n  const stack = [], res = Array(n).fill(0)\n  let m = 0\n  let j = 0;\n  for (let x of obstacles) {\n    let i = chk(x);\n    if (i == m) {\n      ++m;\n      stack.push(x);\n    } else {\n      stack[i] = x;\n    }\n    res[j++] = i + 1;\n  }\n  return res;\n  function chk(x) {\n      if (m && stack[m - 1] <= x) return m;\n      let l = 0, r = m - 1;\n      while (l < r) {\n        let m = (l + r) >> 1;\n        if (stack[m] > x) {\n          r = m;\n        } else {\n          l = m + 1;\n        }\n      }\n      return l;\n  }\n};\n\n"
    }
  },
  {
    "name": "1969-minimum-non-zero-product-of-the-array-elements",
    "code": {
      "JS": "/**\n * @param {number} p\n * @return {number}\n */\nconst minNonZeroProduct = function (p) {\n  const MOD = BigInt(10 ** 9 + 7), bp = BigInt(p)\n  const bpm = BigInt(1n << bp) - 1n, base = BigInt(1n << bp) - 2n, pow = BigInt(1n << (bp - 1n)) - 1n \n  return Number((bpm % MOD) * fastPow(base, pow, MOD) % MOD)\n\n}\n\nfunction fastPow(base, power, mod) {\n  if(power === 0n) return 1n\n  base %= mod\n  let res = fastPow(base, power / 2n, mod)\n  res = (res * res) % mod\n  if(power & 1n) res = (res * base) % mod\n  return res\n}\n\n\n// another\n\n\n/**\n * @param {number} p\n * @return {number}\n */\nconst minNonZeroProduct = function (p) {\n  const b = BigInt(p)\n  const mod = BigInt(10 ** 9 + 7)\n\n  return (\n    (((BigInt(1n << b) - 1n) % mod) *\n      pow(BigInt(1n << b) - 2n, BigInt(1n << (b - 1n)) - 1n)) %\n    mod\n  )\n\n  function pow(a, n) {\n    let r = 1n\n    a %= mod\n    while (n > 0n) {\n      r = (r * a) % mod\n      a = (a * a) % mod\n      n /= 2n\n    }\n    return r\n  }\n}\n"
    }
  },
  {
    "name": "1970-last-day-where-you-can-still-cross",
    "code": {
      "JS": "/**\n * @param {number} row\n * @param {number} col\n * @param {number[][]} cells\n * @return {number}\n */\nconst latestDayToCross = function (row, col, cells) {\n  let l = 0,\n    n = cells.length,\n    r = n\n  while (l < r) {\n    const mid = ~~((l + r) / 2)\n    if (canWalk(mid)) {\n      l = mid + 1\n    } else {\n      r = mid\n    }\n  }\n\n  return l\n\n  function canWalk(mid) {\n    const grid = Array.from({ length: row }, () => Array(col).fill(0))\n    const dirs = [\n      [1, 0],\n      [-1, 0],\n      [0, 1],\n      [0, -1],\n    ]\n    for (let i = 0; i <= mid; i++) {\n      const [r, c] = cells[i]\n      grid[r - 1][c - 1] = 1\n    }\n\n    let q = []\n\n    for (let i = 0; i < col; i++) {\n      if (grid[0][i] === 0) {\n        q.push([0, i])\n        grid[0][i] = 1\n      }\n    }\n\n    while (q.length) {\n      const size = q.length,\n        tmp = []\n      for (let i = 0; i < size; i++) {\n        const [r, c] = q[i]\n        if (r === row - 1) return true\n        for (let [dr, dc] of dirs) {\n          const nr = r + dr,\n            nc = c + dc\n          if (nr < 0 || nr >= row || nc < 0 || nc >= col || grid[nr][nc] === 1)\n            continue\n          tmp.push([nr, nc])\n          grid[nr][nc] = 1\n        }\n      }\n      q = tmp\n    }\n\n    return false\n  }\n}\n"
    }
  },
  {
    "name": "1971-find-if-path-exists-in-graph",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @param {number} start\n * @param {number} end\n * @return {boolean}\n */\nconst validPath = function(n, edges, start, end) {\n  const graph = {}\n  for(const [u, v] of edges) {\n    if(graph[u] == null) graph[u] = new Set()\n    if(graph[v] == null) graph[v] = new Set()\n    graph[u].add(v)\n    graph[v].add(u)\n  }\n  const q = [start], visited = new Set()\n  visited.add(start)\n  while(q.length) {\n    const cur = q.shift()\n    if(cur === end) return true\n    for(const next of graph[cur]) {\n      if(visited.has(next)) continue\n      q.push(next)\n      visited.add(next)\n    }\n  }\n\n  return false\n};\n"
    }
  },
  {
    "name": "1976-number-of-ways-to-arrive-at-destination",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[][]} roads\n * @return {number}\n */\nconst countPaths = function(n, roads) {\n  const graph = {}\n  for(let r of roads) {\n    const [u, v, t] = r\n    if(graph[u] == null) graph[u] = []\n    if(graph[v] == null) graph[v] = []\n    graph[u].push([v, t])\n    graph[v].push([u, t])\n  }\n  \n  return dijkstra(graph, n, 0)\n\n  function dijkstra(graph, n, src) {\n    const dist = Array(n).fill(Infinity)\n    const ways = Array(n).fill(0), mod = 1e9 + 7\n    ways[src] = 1\n    dist[src] = 0\n    const pq = new PriorityQueue((a, b) => a[0] === b[0] ? a[1] < b[1] : a[0] < b[0])\n    pq.push([0, 0])\n    while(!pq.isEmpty()) {\n      const [d, u] = pq.pop()\n      if(d > dist[u]) continue\n      if(graph[u] == null) graph[u] = []\n      for(const [v, time] of graph[u]) {\n        if(dist[v] > d + time) {\n          ways[v] = ways[u]\n          dist[v] = d + time\n          pq.push([dist[v], v])\n        } else if(dist[v] === d + time) {\n          ways[v] = (ways[v] + ways[u]) % mod\n        }\n      }\n    }\n    return ways[n - 1]\n  }\n  \n};\n  \nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n\n// another\n\n/**\n * @param {number} n\n * @param {number[][]} roads\n * @return {number}\n */\nconst countPaths = function(n, roads) {\n  const graph = {}, MOD = 1e9 + 7\n  for(const [u, v, t] of roads) {\n    if(graph[u] == null) graph[u] = {}\n    if(graph[v] == null) graph[v] = {}\n    graph[u][v] = t\n    graph[v][u] = t\n  }\n\n  return dijkstra(graph, n, 0)\n\n  function dijkstra(graph, n, src) {\n    const dist = Array(n).fill(Infinity)\n    const ways = Array(n).fill(0)\n    ways[src] = 1\n    dist[src] = 0\n    const pq = new PriorityQueue((a, b) => a[0] < b[0])\n    pq.push([0, 0])\n    while(!pq.isEmpty()) {\n      const [d, u] = pq.pop()\n      if(d > dist[u]) continue\n      for(const next of Object.keys(graph[u] || {})) {\n        const val = graph[u][next]\n        if(dist[next] > d + val) {\n          dist[next] = d + val\n          ways[next] = ways[u]\n          pq.push([dist[next], next])\n        } else if(dist[next] === d + val) {\n          ways[next] = (ways[next] + ways[u]) % MOD\n        }\n      }\n    }\n\n    return ways[n - 1]\n  }\n};\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n"
    }
  },
  {
    "name": "1977-number-of-ways-to-separate-numbers",
    "code": {
      "JS": "/**\n * @param {string} num\n * @return {number}\n */\nfunction numberOfCombinations(num) {\n  let dpArr = Array(3501).fill(0),\n    dp = Array(3501).fill(0),\n    prefix = Array(3501).fill(0),\n    n = num.length,\n    mod = 1e9 + 7\n  for (let l = 1; l <= n; ++l) {\n    dp[0] = 1\n    for (let i = n; i - l > 0; --i)\n      prefix[i - 1] = num[i - 1 - l] === num[i - 1] ? prefix[i] + 1 : 0\n    for (let i = 0; i < n; ++i) {\n      dpArr[i + 1] = dp[i + 1]\n      if (l <= i + 1 && num[i + 1 - l] != '0') {\n        if (\n          i + 1 - 2 * l >= 0 &&\n          (prefix[i + 1 - l] >= l ||\n            num[i + 1 - l + prefix[i + 1 - l]] > num[i + 1 - 2 * l + prefix[i + 1 - l]])\n        )\n          dpArr[i + 1] = (dpArr[i + 1] + dpArr[i + 1 - l]) % mod\n        else dpArr[i + 1] = (dpArr[i + 1] + dp[i + 1 - l]) % mod\n      }\n    }\n    const tmp = dp\n    dp = dpArr\n    dpArr = tmp\n  }\n  return dp[n]\n}\n"
    }
  },
  {
    "name": "1979-find-greatest-common-divisor-of-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst findGCD = function(nums) {\n  let min = Math.min(...nums)\n  let max = Math.max(...nums)\n  return gcd(min, max)\n};\n\nfunction gcd(a, b) {\n  return b === 0 ? a : gcd(b, a % b)\n}\n"
    }
  },
  {
    "name": "198-house-robber",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nfunction rob(nums) {\n    if (nums.length == 0) return 0;\n    let prev1 = 0;\n    let prev2 = 0;\n    for (let num of nums) {\n        let tmp = prev1;\n        prev1 = Math.max(prev2 + num, prev1);\n        prev2 = tmp;\n    }\n    return prev1;\n}\n"
    }
  },
  {
    "name": "1980-find-unique-binary-string",
    "code": {
      "JS": "/**\n * @param {string[]} nums\n * @return {string}\n */\nconst findDifferentBinaryString = function(nums) {\n  const set = new Set(nums)\n  const len = nums[0].length\n  for(let i = 0, n = 1 << 17; i < n; i++) {\n    const tmp = pad(bin(i), len)\n    if(!set.has(tmp)) return tmp\n  }\n  return ''\n};\n\nfunction bin(num) {\n  return (num >>> 0).toString(2)\n}\n\nfunction pad(str,n) {\n  while(str.length < n) str = '0' + str\n  return str\n}\n"
    }
  },
  {
    "name": "1981-minimize-the-difference-between-target-and-chosen-elements",
    "code": {
      "JS": "/**\n * @param {number[][]} mat\n * @param {number} target\n * @return {number}\n */\nconst minimizeTheDifference = function(mat, target) {\n  const m = mat.length, n = mat[0].length\n  const dp = Array.from({length: m}, () => Array(70*70).fill(-1))\n  return fn(0, 0)\n  \n  function fn(row, sum) {\n    if(row === m) return Math.abs(target - sum)\n    if(dp[row][sum] !== -1) return dp[row][sum]\n    let res = Number.MAX_SAFE_INTEGER\n    for(let j = 0; j < n; j++) {\n      res = Math.min(res, fn(row + 1, sum + mat[row][j]))\n    }\n    return dp[row][sum] = res\n  }\n};\n\n// another\n\n/**\n * @param {number[][]} mat\n * @param {number} target\n * @return {number}\n */\nconst minimizeTheDifference = function(mat, target) {\n  const m = mat.length, n = mat[0].length\n  const memo = Array.from({ length: m }, () => Array())\n  return dfs(0, 0)\n  \n  function dfs(row, sum) {\n    if(row === m) return Math.abs(target - sum)\n    if(memo[row][sum] != null) return memo[row][sum]\n    let res = Number.MAX_SAFE_INTEGER\n    for(let i = 0; i < n; i++) {\n      res = Math.min(res, dfs(row + 1, sum + mat[row][i]))\n    }\n    \n    return memo[row][sum] = res\n  }\n};\n\n\n\n"
    }
  },
  {
    "name": "1982-find-array-given-subset-sums",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[]} sums\n * @return {number[]}\n */\nconst recoverArray = function(n, sums) {\n  const res = []\n  sums.sort((a, b)  => a - b)\n  while(res.length < n) {\n    const used = Array(sums.length).fill(false)\n    const v0 = [], v1 = []\n    let d = sums[1] - sums[0]\n    for(let i = 0, j = 1; ;i++, j++) {\n      while(i < sums.length && used[i]) i++\n      if(i === sums.length) break\n      while(j <= i || sums[j] !== sums[i] + d) j++\n      v0.push(sums[i])\n      v1.push(sums[j])\n      used[i] = used[j] = true\n    }\n    \n    if(bs(v0, 0)) {\n      res.push(d)\n      sums = v0\n    }else {\n      res.push(-d)\n      sums = v1\n    }\n  }\n  return res\n};\n\n\nfunction bs(arr, e) {\n  let l = 0, r = arr.length - 1\n  while(l < r) {\n    const mid = ~~((l + r) / 2)\n    if(arr[mid] < e) l = mid + 1\n    else r = mid\n  }\n  \n  return arr[l] === e\n}\n\n// another\n\n/**\n * @param {number} n\n * @param {number[]} sums\n * @return {number[]}\n */\nconst recoverArray = function(n, sums) {\n  const res = []\n  sums.sort((a, b) => a - b)\n  \n  while(res.length < n) {\n    const visited = Array(sums.length).fill(false)\n    const a1 = [], a2 = []\n    const d = sums[1] - sums[0]\n    for(let i = 0, j = 1; i < sums.length; i++, j++) {\n      while(i < sums.length && visited[i]) i++\n      if(i === sums.length) break\n      while(j <= i || sums[j] !== sums[i] + d) j++\n      a1.push(sums[i])\n      a2.push(sums[j])\n      visited[i] = visited[j] = true\n    }\n    \n    if(bs(a1, 0)) {\n      sums = a1\n      res.push(d)\n    } else {\n      sums = a2\n      res.push(-d)\n    }\n  }\n  \n  return res\n};\n\nfunction bs(arr, val) {\n  let l = 0, r = arr.length - 1\n  while(l < r) {\n    const mid = ~~((l + r) / 2)\n    if(arr[mid] < val) l = mid + 1\n    else r = mid\n  }\n  \n  return arr[l] === val\n}\n\n// another\n\n/**\n * @param {number} n\n * @param {number[]} sums\n * @return {number[]}\n */\nconst recoverArray = function(n, sums) {\n  const res = []\n  sums.sort((a, b) => a - b)\n  \n  while(res.length < n) {\n    const m = sums.length, visited = Array(m).fill(false)\n    let a1 = [], a2 = [], delta = sums[1] - sums[0]\n    for(let i = 0, j = 1; i < m && j < m; i++, j++) {\n      while(i < m && visited[i]) i++\n      if(i === m) break\n      while(i >= j || sums[j] !== sums[i] + delta) j++\n      if(j === m) break\n      a1.push(sums[i])\n      a2.push(sums[j])\n      visited[i] = visited[j] = true\n    }\n    if(binarySearch(a1, 0)) {\n      sums = a1\n      res.push(delta)\n    } else {\n      sums = a2\n      res.push(-delta)\n    }\n  }\n  return res\n  \n  function binarySearch(arr, val) {\n    let l = 0, r = arr.length - 1\n    while(l < r) {\n      const mid = ~~((l + r) / 2)\n      if(arr[mid] < val) l = mid + 1\n      else r = mid\n    }\n    return arr[l] === val\n  }\n};\n"
    }
  },
  {
    "name": "1984-minimum-difference-between-highest-and-lowest-of-k-scores",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nconst minimumDifference = function(nums, k) {\n  nums.sort((a, b) => a - b)\n  let res = Infinity\n  for(let i = 0, n = nums.length; i < n - k + 1; i++) {\n    res = Math.min(res, nums[i + k - 1] - nums[i])\n  }\n  \n  return res\n  \n};\n"
    }
  },
  {
    "name": "1985-find-the-kth-largest-integer-in-the-array",
    "code": {
      "JS": "/**\n * @param {string[]} nums\n * @param {number} k\n * @return {string}\n */\nconst kthLargestNumber = function(nums, k) {\n  nums.sort((a, b) => BigInt(b) - BigInt(a) === 0n ? 0 : (BigInt(b) - BigInt(a) > 0n ? 1 : -1) )\n  return nums[k - 1]\n};\n"
    }
  },
  {
    "name": "1986-minimum-number-of-work-sessions-to-finish-the-tasks",
    "code": {
      "JS": "/**\n * @param {number[]} tasks\n * @param {number} sessionTime\n * @return {number}\n */\nconst minSessions = function(tasks, sessionTime) {\n  const n = tasks.length\n  const dp = Array.from({ length: 1 << 14 }, () => Array(16).fill(-1))\n  return fn(0, 0)\n  \n  function fn(mask, consumed) {\n    if (mask === (1 << n) - 1) {\n      return consumed === 0 ? 0 : 1\n    }\n    if (dp[mask][consumed] !== -1) {\n     return dp[mask][consumed];\n    }\n\n    let result = Number.MAX_VALUE;\n    if (consumed > 0) {\n        result = Math.min(result, 1 + fn(mask, 0));\n    }\n    for (let i = 0; i < n; i++) {\n        if ((mask & (1 << i)) === 0 && consumed + tasks[i] <= sessionTime) {\n            result = Math.min(result, fn(mask | (1 << i), consumed + tasks[i]));\n        }\n    }\n    return dp[mask][consumed] = result;\n  }\n};\n\n// another\n\n/**\n * @param {number[]} tasks\n * @param {number} sessionTime\n * @return {number}\n */\nfunction minSessions(tasks, sessionTime) {\n  const n = tasks.length\n  const memo = Array.from({ length: 1 << n }, () => Array(15))\n  return helper((1 << n) - 1, 0)\n\n  function helper(mask, remain) {\n    if(mask === 0) return 0\n    if(memo[mask][remain] != null) return memo[mask][remain]\n    let res = n\n    \n    for(let i = 0; i < n; i++) {\n      if((1 << i) & mask) {\n        const newMask = mask & (~(1 << i))\n        if(tasks[i] <= remain) {\n          res = Math.min(res, helper(newMask, remain - tasks[i]))\n        } else {\n          res = Math.min(res, helper(newMask, sessionTime - tasks[i]) + 1)\n        }\n      }\n    }\n\n    return memo[mask][remain] = res\n  }\n}\n"
    }
  },
  {
    "name": "1987-number-of-unique-good-subsequences",
    "code": {
      "JS": "/**\n * @param {string} binary\n * @return {number}\n */\nconst numberOfUniqueGoodSubsequences = function (binary) {\n  const n = binary.length,\n    P = 1e9 + 7\n  let first1Position = -1,\n    first0Position = -1\n  for (let i = 0; i < binary.length; i++) {\n    if (binary[i] === '0' && first0Position == -1) {\n      first0Position = i\n    }\n    if (binary[i] === '1' && first1Position == -1) {\n      first1Position = i\n    }\n    if(first0Position !== -1 && first1Position !== -1) break\n  }\n  if (first1Position === -1) return 1\n  if (first0Position === -1) return n\n\n  const next0 = new Array(n).fill(0)\n  const next1 = new Array(n).fill(0)\n  let nextZero = -1,\n    nextOne = -1\n  for (let i = binary.length - 1; i >= 0; i--) {\n    next0[i] = nextZero\n    next1[i] = nextOne\n    if (binary[i] === '0') {\n      nextZero = i\n    } else {\n      nextOne = i\n    }\n  }\n  const dp = new Array(n).fill(-1)\n  return (1 + fn(first1Position)) % P\n\n  function fn(index) {\n    if (index == n) return 0\n    if (dp[index] !== -1) return dp[index]\n    let result = 1\n    if (next0[index] >= 0) {\n      result += fn(next0[index])\n      result %= P\n    }\n    if (next1[index] >= 0) {\n      result += fn(next1[index])\n      result %= P\n    }\n    return (dp[index] = result)\n  }\n}\n\n// another\n\n/**\n * @param {string} binary\n * @return {number}\n */\nconst numberOfUniqueGoodSubsequences = function (binary) {\n  const n = binary.length,\n    mod = 1e9 + 7\n  let hasZero = 0, ends1 = 0, ends0 = 0\n  for(let ch of binary) {\n    if(ch === '1') {\n      ends1 = (ends1 + ends0 + 1) % mod\n    } else {\n      ends0 = (ends1 + ends0) % mod\n      hasZero = 1\n    }\n  }\n  return (ends1 + ends0 + hasZero) % mod\n}\n\n"
    }
  },
  {
    "name": "199-binary-tree-right-side-view",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nconst rightSideView = function(root) {\n  if(root == null) return []\n  const queue = [root]\n  const res = []\n  while(queue.length) {\n    const len = queue.length\n    for(let i = 0; i < len; i++) {\n      const el = queue.shift()\n      if(i === len - 1) res.push(el.val)\n      if(el.left) queue.push(el.left)\n      if(el.right) queue.push(el.right)\n    }\n  }\n  return res\n};\n\n// another\n\nconst rightSideView = function(root) {\n  const res = []\n  const helper = function(node, level) {\n    if (!node) {\n      return\n    }\n    if (!res[level]) {\n      res.push(node.val)\n    }\n    helper(node.right, level + 1)\n    helper(node.left, level + 1)\n  }\n  helper(root, 0)\n  return res\n}\n"
    }
  },
  {
    "name": "1991-find-the-middle-index-in-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst findMiddleIndex = function(nums) {\n  const n = nums.length\n  const sum = nums.reduce((ac, e) => ac + e, 0) \n  \n  let res, leftSum = 0\n  for(let i = 0; i < n; i++) {\n    if(leftSum === sum - leftSum - nums[i]) {\n      res = i\n      break\n    }\n    leftSum += nums[i]\n  }\n\n  return res == null ? -1 : res\n};\n"
    }
  },
  {
    "name": "1994-the-number-of-good-subsets",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst numberOfGoodSubsets = function (nums) {\n  const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n  const n = nums.length,\n    cnt = {},\n    mod = BigInt(1e9 + 7)\n  const bm = []\n  for (let num of nums) {\n    cnt[num] = (cnt[num] || 0n) + 1n\n  }\n  for (let i = 0; i < 31; i++) {\n    let tmp = 0\n    for (let j = 0, m = primes.length; j < m; j++) {\n      const p = primes[j]\n      if (i % p === 0) tmp += 1 << j\n    }\n    bm[i] = tmp\n  }\n  const bad = new Set([4, 8, 9, 12, 16, 18, 20, 24, 25, 27, 28])\n  const memo = {}\n\n  function dp(mask, num) {\n    if (num === 1) return 1n\n    if (memo[mask] && memo[mask][num] != null) return memo[mask][num]\n    let res = dp(mask, num - 1)\n    if (!bad.has(num) && (mask | bm[num]) === mask) {\n      res += dp(mask ^ bm[num], num - 1) * (cnt[num] || 0n)\n    }\n    if (memo[mask] == null) memo[mask] = {}\n    return (memo[mask][num] = res % mod)\n  }\n\n  return ((dp(1023, 30) - 1n) * pow(2n, cnt[1] || 0n, mod)) % mod\n}\n\nfunction pow(base, exp, mod) {\n  if (exp === 0n) return 1n\n  // console.log(base, mod)\n  base %= mod\n  let res = pow(base, exp / 2n, mod)\n  res = (res * res) % mod\n  if (exp & 1n) res = (res * base) % mod\n  return res\n}\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst numberOfGoodSubsets = function (nums) {\n  const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n  const n = nums.length,\n    cnt = {},\n    mod = BigInt(1e9 + 7)\n  const bm = []\n  for (let num of nums) {\n    cnt[num] = (cnt[num] || 0n) + 1n\n  }\n  for (let i = 0; i < 31; i++) {\n    let tmp = 0\n    for (let j = 0, m = primes.length; j < m; j++) {\n      const p = primes[j]\n      if (i % p === 0) tmp += 1 << j\n    }\n    bm[i] = tmp\n  }\n  const bad = new Set([4, 8, 9, 12, 16, 18, 20, 24, 25, 27, 28])\n  const memo = {}\n\n  function dp(mask, num) {\n    if (num === 1) return 1n\n    if (memo[mask] && memo[mask][num] != null) return memo[mask][num]\n    let res = dp(mask, num - 1)\n    if (!bad.has(num) && (mask | bm[num]) === mask) {\n      res += dp(mask ^ bm[num], num - 1) * (cnt[num] || 0n)\n    }\n    if (memo[mask] == null) memo[mask] = {}\n    return (memo[mask][num] = res % mod)\n  }\n\n  return ((dp(1023, 30) - 1n) * pow(2n, cnt[1] || 0n, mod)) % mod\n}\n\nfunction pow(base, exp, mod) {\n  if (exp === 0n) return 1n\n  // console.log(base, mod)\n  base %= mod\n  let res = pow(base, exp / 2n, mod)\n  res = (res * res) % mod\n  if (exp & 1n) res = (res * base) % mod\n  return res\n}\n"
    }
  },
  {
    "name": "1995-count-special-quadruplets",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst countQuadruplets = function(nums) {\n  let res = 0\n  for(let a = 0, n = nums.length; a < n - 3; a++) {\n    for(let b = a + 1; b < n - 2; b++) {\n      for(let c = b + 1; c < n - 1; c++) {\n        for(let d = c + 1; d < n; d++) {\n          if(nums[a] + nums[b] + nums[c] === nums[d]) res++\n        }\n      }\n    }\n  }\n  \n  \n  return res\n  \n};\n"
    }
  },
  {
    "name": "1996-the-number-of-weak-characters-in-the-game",
    "code": {
      "JS": "/**\n * @param {number[][]} properties\n * @return {number}\n */\nconst numberOfWeakCharacters = function(properties) {\n  properties.sort((a, b) => a[0] - b[0] || b[1] - a[1])\n  let stack = [], res = 0\n\n  for(let i = 0, n = properties.length; i < n; i++) {\n    while(stack.length && stack[stack.length - 1] < properties[i][1]) {\n      stack.pop()\n      res++\n    }\n    stack.push(properties[i][1])\n  }\n  \n  return res\n};\n\n// another\n\n/**\n * @param {number[][]} properties\n * @return {number}\n */\nconst numberOfWeakCharacters = function(properties) {\n    if (properties == null || properties.length == 0) {\n        return 0;\n    }\n    properties.sort((o1, o2) => {\n        if (o1[0] == o2[0]) {\n            return o1[1] - o2[1];\n        }\n        return o1[0] - o2[0];\n    });\n  const { max } = Math\n    let mmax = Array(1e5 + 10).fill( 0);\n    let ans = 0;\n    let n = properties.length;\n    for (let i = n - 1; i >= 0; i--) mmax[properties[i][0]] = max(properties[i][1], mmax[properties[i][0]]);\n    for (let i = 1e5; i >= 1; i--) mmax[i] = max(mmax[i], mmax[i + 1]);\n    for (let i = 0; i < n; i++) {\n        if (mmax[properties[i][0] + 1] > properties[i][1]) ans++;\n    }\n    return ans;\n};\n\n// another\n\n/**\n * @param {number[][]} properties\n * @return {number}\n */\nconst numberOfWeakCharacters = function(properties) {\n  properties.sort((a, b) => a[0] === b[0] ? b[1] - a[1] : a[0] - b[0])\n  let max = -Infinity, res = 0\n  for(let n = properties.length, i = n - 1; i >= 0; i--) {\n    const [a, d] = properties[i]\n    if(d < max) res++\n    max = Math.max(max, d)\n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "1997-first-day-where-you-have-been-in-all-the-rooms",
    "code": {
      "JS": "/**\n * @param {number[]} nextVisit\n * @return {number}\n */\nconst firstDayBeenInAllRooms = function(nextVisit) {\n        const P = 1e9+7;\n        const n = nextVisit.length;\n        const f = Array(n).fill(0) ;\n        f[0] = 0;\n\n        for (let i = 1; i < n; i++) {\n            f[i] = ((\n                    (2 * f[i - 1]) % P\n                            + P - f[nextVisit[i - 1]]) % P + 2) % P;\n        }\n\n        return f[n - 1];\n};\n\n// another\n\n/**\n * @param {number[]} nextVisit\n * @return {number}\n */\nconst firstDayBeenInAllRooms = function(nextVisit) {\n  const mod = 1e9 + 7\n  const n = nextVisit.length\n  const dp = Array(n).fill(0)\n  for(let i = 1; i < n; i++) {\n    // i - 1 ---> nextVisit[i - 1] ---> i - 1 ---> i\n    dp[i] = (dp[i - 1] + 1 + dp[i - 1] - dp[nextVisit[i - 1]] + 1 + mod) % mod\n  }\n  \n  return dp[n - 1]\n};\n"
    }
  },
  {
    "name": "1998-gcd-sort-of-an-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nconst gcdSort = function(nums) {\n  const spf = Array(nums.length).fill(0)\n         let maxNum = Math.max(...nums);\n        sieve(maxNum);\n\n        const uf = new UnionFind(maxNum+1);\n        for (let x of nums) {\n            for (let f of getFactors(x)) uf.union(f, x);          \n        }\n\n\n        const sortedArr = nums.slice();\n        sortedArr.sort((a, b) => a - b)\n\n        for (let i = 0; i < nums.length; ++i) {\n            let pu = uf.find(sortedArr[i]);\n            let pv = uf.find(nums[i]);\n            if (pu != pv) return false; // can't swap nums[i] with sortedArr[i]\n        }\n        return true;\n  \n  function sieve( n) { // O(Nlog(logN)) ~ O(N)\n    for (let i = 2; i <= n; ++i) spf[i] = i;\n    for (let i = 2; i * i <= n; i++) {\n      if (spf[i] != i) continue; // skip if `i` is not a prime number\n      for (let j = i * i; j <= n; j += i) {\n        if (spf[j] == j) { // marking spf[j] if it is not previously marked\n          spf[j] = i;\n        }\n      }\n    }\n  }\n  \n  function getFactors(n) { // O(logN)\n    const factors = [];\n    while (n > 1) {\n      factors.push(spf[n]);\n      n = ~~(n /spf[n]);\n    }\n    return factors;\n  }\n};\n\nfunction gcd( x,  y) {\n    return y == 0 ? x : gcd(y, x % y);\n}\n\nclass UnionFind {\n    constructor(n) {\n        this.parent = [];\n        for (let i = 0; i < n; i++) this.parent[i] = i;\n    }\n    find(x) {\n        if (x == this.parent[x]) return x;\n        return this.parent[x] = this.find(this.parent[x]); // Path compression\n    }\n    union( u,  v) {\n        let pu = this.find(u), pv = this.find(v);\n        if (pu != pv) this.parent[pu] = pv;\n    }\n};\n\n"
    }
  },
  {
    "name": "2-add-two-numbers",
    "code": {
      "JS": "/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} l1\r\n * @param {ListNode} l2\r\n * @return {ListNode}\r\n */\r\nconst addTwoNumbers = function(l1, l2) {\r\n  let res = new ListNode(null)\r\n  let inc = false\r\n  let cur = res\r\n  while(l1 || l2 || inc) {\r\n    const tmp = ((l1 && l1.val) || 0) + ((l2 && l2.val) || 0) + (inc ? 1 : 0)\r\n    if(tmp >= 10) inc = true\r\n    else inc = false\r\n    cur.next = new ListNode(tmp % 10)\r\n    cur = cur.next\r\n    if(l1) l1 = l1.next\r\n    if(l2) l2 = l2.next\r\n  }\r\n  \r\n  return res.next\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} l1\r\n * @param {ListNode} l2\r\n * @return {ListNode}\r\n */\r\nconst addTwoNumbers = function(l1, l2) {\r\n  const res = new ListNode(null);\r\n  single(l1, l2, res);\r\n  return res.next;\r\n};\r\n\r\nfunction single(l1, l2, res) {\r\n  let cur;\r\n  let addOne = 0;\r\n  let sum = 0;\r\n  let curVal = 0;\r\n  while (l1 || l2 || addOne) {\r\n    sum = ((l1 && l1.val) || 0) + ((l2 && l2.val) || 0) + addOne;\r\n    if (sum / 10 >= 1) {\r\n      curVal = sum % 10;\r\n      addOne = 1;\r\n    } else {\r\n      curVal = sum;\r\n      addOne = 0;\r\n    }\r\n\r\n    if (cur) {\r\n      cur = cur.next = new ListNode(curVal);\r\n    } else {\r\n      cur = res.next = new ListNode(curVal);\r\n    }\r\n\r\n    if (l1) {\r\n      l1 = l1.next;\r\n    }\r\n    if (l2) {\r\n      l2 = l2.next;\r\n    }\r\n  }\r\n}\r\n\r\n// another\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} l1\r\n * @param {ListNode} l2\r\n * @return {ListNode}\r\n */\r\nconst addTwoNumbers = function(l1, l2) {\r\n  let extra = false\r\n  const dummy = new ListNode()\r\n  let cur = dummy\r\n  while(l1 || l2) {\r\n    let val = 0\r\n    if(l1) val += l1.val\r\n    if(l2) val += l2.val\r\n    if(extra) val += 1\r\n      \r\n    if(val > 9) {\r\n      extra = true\r\n      val = val % 10\r\n    } else {\r\n      extra = false\r\n    }\r\n    cur.next = new ListNode(val)\r\n    cur = cur.next\r\n    if(l1) l1 = l1.next\r\n    if(l2) l2 = l2.next\r\n  }\r\n\r\n  if(extra) cur.next = new ListNode(1)\r\n  return dummy.next\r\n};\r\n\r\n\r\n"
    }
  },
  {
    "name": "20-valid-parentheses",
    "code": {
      "JS": "/**\r\n * @param {string} s\r\n * @return {boolean}\r\n */\r\n const isValid = function(s) {\r\n  const stack = []\r\n  for(let c of s) {\r\n    if(c === '(') stack.push(')')\r\n    else if(c === '{') stack.push('}')\r\n    else if(c === '[') stack.push(']')\r\n    else if(stack.length === 0 || c !== stack.pop()) return false\r\n  }\r\n  return stack.length === 0\r\n};\r\n\r\n\r\n// another\r\n\r\n/**\r\n * @param {string} s\r\n * @return {boolean}\r\n */\r\n const isValid = function(s) {\r\n  const stack = []\r\n  const n = s.length\r\n  for(let c of s) {\r\n    if(c === '(' || c === '{' || c === '[') stack.push(c)\r\n    else if(c === ')') {\r\n      if(stack[stack.length - 1] === '(') stack.pop()\r\n      else return false\r\n    }\r\n    else if(c === '}') {\r\n      if(stack[stack.length - 1] === '{') stack.pop()\r\n      else return false\r\n    }\r\n    else if(c === ']') {\r\n      if(stack[stack.length - 1] === '[') stack.pop()\r\n      else return false\r\n    }\r\n  }\r\n  return stack.length === 0\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * @param {string} s\r\n * @return {boolean}\r\n */\r\nconst isValid = function(s) {\r\n  const openBrackets = [\"(\", \"{\", \"[\"];\r\n  const closeBrackets = [\")\", \"}\", \"]\"];\r\n  const oArr = [];\r\n  let char = \"\";\r\n  let cidx = 0;\r\n  let oidx = 0;\r\n  for (let i = 0; i < s.length; i++) {\r\n    char = s.charAt(i);\r\n    if (closeBrackets.indexOf(char) !== -1) {\r\n      cidx = closeBrackets.indexOf(char);\r\n      lastOpenBracket = oArr[oArr.length - 1];\r\n      oidx = openBrackets.indexOf(lastOpenBracket);\r\n      if (cidx === oidx) {\r\n        oArr.pop();\r\n      } else {\r\n        return false;\r\n      }\r\n    } else {\r\n      oArr.push(char);\r\n    }\r\n  }\r\n  return oArr.length > 0 ? false : true;\r\n};\r\n"
    }
  },
  {
    "name": "200-number-of-islands",
    "code": {
      "JS": "/**\n * @param {character[][]} grid\n * @return {number}\n */\nconst numIslands = function(grid) {\n    if (grid.length === 0) return 0;\n    const totalRow = grid.length;\n    const totalCol = grid[0].length;\n    let res = 0;\n    \n    for (let i = 0; i < totalRow; i += 1) {\n        for (let j = 0; j < totalCol; j += 1) {\n            if (grid[i][j] === '1') {\n                res += 1;\n                dfs(grid, i, j, totalRow, totalCol);\n            }\n        }\n    }\n    \n    return res;\n};\n\nconst dfs = (grid, row, col, totalRow, totalCol) => {\n    if (row < 0 || col < 0 || row === totalRow || col === totalCol || grid[row][col] === '0') {\n       return;\n    }\n    \n    grid[row][col] = '0';\n    dfs(grid, row - 1, col, totalRow, totalCol);\n    dfs(grid, row + 1, col, totalRow, totalCol);\n    dfs(grid, row, col - 1, totalRow, totalCol);\n    dfs(grid, row, col + 1, totalRow, totalCol);\n}\n"
    }
  },
  {
    "name": "2000-reverse-prefix-of-word",
    "code": {
      "JS": "/**\n * @param {string} word\n * @param {character} ch\n * @return {string}\n */\nconst reversePrefix = function(word, ch) {\n  const arr = word.split('')\n  let idx = -1\n  for(let i = 0; i < arr.length; i++) {\n    if(arr[i] === ch) {\n      idx = i\n      break\n    }\n  }\n  if(idx !== -1) {\n    const pre = arr.slice(0, idx + 1)\n    const remain = arr.slice(idx + 1)\n    return pre.reverse().concat(remain).join('')\n  }\n  return word\n};\n"
    }
  },
  {
    "name": "2001-number-of-pairs-of-interchangeable-rectangles",
    "code": {
      "JS": "/**\n * @param {number[][]} rectangles\n * @return {number}\n */\nconst interchangeableRectangles = function(rectangles) {\n    const count = new Map()\n\n    for (const [w, h] of rectangles) {\n      count.set( w / h, 1 + (count.get( w / h) || 0))\n    }\n\n    let res = 0\n    for (let c of count.values()) {\n      if(c > 1) res += ((c * (c - 1)) / 2)\n    }\n    return res \n};\n"
    }
  },
  {
    "name": "2002-maximum-product-of-the-length-of-two-palindromic-subsequences",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nvar maxProduct = function(s) {\n  const n = s.length;\n  let max = 0;\n  for (let i = 0; i < (1 << n); i++) {\n    let n0 = palindromic(i, s, true);\n    if (n0 === 0) continue;\n    for (let j = 0; j < (1 << n); j++) {\n      if ((i & j) > 0) continue;\n      max = Math.max(palindromic(j, s) * n0, max);\n    }\n  }\n  return max; \n};\nfunction palindromic( i, s) {\n  const n = s.length;\n  let sub = \"\";\n  for (let x = 0; x < n; x++) {\n    if (i & (1 << x)) sub += s[x]\n  }\n  let len = sub.length;\n  for (let i = 0; i < len; i++) {\n    if (sub[i] !== sub[len - i - 1]) return 0;\n  }\n  return len;\n}\n"
    }
  },
  {
    "name": "2003-smallest-missing-genetic-value-in-each-subtree",
    "code": {
      "JS": "/**\n * @param {number[]} parents\n * @param {number[]} nums\n * @return {number[]}\n */\nconst smallestMissingValueSubtree = function(parents, nums) {\n      let n = parents.length;\n      const ans = new Array(n).fill(0);\n      const fn = new Array(100010).fill(0);\n      const tree = [];\n      const nums1 = nums;\n      for(let idx=0;idx<n;idx++) {\n        tree.push([]);\n      }\n      for (let idx=1;idx<n;idx++) {\n        tree[parents[idx]].push(idx);\n      }\n      let nodeIdx = 0;\n      search(0,0);\n      return ans;\n  \n    function search( root,  rec) {\n      let pos = 1;\n      for(let next of tree[root]) {\n        pos = Math.max(pos, search(next, nodeIdx));\n      }\n      nodeIdx++;\n      fn[nums1[root]] = nodeIdx;\n      while(fn[pos]!=0 && fn[pos]>rec && fn[pos]<=nodeIdx) {\n        pos++;\n      }\n      ans[root] = pos;\n      return pos;\n    }\n};\n\n"
    }
  },
  {
    "name": "2006-count-number-of-pairs-with-absolute-difference-k",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nconst countKDifference = function(nums, k) {\n  const hash = {}\n  let res = 0\n  for(let i = 0; i < nums.length; i++) {\n    const cur = nums[i]\n    if(hash[cur + k]) res += hash[cur + k]\n    if(hash[cur - k]) res += hash[cur - k]\n\n    if(hash[cur] == null) hash[cur] = 0\n    hash[cur]++\n  } \n  return res\n};\n"
    }
  },
  {
    "name": "2007-find-original-array-from-doubled-array",
    "code": {
      "JS": "/**\n * @param {number[]} changed\n * @return {number[]}\n */\n const findOriginalArray = function(changed) {\n  const n = changed.length, res = [], { abs } = Math\n  if(n % 2 === 1 || n === 0) return res\n  const hash = {}\n  for(let e of changed) {\n    if(hash[e] == null) hash[e] = 0\n    hash[e]++\n  }\n  const keys = Object.keys(hash)\n  keys.sort((a, b) => abs(a) - abs(b))\n\n  for(let k of keys) {\n    if(hash[k] > (hash[k * 2] || 0)) return []\n    for(let i = 0; i < hash[k]; i++) {\n      res.push(k)\n      hash[2 * k]--\n    }\n  }\n\n  return res\n};\n\n// another\n\n/**\n * @param {number[]} changed\n * @return {number[]}\n */\n const findOriginalArray = function(changed) {\n  const n = changed.length, res = []\n  if(n % 2 === 1 || n === 0) return res\n  const hash = {}\n  for(let e of changed) {\n    if(hash[e] == null) hash[e] = 0\n    hash[e]++\n  }\n  changed.sort((a, b) => a - b)\n\n  for(let i = 0, len = n; i < len; i++) {\n    const cur = changed[i], dVal = cur * 2\n    if (cur === 0 && hash[cur] % 2 === 1) continue\n    if(hash[dVal] && hash[cur]) {\n      res.push(cur)\n      hash[dVal]--\n      hash[cur]--\n    }\n  }\n  return res.length === n / 2 ? res : []\n};\n"
    }
  },
  {
    "name": "2008-maximum-earnings-from-taxi",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[][]} rides\n * @return {number}\n */\nconst maxTaxiEarnings = function(n, rides) {\n  const { max } = Math\n  const rideStartAt = Array.from({length: n}, () => []);\n  for (let ride of rides) {\n    let s = ride[0], e = ride[1], t = ride[2];\n    rideStartAt[s].push([e, e - s + t]);  // [end, dollar]\n  }\n  const dp = Array(n+1).fill(0);\n  for (let i = n-1; i >= 1; --i) {\n    for (let [e, d] of rideStartAt[i]) {\n      dp[i] = max(dp[i], dp[e] + d);\n    }\n    dp[i] = max(dp[i], dp[i + 1]);\n  }\n  return dp[1];\n};\n\n// another\n\n/**\n * @param {number} n\n * @param {number[][]} rides\n * @return {number}\n */\nconst maxTaxiEarnings = function(n, rides) {\n  const size = rides.length\n  rides.sort((a, b) => a[1] - b[1])\n  const dp = [[0,0]]\n  for(const [s, e, t] of rides) {\n    const cur = bs(dp, s) + (e - s + t)\n    if(cur > dp[dp.length - 1][1]) {\n      dp.push([e, cur])\n    }\n  }\n  return dp[dp.length - 1][1]\n\n  function bs(arr, t) {\n    let l = 0, r = arr.length - 1\n    while(l < r) {\n      const mid = r - ((r - l) >> 1)\n      if(arr[mid][0] > t) r = mid - 1\n      else l = mid\n    }\n    // console.log(arr, t, l)\n    return arr[l][1]\n  }\n};\n"
    }
  },
  {
    "name": "2009-minimum-number-of-operations-to-make-array-continuous",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst minOperations = function(nums) {\n  const N = nums.length;\n  if(N === 1) return 0;\n  nums.sort((a, b) => a - b)\n  let M = 1;\n  for(let i = 1; i < N; i++) {\n    if(nums[i] != nums[i-1]) nums[M++] = nums[i];\n  }\n  \n  let j = 0;\n  let res = N;\n  for(let i = 0; i < M; i++) {\n    // let `j` point to the first element that is out of range -- `> nums[i] + N - 1`.\n    while(j < M && nums[j] <= N + nums[i] - 1) j++;\n    // The length of this subarray is `j - i`. \n    // We need to replace `N - (j - i)` elements to make it continuous.\n    res = Math.min(res, N - (j - i));\n  }\n  \n  return res;\n};\n"
    }
  },
  {
    "name": "201-bitwise-and-of-numbers-range",
    "code": {
      "JS": "/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nconst rangeBitwiseAnd = function(m, n) {\n  while(m<n) n = n & (n-1);\n  return n;\n};\n\n// another\n\n/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nconst rangeBitwiseAnd = function(m, n) {\n  let s = 0\n  while(m !== n) {\n    m >>= 1\n    n >>= 1\n    s++\n  }\n  return m << s\n};\n"
    }
  },
  {
    "name": "2011-final-value-of-variable-after-performing-operations",
    "code": {
      "JS": "/**\n * @param {string[]} operations\n * @return {number}\n */\nconst finalValueAfterOperations = function(operations) {\n  let res = 0\n  for(let op of operations) {\n    if(op.indexOf('++') !== -1) res++\n    else res--\n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "2012-sum-of-beauty-in-the-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst sumOfBeauties = function(nums) {\n  const n = nums.length\n  const maxArr = Array(n).fill(0), minArr = Array(n).fill(0)\n  let max = -Infinity, min = Infinity\n  for(let i = 0; i < n; i++) {\n    const tmp = Math.max(max, nums[i])\n    if(tmp > max) max = tmp\n    maxArr[i] = max\n  }\n  \n  for(let i = n - 1; i >= 0; i--) {\n    const tmp = Math.min(min, nums[i])\n    if(tmp < min) min = tmp\n    minArr[i] = min\n  }\n  let res = 0\n  \n  for(let i = 1; i < n - 1; i++) {\n    if(nums[i] > maxArr[i - 1] && nums[i] < minArr[i + 1]) res += 2\n    else if(nums[i] > nums[i - 1] && nums[i] < nums[i + 1]) res += 1\n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "2013-detect-squares",
    "code": {
      "JS": "\nconst DetectSquares = function() {\n  this.pts = []\n  this.ptsCnt = {}\n};\n\n/** \n * @param {number[]} point\n * @return {void}\n */\nDetectSquares.prototype.add = function(point) {\n  this.pts.push(point)\n  const key = `${point[0]},${point[1]}`\n  this.ptsCnt[key] = (this.ptsCnt[key] || 0) + 1\n};\n\n/** \n * @param {number[]} point\n * @return {number}\n */\nDetectSquares.prototype.count = function(point) {\n  let res = 0\n  const [px, py] = point\n  for(const [x, y] of this.pts) {\n    if(px === x || py === y || Math.abs(px - x) !== Math.abs(py - y)) {\n       continue\n    }\n    res += (this.ptsCnt[`${px},${y}`] || 0) * (this.ptsCnt[`${x},${py}`] || 0)\n  }\n  \n  return res\n};\n\n/** \n * Your DetectSquares object will be instantiated and called as such:\n * var obj = new DetectSquares()\n * obj.add(point)\n * var param_2 = obj.count(point)\n */\n\n\n// another\n\nvar DetectSquares = function() {\n    this.xMap = new Map();\n    this.yMap = new Map();\n};\n\n/**\n * @param {number[]} point\n * @return {void}\n */\nDetectSquares.prototype.add = function(point) {\n    const [ x, y ] = point;\n\n    // X-map\n    if (this.xMap.has(x)) {\n        const xMap = this.xMap.get(x);\n\n        if (xMap.has(y)) {\n            xMap.set(y, xMap.get(y) + 1);\n        } else {\n            xMap.set(y, 1);\n        }\n    } else {\n        const countMap = new Map();\n        countMap.set(y, 1);\n        this.xMap.set(x, countMap);\n    }\n\n    // Y-map\n    if (this.yMap.has(y)) {\n        const yMap = this.yMap.get(y);\n\n        if (yMap.has(x)) {\n            yMap.set(x, yMap.get(x) + 1);\n        } else {\n            yMap.set(x, 1);\n        }\n    } else {\n        const countMap = new Map();\n        countMap.set(x, 1);\n        this.yMap.set(y, countMap);\n    }\n};\n\n/**\n * @param {number[]} point\n * @return {number}\n */\nDetectSquares.prototype.count = function(point) {\n    const [ x, y ] = point;\n    let ans = 0;\n\n    if (this.xMap.has(x) && this.yMap.has(y)) {\n        for (const y2 of this.xMap.get(x).keys()) {\n            if (y === y2) {\n                continue;\n            }\n\n            // Find parallel\n            const sideLen = Math.abs(y - y2);\n            const possibleX = [ x - sideLen, x + sideLen];\n\n            for (const px of possibleX) {\n                if (this.yMap.get(y).has(px) && this.xMap.has(px) && this.xMap.get(px).has(y2)) {\n                    ans += this.xMap.get(x).get(y2) * this.yMap.get(y).get(px)\n                        * this.xMap.get(px).get(y2);\n                }\n            }\n        }\n    }\n\n    return ans;\n};\n\n/** \n * Your DetectSquares object will be instantiated and called as such:\n * var obj = new DetectSquares()\n * obj.add(point)\n * var param_2 = obj.count(point)\n */\n"
    }
  },
  {
    "name": "2014-longest-subsequence-repeated-k-times",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {number} k\n * @return {string}\n */\nconst longestSubsequenceRepeatedK = function(s, k) {\n  const n = s.length, a = 'a'.charCodeAt(0)\n  \n  let res = ''\n  const q = ['']\n  \n  while(q.length) {\n    const size = q.length\n    for(let i = 0; i < size; i++) {\n      const cur = q.shift()\n      for(let j = 0; j < 26; j++) {\n        const next = cur + String.fromCharCode(a + j)\n        if(isSub(s, next, k)) {\n          res = next\n          q.push(next)\n        }\n      }\n      \n    }\n  }\n  \n  return res\n  \n  \n  function isSub(s, p, k) {\n    let repeated = 0\n    for(let i = 0, j = 0, n = s.length, m = p.length; i < n; i++) {\n      if(s[i] === p[j]) {\n        j++\n        if(j === m) {\n          repeated++\n          j = 0\n          if(repeated === k) {\n            return true\n          }\n        }\n      }\n    }\n    \n    return false\n  }\n};\n\n// another\n\n/**\n * @param {string} s\n * @param {number} k\n * @return {string}\n */\nvar longestSubsequenceRepeatedK = function(s, k) {\n    // Max length of the subsequence can be determined by the length of the string and k\n    const maxLen = Math.floor(s.length / k);\n\n    // Find all possible characters that can appear in the subsequence (characters must appear at\n    // least k times in s)\n    const charCount = new Map();\n    const possibleChars = []\n\n    for (const char of s) {\n        if (charCount.has(char)) {\n            charCount.set(char, charCount.get(char) + 1);\n        } else {\n            charCount.set(char, 1);\n        }\n    }\n\n    for (const char of charCount.keys()) {\n        if (charCount.get(char) >= k) {\n            possibleChars.push(char);\n        }\n    }\n\n    // Test possibilities\n    let ans = \"\";\n    dfs(\"\");\n\n    return ans;\n\n    // Recursive function, tests if the given subsequence repeats k times in s\n    function dfs(seq) {\n        // Does not have enough repeats, return\n        if (countRepeats(seq) < k) {\n            return;\n        }\n\n        // Update our answer if the new subsequence is better\n        if (seq.length > ans.length || (seq.length === ans.length && seq > ans)) {\n            ans = seq;\n        }\n\n        // Append possible characters to the subsequence and test again\n        if (seq.length < maxLen) {\n            for (const char of possibleChars) {\n                dfs(seq + char);\n            }\n        }\n    }\n\n    // Counts the number of times the given subsequence repeats in s (up to k)\n    function countRepeats(seq) {\n\n        // Empty string, return k\n        if (!seq) {\n            return k;\n        }\n\n        let repeats = 0;\n        let seqIdx = 0;\n\n        for (const char of s) {\n            if (char === seq[seqIdx]) {\n                seqIdx += 1;\n\n                if (seqIdx >= seq.length) {\n                    seqIdx = 0;\n                    repeats += 1;\n\n                    if (repeats >= k) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        return repeats;\n    } \n};\n"
    }
  },
  {
    "name": "2018-check-if-word-can-be-placed-in-crossword",
    "code": {
      "JS": "/**\n * @param {character[][]} board\n * @param {string} word\n * @return {boolean}\n */\nconst placeWordInCrossword = function(board, word) {\n  for (let state of [board, getRotated(board)])\n    for (let chars of state)\n      for (let token of chars.join('').split(\"#\"))\n        for (let letters of [word, word.split('').reverse().join('')])\n          if (letters.length == token.length)\n            if (canFit(letters, token))\n              return true;\n  return false;\n}\n\nfunction getRotated(board) {\n  const m = board.length;\n  const n = board[0].length;\n\n  const rotated = Array.from({length: n}, () => Array(m));\n  for (let i = 0; i < m; ++i)\n    for (let j = 0; j < n; ++j)\n      rotated[j][i] = board[i][j];\n  return rotated;\n}\n\nfunction canFit(letters, token) {\n  for (let i = 0; i < letters.length; ++i)\n    if (token.charAt(i) != ' ' && token.charAt(i) != letters.charAt(i))\n      return false;\n  return true;\n}\n"
    }
  },
  {
    "name": "2019-the-score-of-students-solving-math-expression",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {number[]} answers\n * @return {number}\n */\nconst op = {\n    '+': ((a, b) => Number(a) + Number(b)),\n    '*':((a, b) => a * b),\n}\nlet dp = {};\nconst dfs = (s) => {\n    if(s.length == 0) return {};\n    if(s.length == 1) return { [s[0]] : 1};\n    const dps = dp[s];\n    if(dps) return dps;\n    const res = {};\n    for(let i = 0; i < s.length - 2; i += 2) {\n        const l = dfs(s.substr(0, i + 1))\n        const r = dfs(s.substr(i + 2, s.length - i - 2));\n        for(let x in l) {\n            for(let y in r) {\n                const z = op[s[i + 1]](x, y);\n                if(z > 1000) continue;\n                res[z] = 1;\n            }\n        }\n        \n    }\n    dp[s] = res;\n    return res;\n}\n\nconst scoreOfStudents = function(s, answers) {\n    const correct = eval(s);\n    dp = {};\n    const allAns = dfs(s);\n    let ans = 0;\n    answers.forEach(x => {\n        if(  x == correct) ans += 5;\n        else if(allAns[x]) ans += 2;\n    })\n    return ans;\n};\n"
    }
  },
  {
    "name": "202-happy-number",
    "code": {
      "JS": "/**\r\n * @param {number} n\r\n * @return {boolean}\r\n */\r\nconst isHappy = function(n) {\r\n  const arr = [];\r\n  let tmp = n;\r\n  while (arr.indexOf(tmp) === -1) {\r\n    arr.push(tmp);\r\n    let res = (\"\" + tmp)\r\n      .split(\"\")\r\n      .reduce((ac, str) => ac + Math.pow(+str, 2), 0);\r\n    if (res === 1) {\r\n      return true;\r\n    }\r\n    tmp = res;\r\n  }\r\n  return false;\r\n};\r\n"
    }
  },
  {
    "name": "2024-maximize-the-confusion-of-an-exam",
    "code": {
      "JS": "/**\n * @param {string} answerKey\n * @param {number} k\n * @return {number}\n */\nconst maxConsecutiveAnswers = function(answerKey, k) {\n  const helper = (str, transT) => {\n    let res = 0, l = 0, r = 0, num = 0\n    const n = str.length\n    const target = transT === 1 ? 'T' : 'F'\n    while(r < n) {\n      if(str[r] === target) num++\n      while(num > k) {\n        if(str[l] === target) num--\n        l++\n      }\n      res = Math.max(res, r - l + 1)\n      r++\n    }\n    return res\n  }\n  \n  return Math.max(helper(answerKey, 0), helper(answerKey, 1))\n};\n\n// another\n\n/**\n * @param {string} answerKey\n * @param {number} k\n * @return {number}\n */\nconst maxConsecutiveAnswers = function(answerKey, k) {\n  let s = answerKey\n  const freq = Array(26).fill(0), n = s.length, A = 'A'.charCodeAt(0)\n  let res = 0, l = 0, r = 0, maxFreq = 0\n  while(r < n) {\n    maxFreq = Math.max(maxFreq, ++freq[s.charCodeAt(r) - A])\n    if(r - l + 1 - maxFreq > k) {\n      freq[s.charCodeAt(l) - A]--\n      l++\n    }\n    res = Math.max(res, r - l + 1)\n    r++\n  }\n  \n  return res\n};\n\n\n"
    }
  },
  {
    "name": "2025-maximum-number-of-ways-to-partition-an-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nconst waysToPartition = function (nums, k) {\n  const n = nums.length, pre = Array(n).fill(0), suf = Array(n).fill(0)\n  pre[0] = nums[0], suf[n - 1] = nums[n - 1]\n  for(let i = 1; i < n; i++) {\n    pre[i] = pre[i - 1] + nums[i]\n    suf[n - 1 - i] = suf[n - i] + nums[n - 1 - i]\n  }\n  const sum = nums.reduce((ac, e) => ac + e, 0)\n  let res = 0\n  for(let i = 0; i < n - 1; i++) {\n    if(pre[i] === suf[i + 1]) res++\n  }\n  const cnt = new Map()\n  const arr = Array(n).fill(0)\n  for(let i = 0; i < n; i++) {\n    const newSum = sum - nums[i] + k\n    if(newSum % 2 === 0) arr[i] += (cnt.get(newSum / 2) || 0)\n    cnt.set(pre[i], (cnt.get(pre[i]) || 0) + 1)\n  }\n  cnt.clear()\n  for(let i = n - 1; i >= 0; i--) {\n    const newSum = sum - nums[i] + k\n    if(newSum % 2 === 0) arr[i] += (cnt.get(newSum / 2) || 0)\n    cnt.set(suf[i], (cnt.get(suf[i]) || 0) + 1)\n  }\n  \n  for(let e of arr) {\n    if(e > res) res = e\n  }\n  \n  return res\n}\n\n\n// another\n\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nconst waysToPartition = function (nums, k) {\n  const n = nums.length\n  const pref = Array(n).fill(0),\n    suff = Array(n).fill(0)\n  pref[0] = nums[0]\n  suff[n - 1] = nums[n - 1]\n  for (let i = 1; i < n; ++i) {\n    pref[i] = pref[i - 1] + nums[i]\n    suff[n - 1 - i] = suff[n - i] + nums[n - 1 - i]\n  }\n  let ans = 0\n  const left = {},\n    right = {}\n\n  for (let i = 0; i < n - 1; ++i) {\n    const delta = pref[i] - suff[i + 1]\n    if (right[delta] == null) right[delta] = 0\n    right[delta]++\n  }\n\n  if (right[0]) ans = right[0]\n  for (let i = 0; i < n; ++i) {\n    //find the number of pivot indexes when nums[i] is changed to k\n    let curr = 0,\n      diff = k - nums[i]\n    if (left[diff]) curr += left[diff]\n    if (right[-diff]) curr += right[-diff]\n\n    //update answer\n    ans = Math.max(ans, curr)\n\n    //transfer the current element from right to left\n    if (i < n - 1) {\n      let dd = pref[i] - suff[i + 1]\n      if(left[dd] == null) left[dd] = 0\n      if(right[dd] == null) right[dd] = 0\n      left[dd]++\n      right[dd]--\n      if (right[dd] == 0) delete right[dd]\n    }\n  }\n  return ans\n}\n"
    }
  },
  {
    "name": "2029-stone-game-ix",
    "code": {
      "JS": "/**\n * @param {number[]} stones\n * @return {boolean}\n */\nconst stoneGameIX = function(stones) {\n  const cnt = Array(3).fill(0), { abs } = Math \n  for (let a of stones) cnt[a % 3]++;\n  if (cnt[0] % 2 == 0) return cnt[1] && cnt[2]\n  return abs(cnt[1] - cnt[2]) >= 3\n};\n"
    }
  },
  {
    "name": "203-remove-linked-list-elements",
    "code": {
      "JS": "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} val\n * @return {ListNode}\n */\nconst removeElements = function(head, val) {\n  const dummy = new ListNode(Infinity)\n  if(head == null) return null\n  dummy.next = head\n  let cur = head\n  let prev = dummy\n  while(cur) {\n    if(cur.val === val) {\n      prev.next = cur.next\n      cur = cur.next\n    } else {\n      prev = cur\n      cur = cur.next\n    }\n  }\n  return dummy.next\n};\n\n// another\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} val\n * @return {ListNode}\n */\nconst removeElements = function(head, val) {\n  if (head === null) return null;\n  head.next = removeElements(head.next, val);\n  return head.val === val ? head.next : head;\n};\n"
    }
  },
  {
    "name": "2030-smallest-k-length-subsequence-with-occurrences-of-a-letter",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {number} k\n * @param {character} letter\n * @param {number} repetition\n * @return {string}\n */\nconst smallestSubsequence = function (s, k, letter, repetition) {\n  let n_letters = 0\n  for (let i = 0; i < s.length; i++) if (s.charAt(i) == letter) n_letters++\n  const stack = []\n  for (let i = 0; i < s.length; i++) {\n    let c = s.charAt(i)\n    while (\n      stack.length &&\n      stack[stack.length - 1] > c &&\n      s.length - i + stack.length > k &&\n      (stack[stack.length - 1] != letter || n_letters > repetition)\n    ) {\n      if (stack.pop() == letter) repetition++\n    }\n    if (stack.length < k) {\n      if (c == letter) {\n        stack.push(c)\n        repetition--\n      } else if (k - stack.length > repetition) {\n        stack.push(c)\n      }\n    }\n    if (c == letter) n_letters--\n  }\n\n  let sb = ''\n  for (let c of stack) sb += c\n  return sb\n}\n"
    }
  },
  {
    "name": "2032-two-out-of-three",
    "code": {
      "JS": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @param {number[]} nums3\n * @return {number[]}\n */\nconst twoOutOfThree = function(nums1, nums2, nums3) {\n  const res = []\n  const hash = {}\n  for(let e of new Set(nums1)) {\n    if(hash[e] == null) hash[e] = 0\n    hash[e] = 1\n  }\n\n  for(let e of new Set(nums2)) {\n    if(hash[e] == null) hash[e] = 0\n    hash[e]++\n  }\n  \n\n  for(let e of new Set(nums3)) {\n    if(hash[e] == null) hash[e] = 0\n    hash[e]++\n  }\n  \n  Object.keys(hash).forEach(k => {\n    if(hash[k] > 1) res.push(k)\n  })\n\n  \n  return res\n};\n"
    }
  },
  {
    "name": "2033-minimum-operations-to-make-a-uni-value-grid",
    "code": {
      "JS": "/**\n * @param {number[][]} grid\n * @param {number} x\n * @return {number}\n */\nconst minOperations = function(grid, x) {\n  const arr = []\n  const m = grid.length, n = grid[0].length\n  for(let i = 0; i < m; i++) {\n    for(let j = 0; j < n; j++) {\n      arr.push(grid[i][j])\n    }\n  }\n  arr.sort((a, b) => a - b)\n  \n  for(let i = 1; i < m * n; i++) {\n    if((arr[i] - arr[i - 1]) % x !== 0) return -1\n  }\n  const sum = arr.reduce((ac, e) => ac + e, 0)\n  const pre = []\n  pre.push(arr[0])\n  for(let i = 1; i < m * n; i++) {\n    pre[i] = pre[i - 1] + arr[i]\n  }\n  \n  let res = 0, num = 0, min = sum - arr[0] * m * n, idx = 0\n  for(let i = 1; i < m * n; i++) {\n    const cur = (i + 1) * arr[i] - pre[i] + (sum - pre[i] - arr[i] * (m * n - i - 1))\n    // console.log(cur, (i + 1) * arr[i] - pre[i], sum - pre[i] - arr[i] * (m * n - i - 1))\n    // const cur = sum - arr[i] * (m * n - i)\n    if(cur < min) {\n      idx = i\n      min = cur\n    }\n  }\n  \n  // console.log(idx)\n  \n  for(let i = 0; i < m * n; i++) {\n    if(i === idx) continue\n    res += Math.abs(arr[i] - arr[idx]) / x\n  }\n  \n  return res\n};\n// 20 - 6 - 4 * 2\n// 2 4 6 8\n// 1 2 3 5\n\n// another\n\n/**\n * @param {number[][]} grid\n * @param {number} x\n * @return {number}\n */\nconst minOperations = function(grid, x) {\n  const arr = [], m = grid.length, n = grid[0].length\n  for(let i  =  0; i < m; i++) {\n    for(let j = 0; j < n; j++) {\n      arr.push(grid[i][j])\n    }\n  }\n  arr.sort((a,  b) => a - b)\n  const mid = arr[~~((m * n) / 2)]\n  let res = 0\n\n  for(let e of arr) {\n    if (e !== mid) {\n      const cur  = Math.abs(e - mid)\n      if(cur  % x !== 0) return -1\n      res += cur / x\n    }\n  }\n  return res\n};\n\n// another\n\n/**\n * @param {number[][]} grid\n * @param {number} x\n * @return {number}\n */\nfunction minOperations(grid, x) {\n  const m = grid.length, n = grid[0].length, mn = m * n, arr = []\n  for(let i = 0; i < m; i++) {\n    for(let j = 0; j < n; j++) {\n      arr.push(grid[i][j])\n    }\n  }\n  arr.sort((a, b) => a - b)\n  const mid = arr[~~(mn / 2)]\n  let res = 0\n\n  for(let e of arr) {\n    if(e !== mid) {\n      const delta = Math.abs(e - mid)\n      if(delta % x !== 0) return -1\n      res += delta / x\n    }\n  }\n\n  return res\n};\n"
    }
  },
  {
    "name": "2034-stock-price-fluctuation",
    "code": {
      "JS": "const StockPrice = function () {\n  this.timeToPrice = new Map()\n  this.lastTime = 0\n  this.minPrices = new MinPriorityQueue({ priority: (stock) => stock.price })\n  this.maxPrices = new MaxPriorityQueue({ priority: (stock) => stock.price })\n}\n\n/**\n * @param {number} timestamp\n * @param {number} price\n * @return {void}\n */\nStockPrice.prototype.update = function (timestamp, price) {\n  this.timeToPrice.set(timestamp, price)\n  this.lastTime = Math.max(this.lastTime, timestamp)\n  this.minPrices.enqueue({ timestamp, price })\n  this.maxPrices.enqueue({ timestamp, price })\n}\n\n/**\n * @return {number}\n */\nStockPrice.prototype.current = function () {\n  return this.timeToPrice.get(this.lastTime)\n}\n\n/**\n * @return {number}\n */\nStockPrice.prototype.maximum = function () {\n  while (\n    this.maxPrices.front().element.price !==\n    this.timeToPrice.get(this.maxPrices.front().element.timestamp)\n  ) {\n    this.maxPrices.dequeue()\n  }\n\n  return this.maxPrices.front().element.price\n}\n\n/**\n * @return {number}\n */\nStockPrice.prototype.minimum = function () {\n  while (\n    this.minPrices.front().element.price !==\n    this.timeToPrice.get(this.minPrices.front().element.timestamp)\n  ) {\n    this.minPrices.dequeue()\n  }\n\n  return this.minPrices.front().element.price\n}\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * var obj = new StockPrice()\n * obj.update(timestamp,price)\n * var param_2 = obj.current()\n * var param_3 = obj.maximum()\n * var param_4 = obj.minimum()\n */\n"
    }
  },
  {
    "name": "2035-partition-array-into-two-arrays-to-minimize-sum-difference",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst mi = Math.min,\n  abs = Math.abs\nconst minimumDifference = (nums) => {\n  let m = nums.length,\n    n = m >> 1\n  let a = initializeGraph(n + 1)\n  let b = initializeGraph(n + 1)\n  for (let i = 0; i < 1 << n; i++) {\n    // mask\n    let sum = 0,\n      cnt = 0\n    for (let j = 0; j < n; j++) {\n      if (i & (1 << j)) {\n        // bit of 1's\n        sum += nums[j]\n        cnt++ // bit count\n      } else {\n        sum -= nums[j]\n      }\n    }\n    a[cnt].push(sum)\n    ;(sum = 0), (cnt = 0)\n    for (let j = 0; j < n; j++) {\n      if (i & (1 << j)) {\n        sum += nums[n + j]\n        cnt++\n      } else {\n        sum -= nums[n + j]\n      }\n    }\n    b[cnt].push(sum)\n  }\n  for (let i = 0; i < n; i++) {\n    a[i].sort((x, y) => x - y)\n    b[i].sort((x, y) => x - y)\n  }\n  let res = Number.MAX_SAFE_INTEGER\n  let bi = new Bisect()\n  for (let i = 0; i <= n; i++) {\n    for (const x of a[i]) {\n      let idx = bi.bisect_left(b[n - i], -x) // binary search   lower_bound\n      if (idx != b[n - i].length) res = mi(res, abs(x + b[n - i][idx]))\n      if (idx != 0) {\n        idx--\n        res = mi(res, abs(x + b[n - i][idx]))\n      }\n    }\n  }\n  return res\n}\n\n//////////////////////////////////////// Template ////////////////////////////////////////////////////////\nfunction Bisect() {\n  return { insort_right, insort_left, bisect_left, bisect_right }\n  function insort_right(a, x, lo = 0, hi = null) {\n    lo = bisect_right(a, x, lo, hi)\n    a.splice(lo, 0, x)\n  }\n  function bisect_right(a, x, lo = 0, hi = null) {\n    // > upper_bound\n    if (lo < 0) throw new Error('lo must be non-negative')\n    if (hi == null) hi = a.length\n    while (lo < hi) {\n      let mid = (lo + hi) >> 1\n      x < a[mid] ? (hi = mid) : (lo = mid + 1)\n    }\n    return lo\n  }\n  function insort_left(a, x, lo = 0, hi = null) {\n    lo = bisect_left(a, x, lo, hi)\n    a.splice(lo, 0, x)\n  }\n  function bisect_left(a, x, lo = 0, hi = null) {\n    // >= lower_bound\n    if (lo < 0) throw new Error('lo must be non-negative')\n    if (hi == null) hi = a.length\n    while (lo < hi) {\n      let mid = (lo + hi) >> 1\n      a[mid] < x ? (lo = mid + 1) : (hi = mid)\n    }\n    return lo\n  }\n}\n\nconst initializeGraph = (n) => {\n  let G = []\n  for (let i = 0; i < n; i++) {\n    G.push([])\n  }\n  return G\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n"
    }
  },
  {
    "name": "2037-minimum-number-of-moves-to-seat-everyone",
    "code": {
      "JS": "/**\n * @param {number[]} seats\n * @param {number[]} students\n * @return {number}\n */\nconst minMovesToSeat = function(seats, students) {\n  let res = 0\n  seats.sort((a, b) => a - b)\n  students.sort((a, b) => a - b)\n  \n  for(let i = 0; i < students.length; i++) {\n    res += Math.abs(seats[i] - students[i])\n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "204-count-primes",
    "code": {
      "JS": "/**\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nconst countPrimes = function(n) {\r\n  /**\r\n   * if n = 2, the prime 2 is not less than n,\r\n   * so there are no primes less than n\r\n   */\r\n  if (n < 3) return 0;\r\n\r\n  /**\r\n   * Start with the assumption that half the numbers below n are\r\n   * prime candidates, since we know that half of them are even,\r\n   * and so _in general_ aren't prime.\r\n   *\r\n   * An exception to this is 2, which is the only even prime.\r\n   * But also 1 is an odd which isn't prime.\r\n   * These two exceptions (a prime even and a for-sure not-prime odd)\r\n   * cancel each other out for n > 2, so our assumption holds.\r\n   *\r\n   * We'll decrement count when we find an odd which isn't prime.\r\n   *\r\n   * If n = 3,  c = 1.\r\n   * If n = 5,  c = 2.\r\n   * If n = 10, c = 5.\r\n   */\r\n  let c = Math.floor(n / 2);\r\n\r\n  /**\r\n   * Java initializes boolean arrays to {false}.\r\n   * In this method, we'll use truth to mark _composite_ numbers.\r\n   *\r\n   * This is the opposite of most Sieve of Eratosthenes methods,\r\n   * which use truth to mark _prime_ numbers.\r\n   *\r\n   * We will _NOT_ mark evens as composite, even though they are.\r\n   * This is because `c` is current after each `i` iteration below.\r\n   */\r\n  let s = [];\r\n\r\n  /**\r\n   * Starting with an odd prime-candidate above 2, increment by two\r\n   * to skip evens (which we know are not prime candidates).\r\n   */\r\n  for (let i = 3; i * i < n; i += 2) {\r\n    if (s[i]) {\r\n      // c has already been decremented for this composite odd\r\n      continue;\r\n    }\r\n\r\n    /**\r\n     * For each prime i, iterate through the odd composites\r\n     * we know we can form from i, and mark them as composite\r\n     * if not already marked.\r\n     *\r\n     * We know that i * i is composite.\r\n     * We also know that i * i + i is composite, since they share\r\n     * a common factor of i.\r\n     * Thus, we also know that i * i + a*i is composite for all real a,\r\n     * since they share a common factor of i.\r\n     *\r\n     * Note, though, that i * i + i _must_ be composite for an\r\n     * independent reason: it must be even.\r\n     * (all i are odd, thus all i*i are odd,\r\n     * thus all (odd + odd) are even).\r\n     *\r\n     * Recall that, by initializing c to n/2, we already accounted for\r\n     * all of the evens less than n being composite, and so marking\r\n     * i * i + (odd)*i as composite is needless bookkeeping.\r\n     *\r\n     * So, we can skip checking i * i + a*i for all odd a,\r\n     * and just increment j by even multiples of i,\r\n     * since all (odd + even) are odd.\r\n     */\r\n    for (let j = i * i; j < n; j += 2 * i) {\r\n      if (!s[j]) {\r\n        c--;\r\n        s[j] = true;\r\n      }\r\n    }\r\n  }\r\n  return c;\r\n};\r\n"
    }
  },
  {
    "name": "2040-kth-smallest-product-of-two-sorted-arrays",
    "code": {
      "JS": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @param {number} k\n * @return {number}\n */\nconst kthSmallestProduct = function(nums1, nums2, k) {\n  const neg = nums1.filter(e => e < 0)  \n  const pos = nums1.filter(e => e >= 0)\n  const negRev = neg.slice(), posRev = pos.slice()\n  negRev.reverse()\n  posRev.reverse()\n\n  let l = - (10 ** 10), r = 10 ** 10\n  while(l < r) {\n    const mid = l + Math.floor((r - l) / 2)\n    if(fn(mid) < k) l = mid + 1\n    else r = mid\n  } \n\n  return l\n\n  function fn(val) {\n    let res = 0, n = nums2.length\n    let l = 0, r = n - 1\n    const list = val >= 0 ? negRev.concat(pos) : neg.concat(posRev)\n    for(let e of list) {\n      if(e < 0) {\n        while(l < n && e * nums2[l] > val) l++\n        res += n - l\n      } else if (e === 0) {\n        if(val >= 0) res += n\n      } else {\n        while(r >= 0 && e * nums2[r] > val) r--\n        res += r + 1\n      }\n    }\n    return res\n  }\n};\n"
    }
  },
  {
    "name": "2042-check-if-numbers-are-ascending-in-a-sentence",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {boolean}\n */\nconst areNumbersAscending = function(s) {\n  const arr =s.split(' ')\n  const f = arr.filter(e => !Number.isNaN(+e)).map(e => +e)\n  let res = true\n  for(let i = 1; i < f.length; i++) {\n    if(f[i] <= f[i - 1]) return false\n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "2043-simple-bank-system",
    "code": {
      "JS": "/**\n * @param {number[]} balance\n */\nconst Bank = function(balance) {\n  this.n = balance.length\n  balance.unshift(0)\n  this.b = balance\n  \n};\n\n/** \n * @param {number} account1 \n * @param {number} account2 \n * @param {number} money\n * @return {boolean}\n */\nBank.prototype.transfer = function(account1, account2, money) {\n  let res = true\n  if(account1 > this.n || account1 < 1) return false\n  if(account2 > this.n || account2 < 1) return false\n  if(this.b[account1]< money) return false\n  this.b[account1] -= money\n  this.b[account2] += money\n  return true\n};\n\n/** \n * @param {number} account \n * @param {number} money\n * @return {boolean}\n */\nBank.prototype.deposit = function(account, money) {\n  if(account > this.n || account < 1) return false\n  this.b[account] += money\n  return true\n};\n\n/** \n * @param {number} account \n * @param {number} money\n * @return {boolean}\n */\nBank.prototype.withdraw = function(account, money) {\n  if(account > this.n || account < 1) return false\n  if(this.b[account] < money) return false\n  this.b[account] -= money\n  return true\n};\n\n/** \n * Your Bank object will be instantiated and called as such:\n * var obj = new Bank(balance)\n * var param_1 = obj.transfer(account1,account2,money)\n * var param_2 = obj.deposit(account,money)\n * var param_3 = obj.withdraw(account,money)\n */\n"
    }
  },
  {
    "name": "2044-count-number-of-maximum-bitwise-or-subsets",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst countMaxOrSubsets = function(nums) {\n  let res = 0, max = 0, n = nums.length\n  for(let num of nums) max |= num\n  dfs(0, 0)\n  dfs(0, nums[0])\n  return res\n  \n  function dfs(i, cur) {\n    if(i === n) return\n    if(cur === max) return res += Math.pow(2, n - 1 - i)\n    dfs(i + 1, cur)\n    dfs(i + 1, cur | nums[i + 1])\n  }\n};\n"
    }
  },
  {
    "name": "2045-second-minimum-time-to-reach-destination",
    "code": {
      "JS": "const initializeGraph = (n) => {\n  let G = []\n  for (let i = 0; i < n; i++) {\n    G.push([])\n  }\n  return G\n}\nconst addEdgeToG = (G, Edges) => {\n  for (const [u, v] of Edges) {\n    G[u].push(v)\n    G[v].push(u)\n  }\n}\n/**\n * @param {number} n\n * @param {number[][]} edges\n * @param {number} time\n * @param {number} change\n * @return {number}\n */\nconst secondMinimum = (n, edges, time, change) => {\n  let adj = initializeGraph(n + 1)\n  addEdgeToG(adj, edges)\n  let cost = initializeGraph(n + 1)\n  let pq = new MinPriorityQueue({ priority: (x) => x[0] })\n  pq.enqueue([0, 1])\n  let green = 2 * change\n  while (pq.size()) {\n    let cur = pq.dequeue().element\n    let [t, node] = cur\n    if (cost[node].length == 2) continue\n    let nextT =\n      t % green < change ? t : (((t + green - 1) / green) >> 0) * green\n    let cn = cost[node].length\n    if (node == n) {\n      if (cn == 0 || cost[node][cn - 1] != t) {\n        cost[node].push(t)\n      } else {\n        continue\n      }\n    } else {\n      if (cn == 0 || cost[node][cn - 1] != nextT) {\n        cost[node].push(nextT)\n      } else {\n        continue\n      }\n    }\n    for (const next_node of adj[node]) pq.enqueue([nextT + time, next_node])\n  }\n  return cost[n][1]\n}\n"
    }
  },
  {
    "name": "2046-sort-linked-list-already-sorted-using-absolute-values",
    "code": {
      "JS": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nconst sortLinkedList = function(head) {\n  if(head == null) return head\n  const dummy = new ListNode(null, head)\n  let pre = dummy, cur = head\n  while(cur) {\n    if(cur.val < 0 && cur !== head) {\n      const tmp = cur.next, tmpHead = dummy.next\n      dummy.next = cur\n      cur.next = tmpHead\n      pre.next = tmp\n      cur = tmp\n    } else {\n      pre = cur\n      cur = cur.next\n    }\n  }\n\n  return dummy.next\n};\n"
    }
  },
  {
    "name": "2047-number-of-valid-words-in-a-sentence",
    "code": {
      "JS": "/**\n * @param {string} sentence\n * @return {number}\n */\nconst countValidWords = function(s) {\n  const arr = s.split(' ')\n  let res = 0\n  for(const e of arr) {\n    if(e.trim() && valid(e.trim())) res ++\n  }\n  return res\n};\n \nfunction valid(e) {\n  const zi = '0'.charCodeAt(0), ni = '9'.charCodeAt(0)\n  const len = e.length\n  for(const el of e) {\n    if(el.charCodeAt(0) >= zi && el.charCodeAt(0) <= ni) return false\n  }\n  const num = (p, n) => (p >= 'a' && p <= 'z') && (n >= 'a' && n <= 'z')\n  const hi = e.indexOf('-')\n  if(hi !== -1) {\n    if(hi === 0 || hi === e.length - 1 || e.indexOf('-', hi + 1) !== -1 || !num(e[hi - 1], e[hi + 1])) return false\n  }\n  \n  const p1 = e.indexOf('!')\n  if(p1 !== -1) {\n    if((len > 1 && p1 !== e.length - 1) || e.indexOf('-', p1 + 1) !== -1) return false\n  }\n  \n  const p2 = e.indexOf('.')\n  if(p2 !== -1) {\n    if((len > 1 && p2 !== e.length - 1) || e.indexOf('-', p2 + 1) !== -1) return false\n  }\n  \n  const p3 = e.indexOf(',')\n  if(p3 !== -1) {\n    if((len > 1 && p3 !== e.length - 1) || e.indexOf('-', p3 + 1) !== -1) return false\n  }\n  \n  return true\n}\n"
    }
  },
  {
    "name": "2048-next-greater-numerically-balanced-number",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst nextBeautifulNumber = function(n) {\n    while (true) {\n        ++n;\n        if (balance(n)) return n;\n    } \n    function balance(n) {\n        let cnt = Array(10).fill(0);\n        while (n) {\n            if (n % 10 == 0) return false; // no 0 allowed\n            cnt[n % 10]++;\n            n = ~~(n / 10);\n        }\n        for (let i = 1; i < 10; ++i) {\n            if (cnt[i] && cnt[i] !== i) return false;\n        }\n        return true;\n    }\n};\n\n"
    }
  },
  {
    "name": "2049-count-nodes-with-the-highest-score",
    "code": {
      "JS": "/**\n * @param {number[]} parents\n * @return {number}\n */\nconst countHighestScoreNodes = function(parents) {\n  const n = parents.length, graph = {}, hash = {}\n  for(let i = 1; i < n; i++) {\n    if(graph[parents[i]] == null) graph[parents[i]] = []\n    graph[parents[i]].push(i)\n  }\n  dfs(0)\n  \n  function dfs(node) {\n    let product = 1, num = 0\n    for(let child of (graph[node] || [])) {\n      const tmp = dfs(child)\n      product *= tmp\n      num += tmp\n    }\n    if(n - 1 - num > 0) product *= (n - 1 - num)\n    hash[product] = (hash[product] || 0) + 1\n    return num + 1\n  }\n  const maxKey = Math.max(...Object.keys(hash))\n  return hash[maxKey]\n};\n"
    }
  },
  {
    "name": "205-isomorphic-strings",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nconst isIsomorphic = function(s, t) {\n  if (s.length !== t.length) {\n    return false;\n  }\n  const smap = {};\n  const tmap = {};\n\n  for (let i = 0; i < s.length; i++) {\n    if (!smap.hasOwnProperty(s[i])) {\n      smap[s[i]] = t[i];\n    }\n    if (!tmap.hasOwnProperty(t[i])) {\n      tmap[t[i]] = s[i];\n    }\n\n    if (smap[s[i]] !== t[i] || tmap[t[i]] !== s[i]) return false;\n\n  }\n\n  return true;\n};\n"
    }
  },
  {
    "name": "2050-parallel-courses-iii",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[][]} relations\n * @param {number[]} time\n * @return {number}\n */\nconst minimumTime = function(n, relations, time) {\n  const graph = {}, dist = Array(n).fill(0), inDegree = Array(n).fill(0)\n  \n  for(let [pre, next] of relations) {\n    pre--, next--\n    if(graph[pre] == null) graph[pre] = []\n    graph[pre].push(next)\n    inDegree[next]++\n  }\n\n  const q = []\n  for(let i = 0; i < n; i++) {\n    if(inDegree[i] === 0) {\n      q.push(i)\n      dist[i] = time[i]\n    }\n  }\n\n  let res = 0\n  while(q.length) {\n    const cur = q.shift()\n    for(const next of (graph[cur] || [])) {\n      dist[next] = Math.max(dist[next], dist[cur] + time[next])\n      inDegree[next]--\n      if(inDegree[next] === 0) q.push(next)\n    }\n  }\n  \n  return Math.max(...dist)\n}\n\n// another\n\n/**\n * @param {number} n\n * @param {number[][]} relations\n * @param {number[]} time\n * @return {number}\n */\nconst minimumTime = function(n, relations, time) {\n  const graph = {}, dist = Array(n).fill(0), inDegree = Array(n).fill(0)\n  for(let [from, to] of relations) {\n    from--, to--\n    if (graph[from] == null) graph[from] = []\n    graph[from].push(to)\n    inDegree[to]++\n  }\n  const q = []\n  for(let i = 0; i < n; i++) {\n    if(inDegree[i] === 0) {\n      q.push(i)\n      dist[i] = time[i]\n    }\n  }\n\n  while(q.length) {\n    const u = q.shift()\n    for(const v of (graph[u] || [])) {\n      dist[v] = Math.max(dist[v], dist[u] + time[v])\n      if(--inDegree[v] === 0) q.push(v)\n    }\n  }\n\n  let res = 0\n  for(let e of dist) {\n    if(e > res) res = e\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "2053-kth-distinct-string-in-an-array",
    "code": {
      "JS": "/**\n * @param {string[]} arr\n * @param {number} k\n * @return {string}\n */\nconst kthDistinct = function(arr, k) {\n  let num = 0, hash = {}\n  \n  for(let str of arr) {\n    if(hash[str] == null) hash[str] = 0\n    hash[str]++    \n  }\n  for(let str of arr) {\n    if(hash[str] > 1) continue\n    num++\n    if(num === k) return str\n  }\n  return ''\n};\n"
    }
  },
  {
    "name": "2054-two-best-non-overlapping-events",
    "code": {
      "JS": "\n/**\n * @param {number[][]} events\n * @return {number}\n */\nconst maxTwoEvents = function(events) {\n  const n = events.length\n  events.sort((a, b) => a[0] - b[0])\n  const dp = Array.from({ length: n }, () => Array(3).fill(-1))\n\n  return dfs(0, 0)\n\n  function dfs(idx, cnt) {\n    if(cnt === 2 || idx >= n) return 0\n    if(dp[idx][cnt] === -1) {\n      let end = events[idx][1]\n      let lo = idx + 1, hi = n - 1;\n      while (lo < hi) {\n        const mid = lo + ((hi - lo) >> 1);\n        if (events[mid][0] <= end) lo = mid + 1\n        else hi = mid;\n      }\n      const include = events[idx][2] + (lo < n && events[lo][0] > end ? dfs(lo, cnt + 1) : 0);\n      const exclude = dfs(idx + 1, cnt);\n      dp[idx][cnt] = Math.max(include, exclude);\n    }\n\n    return dp[idx][cnt]\n  }\n};\n\n// another\n\n/**\n * @param {number[][]} events\n * @return {number}\n */\nconst maxTwoEvents = function(events) {\n  const n = events.length, { max } = Math\n  let res = 0, maxVal = 0;\n  const pq = new PriorityQueue((a, b) => a[0] < b[0]);\n  events.sort((a, b) => a[0] === b[0] ? a[1] - b[1] : a[0] - b[0])\n  for (let e of events) {\n    for(; !pq.isEmpty() && pq.peek()[0] < e[0]; pq.pop())\n      maxVal = max(maxVal, pq.peek()[1]);\n    res = max(res, maxVal + e[2]);\n    pq.push([e[1], e[2]]);\n  }\n  return res;\n};\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n"
    }
  },
  {
    "name": "2055-plates-between-candles",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {number[][]} queries\n * @return {number[]}\n */\nconst platesBetweenCandles = function(s, queries) {\n  const n = s.length,\n    leftCandlePos = Array(n).fill(-1)\n    rightCandlePos = Array(n).fill(-1)\n    candleCnt = Array(n).fill(0)\n  let pos = -1\n  for(let i = 0; i < n; i++) {\n    if(s[i] === '|') pos = i\n    leftCandlePos[i] = pos\n  }\n  pos = -1\n  for(let i = n - 1; i >= 0; i--) {\n    if(s[i] === '|') pos = i\n    rightCandlePos[i] = pos\n  }\n  for(let i = 0, cnt = 0; i < n; i++) {\n    if(s[i] === '|') cnt++\n    candleCnt[i] = cnt\n  }\n\n  const len = queries.length, res = Array(len).fill(0)\n\n  for(let i = 0; i < len; i++) {\n    const [left, right] = queries[i]\n    const leftCandle = rightCandlePos[left], rightCandle = leftCandlePos[right]\n    const delta = rightCandle - leftCandle\n    if(leftCandle !== -1 && rightCandle !== -1 && delta > 1) {\n      res[i] = delta + 1 - (candleCnt[rightCandle] - candleCnt[leftCandle] + 1)\n    }\n  }\n\n  return res\n}\n"
    }
  },
  {
    "name": "2057-smallest-index-with-equal-value",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar smallestEqual = function(nums) {\n  const n = nums.length\n  for(let i = 0; i < n; i++) {\n    if(i % 10 === nums[i]) return i\n  }\n  return -1\n};\n"
    }
  },
  {
    "name": "2058-find-the-minimum-and-maximum-number-of-nodes-between-critical-points",
    "code": {
      "JS": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number[]}\n */\nconst nodesBetweenCriticalPoints = function(head) {\n  const arr = []\n  let cur = head\n  while(cur) {\n    arr.push(cur.val)\n    cur = cur.next\n  }\n  const idxArr = []\n  const n = arr.length\n  for(let i = 1; i < n - 1; i++) {\n    if((arr[i] > arr[i - 1] && arr[i] > arr[i + 1]) || (arr[i] < arr[i - 1] && arr[i] < arr[i + 1])) {\n      idxArr.push(i)\n    }\n  }\n  \n  let min = Infinity, max = -1\n  for(let i = 1; i < idxArr.length; i++) {\n    if(idxArr[i] - idxArr[i - 1] < min) min = idxArr[i] - idxArr[i - 1]\n  }\n  if(idxArr.length > 1) max = idxArr[idxArr.length - 1] - idxArr[0]\n  return [min === Infinity ? -1 : min, max]\n};\n"
    }
  },
  {
    "name": "2059-minimum-operations-to-convert-number",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} start\n * @param {number} goal\n * @return {number}\n */\nvar minimumOperations = function (nums, start, goal) {\n  const visited = Array(1001).fill(0)\n  const q = []\n  q.push([start, 0])\n  visited[start] = 1\n  while (q.length) {\n    const [val, idx] = q.shift()\n    if (val === goal) return idx\n    for (let e of nums) {\n      if (val + e === goal) return idx + 1\n      if (val + e <= 1000 && val + e >= 0 && !visited[val + e]) {\n        visited[val + e] = 1\n        q.push([val + e, idx + 1])\n      }\n      if (val - e === goal) return idx + 1\n      if (val - e <= 1000 && val - e >= 0 && !visited[val - e]) {\n        visited[val - e] = 1\n        q.push([val - e, idx + 1])\n      }\n\n      if ((val ^ e) === goal) return idx + 1\n      if ((val ^ e) <= 1000 && (val ^ e) >= 0 && !visited[val ^ e]) {\n        visited[val ^ e] = 1\n        q.push([val ^ e, idx + 1])\n      }\n    }\n  }\n\n  return -1\n}\n"
    }
  },
  {
    "name": "206-reverse-linked-list",
    "code": {
      "JS": "/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nconst reverseList = function(head) {\r\n  if(head == null) return head\r\n  const pre = new ListNode(null, head)\r\n  let cur = head\r\n  while(cur.next) {\r\n    let tmp = pre.next\r\n    pre.next = cur.next\r\n    cur.next = cur.next.next\r\n    pre.next.next = tmp\r\n  }\r\n\r\n  return pre.next\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nconst reverseList = function(head) {\r\n  let prev = null;\r\n  let cur = head;\r\n  let tmp;\r\n  let tmpNext;\r\n  while (cur !== null) {\r\n    tmp = cur;\r\n    tmpNext = cur.next;\r\n    cur.next = prev;\r\n    prev = tmp;\r\n    cur = tmpNext;\r\n  }\r\n\r\n  return prev;\r\n};\r\n"
    }
  },
  {
    "name": "2060-check-if-an-original-string-exists-given-two-encoded-strings",
    "code": {
      "JS": "function possiblyEquals(s1, s2) {\n  const n = s1.length, m = s2.length;\n  const dp = Array.from({ length: n + 1 }, v => Array.from({ length: m + 1}, w => new Set()));\n  dp[0][0].add(0);\n\n  for (let i = 0; i <= n; i++) {\n    for (let j = 0; j <= m; j++) {\n      for (let delta of dp[i][j]) {\n        // s1 is number\n        let num = 0;\n        if (delta <= 0) {\n          for (let p = i; i < Math.min(i + 3, n); p++) {\n              if (isDigit(s1[p])) {\n                  num = num * 10 + Number(s1[p]);\n                  dp[p + 1][j].add(delta + num);\n              } else {\n                  break;\n              }\n          }\n        }\n\n        // s2 is number\n        num = 0;\n        if (delta >= 0) {\n            for (let q = j; q < Math.min(j + 3, m); q++) {\n                if (isDigit(s2[q])) {\n                    num = num * 10 + Number(s2[q]);\n                    dp[i][q + 1].add(delta - num);\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // match s1 non-digit character\n        if (i < n && delta < 0 && !isDigit(s1[i])) {\n            dp[i + 1][j].add(delta + 1);\n        }\n\n        // match s2 non-digit character\n        if (j < m && delta > 0 && !isDigit(s2[j])) {\n            dp[i][j + 1].add(delta - 1);\n        }\n\n        // two non-digit character match\n        if (i < n && j < m && delta == 0 && s1[i] == s2[j]) {\n            dp[i + 1][j + 1].add(0);\n        }\n\n      }\n    }\n  }\n  return dp[n][m].has(0);\n};\n\nfunction isDigit(char) {\n  return (/^\\d{1}$/g).test(char);\n}\n\n// another\n\n/**\n * @param {string} s1\n * @param {string} s2\n * @return {boolean}\n */\nconst possiblyEquals = function(s1, s2) {\n  const n = s1.length\n  const m = s2.length\n  const memo = Array.from({ length: n + 1 }, () =>\n    Array.from({ length: m + 1 }, () => Array(1001).fill(null))\n  )\n  memo[0][0][1000] = true\n  \n  return dfs(0, 0, 0)\n\n  function dfs(i, j, diff) {\n    if(memo[i][j][diff] != null) return memo[i][j][diff]\n    let res = false\n    if (i == n && j == m) res = diff === 0\n    else if (i < n && isDigit(s1[i])) {\n      let ii = i\n      while (ii < n && isDigit( s1[ii] )) ii += 1\n      for (let x of helper(s1.slice(i, ii))) {\n        if (dfs(ii, j, diff-x)) res = true \n      }\n    } else if (j < m && isDigit( s2[j] )) {\n      let jj = j \n      while (jj < m && isDigit( s2[jj] )) jj += 1\n      for (let y of helper(s2.slice(j, jj))) {\n        if (dfs(i, jj, diff+y)) res = true \n      }\n    } else if (diff == 0) {\n      if (i < n && j < m && s1[i] == s2[j]) res = dfs(i+1, j+1, 0)\n    }  else if (diff > 0) {\n      if (i < n) res = dfs(i+1, j, diff-1)\n    } else {\n      if (j < m) res = dfs(i, j+1, diff+1)\n    }\n\n    memo[i][j][diff] = res\n    return res\n  }\n\n  function isDigit(ch) {\n    return ch >= '0' && ch <= '9'\n  }\n\n  function helper(str) {\n    const ans = new Set()\n    ans.add(+str)\n    for(let i = 1, len = str.length; i < len; i++) {\n      const pre = helper(str.slice(0, i))\n      const post = helper(str.slice(i))\n      for(let p of pre) {\n        for(let n of post) {\n          ans.add(p + n)\n        }\n      }\n    }\n    return Array.from(ans)\n  }\n};\n\n// another\n\n/**\n * @param {string} s1\n * @param {string} s2\n * @return {boolean}\n */\nvar possiblyEquals = function (s1, s2) {\n  let n = s1.length\n  let m = s2.length\n  const f = Array.from({ length: n + 1 }, () =>\n    Array.from({ length: m + 1 }, () => Array(1001).fill(false))\n  )\n  f[0][0][1000] = true\n\n  for (let i = 0; i <= n; i++)\n    for (let j = 0; j <= m; j++)\n      for (let k = 0; k < 2000; k++) {\n        if (!f[i][j][k]) continue\n        // if k==1000 means length diff is 0, so check both next charactors.\n        if (i + 1 <= n && j + 1 <= m && k == 1000 && s1[i] == s2[j]) {\n          f[i + 1][j + 1][k] = true\n        }\n        // if first string is longer or same length, extend second string.\n        if (k >= 1000 && j + 1 <= m) {\n          if (s2[j] >= 'a' && s2[j] <= 'z') {\n            // do not extend to be a longer string using a-z.\n            if (k > 1000) {\n              f[i][j + 1][k - 1] = true\n            }\n          } else if (s2[j] > '0') {\n            let cur = 0\n            for (let r = j; r < m; r++) {\n              if (s2[r] >= '0' && s2[r] <= '9') {\n                cur = cur * 10 + (s2[r] - '0')\n                f[i][r + 1][k - cur] = true\n              } else break\n            }\n          }\n        }\n        // if second string is longer or same length, extend first string.\n        if (k <= 1000 && i + 1 <= n) {\n          if (s1[i] >= 'a' && s1[i] <= 'z') {\n            if (k < 1000) {\n              f[i + 1][j][k + 1] = true\n            }\n          } else if (s1[i] > '0') {\n            let cur = 0\n            for (let r = i; r < n; r++) {\n              if (s1[r] >= '0' && s1[r] <= '9') {\n                cur = cur * 10 + (s1[r] - '0')\n                f[r + 1][j][k + cur] = true\n              } else break\n            }\n          }\n        }\n      }\n  return f[n][m][1000]\n}\n"
    }
  },
  {
    "name": "2062-count-vowel-substrings-of-a-string",
    "code": {
      "JS": "/**\n * @param {string} word\n * @return {number}\n */\nconst countVowelSubstrings = function(word) {\n  let res = 0, n= word.length\n  for(let i = 0; i < n - 1;i++) {\n    for(let j = i + 1;j < n; j++) {\n      if(valid(word, i, j)) res++\n    }\n  }\n  \n  return res\n  \n  function valid(s, i, j) {\n    const set = new Set(['a', 'e', 'i', 'o','u'])\n    const vis = new Set()\n    for(let idx = i; idx <= j; idx++) {\n      if(!set.has(s[idx])) return false\n      else {\n        vis.add(s[idx])\n      }\n    }\n    // console.log(vis)\n    return vis.size === 5\n  }\n};\n"
    }
  },
  {
    "name": "2063-vowels-of-all-substrings",
    "code": {
      "JS": "/**\n * @param {string} word\n * @return {number}\n */\nconst countVowels = function(word) {\n  let res = 0n\n  const n = BigInt(word.length)\n  const set = new Set(['a', 'e', 'i', 'o', 'u'])\n  const dp = Array(n + 1n).fill(0n)\n  for(let i = 0n; i < n; i++) {\n    const ch = word[i]\n    if(set.has(ch)) dp[i + 1n] = dp[i] + (i + 1n)\n    else dp[i + 1n] = dp[i]\n  }\n  \n  for(const e of dp) res += e\n  return res\n};\n\n\n"
    }
  },
  {
    "name": "2064-minimized-maximum-of-products-distributed-to-any-store",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[]} quantities\n * @return {number}\n */\nvar minimizedMaximum = function(n, quantities) {\n     let MAX = 0;\n    for (let x of quantities) MAX = Math.max(x, MAX);\n    let l = 1, r = MAX;\n    while (l < r) {\n        let mid = Math.floor((l + r) / 2);\n        if (valid(quantities, mid) <= n) r = mid;\n        else l = mid + 1;\n    }\n    return l; \n};\n\n\n\n  function valid(quantities,  max) {\n      let cnt = 0;\n      for (let x of quantities) cnt += Math.floor(x / max) + ((x % max) ? 1 : 0);\n      return cnt;\n  }\n\n// another\n\n/**\n * @param {number} n\n * @param {number[]} quantities\n * @return {number}\n */\nconst minimizedMaximum = function(n, quantities) {\n  let MAX = 0;\n  for (let x of quantities) MAX = Math.max(x, MAX);\n  let l = 1, r = MAX;\n  while (l < r) {\n    let mid = Math.floor((l + r) / 2);\n    if (valid(quantities, mid, n)) l = mid + 1;\n    else r = mid;\n  }\n  return l; \n};\n\nfunction valid(quantities,  max, n) {\n  let cnt = 0;\n  for (let x of quantities) cnt += Math.floor(x / max) + ((x % max) ? 1 : 0);\n  return cnt > n;\n}\n"
    }
  },
  {
    "name": "2065-maximum-path-quality-of-a-graph",
    "code": {
      "JS": "/**\n * @param {number[]} values\n * @param {number[][]} edges\n * @param {number} maxTime\n * @return {number}\n */\nconst maximalPathQuality = function(values, edges, maxTime) {\n  const graph = {}, n = values.length\n  for(const [u, v, t] of edges) {\n    if(graph[u] == null) graph[u] = []\n    if(graph[v] == null) graph[v] = []\n    graph[u].push([v, t])\n    graph[v].push([u, t])\n  }\n  let res = 0, visited = new Array(n).fill(0)\n  visited[0] = 1\n  bt(0, values[0], 0)\n  return res\n\n  function bt(i, val, time) {\n    if(time > maxTime) return\n    if(i === 0) res = Math.max(res, val)\n    \n    for(const [next, nextTime] of (graph[i] || [])) {\n      const nextVal = visited[next] > 0 ? val : val + values[next]\n      visited[next]++\n      bt(next, nextVal, time + nextTime)\n      visited[next]--\n    }\n  }\n};\n\n// another\n\n\n/**\n * @param {number[]} values\n * @param {number[][]} edges\n * @param {number} maxTime\n * @return {number}\n */\nconst maximalPathQuality = function(values, edges, maxTime) {\n  const graph = {}, n = values.length\n  for(const [u, v, t] of edges) {\n    if(graph[u] == null) graph[u] = []\n    if(graph[v] == null) graph[v] = []\n    graph[u].push([v, t])\n    graph[v].push([u, t])\n  }\n  let res = 0, visited = Array(n).fill(false)\n  bt(0, 0, 0)\n  return res\n\n  function bt(i, cur, time) {\n    if(time > maxTime) return\n    const backup = visited[i]\n    if(!visited[i]) {\n      visited[i] = true\n      cur += values[i]\n    }\n\n    if(i === 0) {\n      res = Math.max(res, cur)\n    }\n\n    for(const [next, nextTime] of (graph[i] || [])) {\n      bt(next, cur, time + nextTime)\n    }\n    visited[i] = backup\n  }\n};\n\n// another\n\n/**\n * @param {number[]} values\n * @param {number[][]} edges\n * @param {number} maxTime\n * @return {number}\n */\nconst maximalPathQuality = function(values, edges, maxTime) {\n    let zeroMax = 0;\n    let n = values.length;\n    let ll = Array.from({length: n + 1}, () => [])\n    for (let edge of edges) {\n      let u = edge[0];\n      let v = edge[1];\n      let t = edge[2];\n      ll[u].push([v, t]);\n      ll[v].push([u, t]);\n    }\n    const visited = Array(n + 1).fill(false);\n    dfs(0, 0, 0, maxTime, visited);\n    return zeroMax;\n\n    function dfs(val,  curNode,  curTime,  maxTime, visited) {\n      if (curTime > maxTime) {\n        return;\n      }\n      let before = visited[curNode];\n      if (!visited[curNode]) {\n        val += values[curNode];\n        visited[curNode] = true;\n      }\n      if (curNode == 0) {\n        zeroMax = Math.max(zeroMax, val);\n      }\n      for (let next of (ll[curNode] || [])) {\n        dfs(val, next[0], curTime + next[1], maxTime, visited);\n      }\n      visited[curNode] = before;\n    }\n};\n"
    }
  },
  {
    "name": "2068-check-whether-two-strings-are-almost-equivalent",
    "code": {
      "JS": "/**\n * @param {string} word1\n * @param {string} word2\n * @return {boolean}\n */\nconst checkAlmostEquivalent = function(word1, word2) {\n  const a = 'a'.charCodeAt(0), n = word1.length\n  const arr1 = Array(26).fill(0), arr2 = Array(26).fill(0)\n  \n  for(const ch of word1) {\n    arr1[ch.charCodeAt(0) - a]++\n  }\n  for(const ch of word2) {\n    arr2[ch.charCodeAt(0) - a]++\n  }\n  for(let i = 0; i < 26; i++) {\n    if(Math.abs(arr1[i] - arr2[i]) > 3) return false\n  }\n  \n  return true\n};\n"
    }
  },
  {
    "name": "2069-walking-robot-simulation-ii",
    "code": {
      "JS": "/**\n * @param {number} width\n * @param {number} height\n */\nconst Robot = function(width, height) {\n  this.i = 0\n  const pos = Array()\n  this.len = width + height - 1 + width - 1 + height - 2\n  pos.push( [0,0,3] )\n  for(let i = 1; i < width; i++) {\n    pos.push([i, 0, 0])\n  }\n  for(let i = 1; i < height; i++) {\n    pos.push([width - 1, i, 1])\n  }\n  for(let i = 1; i < width; i++) {\n    pos.push([width - 1 - i, height - 1, 2])\n  }\n  for(let i = 1; i < height - 1; i++) {\n    pos.push([0, height - 1 - i, 3])\n  }\n  this.pos = pos\n};\n\n/** \n * @param {number} num\n * @return {void}\n */\nRobot.prototype.step = function(num) {\n  this.i += num\n};\n\n/**\n * @return {number[]}\n */\nRobot.prototype.getPos = function() {\n  return this.pos[this.i % this.len].slice(0, 2)\n};\n\n/**\n * @return {string}\n */\nRobot.prototype.getDir = function() {\n  const hash = ['East', 'North', 'West', 'South']\n  if(this.i === 0) return hash[0]\n  else {\n    return hash[this.pos[this.i % this.len][2]]\n  }\n};\n"
    }
  },
  {
    "name": "207-course-schedule",
    "code": {
      "JS": "/**\n * @param {number} numCourses\n * @param {number[][]} prerequisites\n * @return {boolean}\n */\nconst canFinish = function(numCourses, prerequisites) {\n  const [graph, inDegree] = buildGraph(numCourses, prerequisites)\n  \n  const q = []\n  for(let i = 0; i < numCourses; i++) {\n    if(inDegree.get(i) == null) q.push(i)\n  }\n  let num = 0\n  while(q.length) {\n    const pre = q.pop()\n    num++\n    for(const next of (graph.get(pre) || [])) {\n      inDegree.set(next, inDegree.get(next) - 1)\n      if(inDegree.get(next) === 0) q.push(next)\n    }\n  }\n  return num === numCourses\n  \n  \n  function buildGraph(n, arr) {\n    const res = new Map(), inDegree = new Map()\n    for(const [cur, pre] of arr) {\n      if(res.get(pre) == null) res.set(pre, new Set())\n      res.get(pre).add(cur)\n      if(inDegree.get(cur) == null) inDegree.set(cur, 0)\n      inDegree.set(cur, inDegree.get(cur) + 1)\n    }\n    return [res, inDegree]\n  }\n};\n\n// another\n\n/**\n * @param {number} numCourses\n * @param {number[][]} prerequisites\n * @return {boolean}\n */\nconst canFinish = function(numCourses, prerequisites) {\n  const seen = new Set()\n  const seeing = new Set()\n  const adj = [...Array(numCourses)].map(r => [])\n  for (let [u, v] of prerequisites) {\n    adj[v].push(u)\n  }\n  for (let c = 0; c < numCourses; c++) {\n    if (!dfs(c)) {\n      return false\n    }\n  }\n  return true\n  function dfs(v) {\n    if (seen.has(v)) return true\n    if (seeing.has(v)) return false\n    seeing.add(v)\n    for (let nv of adj[v]) {\n      if (!dfs(nv)) {\n        return false\n      }\n    }\n    seeing.delete(v)\n    seen.add(v)\n    return true\n  }\n}\n\n// another\n\n/**\n * @param {number} numCourses\n * @param {number[][]} prerequisites\n * @return {boolean}\n */\nconst canFinish = function(vertices, edges) {\n  const sortedOrder = []\n  if (vertices <= 0) {\n    return sortedOrder\n  }\n  const inDegree = Array(vertices).fill(0)\n  const graph = Array(vertices)\n    .fill(0)\n    .map(() => Array())\n  edges.forEach(edge => {\n    let parent = edge[0]\n    let child = edge[1]\n    graph[parent].push(child)\n    inDegree[child]++\n  })\n  const sources = []\n  for (let i = 0; i < inDegree.length; i++) {\n    if (inDegree[i] === 0) {\n      sources.push(i)\n    }\n  }\n  while (sources.length > 0) {\n    const vertex = sources.shift()\n    sortedOrder.push(vertex)\n\n    graph[vertex].forEach(child => {\n      inDegree[child] -= 1\n      if (inDegree[child] === 0) {\n        sources.push(child)\n      }\n    })\n  }\n  return sortedOrder.length === vertices ? true : false\n}\n\n// another\n\n/**\n * @param {number} numCourses\n * @param {number[][]} prerequisites\n * @return {boolean}\n */\nconst canFinish = function(numCourses, prerequisites) {\n  const set = new Set(), hash = {}\n  for(let i = 0; i < prerequisites.length; i++) {\n    const [cur, pre] = prerequisites[i]\n    if(hash[cur] == null) hash[cur] = new Set()\n    hash[cur].add(pre)\n  }\n  const q = []\n\n  for(let i = 0; i < numCourses; i++) {\n    if(hash[i] == null) q.push(i)\n  }\n  let visited = 0\n\n  while(q.length) {\n    const cur = q.shift()\n    visited++\n    Object.keys(hash).forEach(k => {\n       if(hash[k].has(cur)) {\n         hash[k].delete(cur)\n       }\n       if(hash[k].size === 0) {\n         delete hash[k]\n         q.push(+k)\n       }\n    })\n  }\n  return visited === numCourses\n};\n"
    }
  },
  {
    "name": "2071-maximum-number-of-tasks-you-can-assign",
    "code": {
      "JS": "//////////////////////////////////////////////Template/////////////////////////////////////////////////////////////\nfunction Bisect() {\n  return { insort_right, insort_left, bisect_left, bisect_right }\n  function insort_right(a, x, lo = 0, hi = null) {\n    lo = bisect_right(a, x, lo, hi)\n    a.splice(lo, 0, x)\n  }\n  function bisect_right(a, x, lo = 0, hi = null) {\n    // > upper_bound\n    if (lo < 0) throw new Error('lo must be non-negative')\n    if (hi == null) hi = a.length\n    while (lo < hi) {\n      let mid = parseInt((lo + hi) / 2)\n      x < a[mid] ? (hi = mid) : (lo = mid + 1)\n    }\n    return lo\n  }\n  function insort_left(a, x, lo = 0, hi = null) {\n    lo = bisect_left(a, x, lo, hi)\n    a.splice(lo, 0, x)\n  }\n  function bisect_left(a, x, lo = 0, hi = null) {\n    // >= lower_bound\n    if (lo < 0) throw new Error('lo must be non-negative')\n    if (hi == null) hi = a.length\n    while (lo < hi) {\n      let mid = parseInt((lo + hi) / 2)\n      a[mid] < x ? (lo = mid + 1) : (hi = mid)\n    }\n    return lo\n  }\n}\n/**\n * @param {number[]} tasks\n * @param {number[]} workers\n * @param {number} pills\n * @param {number} strength\n * @return {number}\n */\nconst maxTaskAssign = function(tasks, workers, pills, strength) {\n  tasks.sort((a, b) => a - b)\n  workers.sort((a, b) => b - a)\n  const m = tasks.length, n = workers.length\n  const { min, floor } = Math\n  let l = 0, r = min(n, m)\n  while (l < r) {\n    const mid = r - floor((r - l) / 2)\n    if (check(mid)) l = mid\n    else r = mid - 1\n  }\n\n  return l\n\n  function check(k){\n    const wArr = workers.slice(0, k), tArr = tasks.slice(0, k)\n    let tries = pills, bs = new Bisect()\n    wArr.reverse()\n    tArr.reverse()\n  \n    for (let elem of tArr) {\n      const place = bs.bisect_left(wArr, elem)\n      if (place < wArr.length) {\n        wArr.pop()\n      } else if (tries > 0) {\n        const place2 = bs.bisect_left(wArr, elem - strength)\n        if (place2 < wArr.length) {\n          wArr.splice(place2, 1)\n          tries -= 1\n        }\n      } else return false\n    }\n  \n    return wArr.length === 0\n  }\n};\n"
    }
  },
  {
    "name": "2073-time-needed-to-buy-tickets",
    "code": {
      "JS": "/**\n * @param {number[]} tickets\n * @param {number} k\n * @return {number}\n */\nconst timeRequiredToBuy = function(tickets, k) {\n  let res = 0\n  \n  while(tickets[k] !== 0) {\n    res += helper(tickets, k)\n  }\n  \n  return res\n  \n  function helper(arr, k) {\n    let tmp = 0\n    for(let i = 0; i < arr.length; i++) {\n      if(arr[i] > 0) {\n        arr[i]--\n        tmp++\n      }\n      if(arr[k] === 0) break\n    }\n    return tmp\n  }\n  \n};\n"
    }
  },
  {
    "name": "2074-reverse-nodes-in-even-length-groups",
    "code": {
      "JS": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nconst reverseEvenLengthGroups = function(head) {\n  const arr = []\n  let cur = head\n  while(cur) {\n    arr.push(cur)\n    cur = cur.next\n  }\n  let len = 1, res = []\n  for(let i = 0, n = arr.length; i < n; ) {\n    let backup = len, tmp = [], rev = len % 2 === 0\n    while(len && i < n) {\n      tmp.push(arr[i])\n      i++\n      len--\n    }\n    if((tmp.length % 2 === 0) ) {\n      tmp.reverse()\n    }\n    res.push(...tmp)\n    len = backup + 1\n  }\n  for(let i = 0; i < res.length; i++) {\n    if(i === res.length - 1) res[i].next = null\n    else {\n      res[i].next = res[i + 1]\n    }\n  }\n  \n  return res[0]\n};\n"
    }
  },
  {
    "name": "2075-decode-the-slanted-ciphertext",
    "code": {
      "JS": "/**\n * @param {string} encodedText\n * @param {number} rows\n * @return {string}\n */\nvar decodeCiphertext = function(encodedText, rows) {\n    let n = encodedText.length;\n    let cols = ~~(n / rows);\n    const matrix = Array.from({ length: rows }, () => Array(cols).fill('')) \n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n          matrix[i][j] = encodedText[i * cols + j];\n        }\n    }\n    let ans = \"\";\n    for (let i = 0; i < cols; i++) {\n        let t = Math.min(rows, cols - i);\n        for (let j = 0; j < t; j++) {\n          ans += matrix[j][i + j];\n        }\n    }\n    let idx = ans.length - 1\n    for(; idx >= 0; idx--) {\n      if(ans[idx] === ' ') continue\n      else break\n    }\n    return ans.slice(0, idx + 1);\n};\n\n"
    }
  },
  {
    "name": "2076-process-restricted-friend-requests",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[][]} restrictions\n * @param {number[][]} requests\n * @return {boolean[]}\n */\nvar friendRequests = function(n, restrictions, requests) {\n        function validation(arr) {\n            for (const [x, y] of restrictions) {\n                if (arr[x] == arr[y]) return false              \n            }\n\n            return true\n        }\n\n\n\n        let groupId = []\n        for(let i = 0; i < n; i++) groupId.push(i) \n\n\n        const ans = []\n        for(let [u, v] of requests) {\n            if (v < u) [u, v] = [v, u]\n            const tmp = groupId.slice()\n\n            for(let i = 0; i < n; i++) {\n                if (tmp[i] == groupId[v]) tmp[i] = groupId[u]              \n            }\n\n            if (validation(tmp)) {\n                ans.push(true)\n                groupId = tmp\n            } else ans.push(false)\n        }\n\n\n        return ans  \n};\n\n"
    }
  },
  {
    "name": "2078-two-furthest-houses-with-different-colors",
    "code": {
      "JS": "/**\n * @param {number[]} colors\n * @return {number}\n */\nconst maxDistance = function(colors) {\n  const n = colors.length\n  let res = 0\n  for(let i = 1; i < n; i++) {\n    const cur = colors[i]\n    for(let j = 0; j < i; j++) {\n      if(colors[i] !== colors[j]) {\n        res = Math.max(res, i - j)\n        break\n      }\n    }\n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "2079-watering-plants",
    "code": {
      "JS": "/**\n * @param {number[]} plants\n * @param {number} capacity\n * @return {number}\n */\nconst wateringPlants = function(plants, capacity) {\n  let res = 0, cap = capacity, full = capacity\n  for(let i = 0, n = plants.length; i < n; i++) {\n    const cur = plants[i]\n    cap -= cur\n    if(cap >= 0) res++\n    else {\n      res = res + (i + i + 1)\n      cap = full - cur\n    }\n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "208-implement-trie-prefix-tree",
    "code": {
      "JS": "/**\n * Initialize your data structure here.\n */\nconst Trie = function() {\n  this.root = {}\n};\n\n/**\n * Inserts a word into the trie. \n * @param {string} word\n * @return {void}\n */\nTrie.prototype.insert = function(word) {\n  let curr = this.root\n  word.split('').forEach(ch => (curr = curr[ch] = curr[ch] || {}))\n  curr.isWord = true\n};\n\n/**\n * Returns if the word is in the trie. \n * @param {string} word\n * @return {boolean}\n */\nTrie.prototype.search = function(word) {\n  let node = this.traverse(word)\n  return !!node && !!node.isWord   \n};\n\n/**\n * Returns if there is any word in the trie that starts with the given prefix. \n * @param {string} prefix\n * @return {boolean}\n */\nTrie.prototype.startsWith = function(prefix) {\n   return !!this.traverse(prefix)   \n};\n\n/** \n * Your Trie object will be instantiated and called as such:\n * var obj = new Trie()\n * obj.insert(word)\n * var param_2 = obj.search(word)\n * var param_3 = obj.startsWith(prefix)\n */\n\nTrie.prototype.traverse = function(word) {\n  let curr = this.root\n  for (let i = 0; i < word.length; i++) {\n    if (!curr) return null\n    curr = curr[word[i]]\n  }\n  return curr\n}\n\n// another\n\nclass Trie {\n  constructor() {\n    this.links = new Map();\n    this.isWord = false;\n  }\n  insert(word) {\n    let node = this;\n    for (const c of word) {\n      if (!node.links.has(c)) node.links.set(c, new Trie());\n      node = node.links.get(c);\n    }\n    node.isWord = true;\n  }\n  search(word) {\n    const node = this.traverse(word);\n    return node ? node.isWord : false;\n  }\n  startsWith(prefix) {\n    const node = this.traverse(prefix);\n    return node !== null;\n  }\n  traverse(word) {\n    let node = this;\n    for (const c of word) {\n      if (node.links.has(c)) node = node.links.get(c);\n      else return null;\n    }\n    return node;\n  }\n}\n\n// another\n/**\n * Initialize your data structure here.\n */\nconst Trie = function () {\n  this.root = new Node(null)\n}\n\n/**\n * Inserts a word into the trie.\n * @param {string} word\n * @return {void}\n */\nTrie.prototype.insert = function (word) {\n  let cur = this.root\n  for (let i = 0, len = word.length; i < len; i++) {\n    if (!cur.children.has(word[i])) cur.children.set(word[i], new Node(null))\n    cur = cur.children.get(word[i])\n    if (i === len - 1) cur.word = true\n  }\n}\n\n/**\n * Returns if the word is in the trie.\n * @param {string} word\n * @return {boolean}\n */\nTrie.prototype.search = function (word) {\n  let cur = this.root\n  for (let i = 0, len = word.length; i < len; i++) {\n    if (cur.children.has(word[i])) cur = cur.children.get(word[i])\n    else return false\n    if (i === len - 1) return cur.word === true\n  }\n}\n\n/**\n * Returns if there is any word in the trie that starts with the given prefix.\n * @param {string} prefix\n * @return {boolean}\n */\nTrie.prototype.startsWith = function (prefix) {\n  let cur = this.root\n  for (let i = 0, len = prefix.length; i < len; i++) {\n    if (cur.children.has(prefix[i])) cur = cur.children.get(prefix[i])\n    else return false\n    if (i === len - 1) return true\n  }\n}\n\nclass Node {\n  constructor(v) {\n    this.val = v\n    this.word = false\n    this.children = new Map()\n  }\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * var obj = new Trie()\n * obj.insert(word)\n * var param_2 = obj.search(word)\n * var param_3 = obj.startsWith(prefix)\n */\n"
    }
  },
  {
    "name": "2080-range-frequency-queries",
    "code": {
      "JS": "//////////////////////////////////////////////Template/////////////////////////////////////////////////////////////\nfunction Bisect() {\n    return { insort_right, insort_left, bisect_left, bisect_right }\n    function insort_right(a, x, lo = 0, hi = null) {\n        lo = bisect_right(a, x, lo, hi);\n        a.splice(lo, 0, x);\n    }\n    function bisect_right(a, x, lo = 0, hi = null) { // > upper_bound\n        if (lo < 0) throw new Error('lo must be non-negative');\n        if (hi == null) hi = a.length;\n        while (lo < hi) {\n            let mid = parseInt((lo + hi) / 2);\n            x < a[mid] ? hi = mid : lo = mid + 1;\n        }\n        return lo;\n    }\n    function insort_left(a, x, lo = 0, hi = null) {\n        lo = bisect_left(a, x, lo, hi);\n        a.splice(lo, 0, x);\n    }\n    function bisect_left(a, x, lo = 0, hi = null) { // >= lower_bound\n        if (lo < 0) throw new Error('lo must be non-negative');\n        if (hi == null) hi = a.length;\n        while (lo < hi) {\n            let mid = parseInt((lo + hi) / 2);\n            a[mid] < x ? lo = mid + 1 : hi = mid;\n        }\n        return lo;\n    }\n}\n\n// counter with {value: array indices (increasing order)}\nconst counter_value_in_indexA_in = (a_or_s) => { let m = new Map(); let n = a_or_s.length; for (let i = 0; i < n; i++) { if (!m.has(a_or_s[i])) m.set(a_or_s[i], []); m.get(a_or_s[i]).push(i); } return m; };\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n/**\n * @param {number[]} arr\n */\nvar RangeFreqQuery = function(arr) {\n  let a = arr\n  this.m = counter_value_in_indexA_in(a)\n  this.bi = new Bisect();\n};\n\n/** \n * @param {number} left \n * @param {number} right \n * @param {number} value\n * @return {number}\n */\nRangeFreqQuery.prototype.query = function(left, right, value) {\n    let l = left, r =right, x = value, m = this.m, bi = this.bi\n    if (!m.has(x)) return 0;\n    let a = m.get(x), len = a.length;\n    let min = a[0], max = a[len - 1];\n    if (l <= min && r >= max) return len; // cover all\n    if (r < min || l > max) return 0; // out of bound\n    let lbs = bi.bisect_left(a, l); // needs lbs >= l  (lower bound will find first >= l)\n    let ubs = bi.bisect_right(a, r); // needs ubs <= r    (upper bound will find first ubs > r, -1 will guarantee <= r)\n    ubs--;\n    return ubs - lbs + 1;\n};\n\n/** \n * Your RangeFreqQuery object will be instantiated and called as such:\n * var obj = new RangeFreqQuery(arr)\n * var param_1 = obj.query(left,right,value)\n */\n\n"
    }
  },
  {
    "name": "2081-sum-of-k-mirror-numbers",
    "code": {
      "JS": "const isPalindrome = (s) => { let n = s.length; let i = 0; let j = n - 1; while (i < j) { if (s[i++] != s[j--]) return false; } return true; };\n\nconst int = parseInt;\n/**\n * @param {number} k\n * @param {number} n\n * @return {number}\n */\nvar kMirror = function(k, n) {\n    let res = 0;\n    for (let len = 1; ; len++) {\n        let min = 10 ** ((len - 1) >> 1), max = 10 ** ((len + 1) >> 1);\n        for (let base = min; base < max; base++) {\n            let x = base;\n            for (let i = len & 1 ? int(base / 10) : base; i > 0; i = int(i / 10)) {\n                x = x * 10 + i % 10;\n            }\n            let s = x.toString(k);\n            if (isPalindrome(s)) {\n                res += x;\n                n--;\n                if (!n) return res;\n            }\n        }\n    }  \n};\n"
    }
  },
  {
    "name": "2086-minimum-number-of-buckets-required-to-collect-rainwater-from-houses",
    "code": {
      "JS": "/**\n * @param {string} street\n * @return {number}\n */\nvar minimumBuckets = function(street) {\n  const arr = street.split(''), n = arr.length\n  let res = 0\n  for(let i = 0; i < arr.length; i++) {\n    if(arr[i] === 'H') {\n      if(i > 0 && arr[i - 1] === 'B') continue\n      if(i < n - 1 && arr[i + 1] === '.') arr[i + 1] = 'B', res++\n      else if(i > 0 && arr[i - 1] === '.') arr[i - 1] = 'B', res++\n      else return -1\n    }\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "2088-count-fertile-pyramids-in-a-land",
    "code": {
      "JS": "/**\n * @param {number[][]} grid\n * @return {number}\n */\n const countPyramids = function(grid) {\n  const rev = clone(grid).reverse()\n  let res = count(grid)\n  res += count(rev)\n  return res\n\n  function clone(grid) {\n    return grid.map(e => e.slice())\n  }\n\n  function count(grid) {\n    const m = grid.length, n = grid[0].length\n    let res = 0\n    for (let i = 1; i < m; i++) {\n      for (let j = 1; j < n - 1; j++) {\n        if (grid[i][j] && grid[i - 1][j]) {\n          grid[i][j] = Math.min(\n            grid[i - 1][j - 1],\n            grid[i - 1][j + 1]\n          ) + 1\n          res += grid[i][j] - 1\n        }\n      }\n    }\n    return res\n  }\n};\n"
    }
  },
  {
    "name": "2089-find-target-indices-after-sorting-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nconst targetIndices = function(nums, target) {\n  let res = []\n  nums.sort((a, b) => a - b)\n  for(let i = 0; i < nums.length; i++) {\n    if(nums[i] === target) res.push(i)\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "209-minimum-size-subarray-sum",
    "code": {
      "JS": "/**\n * @param {number} s\n * @param {number[]} nums\n * @return {number}\n */\nconst minSubArrayLen = function(s, nums) {\n    let sum = 0, from = 0, win = Number.MAX_SAFE_INTEGER;\n    for (let i = 0; i < nums.length; i++) {\n        sum += nums[i];\n        while (sum >= s) {\n            win = Math.min(win, i - from + 1);\n            sum -= nums[from++];\n        }\n    }\n    return (win === Number.MAX_SAFE_INTEGER) ? 0 : win;\n};\n"
    }
  },
  {
    "name": "2090-k-radius-subarray-averages",
    "code": {
      "JS": "const lowBit = (x) => x & -x\nclass FenwickTree {\n  constructor(n) {\n    if (n < 1) return\n    this.sum = Array(n + 1).fill(0)\n  }\n  update(i, delta) {\n    if (i < 1) return\n    while (i < this.sum.length) {\n      this.sum[i] += delta\n      i += lowBit(i)\n    }\n  }\n  query(i) {\n    if (i < 1) return 0\n    let sum = 0\n    while (i > 0) {\n      sum += this.sum[i]\n      i -= lowBit(i)\n    }\n    return sum\n  }\n}\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nconst getAverages = function(nums, k) {\n  const n = nums.length\n  const bit = new FenwickTree(n)\n  for(let i = 0; i < n; i++) {\n    bit.update(i + 1, nums[i])\n  }\n  const res = Array(n).fill(-1)\n  // console.log(bit)\n  for(let i = k; i < n - k; i++) {\n    const pre = bit.query(i + 1 - k - 1), cur = bit.query(i + 1 + k)\n    res[i] = ~~((cur - pre) / (k * 2 + 1))\n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "2091-removing-minimum-and-maximum-from-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst minimumDeletions = function(nums) {\n  let mi = Infinity, ma = -Infinity\n  let mii = -1, mai = -1\n  const { max, min, abs } = Math, n = nums.length\n  for(let i = 0; i < n; i++) {\n    const e = nums[i]\n    if(e < mi) {\n      mi = e\n      mii = i\n    }\n    if(e > ma) {\n      ma = e\n      mai = i\n    }\n  }\n  \n  const disMi = abs(mii + 1, n - mii)\n  const disMa = abs(mai + 1, n - mai)\n  let res = 0\n  let lmi = min(mii, mai), lma = max(mii, mai)\n  \n  res += min(lmi + 1 + n - lma, lma + 1, n - lmi)\n  \n  \n  return res\n};\n"
    }
  },
  {
    "name": "2092-find-all-people-with-secret",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[][]} meetings\n * @param {number} firstPerson\n * @return {number[]}\n */\nconst findAllPeople = function(n, meetings, firstPerson) {\n  meetings.sort((a, b) => a[2] - b[2])\n  const uf = new UnionFind(n);\n  uf.connect(0, firstPerson);\n  let ppl = [];\n  for (let i = 0, len = meetings.length; i < len; ) {\n    ppl = [];\n    let time = meetings[i][2];\n    while (i < len && meetings[i][2] === time) {\n      uf.connect(meetings[i][0], meetings[i][1]);\n      ppl.push(meetings[i][0]);\n      ppl.push(meetings[i][1]);\n      i++\n    }\n    for (let n of ppl) {\n      if (!uf.connected(0, n)) uf.reset(n);\n    }\n  }\n  let ans = [];\n  for (let i = 0; i < n; ++i) {\n    if (uf.connected(0, i)) ans.push(i);\n  }\n  return ans;\n};\n\nclass UnionFind {\n  constructor(n) {\n    this.arr = Array(n).fill(null)\n    this.arr.forEach((e, i, arr) => arr[i] = i)\n  }\n  connect(a, b) {\n    this.arr[this.find(a)] = this.find(this.arr[b])\n  }\n  find(a) {\n    return this.arr[a] === a ? a : (this.arr[a] = this.find(this.arr[a]))\n  }\n  connected(a, b) {\n    return this.find(a) === this.find(b)\n  }\n  reset(a) {\n    this.arr[a] = a\n  }\n}\n\n// another\n\n/**\n * @param {number} n\n * @param {number[][]} meetings\n * @param {number} firstPerson\n * @return {number[]}\n */\nconst findAllPeople = function(n, meetings, firstPerson) {\n  meetings.sort((a, b) => a[2] - b[2])\n  const shared = new Set([0, firstPerson])\n  \n  let start = new Set(), links = {}\n  for(let i = 0, len = meetings.length; i < len; i++) {\n    const [x,y,t] = meetings[i]\n    if(i > 0 && t !== meetings[i - 1][2]) {\n      bfs(start, links)\n      start = new Set()\n      links = {}\n    }\n    if(shared.has(x)) start.add(x)\n    if(shared.has(y)) start.add(y)\n    if(links[x] == null) links[x] = []\n    if(links[y] == null) links[y] = []\n    links[x].push(y)\n    links[y].push(x)\n  }\n  \n  bfs(start, links)\n  return Array.from(shared)\n  \n  function bfs(start, links) {\n    const visited = new Set()\n    while(start.size) {\n      const it = start[Symbol.iterator]()\n      const cur = it.next().value\n      start.delete(cur)\n      visited.add(cur)\n      shared.add(cur)\n      for(let e of (links[cur] || [])) {\n        if(!visited.has(e)) start.add(e)\n      }\n    }\n  }\n};\n"
    }
  },
  {
    "name": "2094-finding-3-digit-even-numbers",
    "code": {
      "JS": "/**\n * @param {number[]} digits\n * @return {number[]}\n */\nconst findEvenNumbers = function(digits) {\n  const set = new Set(), visited = new Set()\n  helper(0, [])\n  const res = Array.from(set)\n  res.sort((a, b) => a - b)\n  return res\n  \n  function helper(idx, cur) {\n    if(cur.length === 3) {\n      set.add(+cur.join(''))\n      return\n    }\n    for(let i = 0; i < digits.length; i++) {\n      if(visited.has(i)) continue\n      const d = digits[i]\n      if(d === 0) {\n        if(cur.length === 0) continue\n        else {\n          cur.push(d)\n          visited.add(i)\n          helper(i + 1, cur)\n          visited.delete(i)\n          cur.pop()\n        }\n      } else {\n        const isEven = d % 2 === 0\n        if(cur.length === 3 - 1) {\n          if(isEven) {\n            cur.push(d)\n                      visited.add(i)\n            helper(i + 1, cur)\n                      visited.delete(i)\n            cur.pop()\n          } else continue\n        } else {\n           cur.push(d)\n                    visited.add(i)\n            helper(i + 1, cur)\n                    visited.delete(i)\n            cur.pop()\n        }\n      }\n    }\n  }\n};\n"
    }
  },
  {
    "name": "2095-delete-the-middle-node-of-a-linked-list",
    "code": {
      "JS": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nconst deleteMiddle = function(head) {\n  if(head == null) return head\n  const dummy = new ListNode(null, head)\n  let n = 0, cur = head\n  while(cur) {\n    n++\n    cur = cur.next\n  }\n  if(n === 1) return null\n  const mid = Math.floor(n / 2)\n  cur = dummy.next\n  let pre = dummy \n  for(let i = 0; i < n; i++) {\n    if(i === mid - 1) {\n      pre = cur\n      // pre.next = cur.next.next\n    }\n    if(i === mid) {\n      pre.next = cur.next\n    }\n    if(i > mid) break\n    cur = cur.next\n  }\n  return dummy.next\n};\n"
    }
  },
  {
    "name": "2096-step-by-step-directions-from-a-binary-tree-node-to-another",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} startValue\n * @param {number} destValue\n * @return {string}\n */\nconst getDirections = function (root, startValue, destValue) {\n  let start = ''\n  let end = ''\n  const traverse = (node, path) => {\n    if (node === null) return\n    if (node.val === startValue) start = path\n    if (node.val === destValue) end = path\n    if (start !== '' && end !== '') return\n    if (node.left !== null) traverse(node.left, path + 'L')\n    if (node.right !== null) traverse(node.right, path + 'R')\n  }\n  traverse(root, '')\n  let skip = 0\n  while (start[skip] && start[skip] === end[skip]) skip++\n  return 'U'.repeat(start.length - skip) + end.slice(skip)\n}\n"
    }
  },
  {
    "name": "2097-valid-arrangement-of-pairs",
    "code": {
      "JS": "const packDGInOutDegreeMap = (gm, edges, dm) => { for (const [u, v] of edges) { if (!gm.has(u)) gm.set(u, []); gm.get(u).push(v); dm.set(u, (dm.get(u) || 0) + 1); dm.set(v, (dm.get(v) || 0) - 1); } };\n\n/**\n * @param {number[][]} pairs\n * @return {number[][]}\n */\nconst validArrangement = (pairs) => {\n    let g = new Map(), deg = new Map(), res = [];\n    packDGInOutDegreeMap(g, pairs, deg);\n    let start = -1;\n    for (const [node, ] of deg) { // looking for starting node\n        if (start == -1 || deg.get(node) == 1) start = node;\n    }\n    let path = eulerianPath(g, start);\n    path.reverse();\n    for (let i = 1; i < path.length; i++) {\n       res.push([path[i-1], path[i]]);\n    }\n    return res;\n};\n\nconst eulerianPath = (g, start) => { // eulerian Path with Hierholzer’s Algorithm\n    let st = [start], path = [];\n    while (st.length) {\n        let u = st[st.length - 1], ua = g.get(u) || [];\n        if (ua.length) {\n            let v = ua.pop();\n            g.set(u, ua);\n            st.push(v);\n        } else {\n            path.push(u);\n            st.pop();\n        }\n    }\n    return path;\n};\n"
    }
  },
  {
    "name": "21-merge-two-sorted-lists",
    "code": {
      "JS": "/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} l1\r\n * @param {ListNode} l2\r\n * @return {ListNode}\r\n */\r\n\r\nconst mergeTwoLists = function(l1, l2) {\r\n  if (l1 === null) return l2;\r\n  if (l2 === null) return l1;\r\n  if (l1.val < l2.val) {\r\n    l1.next = mergeTwoLists(l1.next, l2);\r\n    return l1;\r\n  } else {\r\n    l2.next = mergeTwoLists(l1, l2.next);\r\n    return l2;\r\n  }\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} l1\r\n * @param {ListNode} l2\r\n * @return {ListNode}\r\n */\r\nconst mergeTwoLists = function(l1, l2) {\r\n  const dummy = new ListNode()\r\n  let cur = dummy\r\n  while(l1 && l2) {\r\n    if(l1.val < l2.val) {\r\n      cur.next = new ListNode(l1.val)\r\n      l1 = l1.next\r\n    } else {\r\n      cur.next = new ListNode(l2.val)\r\n      l2 = l2.next\r\n    }\r\n    \r\n    cur = cur.next\r\n  }\r\n  if(l1) cur.next = l1\r\n  if(l2) cur.next = l2\r\n  \r\n  return dummy.next\r\n};\r\n"
    }
  },
  {
    "name": "210-course-schedule-ii",
    "code": {
      "JS": "/**\n * @param {number} numCourses\n * @param {number[][]} prerequisites\n * @return {number[]}\n */\nconst findOrder = function(numCourses, prerequisites) {\n  const indegree = new Array(numCourses).fill(0)\n  const graph = {}\n  for (let [course, prereq] of prerequisites) {\n    indegree[course]++\n    graph[prereq] === undefined\n      ? (graph[prereq] = [course])\n      : graph[prereq].push(course)\n  }\n  const queue = [],\n    ans = []\n  for (let i = 0; i < indegree.length; i++) if (!indegree[i]) queue.push(i)\n  while (queue.length) {\n    let cur = queue.shift()\n    ans.push(cur)\n    for (let neigbhors of graph[cur] || []) {\n      if (!--indegree[neigbhors]) queue.push(neigbhors)\n    }\n  }\n  return ans.length === numCourses ? ans : []\n}\n\n// another\n\n/**\n * @param {number} numCourses\n * @param {number[][]} prerequisites\n * @return {number[]}\n */\nconst findOrder = function(numCourses, prerequisites) {\n  const seen = new Set()\n  const seeing = new Set()\n  const res = []\n\n  const adj = [...Array(numCourses)].map(r => [])\n  for (let [u, v] of prerequisites) {\n    adj[v].push(u)\n  }\n  for (let c = 0; c < numCourses; c++) {\n    if (!dfs(c)) {\n      return []\n    }\n  }\n  return res.reverse()\n\n  function dfs(v) {\n    if (seen.has(v)) {\n      return true\n    }\n    if (seeing.has(v)) {\n      return false\n    }\n    seeing.add(v)\n    for (let nv of adj[v]) {\n      if (!dfs(nv)) {\n        return false\n      }\n    }\n    seeing.delete(v)\n    seen.add(v)\n    res.push(v)\n    return true\n  }\n}\n"
    }
  },
  {
    "name": "2101-detonate-the-maximum-bombs",
    "code": {
      "JS": "/**\n * @param {number[][]} bombs\n * @return {number}\n */\n const maximumDetonation = function(bombs) {\n  let n = bombs.length, res = 1, graph = {}\n  for(let i = 0; i < n; i++) {\n    for(let j = 0; j < n; j++) {\n      if (i === j) continue\n      if (bombAdj(bombs[i], bombs[j])) {\n        if (graph[i] == null) graph[i] = []\n        graph[i].push(j)\n      }\n    }\n  }\n  function dfs(node, visited) {\n    for(const next of (graph[node] || [])) {\n      if(!visited.has(next)) {\n        visited.add(next)\n        dfs(next, visited)\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    const set = new Set([i])\n    dfs(i, set)\n    res = Math.max(res, set.size)\n  }\n\n  return res\n};\n\nfunction bombAdj(source, target) {\n  const [x1, y1, r1] = source\n  const [x2, y2] = target\n  const { abs } = Math\n  return abs(x1 - x2) ** 2 + abs(y1 - y2) ** 2 <= r1 ** 2\n}\n"
    }
  },
  {
    "name": "2103-rings-and-rods",
    "code": {
      "JS": "/**\n * @param {string} rings\n * @return {number}\n */\nconst countPoints = function(rings) {\n  const hash = {}\n  \n  for(let i = 0, n = rings.length; i < n; i+=2) {\n    const ch = rings[i], num = +rings[i + 1]\n    if(hash[num] == null) hash[num] = new Set()\n    hash[num].add(ch)\n  }\n  \n  \n  \n  let res = 0\n  Object.keys(hash).forEach(k => {\n    if(hash[k].size === 3) res++\n  })\n  \n  return res\n};\n"
    }
  },
  {
    "name": "2104-sum-of-subarray-ranges",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst subArrayRanges = function(nums) {\n  const n = nums.length, { max, min } = Math\n  let res = 0\n  \n  for(let i = 0; i < n; i++) {\n    let [most, least] = [-Infinity, Infinity]\n    for(let j = i; j < n; j++) {\n      most = max(most, nums[j])\n      least = min(least, nums[j])\n      res += most - least     \n    }\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "2105-watering-plants-ii",
    "code": {
      "JS": "/**\n * @param {number[]} plants\n * @param {number} capacityA\n * @param {number} capacityB\n * @return {number}\n */\nconst minimumRefill = function(plants, capacityA, capacityB) {\n    const n = plants.length\n    let [left, right] = [0, n - 1]\n    let [A, B] = [capacityA, capacityB]\n    let ans = 0\n    while (left < right) {\n        if (A < plants[left]) {\n            A = capacityA\n            ans += 1              \n        }\n\n        A -= plants[left]\n        left += 1\n        if (B < plants[right]) {\n            B = capacityB\n            ans += 1              \n        }\n\n        B -= plants[right]\n        right -= 1          \n    }\n\n\n    if (left != right || A >= plants[left] || B >= plants[left]) return ans\n    return ans + 1   \n};\n\n"
    }
  },
  {
    "name": "2106-maximum-fruits-harvested-after-at-most-k-steps",
    "code": {
      "JS": "/**\n * @param {number[][]} fruits\n * @param {number} startPos\n * @param {number} k\n * @return {number}\n */\nconst maxTotalFruits = function(fruits, startPos, k) {\n    let n = fruits.length, { max, min } = Math\n    let pos = fruits.map(([p,a]) => p)\n    const prefix = Array(n).fill(0)\n\n    let curr = 0\n    for (let i = 0; i < n; i++) {\n        curr += fruits[i][1]\n        prefix[i] = curr      \n    }\n\n  function bisect_left(a, x, lo = 0, hi = null) {\n    // >= lower_bound\n    if (lo < 0) throw new Error('lo must be non-negative')\n    if (hi == null) hi = a.length\n    while (lo < hi) {\n      let mid = parseInt((lo + hi) / 2)\n      a[mid] < x ? (lo = mid + 1) : (hi = mid)\n    }\n    return lo\n  }\n    function bisect_right(a, x, lo = 0, hi = null) {\n    // > upper_bound\n    if (lo < 0) throw new Error('lo must be non-negative')\n    if (hi == null) hi = a.length\n    while (lo < hi) {\n      let mid = parseInt((lo + hi) / 2)\n      x < a[mid] ? (hi = mid) : (lo = mid + 1)\n    }\n    return lo\n  }\n    function query(left, right) {\n         left = max(left, 0)\n        right = min(right, 200000)\n        let l = bisect_left(pos, left)\n        let r = bisect_right(pos, right) - 1\n        if (l > r) return 0\n        if (!l) return prefix[r]\n        return prefix[r] - prefix[l - 1]      \n    }\n\n\n    let best = 0\n    let idx = 0\n    for(let right = startPos + k; right > startPos - 1; right -= 2) {\n        let cand = query(startPos - idx, right)\n        best = max(best, cand)\n        idx += 1      \n    }\n\n    idx = 0\n      for(let left = startPos - k; left < startPos + 1; left += 2) {\n                let cand = query(left, startPos + idx)\n        best = max(best, cand)\n        idx += 1\n      }\n\n    return best    \n};\n\n"
    }
  },
  {
    "name": "211-add-and-search-word-data-structure-design",
    "code": {
      "JS": "/**\n * Initialize your data structure here.\n */\nclass TrieNode {\n  constructor() {\n    this.children = [];\n    this.isWord = false;\n  }\n}\n\nconst WordDictionary = function() {\n  this.root = new TrieNode();\n  this.aCode = \"a\".charCodeAt(0);\n};\n\n/**\n * Adds a word into the data structure.\n * @param {string} word\n * @return {void}\n */\nWordDictionary.prototype.addWord = function(word) {\n  let node = this.root;\n  for (let c of word.split(\"\")) {\n    let code = c.charCodeAt(0);\n    if (node.children[code - this.aCode] == null) {\n      node.children[code - this.aCode] = new TrieNode();\n    }\n    node = node.children[code - this.aCode];\n  }\n  node.isWord = true;\n};\n\n/**\n * Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter.\n * @param {string} word\n * @return {boolean}\n */\nWordDictionary.prototype.search = function(word) {\n  return this._match(word.split(\"\"), 0, this.root);\n};\nWordDictionary.prototype._match = function(arr, k, node) {\n  if (k == arr.length) {\n    return node && node.isWord;\n  }\n  if (arr[k] === \".\") {\n    for (let i = 0; node != null && i < node.children.length; i++) {\n      if (\n        node.children[i] !== null &&\n        this._match(arr, k + 1, node.children[i])\n      ) {\n        return true;\n      }\n    }\n  } else {\n    return (\n      node != null && node.children[arr[k].charCodeAt(0) - this.aCode] != null &&\n      this._match(arr, k + 1, node.children[arr[k].charCodeAt(0) - this.aCode])\n    );\n  }\n  return false;\n};\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * var obj = Object.create(WordDictionary).createNew()\n * obj.addWord(word)\n * var param_2 = obj.search(word)\n */\n"
    }
  },
  {
    "name": "2111-minimum-operations-to-make-the-array-k-increasing",
    "code": {
      "JS": "/**\n * @param {number[]} arr\n * @param {number} k\n * @return {number}\n */\nconst kIncreasing = function(arr, k) {\n  let res = 0, matrix = Array.from({ length: k }, () => []), n = arr.length\n  for(let i = 0; i < k; i++) {\n    for(let j = i; j < n; j += k) {\n      matrix[i].push(arr[j])\n    }\n  }\n\n  for (let i = 0; i < k; i++) {\n    res += matrix[i].length - nonDecreasing(matrix[i])\n  }\n\n  return res\n\n  function bisect_right(ar, x, l = 0, r) {\n    if(r == null) r = ar.length\n    while(l < r) {\n      const mid = ~~((l + r) / 2)\n      if(ar[mid] <= x) l = mid + 1\n      else r = mid\n    }\n    return l\n  }\n\n  function nonDecreasing(ar) {\n    let stk = []\n    for(let e of ar) {\n      const idx = bisect_right(stk, e)\n      if(idx === stk.length) stk.push(e)\n      else stk[idx] = e\n    }\n\n    return stk.length\n  }\n};\n\n// another\n/**\n * @param {number[]} arr\n * @param {number} k\n * @return {number}\n */\nconst kIncreasing = function(arr, k) {\n  const n = arr.length\n  const a = Array.from({ length: k }, () => Array())\n  \n  for(let i = 0; i < k; i++) {\n    for(let j = i; j < n; j += k) {\n      a[i].push(arr[j])\n    }\n  }\n  \n  let res = 0\n  for(let i = 0; i < a.length; i++) {\n    const r = a[i]\n    res += r.length - lis(r)\n  }\n  \n  return res\n  \n  function bisect_right(a, x, lo = 0, hi = null) { // > upper_bound\n      if (lo < 0) throw new Error('lo must be non-negative');\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n          let mid = parseInt((lo + hi) / 2);\n          x < a[mid] ? hi = mid : lo = mid + 1;\n      }\n      return lo;\n  }\n  \n  function lis(ar) {\n    let q = []\n    for (let x of ar) {\n        let i = bisect_right(q, x)\n        if (i == q.length) q.push(x)\n        else q[i] = x      \n    }\n\n    return q.length\n  }\n};\n\n"
    }
  },
  {
    "name": "2115-find-all-possible-recipes-from-given-supplies",
    "code": {
      "JS": "/**\n * @param {string[]} recipes\n * @param {string[][]} ingredients\n * @param {string[]} supplies\n * @return {string[]}\n */\nconst findAllRecipes = function(recipes, ingredients, supplies) {\n  const set = new Set(supplies), res = [], graph = {}, n = recipes.length\n  const inDegree = {}\n  for(let x of recipes) inDegree[x] = 0\n  for(let i = 0; i < n; i++) {\n    for(let j = 0; j < ingredients[i].length; j++) {\n      const ing = ingredients[i][j]\n      if(!set.has(ing)) {\n        if (graph[ing] == null) graph[ing] = []\n        graph[ing].push(recipes[i])\n        inDegree[recipes[i]]++\n      }\n    }\n  }\n  // Kahn's Algorithm\n  const q = []\n  for(let x in inDegree) {\n    if (inDegree[x] === 0) q.push(x)\n  }\n  while(q.length) {\n    const len = q.length\n    for(let i = 0; i < len; i++) {\n      const cur = q.pop()\n      res.push(cur)\n      for(let next of (graph[cur] || [])) {\n        inDegree[next]--\n        if(inDegree[next] === 0) {\n          q.push(next)\n        }\n      }\n    }\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "2116-check-if-a-parentheses-string-can-be-validcheck-if-a-parentheses-string-can-be-valid",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {string} locked\n * @return {boolean}\n */\nconst canBeValid = function(s, locked) {\n  const n = s.length\n  if(n % 2 === 1) return false\n  let x = 0\n  for(let i = 0; i < n; i++) {\n    if(s[i] === '(' || locked[i] === '0') x++\n    else if(x > 0) x--\n    else return false\n  }\n  x = 0\n  for(let i = n - 1; i >= 0; i--) {\n    if(s[i] === ')' || locked[i] === '0') x++\n    else if(x > 0) x--\n    else return false\n  }\n  return true\n};\n\n// another\n\n/**\n * @param {string} s\n * @param {string} locked\n * @return {boolean}\n */\nconst canBeValid = function (s, locked) {\n  return s.length % 2 === 0 && chk(s, locked, '(') && chk(s, locked, ')')\n\n  function chk(s, locked, op) {\n    let bal = 0,\n      wild = 0,\n      sz = s.length\n    let start = op === '(' ? 0 : sz - 1,\n      dir = op === '(' ? 1 : -1\n    for (let i = start; i >= 0 && i < sz && wild + bal >= 0; i += dir) {\n      if (locked[i] === '1') bal += s[i] === op ? 1 : -1\n      else wild++\n    }\n    return Math.abs(bal) <= wild\n  }\n}\n"
    }
  },
  {
    "name": "2119-a-number-after-a-double-reversal",
    "code": {
      "JS": "/**\n * @param {number} num\n * @return {boolean}\n */\nvar isSameAfterReversals = function(num) {\n  if(('' +num).length === 1) return true\n  const tmp = (''+num).endsWith('0')\n  return !tmp\n};\n"
    }
  },
  {
    "name": "212-word-search-ii",
    "code": {
      "JS": "/**\n * @param {character[][]} board\n * @param {string[]} words\n * @return {string[]}\n */\nclass Trie {\n  constructor() {\n    this.word = null\n    this.children = new Map()\n  }\n  add(word) {\n    let cur = this\n    for (let i = 0; i < word.length; i++) {\n      if (!cur.children.has(word[i])) {\n        cur.children.set(word[i], new Trie())\n      }\n      cur = cur.children.get(word[i])\n    }\n    cur.word = word\n  }\n  addArr(words) {\n    words.forEach(word => this.add(word))\n  }\n}\n\nconst findWords = function(board, words) {\n  const trie = new Trie()\n  trie.addArr(words)\n  const results = []\n  const dirs = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n  for (let i = 0; i < board.length; i++) {\n    for (let j = 0; j < board[0].length; j++) {\n      dfs(board, i, j, trie, results, dirs)\n    }\n  }\n  return results\n}\n\nconst dfs = (board, i, j, trie, results, dirs) => {\n  if(i < 0 || j < 0 || i >= board.length || j >= board[0].length) return\n  const char = board[i][j]\n  if (!trie.children.has(char)) return\n\n  const nextTrie = trie.children.get(char)\n  if (nextTrie.word) {\n    results.push(nextTrie.word)\n    nextTrie.word = null\n  }\n  \n  for(let dir of dirs) {\n    board[i][j] = '#'\n    dfs(board, i + dir[0], j + dir[1], nextTrie, results, dirs)\n    board[i][j] = char\n  }\n  \n}\n"
    }
  },
  {
    "name": "2121-intervals-between-identical-elements",
    "code": {
      "JS": "/**\n * @param {number[]} arr\n * @return {number[]}\n */\nconst getDistances = function(arr) {\n  let n = arr.length\n  const pre = Array(n).fill(0), suf = Array(n).fill(0), res = Array(n).fill(0), mp = {}\n  \n  for(let i = 0; i < n; i++) {\n    if(mp[arr[i]] == null) mp[arr[i]] = []\n    mp[arr[i]].push(i)\n  }\n\n  Object.keys(mp).forEach(k => {\n    const idxArr = mp[k]\n    for(let i = 1; i < idxArr.length; i++) {\n      pre[idxArr[i]] = pre[idxArr[i - 1]] + i * (idxArr[i] - idxArr[i - 1])\n    }\n  })\n\n  Object.keys(mp).forEach(k => {\n    const idxArr = mp[k]\n    for(let i = idxArr.length - 2; i >= 0; i--) {\n      suf[idxArr[i]] = suf[idxArr[i + 1]] + (idxArr.length - 1 - i) * (idxArr[i + 1] - idxArr[i])\n    }\n  })\n\n  for(let i = 0; i < n; i++) res[i] = pre[i] + suf[i]\n\n  return res\n};\n"
    }
  },
  {
    "name": "2122-recover-the-original-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nconst recoverArray = function(nums) {\n  const n = nums.length, cnt = calcHash(nums)\n  nums.sort((a, b) => a - b)\n  for(let i = 1; i < n; i++) {\n    const tk = nums[i] - nums[0]\n    if(tk === 0 || tk % 2 === 1) continue\n    const [valid, res] = helper(tk)\n    if(valid) return res\n  }\n  \n  function helper(tk) {\n    const res = [], hash = Object.assign({}, cnt)\n    for(let i = 0; i < n; i++) {\n      const cur = nums[i]\n      if(hash[cur] === 0) continue\n      if(hash[cur + tk] === 0 || hash[cur + tk] == null) return [false]\n      hash[cur]--\n      hash[cur + tk]--\n      res.push(cur + tk / 2)\n    }\n    return [true, res]\n  }\n  function calcHash(arr) {\n    const hash = {}\n    for(let e of arr) {\n      if(hash[e] == null) hash[e] = 0\n      hash[e]++\n    }\n    return hash\n  }\n};\n"
    }
  },
  {
    "name": "2124-check-if-all-as-appears-before-all-bs",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {boolean}\n */\nconst checkString = function(s) {\n  const la = s.lastIndexOf('a')\n  const fb = s.indexOf('b')\n  return fb === -1 ? true : la < fb\n};\n"
    }
  },
  {
    "name": "2125-number-of-laser-beams-in-a-bank",
    "code": {
      "JS": "/**\n * @param {string[]} bank\n * @return {number}\n */\nvar numberOfBeams = function(bank) {\n  const comb = (num1, num2) => num1 * num2\n  const m = bank.length, n = bank[0].length\n  if(m === 0 || n === 0) return 0\n  let pre = 0, res = 0\n  for(let j = 0; j < n; j++) {\n    if(bank[0][j] === '1') pre++\n  }\n  for(let i = 1; i < m; i++) {\n    let chk = 0, cur = bank[i]\n    for(let j = 0; j < n; j++) {\n      if(cur[j] === '1') chk++\n    }\n    if(chk) {\n      res += comb(pre, chk)\n      pre = chk\n    }\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "2126-destroying-asteroids",
    "code": {
      "JS": "/**\n * @param {number} mass\n * @param {number[]} asteroids\n * @return {boolean}\n */\nconst asteroidsDestroyed = function(mass, asteroids) {\n  asteroids.sort((a, b) => a - b)\n  let res = true\n  for(let i = 0, n = asteroids.length; i < n; i++) {\n    const cur = asteroids[i]\n    if(mass >= cur) {\n      mass += cur\n    } else {\n      res = false\n      break\n    }\n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "2127-maximum-employees-to-be-invited-to-a-meeting",
    "code": {
      "JS": "/**\n * @param {number[]} favorite\n * @return {number}\n */\nvar maximumInvitations = function(favorite) {\n  const n = favorite.length, m = Array(n).fill(-1), r = Array.from({ length: n }, () => [])\n  for(let i = 0; i < n; i++) r[favorite[i]].push(i)\n  \n  function dfs(u) {\n    if(m[u] !== -1) return m[u]\n    let res = 0\n    for(let v of r[u]) res = Math.max(res, dfs(v))\n    return m[u] = 1 + res\n  }\n  let res = 0, free = 0\n  for(let i = 0; i < n; ++i) {\n    if (m[i] != -1) continue; // skip visited nodes\n    if (favorite[favorite[i]] == i) {\n      m[i] = m[favorite[i]] = 0;\n      let a = 0, b = 0; // find the length of the longest arms starting from `i` and `A[i]`\n      for (let v of r[i]) {\n          if (v == favorite[i]) continue;\n          a = Math.max(a, dfs(v));\n      }\n      for (let v of r[favorite[i]]) {\n          if (v == i) continue;\n          b = Math.max(b, dfs(v));\n      }\n      free += a + b + 2; // this free component is of length `a+b+2`\n    } \n  }\n  function dfs2(u) {\n    if (m[u] != -1) return[u, m[u], false]; // this is the merge point\n    m[u] = 0;\n    let [mergePoint, depth, mergePointMet] = dfs2(favorite[u]);\n    if (mergePointMet) { // If we've met the merge point again already, this node is outside of the cycle and should be ignored.\n        m[u] = 0;\n        return [mergePoint, depth, true];\n    }\n    m[u] = 1 + depth; // If we haven't met the merge point, we increment the depth.\n    return [mergePoint, m[u], u == mergePoint];\n  }\n  \n  for(let i = 0; i < n; i++) {\n    if(m[i] !== -1) continue\n    let [mergePoint, depth, mergePointMet] = dfs2(i)\n    if(mergePointMet) res = Math.max(res, depth)\n  }\n  \n  return Math.max(res, free)\n};\n\n"
    }
  },
  {
    "name": "213-house-robber-ii",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst rob = function(nums) {\n    if(nums.length === 0) return 0\n    if(nums.length < 3) return Math.max(...nums)\n  \n    const startFromFirst = [0,nums[0]]\n    const startFromSecond = [0,0]\n    \n    for(let i = 2; i <= nums.length; i++) {\n      startFromFirst[i] = Math.max(startFromFirst[i - 1], startFromFirst[i - 2] + nums[i - 1])\n      startFromSecond[i] = Math.max(startFromSecond[i - 1], startFromSecond[i - 2] + nums[i - 1])\n    }\n    \n    return Math.max(startFromFirst[nums.length - 1], startFromSecond[nums.length])\n  \n};\n"
    }
  },
  {
    "name": "2132-stamping-the-grid",
    "code": {
      "JS": "/**\n * @param {number[][]} grid\n * @param {number} stampHeight\n * @param {number} stampWidth\n * @return {boolean}\n */\nvar possibleToStamp = function(grid, stampHeight, stampWidth) {\n    let d = [];\n    let a = grid;\n    let h = grid.length;\n    let w = grid[0].length;\n    for (let i = 0; i <= h; i++) {\n        d[i] = new Array(w + 1).fill(0);\n    }\n    //d - height of empty cells below\n    for (let i = h - 1; i >= 0; i--) {\n        for (let j = 0; j < w; j++) {\n            if (a[i][j] === 0) d[i][j] = d[i + 1][j] + 1;\n        }\n    }\n    //find stamps, and start to fill matrix\n    for (let i = 0; i < h; i++) {\n        let columns = 0; //width of consecutive empty columns with height>=stampHeight\n        for (let j = 0; j <= w; j++) {\n            if (d[i][j] >= stampHeight) { //column can be part of stamp\n                columns++;\n                if (columns >= stampWidth) {\n                    //fill first row\n                    if (columns === stampWidth) {\n                        //fill previous columns\n                        for (let l = j - stampWidth + 1; l <= j; l++) {\n                            a[i][l] = stampHeight\n                        }\n                    } else {\n                        a[i][j] = stampHeight;\n                    }\n                }\n            } else {\n                columns = 0;\n            }\n        }\n        //fill cells below\n        for (let l = 0; l < w; l++) {\n            if (a[i][l] > 1) {\n                a[i + 1][l] = a[i][l] - 1;\n            }\n        }\n    }\n\n    //check if all cells covered\n    let ans = true;\n    for (let i = 0; i < h; i++) {\n        for (let j = 0; j < w; j++) {\n            if (a[i][j] === 0) ans = false;\n        }\n    }\n\n    return ans;  \n};\n"
    }
  },
  {
    "name": "2136-earliest-possible-day-of-full-bloom",
    "code": {
      "JS": "/**\n * @param {number[]} plantTime\n * @param {number[]} growTime\n * @return {number}\n */\nconst earliestFullBloom = function(plantTime, growTime) {\n  const n = plantTime.length, arr = Array(n)\n  for(let i = 0; i < n; i++) {\n    arr.push([growTime[i], plantTime[i]])\n  }\n  arr.sort((a, b) => b[0] - a[0])\n  \n  let res = 0, cur = 0\n  for(let i = 0; i < n; i++) {\n    const e = arr[i]\n    res = Math.max(res, cur + e[0] + e[1])\n    cur += e[1]\n  }\n  \n  return res\n};\n\n// another\n\n\n/**\n * @param {number[]} plantTime\n * @param {number[]} growTime\n * @return {number}\n */\nconst earliestFullBloom = function(plantTime, growTime) {\n  const sum = arr => arr.reduce((ac, e) => ac +e, 0)\n  let l = 0, r = sum(plantTime) + sum(growTime)\n  const n = plantTime.length\n\n  const a = []\n  for(let i = 0; i < n; i++) {\n    a.push([growTime[i], plantTime[i] ])\n  }\n\n  a.sort((a, b) => a[0] === b[0] ? a[1] - b[1] : a[0] - b[0])\n  a.reverse()\n  function chk(d) {\n    let total = -1\n    let max_num = 0\n    for(let i = 0; i < n; i++) {\n      total += a[i][1]\n      max_num = Math.max(max_num, total + a[i][0] + 1)\n    }\n    return max_num <= d\n  }\n\n  while (l < r) {\n    let m = ~~((l + r) / 2)\n    if (chk(m)) r = m\n    else l = m + 1          \n  }\n\n  return l\n};\n\n"
    }
  },
  {
    "name": "2138-divide-a-string-into-groups-of-size-k",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {number} k\n * @param {character} fill\n * @return {string[]}\n */\nvar divideString = function(s, k, fill) {\n  let res = [], tmp = ''\n  for(let i = 0, n = s.length; i < n; i++) {\n    tmp += s[i]\n    if(tmp.length === k) {\n      res.push(tmp)\n      tmp = ''\n    }\n  }\n  if(tmp.length) {\n    for(let i = 0, limit = k - tmp.length; i < limit; i++) {\n      tmp += fill\n    }\n    res.push(tmp)\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "2139-minimum-moves-to-reach-target-score",
    "code": {
      "JS": "/**\n * @param {number} target\n * @param {number} maxDoubles\n * @return {number}\n */\nconst minMoves = function(target, maxDoubles) {\n        let count = 0;\n        \n        while(target != 1){\n            \n            if(target % 2 != 0){\n                target--;\n                count++;\n            }\n            else{\n                if(maxDoubles != 0){\n                    target /= 2;\n                    count++;\n                    maxDoubles--;\n                }\n                else{\n                    count += target - 1;\n                    break;\n                }\n            }\n        }\n        return count;\n};\n"
    }
  },
  {
    "name": "214-shortest-palindrome",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {string}\n */\nconst shortestPalindrome = function(s) {\n  let j = 0;\n  for (let i = s.length - 1; i >= 0; i--) {\n    if (s.charAt(i) === s.charAt(j)) { j += 1; }\n  }\n  if (j === s.length) { return s; }\n  let suffix = s.substring(j);\n  return suffix.split('').reverse().join('') + shortestPalindrome(s.substring(0, j)) + suffix;\n};\n\n// another\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst shortestPalindrome = function (s) {\n  const tmp = s + '#' + s.split('').reverse().join('')\n  const fail = getFail(tmp)\n  return (\n    s\n      .split('')\n      .slice(fail[fail.length - 1])\n      .reverse()\n      .join('') + s\n  )\n}\n\nfunction getFail(s) {\n  const n = s.length\n  const table = new Array(n).fill(0)\n  let index = 0\n  for (let i = 1; i < n; ) {\n    if (s.charAt(index) === s.charAt(i)) {\n      table[i] = ++index\n      i++\n    } else {\n      if (index > 0) {\n        index = table[index - 1]\n      } else {\n        index = 0\n        i++\n      }\n    }\n  }\n  return table\n}\n\n// another\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst shortestPalindrome = function(s) {\n  const tmp = `${s}#${reverse(s)}`\n  const table = kmp(tmp)\n  return `${reverse(s.slice(table[table.length - 1]))}${s}`\n};\nfunction reverse(str) {\n  return [...str].reverse().join('')\n}\n\nfunction kmp(s) {\n  const n = s.length, table = Array(n).fill(0)\n  let idx = 0\n  for(let i = 1; i < n; ) {\n    if(s[i] === s[idx]) {\n      idx++\n      table[i] = idx\n      i++\n    } else {\n      if(idx > 0) {\n        idx = table[idx - 1]\n      } else {\n        idx = 0\n        i++\n      }\n    }\n  }\n  return table\n}\n"
    }
  },
  {
    "name": "2140-solving-questions-with-brainpower",
    "code": {
      "JS": "/**\n * @param {number[][]} questions\n * @return {number}\n */\nconst mostPoints = function(questions) {\n  const n = questions.length, dp = Array(n + 1).fill(0)\n  for (let i = n - 1; i >= 0; i--) {\n    const [gain, p] = questions[i]\n    dp[i] = Math.max(dp[i + 1], (dp[p + i + 1] || 0) + gain)\n  }\n  return dp[0]\n};\n\n// another\n\n/**\n * @param {number[][]} questions\n * @return {number}\n */\nconst mostPoints = function (questions) {\n  let n = questions.length\n  const temp = Array(n).fill(0)\n\n  temp[n - 1] = questions[n - 1][0]\n\n  for (let i = n - 2; i >= 0; i--) {\n    if (i + questions[i][1] + 1 <= n - 1)\n      temp[i] = Math.max(\n        temp[i + 1],\n        questions[i][0] + temp[i + questions[i][1] + 1]\n      )\n    else temp[i] = Math.max(temp[i + 1], questions[i][0])\n  }\n  return temp[0]\n}\n"
    }
  },
  {
    "name": "2141-maximum-running-time-of-n-computers",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[]} batteries\n * @return {number}\n */\nvar maxRunTime = function (n, batteries) {\n  batteries.sort((a, b) => a - b)\n  const sum = batteries.reduce((ac, e) => ac + BigInt(e), 0n)\n  let hi = ~~(sum / BigInt(n)) + 1n,\n    lo = 0n\n  while (lo < hi) {\n    let mid = ~~((lo + hi) / 2n)\n    if (chk(mid)) {\n      lo = mid + 1n\n    } else {\n      hi = mid\n    }\n  }\n\n  return lo - 1n\n  function chk(x) {\n    let current = 0n\n    let i = 0n\n    for (let b of batteries) {\n      if (i == BigInt(n)) break\n      if (b > x) b = x\n      if (b >= x - current) {\n        i += 1n\n        current = BigInt(b) - (x - current)\n      } else {\n        current += BigInt(b)\n      }\n    }\n\n    return i == n\n  }\n}\n"
    }
  },
  {
    "name": "2148-count-elements-with-strictly-smaller-and-greater-elements",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar countElements = function(nums) {\n  let min = Infinity, max = -Infinity\n  for(let e of nums) {\n    if(e > max) max = e\n    if(e < min) min = e\n  }\n  let res = 0\n  for(let e of nums) {\n    if(e > min && e < max) res++\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "2149-rearrange-array-elements-by-sign",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nconst rearrangeArray = function(nums) {\n  const pos = [], neg = []\n  for(let e of nums) {\n    if(e >= 0) pos.push(e)\n    else neg.push(e)\n  }\n  const res = []\n  for(let i = 0; i < nums.length; i++) {\n    if(i % 2 === 0) res.push(pos[~~(i / 2)])\n    else res.push(neg[~~(i / 2)])\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "215-kth-largest-element-in-an-array",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nconst findKthLargest = function(nums, k) {\r\n  if (!nums || k > nums.length) return 0;\r\n\r\n  const larger = [];\r\n  const smaller = [];\r\n  const pivot = nums[parseInt(nums.length / 2)];\r\n  let pivotCount = 0;\r\n\r\n  for (let i = 0; i < nums.length; i++) {\r\n    const ele = nums[i];\r\n\r\n    if (ele > pivot) larger.push(ele);\r\n    else if (ele === pivot) pivotCount++;\r\n    else smaller.push(ele);\r\n  }\r\n\r\n  if (larger.length >= k) return findKthLargest(larger, k);\r\n  else if (k - larger.length - pivotCount <= 0) return pivot;\r\n  else return findKthLargest(smaller, k - larger.length - pivotCount);\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nconst findKthLargest = function(nums, k) {\r\n  return quickselect(nums, 0, nums.length - 1, k)\r\n};\r\nfunction quickselect(arr, lo, hi, k) {\r\n  let pivtIdx = Math.floor(Math.random() * (hi - lo + 1)) + lo\r\n  let pivtVal = arr[pivtIdx]\r\n  ;[arr[hi], arr[pivtIdx]] = [arr[pivtIdx], arr[hi]]\r\n  let i = lo\r\n  let j = hi - 1\r\n\r\n  while (i <= j) {\r\n    if (arr[i] <= pivtVal) {\r\n      i++\r\n    } else {\r\n      ;[arr[j], arr[i]] = [arr[i], arr[j]]\r\n      j--\r\n    }\r\n  }\r\n\r\n  ;[arr[i], arr[hi]] = [arr[hi], arr[i]]\r\n\r\n  pivtIdx = i\r\n\r\n  if (pivtIdx === arr.length - k) return arr[pivtIdx]\r\n  if (pivtIdx < arr.length - k) return quickselect(arr, pivtIdx + 1, hi, k)\r\n  return quickselect(arr, lo, pivtIdx - 1, k)\r\n}\r\n\r\n// another\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nconst findKthLargest = function(nums, k) {\r\n  const n = nums.length\r\n  let l = 0, r = n - 1, t = n - k\r\n  while(l < r) {\r\n    const mid = partition(nums, l, r)\r\n    if(mid < t) {\r\n      l = mid + 1\r\n    } else {\r\n      if(mid === t) break\r\n      else r = mid - 1\r\n    }\r\n  }\r\n  return nums[t]\r\n};\r\n\r\nfunction partition(arr, left, right) {\r\n  let pivot = arr[right]\r\n  let l = left, r = right - 1, j = left\r\n  for(let i = left; i < right; i++) {\r\n    if(arr[i] <= pivot) {\r\n      swap(arr, i, j)\r\n      j++\r\n    }\r\n  }\r\n  swap(arr, j, right)\r\n  return j\r\n}\r\n\r\nfunction swap(arr, i, j) {\r\n  const tmp = arr[i]\r\n  arr[i] = arr[j]\r\n  arr[j] = tmp\r\n}\r\n\r\n// another\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nconst findKthLargest = function(nums, k) {\r\n  const n = nums.length\r\n  let l = 0, r = n - 1, t = n - k\r\n  while(l < r) {\r\n    const idx = partition(nums, l, r)\r\n    if (idx === t) return nums[t]\r\n    if (idx < t) l = idx + 1\r\n    else r = idx - 1\r\n  }\r\n  return nums[l]\r\n};\r\n\r\nfunction partition(arr, l, r) {\r\n  let tmp = l, pivot = arr[l]\r\n  while(l < r) {\r\n    while(l < r && arr[r] >= pivot) r--\r\n    while(l < r && arr[l] <= pivot) l++\r\n    swap(arr, l, r)\r\n  }\r\n  swap(arr, l, tmp)\r\n  return l\r\n}\r\n\r\nfunction swap(arr, i, j) {\r\n  const tmp = arr[i]\r\n  arr[i] = arr[j]\r\n  arr[j] = tmp\r\n}\r\n\r\n\r\n"
    }
  },
  {
    "name": "2150-find-all-lonely-numbers-in-the-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar findLonely = function(nums) {\n  nums.sort((a, b) => a - b)\n  const cnt = {}\n  for(let e of nums) {\n    if(cnt[e] == null) cnt[e] = 0\n    cnt[e]++\n  }\n  // console.log(cnt)\n  const res = []\n  for(let i = 0, n = nums.length; i < n; i++) {\n    if(i === 0){\n      if(nums[i + 1] !== nums[i] + 1 && cnt[nums[i]] === 1) {\n        res.push(nums[i])  \n      }\n    } \n    else if(i === n - 1 ) {\n      if(nums[i] !== nums[i - 1] + 1 && cnt[nums[i]] === 1) {\n        res.push(nums[i])\n      }\n    }\n    else if(cnt[nums[i]] === 1 && nums[i] !== nums[i - 1] + 1 && nums[i] !== nums[i + 1] - 1) {\n      res.push(nums[i])\n    }\n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "2151-maximum-good-people-based-on-statements",
    "code": {
      "JS": "/**\n * @param {number[][]} statements\n * @return {number}\n */\nconst maximumGood = function (statements) {\n  const n = statements.length\n  let res = 0,\n    c = (1 << n) - 1\n  for (let i = 0; i < c + 1; i++) {\n    let s = dec2bin(i)\n    s = '0'.repeat(n - s.length) + s\n    let arr = [],\n      f = 1\n    for (let i = 0; i < n; i++) {\n      if (s[i] === '1') arr.push(i)\n    }\n    for (let i of arr) {\n      for (let j = 0; j < n; j++) {\n        if (statements[i][j] !== 2 && statements[i][j] !== +s[j]) {\n          f = 0\n          break\n        }\n      }\n      if (!f) break\n    }\n    if (f) res = Math.max(res, cnt(s, '1'))\n  }\n\n  return res\n}\nfunction cnt(s, ch) {\n  let res = 0\n  for (let e of s) {\n    if (e === ch) res++\n  }\n  return res\n}\nfunction dec2bin(dec) {\n  return (dec >>> 0).toString(2)\n}\n"
    }
  },
  {
    "name": "2152-minimum-number-of-lines-to-cover-points",
    "code": {
      "JS": "/**\n * @param {number[][]} points\n * @return {number}\n */\nconst minimumLines = function(points) {\n  const n = points.length;\n  const connects = Array.from({ length: n }, () => Array(n).fill(0));\n  for(let i = 0; i < n; ++i) {\n      for(let j = i + 1; j < n; ++j) {\n          connects[i][j] = (1 << i) | (1 << j);\n          let dx = points[j][0] - points[i][0];\n          let dy = points[j][1] - points[i][1];\n          for(let k = j + 1; k < n; ++k) { // check if k will be on the line connecting i and j.\n              let dx2 = points[k][0] - points[i][0];\n              let dy2 = points[k][1] - points[i][1];\n              if (dx * dy2 == dy * dx2) {\n                  connects[i][j] |= (1 << k);\n              }\n          }\n      }\n  }\n  const dp = new Array(1<<n).fill(Infinity);\n  return helper(n, 0, dp, connects);\n};\n\nfunction helper(n, mask, dp, connects) {\n  if (dp[mask] == Infinity) {\n      let has = numOfOne(mask);\n      if (has == n) { // if all the points have been connected\n          dp[mask] = 0;\n      } else if (has >= n - 2) { // if only 2 points left\n          dp[mask] = 1;\n      } else { // if there are more than 2 points, try a line connecting first to second, third, ...\n          let i = 0;\n          for(let x = (1 << i); i < n; ++i, x <<= 1) {\n              if ((mask & x) == 0) {\n                  break;\n              }\n          }\n          for(let j = i + 1, x = (1 << j); j < n; ++j, x <<= 1) {\n              if ((mask & x) == 0) {\n                  let mask2 = mask | connects[i][j];\n                  dp[mask] = Math.min(dp[mask], 1 + helper(n, mask2, dp, connects));\n              }\n          }\n      }\n  }\n  return dp[mask];\n}\n\nfunction numOfOne(num) {\n  const str = (num >>> 0).toString(2)\n  let res = 0\n  for(let ch of str) {\n    if(ch === '1') res++\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "2154-keep-multiplying-found-values-by-two",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} original\n * @return {number}\n */\nvar findFinalValue = function(nums, original) {\n    let res = original\n    while(nums.indexOf(res) !== -1) {\n      // const idx = nums.indexOf(res)\n      res *= 2\n    }\n    return res\n};\n"
    }
  },
  {
    "name": "2155-all-divisions-with-the-highest-score-of-a-binary-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar maxScoreIndices = function(nums) {\n  const n = nums.length\n  // if(n === 1) return [0]\n  const leftZero = Array(n).fill(0), rightOne = Array(n).fill(0)\n  for (let i = 0, sum = 0; i < n; i++) {\n    if(nums[i] === 0) sum++\n    leftZero[i] = sum\n  }\n  for (let i = n - 1, sum = 0; i >= 0; i--) {\n    if(nums[i] === 1) sum++\n    rightOne[i] = sum\n  }\n  let hash = {}\n  for (let i = 0, sum = 0; i <= n; i++) {\n    \n    hash[i] = (i === 0 ? 0 : leftZero[i - 1]) + (i === n ? 0 : rightOne[i])\n  }\n  const max = Math.max(...Object.values(hash))\n  const res = []\n  Object.keys(hash).forEach(k => {\n    if(hash[k] === max) res.push(+k)\n  })\n  return res\n};\n"
    }
  },
  {
    "name": "2156-find-substring-with-given-hash-value",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {number} power\n * @param {number} modulo\n * @param {number} k\n * @param {number} hashValue\n * @return {string}\n */\nvar subStrHash = function (s, power, modulo, k, hashValue) {\n  let n = s.length;\n  const p_pow = Array(n + 1);\n  p_pow[0] = 1n;\n  power = BigInt(power);\n  let m = BigInt(modulo);\n  for (let i = 1; i < p_pow.length; i++) p_pow[i] = (p_pow[i - 1] * power) % m;\n\n  const val = (ch) => BigInt(ch.charCodeAt(0) - \"a\".charCodeAt(0));\n  const h = Array(n + 1).fill(0n);\n  for (let i = n - 1; i >= 0; i--)\n    h[i] = (h[i + 1] * power + val(s[i]) + 1n) % m;\n\n  for (let i = 0; i + k - 1 < n; i++) {\n    let cur_h = (h[i] - h[i + k] * p_pow[k]) % m;\n    let temp = (cur_h + m) % m;\n    if (temp == hashValue) {\n      return s.substr(i, k);\n    }\n  }\n  return \"\";\n};\n"
    }
  },
  {
    "name": "216-combination-sum-III",
    "code": {
      "JS": "/**\r\n * @param {number} k\r\n * @param {number} n\r\n * @return {number[][]}\r\n */\r\nconst combinationSum3 = function(k, n) {\r\n  const ans = [];\r\n  combination(ans, [], k, 1, n);\r\n  return ans;\r\n};\r\n\r\nfunction combination(ans, comb, k, start, n) {\r\n  if (comb.length > k) {\r\n    return;\r\n  }\r\n  if (comb.length === k && n === 0) {\r\n    ans.push(comb.slice(0));\r\n    return;\r\n  }\r\n  for (let i = start; i <= n && i <= 9; i++) {\r\n    comb.push(i);\r\n    combination(ans, comb, k, i + 1, n - i);\r\n    comb.pop();\r\n  }\r\n}\r\n"
    }
  },
  {
    "name": "2163-minimum-difference-in-sums-after-removal-of-elements",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst minimumDifference = function(nums) {\n  const n = nums.length, len = n / 3\n  const maxHeap = new PriorityQueue((a, b) => a > b)\n  const minHeap = new PriorityQueue((a, b) => a < b)\n  const pre = Array(n).fill(Infinity), suffix = Array(n).fill(-Infinity)\n  for(let i = 0, sum = 0; i < 2 * len; i++) {\n    const cur = nums[i]\n    maxHeap.push(cur)\n    sum += cur\n    if(maxHeap.size() > len) {\n      const tmp = maxHeap.pop()\n      sum -= tmp\n    }\n    if(maxHeap.size() === len) {\n      pre[i] = sum\n    }\n  }\n\n  for(let i = n - 1, sum = 0; i >= len; i--) {\n    const cur = nums[i]\n    minHeap.push(cur)\n    sum += cur\n    if(minHeap.size() > len) {\n      const tmp = minHeap.pop()\n      sum -= tmp\n    }\n    if(minHeap.size() === len) {\n      suffix[i] = sum\n    }\n  }\n\n  // console.log(pre, suffix)\n  let res = Infinity\n  for(let i = len - 1; i < n - len; i++) {\n    res = Math.min(res, pre[i] - suffix[i + 1])\n  }\n  return res\n};\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n"
    }
  },
  {
    "name": "2164-sort-even-and-odd-indices-independently",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar sortEvenOdd = function(nums) {\n        let nums_size = nums.length;\n        for (let i = 0; i < nums_size - 2; i++) {\n            for (let j = i + 2; j < nums_size; j += 2) {\n                if (i % 2 == 1) {\n                    if (nums[i] < nums[j]) {\n                        let temp = nums[i];\n                        nums[i] = nums[j];\n                        nums[j] = temp;\n                    }\n                } else {\n                    if (nums[i] > nums[j]) {\n                        let temp = nums[i];\n                        nums[i] = nums[j];\n                        nums[j] = temp;\n                    }\n                }\n            }\n        }\n        return nums;  \n};\n"
    }
  },
  {
    "name": "2165-smallest-value-of-the-rearranged-number",
    "code": {
      "JS": "/**\n * @param {number} num\n * @return {number}\n */\nvar smallestNumber = function(num) {\n    const minus = num < 0\n    const nums = Math.abs(num)\n      .toString()\n      .split('')\n      .map(_ => parseInt(_))\n      .sort((a, b) => minus ? b-a : a-b);\n    if(!minus && nums[0] === 0) {\n        let i = 0\n        while(nums[i] === 0 && i < nums.length-1) i++\n        nums[0] = nums[i]\n        nums[i] = 0\n    }\n    const answer = parseInt(nums.map(_ => _.toString()).join(''))\n    return minus ? -answer : answer\n};\n"
    }
  },
  {
    "name": "2166-design-bitset",
    "code": {
      "JS": "/**\n * @param {number} size\n */\nvar Bitset = function(size) {\n  this.s = Array.from({ length:2 }, () => Array())\n  this.cnt = 0\n  this.now = 0\n  for (let i = 0; i < size; i++) {\n    this.s[this.now].push( '0');\n    this.s[this.now ^ 1].push( '1');\n  }\n};\n\n/** \n * @param {number} idx\n * @return {void}\n */\nBitset.prototype.fix = function(idx) {\n    if (this.s[this.now][idx] == '1') return;\n    // swap(this.s[this.now][idx], this.s[this.now ^ 1][idx]);\n    const tmp = this.s[this.now][idx]\n    this.s[this.now][idx] = this.s[this.now ^ 1][idx]\n    this.s[this.now ^ 1][idx] = tmp\n    this.cnt++;\n};\n\n/** \n * @param {number} idx\n * @return {void}\n */\nBitset.prototype.unfix = function(idx) {\n    if (this.s[this.now][idx] == '0') return;\n    // swap(this.s[this.now][idx], this.s[this.now ^ 1][idx]);\n    const tmp = this.s[this.now][idx]\n    this.s[this.now][idx] =  this.s[this.now ^ 1][idx]\n   this.s[this.now ^ 1][idx] = tmp\n    this.cnt--;\n};\n\n/**\n * @return {void}\n */\nBitset.prototype.flip = function() {\n    this.now = this.now ^ 1;\n    this.cnt = this.s[0].length - this.cnt;\n};\n\n/**\n * @return {boolean}\n */\nBitset.prototype.all = function() {\n    return this.cnt == this.s[0].length;\n};\n\n/**\n * @return {boolean}\n */\nBitset.prototype.one = function() {\n    return this.cnt !== 0\n};\n\n/**\n * @return {number}\n */\nBitset.prototype.count = function() {\n    return this.cnt;\n};\n\n/**\n * @return {string}\n */\nBitset.prototype.toString = function() {\n     return this.s[this.now].join('');\n};\n\n\n/** \n * Your Bitset object will be instantiated and called as such:\n * var obj = new Bitset(size)\n * obj.fix(idx)\n * obj.unfix(idx)\n * obj.flip()\n * var param_4 = obj.all()\n * var param_5 = obj.one()\n * var param_6 = obj.count()\n * var param_7 = obj.toString()\n */\n\n"
    }
  },
  {
    "name": "2167-minimum-time-to-remove-all-cars-containing-illegal-goods",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst minimumTime = function(s) {\n  const n = s.length\n  const arr = []\n  for(let ch of s) {\n    arr.push(ch === '1' ? 1 : -1)\n  }\n  const score = minSum(arr)\n  return n + score\n\n  function minSum(ar) {\n    const dp = Array(n).fill(Infinity)\n    dp[0] = ar[0]\n    let ans = dp[0]\n    for(let i = 1; i < n; i++) {\n      dp[i] = Math.min(ar[i], ar[i] + dp[i - 1])\n      ans = Math.min(ans, dp[i])\n    }\n    return ans > 0 ? 0 : ans\n  }\n};\n\n// another\n\n/**\n * @param {string} s\n * @return {number}\n */\nconst minimumTime = function(s) {\n  const n = s.length\n  const arr = []\n  for(let ch of s) {\n    arr.push(ch === '1' ? 1 : -1)\n  }\n  const score = minSum(arr)\n  return n + score\n\n  function minSum(ar) {\n    const dp = Array(n).fill(0)\n    dp[0] = ar[0]\n    for(let i = 1; i < n; i++) {\n      dp[i] = Math.min(ar[i], ar[i] + dp[i - 1])\n    }\n    return Math.min(0, Math.min(...dp))\n  }\n};\n\n// another\n\n/**\n * @param {string} s\n * @return {number}\n */\nconst minimumTime = function(s) {\n  if(s.length === 1) return s === '1' ? 1 : 0\n  const n = s.length\n  const arr = []\n  for(let ch of s) {\n    arr.push(ch === '1' ? 1 : -1)\n  }\n  const score = minSum(arr)\n  return n + score\n\n  function minSum(ar) {\n    const dp = Array(n).fill(0)\n    dp[0] = ar[0]\n    let ans = dp[0]\n    for(let i = 1; i < n; i++) {\n      dp[i] = Math.min(ar[i], ar[i] + dp[i - 1])\n      ans = Math.min(0, ans, dp[i])\n    }\n    return ans\n  }\n};\n\n// another\n\n\n/**\n * @param {string} s\n * @return {number}\n */\nvar minimumTime = function(s) {\n\n  const { max, min } = Math\n  \n        let n = s.length;\n    const l = Array.from({ length: n + 1 }, () => Array(2).fill(0))\n  const r = Array.from({ length: n + 1 }, () => Array(2).fill(0))\n        for (let i = 0; i < n; i++) l[i][0] = l[i][1] = r[i][0] = r[i][1] = 0;\n        if (s[0] == '1') {\n            l[0][0] = 1;\n            l[0][1] = 2;\n        }\n        for (let i = 1; i < n; i++) {\n            if (s[i] == '0') {\n                l[i][0] = l[i - 1][0];\n                l[i][1] = l[i - 1][1];\n            } else {\n                l[i][0] = i + 1;\n                l[i][1] = min(l[i - 1][0], l[i - 1][1]) + 2;\n            }\n        }\n        if (s[n - 1] == '1') {\n            r[n - 1][0] = 1;\n            r[n - 1][1] = 2;\n        }\n        for (let i = n - 2; i >= 0; i--) {\n            if (s[i] == '0') {\n                r[i][0] = r[i + 1][0];\n                r[i][1] = r[i + 1][1];\n            } else {\n                r[i][0] = n - i;\n                r[i][1] = min(r[i + 1][0], r[i + 1][1]) + 2;\n            }\n        }\n        let ans = n;\n        for (let i = -1; i < n; i++) {\n            let cost = 0;\n            if (i != -1) cost += min(l[i][0], l[i][1]);\n            if (i != n - 1) cost += min(r[i + 1][0], r[i + 1][1]);\n            ans = min(ans, cost);\n        }\n        return ans;\n};\n"
    }
  },
  {
    "name": "2169-count-operations-to-obtain-zero",
    "code": {
      "JS": "/**\n * @param {number} num1\n * @param {number} num2\n * @return {number}\n */\nvar countOperations = function(num1, num2) {\n  let res = 0\n  while(num1 !== 0 && num2 !== 0) {\n    if(num1 >= num2) num1 -= num2\n    else num2 -= num1\n    res++\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "217-contains-duplicate",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n * @return {boolean}\r\n */\r\nconst containsDuplicate = function(nums) {\r\n  const hash = {};\r\n  for (let el of nums) {\r\n    if (hash.hasOwnProperty(el)) {\r\n      return true;\r\n    } else {\r\n      hash[el] = 1;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n"
    }
  },
  {
    "name": "2179-count-good-triplets-in-an-array",
    "code": {
      "JS": "/**\n * @param {number[]} a\n * @param {number[]} b\n * @return {number}\n */\nconst goodTriplets = function(a, b) {\n    let n = a.length, m = new Map(), res = 0;\n    for (let i = 0; i < n; i++) m.set(b[i], i);\n    let fen = new Fenwick(n + 3);\n    for (let i = 0; i < n; i++) {\n       let pos = m.get(a[i]);\n       let l = fen.query(pos), r = (n - 1 - pos) - (fen.query(n - 1) - fen.query(pos));\n       res += l * r; \n       fen.update(pos, 1);\n    }\n    return res;\n};\nfunction Fenwick(n) {\n    let tree = Array(n).fill(0);\n    return { query, update }\n    function query(i) {\n        let sum = 0;\n        i++;\n        while (i > 0) {\n            sum += tree[i];\n            i -= i & -i;\n        }\n        return sum;\n    }\n    function update(i, v) {\n        i++;\n        while (i < n) {\n            tree[i] += v;\n            i += i & -i;\n        }\n    }\n}\n"
    }
  },
  {
    "name": "218-the-skyline-problem",
    "code": {
      "JS": "/**\n * @param {number[][]} buildings\n * @return {number[][]}\n */\nconst getSkyline = function getSkyline(\n  buildings,\n  begin = 0,\n  end = buildings.length\n) {\n  if (begin === end) {\n    return []\n  } else if (end - begin === 1) {\n    const [Li, Ri, Hi] = buildings[begin]\n    return [[Li, Hi], [Ri, 0]]\n  } else {\n    const pivotIndex = begin + Math.ceil((end - begin) / 2)\n    return combineOutputs(\n      getSkyline(buildings, begin, pivotIndex),\n      getSkyline(buildings, pivotIndex, end)\n    )\n  }\n}\n\nfunction combineOutputs(a, b) {\n  let aIndex = 0\n  const aLength = a.length\n  let bIndex = 0\n  const bLength = b.length\n  let aHeight = 0\n  let bHeight = 0\n  const combined = []\n  while (aIndex < aLength || bIndex < bLength) {\n    if (aIndex < aLength && bIndex === bLength) {\n      return combined.concat(a.slice(aIndex))\n    } else if (bIndex < bLength && aIndex === aLength) {\n      return combined.concat(b.slice(bIndex))\n    } else {\n      const previousMax = Math.max(aHeight, bHeight)\n      const nextX = Math.min(a[aIndex][0], b[bIndex][0])\n      if (a[aIndex][0] === nextX) {\n        aHeight = a[aIndex][1]\n        aIndex++\n      }\n      if (b[bIndex][0] === nextX) {\n        bHeight = b[bIndex][1]\n        bIndex++\n      }\n      const newMax = Math.max(aHeight, bHeight)\n      if (newMax !== previousMax) {\n        combined.push([nextX, newMax])\n      }\n    }\n  }\n  return combined\n}\n"
    }
  },
  {
    "name": "2180-count-integers-with-even-digit-sum",
    "code": {
      "JS": "/**\n * @param {number} num\n * @return {number}\n */\nvar countEven = function(num) {\n  let res = 0\n  for(let i = 1; i <= num; i++) {\n    const tmp = sum(i)\n    if(tmp % 2 === 0) res++\n  }\n  \n  return res\n};\n\nfunction sum(e) {\n  let res = 0\n  while(e) {\n    res += e % 10\n    e = Math.floor(e/10)\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "2181-merge-nodes-in-between-zeros",
    "code": {
      "JS": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar mergeNodes = function(head) {\n  const dummy = new ListNode()\n  const arr = []\n  let cur = head\n  while(cur) {\n    arr.push(cur)\n    cur = cur.next\n  }\n  let tail = dummy\n  let lastIdx = 0, sum = 0\n  if(arr.length) {\n    for(let i = 1; i < arr.length; i++) {\n      const tmp = arr[i]\n      if(tmp.val === 0 && sum !== 0) {\n        lastIdx = i\n        tail.next = new ListNode(sum)\n        tail = tail.next\n        sum = 0\n      } else {\n        sum += tmp.val\n      }\n    }\n  }\n  \n  return dummy.next\n};\n"
    }
  },
  {
    "name": "2182-construct-string-with-repeat-limit",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {number} repeatLimit\n * @return {string}\n */\nvar repeatLimitedString = function(s, repeatLimit) {\n    const a = 'a'.charCodeAt(0)\n    const ch = Array(26).fill(0)\n    for(let e of s) {\n      const idx = e.charCodeAt(0)\n      ch[idx - a]++\n    }\n    let res = '', last = ''\n    while(true) {\n      let len = res.length\n      let h = false\n      for(let i = 25; i >= 0; i--) {\n        if(ch[i] >= repeatLimit && res[res.length - 1] !== String.fromCharCode(a + i)) {\n\n          res += String.fromCharCode(a + i).repeat(repeatLimit)\n          ch[i] -= repeatLimit\n          \n          if(ch[i]) {\n            for(let j = i - 1; j >= 0; j--) {\n              if(ch[j]) {\n                res += String.fromCharCode(a + j)\n                ch[j]--\n                break\n              }\n            }\n            break\n          }\n\n        }else if(ch[i] > 0 && res[res.length - 1] !== String.fromCharCode(a + i)) {\n          \n          res += String.fromCharCode(a + i).repeat(ch[i])\n          ch[i] = 0\n          break\n        }\n      }\n      if(len === res.length) break\n    }\n    \n    \n    return res\n};\n"
    }
  },
  {
    "name": "2183-count-array-pairs-divisible-by-k",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nconst coutPairs = function(nums, k) {\n  let res = 0;\n  let cnt = Array(1e5 + 1).fill(0);\n  const n = nums.length\n  for (let i = 0; i < n; ++i) {\n    if (nums[i] % k == 0) {\n      res += i;\n      ++cnt[0];\n    }\n    else {\n      let div = gcd(k, nums[i]);\n      for (let d = 0; d <= div; ++d) res += cnt[k / div * d];\n      ++cnt[div];\n    }   \n  }\n  return res;\n};\n\nfunction gcd(a, b) {\n  if(b === 0) return a\n  return gcd(b, a % b)\n}\n"
    }
  },
  {
    "name": "2188-minimum-time-to-finish-the-race",
    "code": {
      "JS": "/**\n * @param {number[][]} tires\n * @param {number} changeTime\n * @param {number} numLaps\n * @return {number}\n */\n const minimumFinishTime = function (tires, changeTime, numLaps) {\n  tires = preprocess(tires)\n  let n = tires.length\n  const { max, min } = Math\n  // to handle the cases where numLaps is small\n  // pre[i][j]: the total time to run j laps consecutively with tire i\n  const pre = Array.from({ length: n }, () =>\n    Array(20).fill(Infinity)\n  )\n  for (let i = 0; i < n; i++) {\n    pre[i][1] = tires[i][0]\n    for (let j = 2; j < 20; j++) {\n      if (pre[i][j - 1] * tires[i][1] >= 2e9) break\n      pre[i][j] = pre[i][j - 1] * tires[i][1]\n    }\n    // since we define it as the total time, rather than just the time for the j-th lap\n    // we have to make it prefix sum\n    for (let j = 2; j < 20; j++) {\n      if (pre[i][j - 1] + pre[i][j] >= 2e9) break\n      pre[i][j] += pre[i][j - 1]\n    }\n  }\n\n  // dp[x]: the minimum time to finish x laps\n  const dp = Array(numLaps + 1).fill(Infinity)\n  for (let i = 0; i < n; i++) {\n    dp[1] = min(dp[1], tires[i][0])\n  }\n  for (let x = 1; x <= numLaps; x++) {\n    if (x < 20) {\n      // x is small enough, so an optimal solution might never changes tires!\n      for (let i = 0; i < n; i++) {\n        dp[x] = min(dp[x], pre[i][x])\n      }\n    }\n    for (let j = x - 1; j > 0 && j >= x - 18; j--) {\n      dp[x] = min(dp[x], dp[j] + changeTime + dp[x - j])\n    }\n  }\n\n  return dp[numLaps]\n}\n\nfunction preprocess(tires) {\n  tires.sort((a, b) => (a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]))\n  const res = []\n  for (let t of tires) {\n    if (res.length === 0 || res[res.length - 1][1] > t[1]) {\n      res.push(t)\n    }\n  }\n  return res\n}\n\n// another\n\n/**\n * @param {number[][]} tires\n * @param {number} changeTime\n * @param {number} numLaps\n * @return {number}\n */\nvar minimumFinishTime = function (tires, changeTime, numLaps) {\n  let N = tires.length,\n    len = 0\n  const { max, min } = Math\n  const best = Array(numLaps).fill(Infinity),\n    dp = Array(numLaps + 1).fill(Infinity)\n  for (let i = 0; i < N; ++i) {\n    // We assume we also need `changeTime` time to use the first tire\n    // so that we don't need to treat the first tire as a special case\n    let f = tires[i][0],\n      r = tires[i][1],\n      sum = changeTime,\n      p = 1\n    for (let j = 0; j < numLaps; ++j) {\n      sum += f * p\n      // If using the same tire takes no less time than changing the tire,\n      // stop further using the current tire\n      if (f * p >= f + changeTime) break \n      best[j] = min(best[j], sum)\n      len = max(len, j + 1)\n      p *= r\n    }\n  }\n  // dp[i + 1] is the minimum time to finish `numLaps` laps\n  dp[0] = 0 \n  for (let i = 0; i < numLaps; ++i) {\n    for (let j = 0; j < len && i - j >= 0; ++j) {\n      // try using the same tire in the last `j+1` laps\n      dp[i + 1] = min(dp[i + 1], dp[i - j] + best[j])\n    }\n  }\n  // minus the `changeTime` we added to the first tire\n  return dp[numLaps] - changeTime \n}\n\n"
    }
  },
  {
    "name": "2189-number-of-ways-to-build-house-of-cards",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst houseOfCards = function(n) {\n  const memo = Array.from({ length: n + 1 }, () => Array(n + 2).fill(null))\n  return helper(n, n + 1)\n  \n  function helper(remain, preRow) {\n    if(remain === 0 || remain === 2) return 1\n    if(memo[remain][preRow] != null) return memo[remain][preRow]\n    let res = 0\n    for(let i = 5; i <= remain && i < preRow; i += 3) {\n      res += helper(remain - i, i)\n    }\n    return memo[remain][preRow] = res\n  }\n};\n"
    }
  },
  {
    "name": "219-contains-duplicate-ii",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {boolean}\n */\nconst containsNearbyDuplicate = function(nums, k) {\n    const map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        if (map.has(nums[i])) {\n            if (i - map.get(nums[i]) <= k) {\n                return true;\n            } else {\n                map.set(nums[i], i);\n            }\n        } else {\n            map.set(nums[i], i);\n        }\n    }\n    return false;\n};\n"
    }
  },
  {
    "name": "2193-minimum-number-of-moves-to-make-palindrome",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst minMovesToMakePalindrome = function(s) {\n  let res = 0\n  const arr = s.split('')\n  \n  while(arr.length) {\n    const idx = arr.indexOf(arr[arr.length - 1])\n    if(idx === arr.length - 1) {\n      res += ~~(idx / 2)\n    } else {\n      res += idx\n      arr.splice(idx, 1)\n    }\n    arr.pop()\n  }\n\n  return res\n};\n"
    }
  },
  {
    "name": "22-generate-parentheses",
    "code": {
      "JS": "/**\r\n * @param {number} n\r\n * @return {string[]}\r\n */\r\nconst generateParenthesis = function(n) {\r\n  const res = [];\r\n  backtrack(res, \"\", 0, 0, n);\r\n  return res;\r\n};\r\nfunction backtrack(arr, cur, open, close, max) {\r\n  if (cur.length === max * 2) {\r\n    arr.push(cur);\r\n    return;\r\n  }\r\n  if (open < max) backtrack(arr, cur + \"(\", open + 1, close, max);\r\n  if (close < open) backtrack(arr, cur + \")\", open, close + 1, max);\r\n}\r\n"
    }
  },
  {
    "name": "220-contains-duplicate-iii",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} k\n * @param {number} t\n * @return {boolean}\n */\nconst containsNearbyAlmostDuplicate = function(nums, k, t) {\n  if (k < 1 || t < 0) {\n    return false\n  }\n  const array = new Map()\n  const num = 10 ** 10\n  for (let i = 0, iL = nums.length; i < iL; ++i) {\n    const noNegative = nums[i] + num\n    const factor = Math.floor(noNegative / (t + 1))\n    if (\n      array.has(factor) ||\n      (array.has(factor - 1) && noNegative - array.get(factor - 1) <= t) ||\n      (array.has(factor + 1) && array.get(factor + 1) - noNegative <= t)\n    ) {\n      return true\n    }\n    if (array.size >= k) {\n      array.delete(Math.floor((nums[i - k] + num) / (t + 1)))\n    }\n    array.set(factor, noNegative)\n  }\n  return false\n}\n\n// another\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @param {number} t\n * @return {boolean}\n */\nconst containsNearbyAlmostDuplicate = function(nums, k, t) {\n  const map = nums\n    .map((val, idx) => ({ val, idx }))\n    .sort((a, b) => a.val - b.val)\n  let l = 0\n  let r = 1\n  while (r < map.length) {\n    const diff = Math.abs(map[r].val - map[l].val)\n    const range = Math.abs(map[r].idx - map[l].idx)\n    if (diff <= t && range <= k) return true\n    else if (diff > t) l++\n    else if (range > k) r++\n    if (l === r) r++\n  }\n  return false\n}\n"
    }
  },
  {
    "name": "2209-minimum-white-tiles-after-covering-with-carpets",
    "code": {
      "JS": "/**\n * @param {string} floor\n * @param {number} numCarpets\n * @param {number} carpetLen\n * @return {number}\n */\nconst minimumWhiteTiles = function(floor, numCarpets, carpetLen) {\n  // 0: black, 1: white\n  const n = floor.length\n  // dp[i][j]: the minimum number of white tiles still visible\n  // when using j tiles to cover the first i tiles \n  const dp = Array.from({ length: n + 1 }, () => Array(numCarpets + 1).fill(0))\n\n  const ones = Array(n + 1).fill(0)\n  for(let i = 1; i <= n; i++) {\n    ones[i] = ones[i - 1] + (floor[i - 1] === '1' ? 1 : 0) \n  }\n  for(let i = 1; i <= n; i++) {\n    dp[i][0] = ones[i]\n    for(let j = 1; j <= numCarpets; j++) {\n      const skip = dp[i - 1][j] + (floor[i - 1] === '1' ? 1 : 0)\n      const cover = dp[Math.max(i - carpetLen, 0)][j - 1]\n      dp[i][j] = Math.min(skip, cover)\n    }\n  }\n\n  return dp[n][numCarpets]\n};\n"
    }
  },
  {
    "name": "221-maximal-square",
    "code": {
      "JS": "/**\n * @param {character[][]} matrix\n * @return {number}\n */\nconst maximalSquare = function(matrix) {\n    const rows = matrix.length\n    const cols = rows > 0 ? matrix[0].length : 0\n    const dp = Array.from(new Array(rows + 1), el => new Array(cols + 1).fill(0))\n    let maxLen = 0\n    for(let i = 1; i <= rows; i++) {\n        for(let j = 1; j <= cols; j++) {\n            if(matrix[i - 1][j - 1] === '1') {\n               dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n               maxLen = Math.max(maxLen, dp[i][j])\n            }\n        }\n    }\n    \n    return maxLen * maxLen\n};\n\n// another\n\nconst maximalSquare = function(matrix) {\n  const rows = matrix.length\n  if(rows === 0) return 0\n  const cols = matrix[0].length\n  const dp = new Array(cols + 1).fill(0)\n  let max = 0\n  let prev = 0\n  let tmp\n  for(let i = 1; i <= rows; i++) {\n    for(let j = 1; j <= cols; j++) {\n      tmp = dp[j]\n      if(matrix[i - 1][j - 1] === '1') {\n        dp[j] = Math.min(dp[j - 1], dp[j], prev) + 1\n        if(dp[j] > max) max = dp[j]\n      } else {\n        dp[j] = 0\n      }\n      prev = tmp\n    }\n  }\n  return max ** 2\n};\n"
    }
  },
  {
    "name": "2210-count-hills-and-valleys-in-an-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst countHillValley = function(nums) {\n  const arr = [nums[0]], n = nums.length\n  for(let i = 1; i < n; i++) {\n    if(nums[i] !== nums[i - 1]) arr.push(nums[i])\n  }\n  let res = 0\n  for(let i = 1; i < arr.length - 1; i++) {\n     if(\n       arr[i] > arr[i - 1] && arr[i] > arr[i + 1] ||\n       arr[i] < arr[i - 1] && arr[i] < arr[i + 1]\n     ) res++\n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "2211-count-collisions-on-a-road",
    "code": {
      "JS": "/**\n * @param {string} directions\n * @return {number}\n */\nconst countCollisions = function(directions) {\n  let res = 0, n = directions.length\n\n  let flag = false\n  // left -> right\n  for(let i = 0; i < n; i++) {\n    if(directions[i] !== 'L') {\n      flag = true\n    } else {\n      res += flag ? 1 : 0\n    }\n  }\n  flag = false\n  // right -> left\n  for(let i = n - 1; i >= 0; i--) {\n    if(directions[i] !== 'R') {\n      flag = true\n    } else {\n      res += flag ? 1 : 0\n    }\n  }\n\n  return res\n};\n\n// another\n\n/**\n * @param {string} directions\n * @return {number}\n */\n const countCollisions = function(directions) {\n  let res = 0, n = directions.length\n  let left = 0, right = n - 1\n  while(left < n && directions[left] === 'L') left++\n  while(right >= 0 && directions[right] === 'R') right--\n  for(let i = left; i <= right; i++) res += directions[i] === 'S' ? 0 : 1\n  return res\n};\n"
    }
  },
  {
    "name": "2212-maximum-points-in-an-archery-competition",
    "code": {
      "JS": "/**\n * @param {number} numArrows\n * @param {number[]} aliceArrows\n * @return {number[]}\n */\nconst maximumBobPoints = function(numArrows, aliceArrows) {\n  let bestScore = 0, res = null\n  const sum = arr => arr.reduce((ac, e) => ac + e, 0)\n  bt(0, numArrows, 0, Array(12).fill(0))\n  res[0] += numArrows - sum(res)\n  return res\n\n  function bt(k, remain, score, bobArrows) {\n    if(k == 12) {\n      if(score > bestScore) {\n        bestScore = score\n        res = bobArrows.slice(0)\n      }\n      return\n    }\n    bt(k + 1, remain, score, bobArrows)\n    let arrowsNeeded = aliceArrows[k] + 1\n    if(remain >= arrowsNeeded) {\n      let bak = bobArrows[k]\n      bobArrows[k] = arrowsNeeded\n      bt(k + 1, remain - arrowsNeeded, score + k, bobArrows)\n      bobArrows[k] = bak\n    }\n  }\n};\n"
    }
  },
  {
    "name": "2215-find-the-difference-of-two-arrays",
    "code": {
      "JS": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number[][]}\n */\nvar findDifference = function(nums1, nums2) {\n  const set1 = new Set(nums1), set2 = new Set(nums2)\n  const res = [new Set(), new Set()]\n  for(let e of nums1) {\n    if(set2.has(e)) continue\n    else res[0].add(e)\n  }\n  for(let e of nums2) {\n    if(set1.has(e)) continue\n    else res[1].add(e)\n  }\n  res[0] = Array.from(res[0])\n  res[1] = Array.from(res[1])\n  return res\n};\n"
    }
  },
  {
    "name": "2216-minimum-deletions-to-make-array-beautiful",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst minDeletion = function(nums) {\n  let res = 0, i = 0\n  for(i = 0, n = nums.length; i < n - 1;) {\n    if(nums[i] === nums[i + 1]) {\n      res++\n      i++\n    }else{\n      i += 2\n    }\n  }\n  if((nums.length - res) % 2 === 1) res++\n  \n  return res\n};\n"
    }
  },
  {
    "name": "2217-find-palindrome-with-fixed-length",
    "code": {
      "JS": "/**\n * @param {number[]} queries\n * @param {number} intLength\n * @return {number[]}\n */\nvar kthPalindrome = function(queries, intLength) {\n    if (intLength == 1) {\n        let res = []\n        for (let item of queries) {\n            if (item <= 9) res.push(item)\n            else res.push(-1)          \n        }\n        return res      \n    }\n\n    let n = Math.floor(intLength / 2)\n    let ref = +(\"1\"+\"0\".repeat(n-1))\n\n    if (intLength % 2 == 0) {\n      let res = []\n      for (let item of queries) res.push(gen_even(item))\n      return res          \n    } else {\n      let res = []\n      for (let item of queries) res.push(gen_odd(item))\n      return res\n    }\n\n    function gen_even(val) {\n        let part = ref + val - 1\n        part = '' + part\n        if (part.length != n) return -1\n        return +(part + part.split('').reverse().join(''))          \n    }\n\n\n    function gen_odd(val) {\n        let mod = (val - 1) % 10\n        let div = Math.floor((val - 1) / 10)\n        let part = ref + div\n        mod = '' + mod, part = '' + part\n        if (part.length != n) return -1\n        return +(part + mod + part.split('').reverse().join(''))          \n    }\n};\n"
    }
  },
  {
    "name": "2218-maximum-value-of-k-coins-from-piles",
    "code": {
      "JS": "/**\n * @param {number[][]} piles\n * @param {number} k\n * @return {number}\n */\nvar maxValueOfCoins = function(piles, k) {\n    let dp = Array(k + 1).fill(0);\n    for (let i = 0; i < piles.length; i++) {\n      const next = Array(k + 1).fill(0);\n      for (let l = 1; l <= k; l++) {\n        let sum = 0;\n        next[l] = dp[l];\n        for (let j = 0; j < Math.min(piles[i].length, l); j++) {\n          sum += piles[i][j];\n          next[l] = Math.max(next[l], dp[l - j - 1] + sum);\n        }\n      }\n      dp = next;\n    }\n    return dp[k];    \n};\n\n// another\n\n/**\n * @param {number[][]} piles\n * @param {number} k\n * @return {number}\n */\nconst maxValueOfCoins = function(piles, k) {\n  const n = piles.length\n  const memo = Array.from({ length: n + 1 }, () => Array(k + 1).fill(null))\n  return helper(0, k)\n\n  // TC: O(k * m)\n  // k: k\n  // n: length of piles\n  // m: sum(piles[i]), total elements of all piles\n  function helper(i, k) {\n    if(k == 0 || i === n) return 0\n    if(memo[i][k] != null) return memo[i][k]\n    let res = helper(i + 1, k)\n    let cur = 0\n\n    for(let j = 0; j < Math.min(piles[i].length, k); j++) {\n      cur += piles[i][j]\n      res = Math.max(res, cur + helper(i + 1, k - j - 1))\n    }\n    return memo[i][k] = res\n  }\n};\n"
    }
  },
  {
    "name": "222-count-complete-tree-nodes",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nconst countNodes = function(root) {\n  if (root == null) return 0;\n  const payload = { depth: 0, numOfLast: 0, total: 0 };\n  traverse([root], 0, payload);\n  return payload.total;\n};\n\nfunction traverse(row, depth, obj) {\n  const next = [];\n  for (let i = 0; i < row.length; i++) {\n    if (row[i].left) next.push(row[i].left);\n    if (row[i].right) next.push(row[i].right);\n  }\n  if (Math.pow(2, depth + 1) !== next.length) {\n    obj.total = Math.pow(2, depth + 1) - 1 + next.length;\n    return;\n  }\n  if (next.length) traverse(next, depth + 1, obj);\n}\n\n// another\n\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nconst countNodes = function(root) {\n  if (!root) {\n    return 0;\n  }\n\n  return 1 + countNodes(root.left) + countNodes(root.right);\n};\n"
    }
  },
  {
    "name": "2223-sum-of-scores-of-built-strings",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nvar sumScores = function(s) {\n  function z_function(s) {\n      let n = s.length\n      let z = Array(n).fill(0)\n      let l = 0, r = 0\n      for (let i = 1; i < n; i++) {\n          if (i <= r) z[i] = Math.min(r - i + 1, z[i - l])\n          while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n              z[i] += 1                  \n          }\n\n          if (i + z[i] - 1 > r) {\n              l = i\n              r = i + z[i] - 1                  \n          }\n\n      }\n      return z          \n  }\n\n  const sum = z_function(s).reduce((ac, e) => ac + e, 0)\n  return sum + s.length  \n};\n \n"
    }
  },
  {
    "name": "2224-minimum-number-of-operations-to-convert-time",
    "code": {
      "JS": "/**\n * @param {string} current\n * @param {string} correct\n * @return {number}\n */\nvar convertTime = function(current, correct) {\n  const s = current.split(':').map(e => +e)\n  const t = correct.split(':').map(e => +e)\n  let res = 0\n  // hour\n  if(s[0] < t[0]) res += t[0] - s[0]\n  else if(s[0] > t[0]) res += (24 - (s[0] - t[0]))\n  \n  // min\n  let delta = t[1] - s[1]\n  if(delta > 0) {\n    if(delta >= 15) {\n      res += ~~(delta / 15)\n      delta %= 15\n    }\n    if(delta >= 5) {\n      res += ~~(delta / 5)\n      delta %= 5\n    }\n    res += delta\n  } else if(delta < 0) {\n    res--\n    delta += 60\n    if(delta >= 15) {\n      res += ~~(delta / 15)\n      delta %= 15\n    }\n    if(delta >= 5) {\n      res += ~~(delta / 5)\n      delta %= 5\n    }\n    res += delta\n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "2225-find-players-with-zero-or-one-losses",
    "code": {
      "JS": "/**\n * @param {number[][]} matches\n * @return {number[][]}\n */\nvar findWinners = function(matches) {\n    const win = {}, lose = {}, total = new Set(), ls = new Set()\n    for(const [w, l] of matches) {\n      if(win[w] == null) win[w] = 0\n      win[w]++\n      if(lose[l] == null) lose[l] = 0\n      lose[l]++\n      total.add(l)\n      total.add(w)\n      ls.add(l)\n    }\n  \n    const loseKeys = Object.keys(lose)\n    const a0 = []\n    for(const e of total) {\n      if(!ls.has(e)) a0.push(e)\n    }\n    const a1 = []\n    for(const e of loseKeys) {\n      if(lose[e] === 1) a1.push(e)\n    }\n    a0.sort((a, b) => a - b)\n    a1.sort((a, b) => a - b)\n    return [a0, a1]\n};\n"
    }
  },
  {
    "name": "2226-maximum-candies-allocated-to-k-children",
    "code": {
      "JS": "/**\n * @param {number[]} candies\n * @param {number} k\n * @return {number}\n */\nconst maximumCandies = function(candies, k) {\n  let max = candies.reduce((ac, e) => ac + e, 0);\n  let min = 0;\n  while (min < max) {\n    let mid = max - Math.floor((max - min) / 2);\n    let cnt = 0;\n    for (let cand of candies) {\n      cnt += ~~(cand / mid);\n    }\n    if (cnt < k) {\n      max = mid - 1;\n    } else {\n      min = mid;\n    }\n  }\n  return min;\n};\n\n// another\n\n/**\n * @param {number[]} candies\n * @param {number} k\n * @return {number}\n */\nconst maximumCandies = function(candies, k) {\n  let max = candies.reduce((ac, e) => ac + e, 0)\n  let min = 0\n  while(min < max) {\n    const mid = max - Math.floor((max - min) /2)\n    let num = 0\n    for(let e of candies) num += ~~(e / mid)\n    if(num < k) max = mid - 1\n    else min = mid\n  }\n  return min\n};\n"
    }
  },
  {
    "name": "223-rectangle-area",
    "code": {
      "JS": "/**\n * @param {number} A\n * @param {number} B\n * @param {number} C\n * @param {number} D\n * @param {number} E\n * @param {number} F\n * @param {number} G\n * @param {number} H\n * @return {number}\n */\nconst computeArea = function(A, B, C, D, E, F, G, H) {\n  const areaA = (C - A) * (D - B)\n  const areaB = (G - E) * (H - F)\n  const intersectionArea =\n    Math.max(0, Math.min(C, G) - Math.max(A, E)) *\n    Math.max(0, Math.min(D, H) - Math.max(B, F))\n  return areaA + areaB - intersectionArea\n}\n\n\n// another\n\n\n/**\n * @param {number} A\n * @param {number} B\n * @param {number} C\n * @param {number} D\n * @param {number} E\n * @param {number} F\n * @param {number} G\n * @param {number} H\n * @return {number}\n */\nconst computeArea = function(A, B, C, D, E, F, G, H) {\n  const x1 = A,\n    x2 = C,\n    x3 = E,\n    x4 = G\n  const y1 = B,\n    y2 = D,\n    y3 = F,\n    y4 = H\n  return (\n    area(x1, y1, x2, y2) +\n    area(x3, y3, x4, y4) -\n    delta(x1, x2, x3, x4) * delta(y1, y2, y3, y4)\n  )\n}\n\nfunction area(x1, y1, x2, y2) {\n  return Math.abs(x1 - x2) * Math.abs(y1 - y2)\n}\n\nfunction delta(v1, v2, v3, v4) {\n  if (v1 > v2) {\n    let tmp = v1\n    v1 = v2\n    v2 = tmp\n  }\n  if (v3 > v4) {\n    let tmp = v3\n    v3 = v4\n    v4 = tmp\n  }\n  if (v3 >= v2 || v4 <= v1) return 0\n  return Math.min(v2, v4) - Math.max(v1, v3)\n}\n"
    }
  },
  {
    "name": "224-basic-calculator",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst calculate = function(s) {\n  let stack = []\n  let num = 0\n  let sign = 1\n  let res = 0\n  for (let i = 0; i < s.length; i++) {\n    let char = s.charAt(i)\n    if (char >= '0' && char <= '9') {\n      num = num * 10 + parseInt(char, 10)\n    } else if (char === '+') {\n      res += sign * num\n      sign = 1\n      num = 0\n    } else if (char === '-') {\n      res += sign * num\n      sign = -1\n      num = 0\n    } else if (char === '(') {\n      stack.push(res)\n      stack.push(sign)\n      sign = 1\n      res = 0\n      num = 0\n    } else if (char === ')') {\n      res += sign * num\n      res *= stack.pop()\n      res += stack.pop()\n      num = 0\n    }\n  }\n  return res + sign * num\n}\n\n// another\n\n/**\n * @param {string} s\n * @return {number}\n */\nconst calculate = function(s) {\n  s = s.split(' ').join('')\n  const n = s.length, stack = []\n  const isNum = ch => ch >= '0' && ch <= '9'\n  let num = 0, op = 1, res = 0\n  for(let i = 0; i < n; i++) {\n    const ch = s[i]\n    if(isNum(ch)) {\n      num = num * 10 + (+ch)\n    } else {\n      if(ch === '(') {\n        stack.push(res)\n        stack.push(op)\n        num = 0\n        op = 1\n        res = 0\n      } else if(ch === ')') {\n        res += num * op\n        res *= stack.pop()\n        res += stack.pop()\n        num = 0\n        op = 1\n      } else if(ch === '+') {\n        res += op * num\n        op = 1\n        num = 0\n      } else if(ch === '-') {\n        res += op * num\n        op = -1\n        num = 0\n      }\n    }\n  }\n  \n  return res + op * num\n};\n"
    }
  },
  {
    "name": "225-implement-stack-using-queues",
    "code": {
      "JS": "/**\n * Initialize your data structure here.\n */\nconst MyStack = function() {\n    this.stack = []\n};\n\n/**\n * Push element x onto stack. \n * @param {number} x\n * @return {void}\n */\nMyStack.prototype.push = function(x) {\n    this.stack.push(x)\n};\n\n/**\n * Removes the element on top of the stack and returns that element.\n * @return {number}\n */\nMyStack.prototype.pop = function() {\n    return this.stack.pop()\n};\n\n/**\n * Get the top element.\n * @return {number}\n */\nMyStack.prototype.top = function() {\n    return this.stack.length === 0 ? null : this.stack[this.stack.length - 1]\n};\n\n/**\n * Returns whether the stack is empty.\n * @return {boolean}\n */\nMyStack.prototype.empty = function() {\n    return this.stack.length === 0\n};\n\n/** \n * Your MyStack object will be instantiated and called as such:\n * var obj = Object.create(MyStack).createNew()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.top()\n * var param_4 = obj.empty()\n */\n"
    }
  },
  {
    "name": "226-invert-binary-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nconst invertTree = function (root) {\n  if (root) {\n    ;[root.left, root.right] = [invertTree(root.right), invertTree(root.left)]\n  }\n  return root\n}\n\n// another\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nconst invertTree = function (root) {\n  if (!root) return root\n  let queue = [root]\n  while (queue.length) {\n    let node = queue.shift()\n    if (node.left) {\n      queue.push(node.left)\n    }\n    if (node.right) {\n      queue.push(node.right)\n    }\n    let left = node.left\n    node.left = node.right\n    node.right = left\n  }\n  return root\n}\n\n// anoother\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nconst invertTree = function(root) {\n  if(root == null) return root\n  let tmp = root.left\n  root.left = invertTree(root.right)\n  root.right = invertTree(tmp)\n  return root\n};\n"
    }
  },
  {
    "name": "227-basic-calculator-ii",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst calculate = function(s) {\n  const stack = [], n = s.length\n  let op = '+', num = 0\n  for(let i = 0; i < n; i++) {\n    const isNumber = s[i] >= '0' && s[i] <= '9'\n    if(isNumber) num = num * 10 + (+s[i])\n    if((!isNumber && s[i] !== ' ') || i === n - 1) {\n      if(op === '+') stack.push(num)\n      else if(op === '-') stack.push(-num)\n      else if(op === '*') stack.push(stack.pop() * num)\n      else if(op === '/') stack.push(~~(stack.pop() / num))\n      op = s[i]\n      num = 0\n    }\n  }\n  \n  return stack.reduce((ac, e) => ac + e, 0)\n};\n\n// another\n\n/**\n * @param {string} s\n * @return {number}\n */\nconst calculate = function(s) {\n  if(s == null || s.length === 0) return 0\n  let sum = 0, num = 0, op = '+', tmp = 0\n  const stack = []\n  for(let i = 0; i < s.length; i++) {\n    const ch = s[i]\n    const isInt = ch => ch >= '0' && ch <= '9'\n    if(isInt(ch)) {\n      num = num * 10 + (+ch)\n    }\n    if((!isInt(ch) && ch !== ' ') || i === s.length - 1) {\n      if(op === '+') {\n        sum += tmp\n        tmp = num\n      }\n      else if(op === '-') {\n        sum += tmp\n        tmp = - num\n      }\n      else if(op === '*') {\n        tmp *= num\n      }\n      else if(op === '/') {\n        tmp = ~~(tmp / num)\n      }\n      op = ch\n      num = 0\n    }\n\n  }\n\n  return sum + tmp\n}\n"
    }
  },
  {
    "name": "228-summary-ranges",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {string[]}\n */\nconst summaryRanges = function(nums) {\n  if (nums == null || nums.length === 0) return []\n  const res = []\n  if (nums.length === 1) return [`${nums[0]}`]\n  let start = nums[0]\n  let end = nums[0]\n  let endVal = end\n  for (let i = 1, len = nums.length; i < len; i++) {\n    let cur = nums[i]\n    if (cur - end > 1) {\n      endVal = end\n      insert(res, start, end)\n      start = cur\n      end = cur\n    } else {\n      end = cur\n    }\n  }\n  if (endVal !== end) {\n    insert(res, start, end)\n  }\n  return res\n}\n\nfunction insert(arr, start, end) {\n  if (start === end) {\n    arr.push(`${start}`)\n  } else {\n    arr.push(`${start}->${end}`)\n  }\n}\n\n// another\n\nconst summaryRanges = nums => {\n  if (!nums || nums.length === 0) {\n    return [];\n  }\n  const returnArray = [];\n  let tempIdx = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] + 1 !== nums[i + 1]) {\n      if (tempIdx === i) {\n        returnArray.push(nums[tempIdx].toString());\n      } else {\n        returnArray.push(nums[tempIdx].toString() + \"->\" + nums[i].toString());\n      }\n      tempIdx = i + 1;\n    }\n  }\n\n  return returnArray;\n};\n"
    }
  },
  {
    "name": "229-majority-element-ii",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nconst majorityElement = function(nums) {\n  const res = []\n  const hash = {}\n  const len = nums.length\n  const limit = Math.floor(len / 3)\n  nums.forEach(el => {\n    if(hash.hasOwnProperty(''+el)) {\n       hash[el] += 1\n    } else {\n      hash[el] = 1\n    }\n  })\n  Object.keys(hash).forEach(el => {\n    if(hash[el] > limit) res.push(+el)\n  })\n  \n  return res\n};\n"
    }
  },
  {
    "name": "23-merge-k-sorted-lists",
    "code": {
      "JS": "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode[]} lists\n * @return {ListNode}\n */\nconst mergeKLists = function(lists) {\n  return merge(lists, 0, lists.length - 1)\n}\nfunction merge(lists, l, r) {\n  if (l > r) return null\n  if (l === r) return lists[l]\n  let m = Math.floor((r + l) / 2)\n  let left = merge(lists, l, m)\n  let right = merge(lists, m + 1, r)\n  let head = new ListNode(0)\n  let dummy = head\n  while (left && right) {\n    if (left.val <= right.val) {\n      head.next = left\n      left = left.next\n    } else {\n      head.next = right\n      right = right.next\n    }\n    head = head.next\n  }\n  head.next = left ? left : right\n  return dummy.next\n}\n\n// another\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode[]} lists\n * @return {ListNode}\n */\nconst mergeKLists = function(lists) {\n  if(lists == null || lists.length === 0) return null\n  if(lists.length === 1) return lists[0]\n  if(lists.length === 2) return mergeTwo(lists[0], lists[1])\n  const left = mergeKLists(lists.slice(0, ~~(lists.length / 2)))\n  const right = mergeKLists(lists.slice(~~(lists.length / 2)))\n  \n  return mergeTwo(left, right)\n};\n\nfunction mergeTwo(l1, l2) {\n  const dummy = new ListNode()\n  let cur = dummy\n  while(l1 && l2) {\n    if(l1.val < l2.val) {\n      cur.next = l1\n      l1 = l1.next\n    } else {\n      cur.next = l2\n      l2 = l2.next\n    }\n    cur = cur.next\n  }\n  if(l1) cur.next = l1\n  if(l2) cur.next = l2\n  \n  \n  return dummy.next\n}\n\n\n// another\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode[]} lists\n * @return {ListNode}\n */\nconst mergeKLists = function(lists) {\n  if(lists == null || lists.length === 0) return null\n  const dummy = new ListNode()\n  let head = dummy\n  const pq = new PriorityQueue((a, b) => a.val < b.val)\n  for(let list of lists) {\n    while(list) {\n      pq.push(list)\n      list = list.next\n    }\n  }\n  while(!pq.isEmpty()) {\n    const pop = pq.pop()\n    head.next = new ListNode(pop.val)\n    head = head.next\n  }\n  return dummy.next\n};\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n"
    }
  },
  {
    "name": "230-kth-smallest-element-in-a-bst",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} k\n * @return {number}\n */\nconst kthSmallest = function (root, k) {\n  const st = []\n  while (root !== null) {\n    st.push(root)\n    root = root.left\n  }\n  while (k !== 0) {\n    const n = st.pop()\n    k--\n    if (k === 0) return n.val\n    let right = n.right\n    while (right !== null) {\n      st.push(right)\n      right = right.left\n    }\n  }\n  return -1\n}\n"
    }
  },
  {
    "name": "231-power-of-two",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {boolean}\n */\nconst isPowerOfTwo = function(n) {\n    let tmp = 0\n    let idx = 0\n    while(tmp <= n) {\n          if((tmp = Math.pow(2, idx)) === n) {\n              return true\n          } else {\n              idx += 1\n          }\n    }\n    return false\n};\n\n// another\n\n/**\n * @param {number} n\n * @return {boolean}\n */\nconst isPowerOfTwo = function(n) {\n    return Math.log2(n)%1 === 0\n};\n\n// another\n\n/**\n * @param {number} n\n * @return {boolean}\n */\nconst isPowerOfTwo = n => n < 1 ? false : Number.MAX_VALUE % n === 0\n\n// another\n\n/**\n * @param {number} n\n * @return {boolean}\n */\nconst isPowerOfTwo = x => x > 0 ? !(x & (x - 1)) : false;\n\n"
    }
  },
  {
    "name": "232-implement-queue-using-stacks",
    "code": {
      "JS": "/**\n * Initialize your data structure here.\n */\nconst MyQueue = function() {\n    this.queue = []\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.queue.push(x)\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    return this.queue.shift()\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    return this.queue[0]\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.queue.length === 0\n};\n\n/** \n * Your MyQueue object will be instantiated and called as such:\n * var obj = Object.create(MyQueue).createNew()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n"
    }
  },
  {
    "name": "233-number-of-digit-one",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst countDigitOne = function(n) {\n  let count = 0\n  for (let m = 1; m <= n; m *= 10) {\n    const a = Math.floor(n / m)\n    const b = n % m\n    if (a % 10 > 1) {\n      count += (Math.floor(a / 10) + 1) * m\n    } else if (a % 10 === 1) {\n      count += Math.floor(a / 10) * m + b + 1\n    } else {\n      count += Math.floor(a / 10) * m\n    }\n  }\n  return count\n}\n\n// another\n\n/**\n * @param {number} n\n * @return {number}\n */\nconst countDigitOne = function (n) {\n  if (n <= 0) return 0\n  let ones = 0\n  for (let i = 1, q = n; i <= n; i *= 10, q = (q / 10) >> 0) {\n    const pre = (n / (i * 10)) >> 0,\n      cur = q % 10,\n      suf = n % i\n    ones += pre * i\n    ones += 1 < cur ? i : 1 == cur ? suf + 1 : 0\n  }\n  return ones\n}\n\n// another\n\n/**\n * @param {number} n\n * @return {number}\n */\nconst countDigitOne = function(n) {\n  let res = 0, factor = 1, lower = 0, cur = 0, higher = 0\n  while(~~(n / factor) !== 0) {\n    lower = n - (~~(n / factor)) * factor\n    cur = (~~(n / factor)) % 10\n    higher = ~~(n / (factor * 10))\n    switch(cur) {\n      case 0:\n        res += higher * factor\n        break\n      case 1:\n        res += higher * factor + lower + 1\n        break\n      default:\n        res += (higher + 1) * factor\n        break\n    }\n    factor *= 10\n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "234-palindrome-linked-list",
    "code": {
      "JS": "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {boolean}\n */\nconst isPalindrome = function(head) {\n  const arr = []  \n  while(head != null) {\n      arr.push(head.val)\n      head = head.next\n  }\n  let start = 0\n  let end = arr.length - 1\n  while(start < end) {\n      if(arr[start] !== arr[end]) {\n         return false\n      }\n    start++\n    end--\n  }\n  return true\n};\n"
    }
  },
  {
    "name": "235-lowest-common-ancestor-of-a-binary-search-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {TreeNode}\n */\nconst lowestCommonAncestor = function(root, p, q) {\n    while((root.val - p.val) * (root.val - q.val) > 0) {\n          root = root.val > p.val ? root.left : root.right\n    }\n    return root\n};\n"
    }
  },
  {
    "name": "236-lowest-common-ancestor-of-a-binary-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {TreeNode}\n */\nconst lowestCommonAncestor = function(root, p, q) {\n    const arr = []\n    traverse(root, [], arr)\n    let pii\n    let qii\n    // in same path\n    for(let i = 0; i < arr.length; i++) {\n      let pi = arr[i].indexOf(p.val)\n      let qi = arr[i].indexOf(q.val)\n      if(pi !== -1) pii = [i, pi]\n      if(qi !== -1) qii = [i, qi]\n      if(pi !== -1 && qi !== -1) {\n         return new TreeNode( pi <= qi ? p.val : q.val )\n      }\n    }\n\n    const len = Math.min(arr[pii[0]].length, arr[qii[0]].length)\n    const pp = arr[pii[0]]\n    const qp = arr[qii[0]]\n    for(let i = 0; i < len; i++) {\n      if(pp[i] !== qp[i]) return new TreeNode(pp[i - 1])\n    }\n};\n\nfunction traverse(node, path = [], arr) {\n  if(node == null) return\n  path.push(node.val)\n  if(node.left === null && node.right === null) {\n    arr.push(path.slice(0))\n    return\n  }\n  traverse(node.left, path.slice(0), arr)\n  traverse(node.right, path.slice(0), arr)\n}\n\n// another\n\nconst lowestCommonAncestor = function(root, p, q) {\n    if(root === null || root === p || root === q) return root;\n    const left = lowestCommonAncestor(root.left, p, q);\n    const right = lowestCommonAncestor(root.right, p, q);\n    if(left && right) return root;\n    return left ? left : right;\n};\n"
    }
  },
  {
    "name": "237-delete-node-in-a-linked-list",
    "code": {
      "JS": "/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} node\r\n * @return {void} Do not return anything, modify node in-place instead.\r\n */\r\nconst deleteNode = function(node) {\r\n  if (node.next !== null) {\r\n    node.val = node.next.val;\r\n    node.next = node.next.next;\r\n  }\r\n};\r\n"
    }
  },
  {
    "name": "238-product-of-array-except-self",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n * @return {number[]}\r\n */\r\nconst productExceptSelf = function(nums) {\r\n  const zeroIdx = new Set();\r\n  const p = nums.reduce((ac, el, idx) => {\r\n    if (el === 0) {\r\n      zeroIdx.add(idx);\r\n      return ac;\r\n    } else {\r\n      return ac * el;\r\n    }\r\n  }, 1);\r\n  const res = [];\r\n  for (let i = 0; i < nums.length; i++) {\r\n    if (zeroIdx.size > 1) {\r\n      res.push(0);\r\n    } else if (zeroIdx.size === 1) {\r\n      res.push(i === [...zeroIdx.values()][0] ? p : 0);\r\n    } else {\r\n      res.push(p / nums[i]);\r\n    }\r\n  }\r\n  return res;\r\n};\r\n\r\n"
    }
  },
  {
    "name": "239-sliding-window-maximum",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nconst maxSlidingWindow = function(nums, k) {\n  let n = nums.length\n  if (n === 0) {\n    return nums\n  }\n  let result = []\n\n  let dq = []\n  for (let i = 0; i < n; i++) {\n    if (dq.length && dq[0] < i - k + 1) {\n      dq.shift()\n    }\n    while (dq.length && nums[i] >= nums[dq[dq.length - 1]]) {\n      dq.pop()\n    }\n    dq.push(i)\n    if (i - k + 1 >= 0) {\n      result[i - k + 1] = nums[dq[0]]\n    }\n  }\n  return result\n}\n"
    }
  },
  {
    "name": "24-swap-nodes-in-pairs",
    "code": {
      "JS": "/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nconst swapPairs = function(node) {\r\n  const head = new ListNode(-1);\r\n  let cur = head;\r\n\r\n  while (node !== null) {\r\n    if (node.next !== null) {\r\n      let one = node;\r\n      let two = node.next;\r\n      let three = node.next.next;\r\n      cur.next = two;\r\n      two.next = one;\r\n      one.next = three;\r\n      cur = cur.next.next;\r\n      node = three;\r\n    } else {\r\n      cur.next = node;\r\n      break;\r\n    }\r\n  }\r\n\r\n  return head.next;\r\n};\r\n"
    }
  },
  {
    "name": "240-search-a-2d-matrix-ii",
    "code": {
      "JS": "/**\n * @param {number[][]} matrix\n * @param {number} target\n * @return {boolean}\n */\nconst searchMatrix = function(matrix, target) {\n  if (matrix == null || matrix.length == 0) {\n    return false;\n  }\n\n  const length = matrix.length;\n  for (let i = 0; i < length; i++) {\n    const row = matrix.shift();\n    let left = 0,\n      right = row.length - 1;\n\n    while (left <= right) {\n      const mid = left + parseInt((right - left) / 2);\n\n      if (row[mid] == target) {\n        return true;\n      } else if (row[mid] > target) {\n        right = mid - 1;\n      } else {\n        left = mid + 1;\n      }\n    }\n  }\n\n  return false;\n};\n"
    }
  },
  {
    "name": "241-different-ways-to-add-parentheses",
    "code": {
      "JS": "/**\r\n * @param {string} input\r\n * @return {number[]}\r\n */\r\nconst diffWaysToCompute = function(input) {\r\n  const res = [];\r\n  let left;\r\n  let right;\r\n  for (let i = 0; i < input.length; i++) {\r\n    if (input[i] < \"0\") {\r\n      left = diffWaysToCompute(input.slice(0, i));\r\n      right = diffWaysToCompute(input.slice(i + 1));\r\n      for (let rl of left) {\r\n        for (let rr of right) {\r\n          switch (input[i]) {\r\n            case \"+\":\r\n              res.push(rl + rr);\r\n              break;\r\n            case \"-\":\r\n              res.push(rl - rr);\r\n              break;\r\n            case \"*\":\r\n              res.push(rl * rr);\r\n              break;\r\n            default:\r\n              break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  if (res.length === 0) {\r\n    res.push(+input);\r\n  }\r\n  return res;\r\n};\r\n"
    }
  },
  {
    "name": "242-valid-anagram",
    "code": {
      "JS": "/**\r\n * @param {string} s\r\n * @param {string} t\r\n * @return {boolean}\r\n */\r\nconst isAnagram = function(s, t) {\r\n  if (s.length !== t.length) return false;\r\n  const sh = strHash(s);\r\n  const th = strHash(t);\r\n  for (let key in sh) {\r\n    if (sh.hasOwnProperty(key) && sh[key] !== th[key]) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n};\r\n\r\nfunction strHash(str) {\r\n  let res = {};\r\n  for (let i = 0; i < str.length; i++) {\r\n    if (res.hasOwnProperty(str[i])) {\r\n      res[str[i]] += 1;\r\n    } else {\r\n      res[str[i]] = 1;\r\n    }\r\n  }\r\n  return res;\r\n}\r\n"
    }
  },
  {
    "name": "243-shortest-word-distance",
    "code": {
      "JS": "/**\n\nGiven a list of words and two words word1 and word2,\nreturn the shortest distance between these two words in the list.\n\nExample:\nAssume that words = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"].\n\nInput: word1 = “coding”, word2 = “practice”\nOutput: 3\nInput: word1 = \"makes\", word2 = \"coding\"\nOutput: 1\n\nNote:\nYou may assume that word1 does not equal to word2, and word1 and word2 are both in the list.\n\n*/\n\n/**\n * @param {string[]} words\n * @param {string} word1\n * @param {string} word2\n * @return {number}\n */\nconst shortestDistance = function(words, word1, word2) {\n  let w1 = -1\n  let w2 = -1\n  let min = Number.MAX_VALUE\n  for (let i = 0; i < words.length; i++) {\n    if (words[i] === word1) {\n      w1 = i\n    } else if (words[i] === word2) {\n      w2 = i\n    }\n    if (w1 >= 0 && w2 >= 0) {\n      min = Math.min(min, Math.abs(w1 - w2))\n    }\n  }\n  return min\n}\n"
    }
  },
  {
    "name": "244-shortest-word-distance-ii",
    "code": {
      "JS": "/**\n * @param {string[]} words\n */\nconst WordDistance = function(words) {\n  this.wordMap = {}\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    if (!this.wordMap[word]) this.wordMap[word] = []\n    this.wordMap[word].push(i)\n  }\n}\n\n/**\n * @param {string} word1\n * @param {string} word2\n * @return {number}\n */\nWordDistance.prototype.shortest = function(word1, word2) {\n  let min = Infinity\n  const iList = this.wordMap[word1]\n  const jList = this.wordMap[word2]\n  for (let i = 0, j = 0; i < iList.length && j < jList.length; ) {\n    min = Math.min(min, Math.abs(iList[i] - jList[j]))\n    if (iList[i] < jList[j]) {\n      i++\n    } else {\n      j++\n    }\n  }\n  return min\n}\n\n/**\n * Your WordDistance object will be instantiated and called as such:\n * var obj = new WordDistance(words)\n * var param_1 = obj.shortest(word1,word2)\n */\n"
    }
  },
  {
    "name": "245-shortest-word-distance-iii",
    "code": {
      "JS": "/**\n * @param {string[]} words\n * @param {string} word1\n * @param {string} word2\n * @return {number}\n */\nconst shortestWordDistance = function(words, word1, word2) {\n  let l = Infinity\n  let r = Infinity\n  let res = Infinity\n  const same = word1 === word2\n  for (let i = 0; i < words.length; i++) {\n    if (same) r = l\n    if (words[i] === word1) {\n      l = i\n    } else if (words[i] === word2) {\n      r = i\n    } else {\n      continue\n    }\n    res = Math.min(res, Math.abs(l - r))\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "246-strobogrammatic-number",
    "code": {
      "JS": "/**\n * @param {string} num\n * @return {boolean}\n */\nconst isStrobogrammatic = function(num) {\n  const m = {\n    0: 0,\n    1: 1,\n    2: null,\n    3: null,\n    4: null,\n    5: null,\n    6: 9,\n    7: null,\n    8: 8,\n    9: 6\n  }\n  const arr = num.split('')\n  for(let i = 0, len = arr.length; i < len; i++) {\n    if(m[arr[i]] === null) return false\n    else arr[i] = m[arr[i]]\n  }\n  return num === arr.reverse().join('')\n};\n\n// another\n\nconst isStrobogrammatic = function(num) {\n  const map = { 0: '0', 1: '1', 8: '8', 6: '9', 9: '6' }\n  let left = 0\n  let right = num.length - 1\n\n  while (left < right) {\n    const leftNum = num[left]\n    const rightNum = num[right]\n    if (map[leftNum] != rightNum) return false\n    left++\n    right--\n  }\n  if (right == left) {\n    if (!map[num[right]] || num[right] == '9' || num[right] == '6') return false\n  }\n  return true\n}\n"
    }
  },
  {
    "name": "247-strobogrammatic-number-ii",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {string[]}\n */\nconst findStrobogrammatic = function(n) {\n  return recursionHelper(n, n)\n}\nconst recursionHelper = function(n, m) {\n  if (n === 0) return ['']\n  if (n === 1) return ['0', '1', '8']\n  let rtnArr = recursionHelper(n - 2, m)\n  let res = []\n  for (let i = 0; i < rtnArr.length; i++) {\n    if (n !== m) res.push('0' + rtnArr[i] + '0')\n    res.push('1' + rtnArr[i] + '1')\n    res.push('6' + rtnArr[i] + '9')\n    res.push('8' + rtnArr[i] + '8')\n    res.push('9' + rtnArr[i] + '6')\n  }\n  return res\n}\n\n// another\n\n/**\n * @param {number} n\n * @return {string[]}\n */\nconst findStrobogrammatic = function(n) {\n  let cur, ans\n  ans = (n & 1) == 0 ? [''] : ['0', '1', '8']\n  if (n < 2) return ans\n  for (; n > 1; n -= 2) {\n    cur = ans\n    ans = []\n    for (let i of cur) {\n      if (n > 3) ans.push('0' + i + '0')\n      ans.push('1' + i + '1')\n      ans.push('8' + i + '8')\n      ans.push('6' + i + '9')\n      ans.push('9' + i + '6')\n    }\n  }\n  return ans\n}\n"
    }
  },
  {
    "name": "248-strobogrammatic-number-iii",
    "code": {
      "JS": "/**\n * @param {string} low\n * @param {string} high\n * @return {number}\n */\nconst strobogrammaticInRange = function(low, high) {\n  const pairs = [\n    ['0', '0'],\n    ['1', '1'],\n    ['6', '9'],\n    ['8', '8'],\n    ['9', '6']\n  ]\n  let count = 0\n  function dfs(left, right, current) {\n    if (left > right) {\n      const s = current.join('')\n      if (\n        (s.length === low.length && s < low) ||\n        (s.length === high.length && s > high)\n      ) {\n        return\n      }\n      count++\n      return\n    }\n    for (const [p1, p2] of pairs) {\n      current[left] = p1\n      current[right] = p2\n      if (left === right && p1 !== p2) {\n        continue\n      }\n      if (current.length !== 1 && current[0] === '0') {\n        continue\n      }\n      dfs(left + 1, right - 1, current)\n    }\n  }\n  for (let i = low.length; i <= high.length; i++) {\n    dfs(0, i - 1, Array(i).fill(''))\n  }\n  return count\n}\n"
    }
  },
  {
    "name": "249-group-shifted-strings",
    "code": {
      "JS": "/**\n * @param {string[]} strings\n * @return {string[][]}\n */\nconst groupStrings = function(strings) {\n  const m = {}\n  for(let e of strings) {\n    const key = gkey(e)\n    let list\n    if(m.hasOwnProperty(key)) {\n      list = m[key]\n    } else {\n      list = []\n    }\n    list.push(e)\n    m[key] = list\n  }\n  return Object.values(m)\n};\n\nfunction gkey(str) {\n  let res = ''\n  for(let i = 1, len = str.length; i < len; i++) {\n    const diff = str.charCodeAt(i) - str.charCodeAt(i - 1)\n    res += `${diff < 0 ? diff + 26 : diff},`\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "25-reverse-nodes-in-k-group",
    "code": {
      "JS": "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nconst reverseKGroup = function(head, k) {\n  let n = 0\n  for (let i = head; i != null; n++, i = i.next);\n  let dmy = new ListNode(0)\n  dmy.next = head\n  for (let prev = dmy, tail = head; n >= k; n -= k) {\n    for (let i = 1; i < k; i++) {\n      let next = tail.next.next\n      tail.next.next = prev.next\n      prev.next = tail.next\n      tail.next = next\n    }\n\n    prev = tail\n    tail = tail.next\n  }\n  return dmy.next\n}\n\n// another\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nconst reverseKGroup = function (head, k) {\n  if(head == null) return head\n  const dummy = new ListNode()\n  dummy.next = head\n  let n = 0, cur = head\n  while(cur) {\n    n++\n    cur = cur.next\n  }\n  if(n < k) return head\n  let pre = dummy, tail = head\n\n  for(let i = 0; i + k <= n; i += k) {\n    for(let j = 1; j < k; j++) {\n      const tmp = pre.next\n      pre.next = tail.next\n      tail.next = tail.next.next\n      pre.next.next = tmp\n    }\n    pre = tail\n    tail = tail.next\n  } \n  \n  return dummy.next\n}\n\n\n\n// another\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nconst reverseKGroup = function (head, k) {\n  let ptr = head\n  let ktail = null\n\n  // Head of the final, moified linked list\n  let new_head = null\n\n  // Keep going until there are nodes in the list\n  while (ptr != null) {\n    let count = 0\n\n    // Start counting nodes from the head\n    ptr = head\n\n    // Find the head of the next k nodes\n    while (count < k && ptr != null) {\n      ptr = ptr.next\n      count += 1\n    }\n\n    // If we counted k nodes, reverse them\n    if (count == k) {\n      // Reverse k nodes and get the new head\n      let revHead = reverseLinkedList(head, k)\n\n      // new_head is the head of the final linked list\n      if (new_head == null) new_head = revHead\n\n      // ktail is the tail of the previous block of\n      // reversed k nodes\n      if (ktail != null) ktail.next = revHead\n\n      ktail = head\n      head = ptr\n    }\n  }\n\n  // attach the final, possibly un-reversed portion\n  if (ktail != null) ktail.next = head\n\n  return new_head == null ? head : new_head\n}\n\nfunction reverseLinkedList(head, k) {\n  // Reverse k nodes of the given linked list.\n  // This function assumes that the list contains\n  // atleast k nodes.\n  let new_head = null\n  let ptr = head\n\n  while (k > 0) {\n    // Keep track of the next node to process in the\n    // original list\n    let next_node = ptr.next\n\n    // Insert the node pointed to by \"ptr\"\n    // at the beginning of the reversed list\n    ptr.next = new_head\n    new_head = ptr\n\n    // Move on to the next node\n    ptr = next_node\n\n    // Decrement the count of nodes to be reversed by 1\n    k--\n  }\n\n  // Return the head of the reversed list\n  return new_head\n}\n"
    }
  },
  {
    "name": "250-count-univalue-subtrees",
    "code": {
      "JS": "/**\n\nGiven a binary tree, count the number of uni-value subtrees.\n\nA Uni-value subtree means all nodes of the subtree have the same value.\n\nExample :\n\nInput:  root = [5,1,5,5,5,null,5]\n\n              5\n             / \\\n            1   5\n           / \\   \\\n          5   5   5\n\nOutput: 4\n\n*/\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nconst countUnivalSubtrees = function(root) {\n  let res = { num: 0 }\n  chk(root, null, res)\n  return res.num\n}\n\nfunction chk(node, pVal, obj) {\n  if (node == null) return true\n  const left = chk(node.left, node.val, obj)\n  const right = chk(node.right, node.val, obj)\n  if (left && right) {\n    if (node.left !== null && node.val !== node.left.val) {\n      return false;\n    }\n    if (node.right !== null && node.val !== node.right.val) {\n      return false;\n    }\n    obj.num++\n    return true\n  }\n  return false\n}\n\n"
    }
  },
  {
    "name": "251-flatten-2d-vector",
    "code": {
      "JS": "/**\n * @param {number[][]} v\n */\nconst Vector2D = function(v) {\n  this.a = []\n  this.idx = 0\n  v.forEach(el => this.a.push(...el))\n};\n\n/**\n * @return {number}\n */\nVector2D.prototype.next = function() {\n  return this.a[this.idx++]\n};\n\n/**\n * @return {boolean}\n */\nVector2D.prototype.hasNext = function() {\n  return this.idx <= this.a.length - 1\n};\n\n/** \n * Your Vector2D object will be instantiated and called as such:\n * var obj = new Vector2D(v)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */\n\n// another\n\n/**\n * @param {number[][]} v\n */\nconst Vector2D = function(v) {\n  this.iterator = v[Symbol.iterator]()\n  this.row = this.iterator.next()\n  this.idx = 0\n}\n/**\n * @return {number}\n */\nVector2D.prototype.next = function() {\n  if (this.hasNext()) {\n    return this.row.value[this.idx++]\n  }\n}\n/**\n * @return {boolean}\n */\nVector2D.prototype.hasNext = function() {\n  while (this.row.done == false && this.idx == this.row.value.length) {\n    this.row = this.iterator.next()\n    this.idx = 0\n  }\n  return this.row.done == false\n}\n/**\n * Your Vector2D object will be instantiated and called as such:\n * var obj = new Vector2D(v)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */\n"
    }
  },
  {
    "name": "252-meeting-rooms",
    "code": {
      "JS": "/**\n\nGiven an array of meeting time intervals consisting of\nstart and end times [[s1,e1],[s2,e2],...] (si < ei),\ndetermine if a person could attend all meetings.\n\nExample 1:\n\nInput: [[0,30],[5,10],[15,20]]\nOutput: false\nExample 2:\n\nInput: [[7,10],[2,4]]\nOutput: true\n\n*/\n\n/**\n * @param {number[][]} intervals\n * @return {boolean}\n */\nconst canAttendMeetings = function(intervals) {\n  if(intervals == null || intervals.length === 0) return true\n  intervals.sort((a,b) => a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]);\n  for (let i = 0; i < intervals.length - 1; i++) {\n    if (intervals[i][1] > intervals[i+1][0]) return false;\n  }\n  return true;\n};\n"
    }
  },
  {
    "name": "253-meeting-rooms-ii",
    "code": {
      "JS": "/**\n\nGiven an array of meeting time intervals consisting of\nstart and end times [[s1,e1],[s2,e2],...] (si < ei),\nfind the minimum number of conference rooms required.\n\nExample 1:\n\nInput: [[0, 30],[5, 10],[15, 20]]\nOutput: 2\nExample 2:\n\nInput: [[7,10],[2,4]]\nOutput: 1\n \n */\n\n/**\n * @param {number[][]} intervals\n * @return {number}\n */\nconst minMeetingRooms = function(intervals) {\n  const n = intervals.length\n  const start = Array(n), end = Array(n)\n  for(let i = 0; i < n; i++) {\n    start[i] = intervals[i][0]\n    end[i] = intervals[i][1]\n  }\n  start.sort((a, b) => a - b)\n  end.sort((a, b) => a - b)\n\n  let res = 0, endIdx = 0\n  for(let i = 0; i < n; i++) {\n    if(start[i] < end[endIdx]) res++\n    else endIdx++\n  }\n\n  return res\n}\n"
    }
  },
  {
    "name": "254-factor-combinations",
    "code": {
      "JS": "/**\n\nNumbers can be regarded as product of its factors. For example,\n\n8 = 2 x 2 x 2;\n  = 2 x 4.\nWrite a function that takes an integer n and return all possible combinations of its factors.\n\nNote:\n\nYou may assume that n is always positive.\nFactors should be greater than 1 and less than n.\nExample 1:\n\nInput: 1\nOutput: []\nExample 2:\n\nInput: 37\nOutput:[]\nExample 3:\n\nInput: 12\nOutput:\n[\n  [2, 6],\n  [2, 2, 3],\n  [3, 4]\n]\nExample 4:\n\nInput: 32\nOutput:\n[\n  [2, 16],\n  [2, 2, 8],\n  [2, 2, 2, 4],\n  [2, 2, 2, 2, 2],\n  [2, 4, 4],\n  [4, 8]\n]\n\n*/\n\n/**\n * @param {number} n\n * @return {number[][]}\n */\nconst getFactors = function(n) {\n  if (n <= 0) {\n    return []\n  }\n  const result = []\n  helper(n, result, [], 2)\n  return result\n}\nconst helper = (n, result, list, start) => {\n  for (let i = start; i * i <= n; i++) {\n    if (n % i === 0) {\n      list.push(i)\n      list.push(n / i)\n      result.push(list.slice())\n      list.pop()\n      helper(n / i, result, list, i)\n      list.pop()\n    }\n  }\n}\n\n"
    }
  },
  {
    "name": "255-verify-preorder-sequence-in-binary-search-tree",
    "code": {
      "JS": "/**\n * @param {number[]} preorder\n * @return {boolean}\n */\nconst verifyPreorder = function(preorder) {\n  let low = Number.MIN_VALUE,\n    i = -1\n  for (let p of preorder) {\n    if (p < low) return false\n    while (i >= 0 && p > preorder[i]) low = preorder[i--]\n    preorder[++i] = p\n  }\n  return true\n}\n"
    }
  },
  {
    "name": "256-paint-house",
    "code": {
      "JS": "/**\n * @param {number[][]} costs\n * @return {number}\n */\nconst minCost = function(costs) {\n  if (!costs || costs.length < 1) return 0\n  const n = costs.length\n  for (let i = 1; i < n; i++) {\n    const c = costs[i],\n      cPrev = costs[i - 1]\n    c[0] += Math.min(cPrev[1], cPrev[2])\n    c[1] += Math.min(cPrev[0], cPrev[2])\n    c[2] += Math.min(cPrev[0], cPrev[1])\n  }\n  const cLast = costs[n - 1]\n  return Math.min(cLast[0], cLast[1], cLast[2])\n}\n"
    }
  },
  {
    "name": "257-binary-tree-paths",
    "code": {
      "JS": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {string[]}\r\n */\r\nconst binaryTreePaths = function(root) {\r\n  const res = [];\r\n  traverse(root, res, []);\r\n  return res;\r\n};\r\n\r\nfunction traverse(node, res, p) {\r\n  if (node === null) return;\r\n  p.push(node.val);\r\n  if (node.left === null && node.right === null) {\r\n    res.push(p.join(\"->\"));\r\n  }\r\n  if (node.left) {\r\n    traverse(node.left, res, p.slice(0));\r\n  }\r\n  if (node.right) {\r\n    traverse(node.right, res, p.slice(0));\r\n  }\r\n}\r\n"
    }
  },
  {
    "name": "258-add-digits",
    "code": {
      "JS": "/**\r\n * @param {number} num\r\n * @return {number}\r\n */\r\nconst addDigits = function(num) {\r\n  let arr = (\"\" + num).split(\"\");\r\n  let res = num;\r\n\r\n  while (arr.length > 1) {\r\n    res = arr.reduce((ac, el) => +ac + +el, 0);\r\n    arr = (\"\" + res).split(\"\");\r\n  }\r\n  return +res;\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * @param {number} num\r\n * @return {number}\r\n */\r\nconst addDigits = function(num) {\r\n  return 1 + (num - 1) % 9;\r\n};\r\n\r\nconsole.log(addDigits(0));\r\nconsole.log(addDigits(38));\r\n"
    }
  },
  {
    "name": "259-3sum-smaller",
    "code": {
      "JS": "/**\n\nGiven an array of n integers nums and a target,\nfind the number of index triplets i, j, k with 0 <= i < j < k < n\nthat satisfy the condition nums[i] + nums[j] + nums[k] < target.\n\nExample:\n\nInput: nums = [-2,0,1,3], and target = 2\nOutput: 2 \nExplanation: Because there are two triplets which sums are less than 2:\n             [-2,0,1]\n             [-2,0,3]\n\nFollow up: Could you solve it in O(n2) runtime?\n\n*/\n\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nconst threeSumSmaller = function(nums, target) {\n  nums.sort((a, b) => a - b)\n  let res = 0\n  for(let i = 0, len = nums.length; i < len - 2; i++) {\n    let lo = i + 1\n    let hi = len - 1\n    while(lo < hi) {\n      if(nums[i] + nums[lo] + nums[hi] < target) {\n        res += hi - lo\n        lo++\n      } else hi--\n    }\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "26-remove-duplicates-from-sorted-array",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nconst removeDuplicates = function(nums) {\r\n  if (nums.length === 0) return 0;\r\n  if (nums.length === 1) return 1;\r\n  let pre = nums[0];\r\n  for (let i = 1; i < nums.length; ) {\r\n    if (nums[i] !== pre) {\r\n      pre = nums[i];\r\n      i += 1;\r\n    } else {\r\n      nums.splice(i, 1);\r\n    }\r\n  }\r\n  return nums.length;\r\n};\r\n"
    }
  },
  {
    "name": "260-single-number-III",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nconst singleNumber = function(nums) {\n  const hash = {};\n  nums.forEach((el, idx) => {\n    if (hash.hasOwnProperty(el)) {\n      hash[el] += 1;\n      delete hash[el];\n    } else {\n      hash[el] = 1;\n    }\n  });\n  return Object.keys(hash).map(el => +el);\n};\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\nconst singleNumber = function(nums) {\n  const s = new Set()\n  for(let el of nums) {\n    if(s.has(el)) s.delete(el)\n    else s.add(el)\n  }\n  return Array.from(s)\n};\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\nconst singleNumber = function (nums) {\n  const res = Array(2).fill(0)\n  const x = nums.reduce((acc, v) => acc ^ v, 0)\n  const partition = x & ~(x - 1)\n  for (let i = 0; i < nums.length; i++) {\n    if (partition & nums[i]) {\n      res[1] ^= nums[i]\n    } else {\n      res[0] ^= nums[i]\n    }\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "261-graph-valid-tree",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {boolean}\n */\nconst validTree = function(n, edges) {\n  const nums = Array(n).fill(-1)\n  for(let i = 0; i < edges.length; i++) {\n    const x = find(nums, edges[i][0])\n    const y = find(nums, edges[i][1])\n    if(x === y) return false\n    nums[x] = y\n  }\n  return edges.length === n - 1\n  function find(arr, i) {\n    if(arr[i] === -1) return i\n    return find(arr, arr[i])\n  }\n};\n\n// another\n\n/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {boolean}\n */\nconst validTree = function(n, edges) {\n  if (edges.length !== n - 1) {\n    return false\n  }\n  const graph = {}\n  edges.forEach(edge => {\n    if (!graph[edge[0]]) {\n      graph[edge[0]] = []\n    }\n    if (!graph[edge[1]]) {\n      graph[edge[1]] = []\n    }\n    graph[edge[0]].push(edge[1])\n    graph[edge[1]].push(edge[0])\n  })\n  const queue = [0],\n    visited = new Set()\n  while (queue.length) {\n    const currentNode = queue.shift()\n    visited.add(currentNode)\n    if (graph[currentNode]) {\n      graph[currentNode].forEach(node => {\n        if (!visited.has(node)) {\n          queue.push(node)\n        }\n      })\n    }\n  }\n  return visited.size === n\n}\n"
    }
  },
  {
    "name": "263-ugly-number",
    "code": {
      "JS": "/**\n * @param {number} num\n * @return {boolean}\n */\nconst isUgly = function(num) {\n  if (num < 1) return false\n  while (num >= 2) {\n    if (num % 2 === 0) num = num / 2\n    else if (num % 3 === 0) num = num / 3\n    else if (num % 5 === 0) num = num / 5\n    else return false\n  }\n  return true\n}\n"
    }
  },
  {
    "name": "264-ugly-number-ii",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst nthUglyNumber = function (n) {\n  if (n <= 0) return false\n  if (n === 1) return true\n  let t2 = 0,\n    t3 = 0,\n    t5 = 0\n  const k = Array(n).fill(1)\n  k[0] = 1\n  for (let i = 1; i < n; i++) {\n    k[i] = Math.min(k[t2] * 2, k[t3] * 3, k[t5] * 5)\n    if (k[i] == k[t2] * 2) t2++\n    if (k[i] == k[t3] * 3) t3++\n    if (k[i] == k[t5] * 5) t5++\n  }\n  return k[n - 1]\n}\n"
    }
  },
  {
    "name": "265-paint-house-ii",
    "code": {
      "JS": "/**\n * @param {number[][]} costs\n * @return {number}\n */\nconst minCostII = function(costs) {\n  if (costs == null || costs.length === 0 || costs[0].length === 0) return 0\n  let n = costs.length,\n    k = costs[0].length\n  if (k === 1) return n === 1 ? costs[0][0] : -1\n\n  let prevMin = 0,\n    prevMinInd = -1,\n    prevSecMin = 0\n  for (let i = 0; i < n; i++) {\n    let min = Number.MAX_VALUE,\n      minInd = -1,\n      secMin = Number.MAX_VALUE\n    for (let j = 0; j < k; j++) {\n      const val = costs[i][j] + (j == prevMinInd ? prevSecMin : prevMin)\n      if (val < min) {\n        secMin = min\n        min = val\n        minInd = j\n      } else if (val < secMin) {\n        secMin = val\n      }\n    }\n    prevMin = min\n    prevMinInd = minInd\n    prevSecMin = secMin\n  }\n  return prevMin\n}\n"
    }
  },
  {
    "name": "266-palindrome-permutation",
    "code": {
      "JS": "/**\n\nGiven a string, determine if a permutation of the string could form a palindrome.\n\nExample 1:\n\nInput: \"code\"\nOutput: false\nExample 2:\n\nInput: \"aab\"\nOutput: true\nExample 3:\n\nInput: \"carerac\"\nOutput: true\n\n*/\n\n/**\n * @param {string} s\n * @return {boolean}\n */\nconst canPermutePalindrome = function(s) {\n  const m = {}\n  for(let i = 0, len = s.length; i < len; i++) {\n    if(m[s[i]] == null || m[s[i]] === 0) m[s[i]] = 1\n    else m[s[i]] -= 1\n  }\n  let num = 0\n  for(let el in m) {\n    if(m.hasOwnProperty(el)) {\n      if(m[el] > 0) num++\n    }\n  }\n  return num === 0 || num === 1\n};\n"
    }
  },
  {
    "name": "267-palindrome-permutation-ii",
    "code": {
      "JS": "/**\n\nGiven a string s, return all the palindromic permutations (without duplicates) of it.\nReturn an empty list if no palindromic permutation could be form.\n\nExample 1:\n\nInput: \"aabb\"\nOutput: [\"abba\", \"baab\"]\nExample 2:\n\nInput: \"abc\"\nOutput: []\n\n*/\n\n/**\n * @param {string} s\n * @return {string[]}\n */\nconst generatePalindromes = function(s) {\n  const ans = []\n  const count = Array(256).fill(0)\n  let odds = 0\n  for (let c of s) count[c.charCodeAt(0)]++\n  for (let c of count) if (c % 2 !== 0) odds++\n  if (odds <= 1) {\n    let center = null\n    for (let idx = 0; idx < count.length; idx++) {\n      if (count[idx] % 2 === 1) {\n        center = String.fromCharCode(idx)\n        count[idx]--\n        break\n      }\n    }\n    generate(ans, count, center != null ? center : '', s.length)\n  }\n  return ans\n}\n\nfunction generate(ans, count, build, len) {\n  if (build.length === len) {\n    ans.push(build)\n    return\n  }\n  for (let idx = 0; idx < count.length; idx++) {\n    if (count[idx] > 0) {\n      count[idx] -= 2\n      generate(\n        ans,\n        count,\n        String.fromCharCode(idx) + build + String.fromCharCode(idx),\n        len\n      )\n      count[idx] += 2\n    }\n  }\n}\n"
    }
  },
  {
    "name": "268-missing-number",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nconst missingNumber = function(nums) {\r\n  const n = nums.length\r\n  let xor =  0 ^ nums[0]\r\n  for(let i = 1; i < n; i++) xor = xor ^ i ^ nums[i]\r\n  return xor ^ n\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nconst missingNumber = function(nums) {\r\n  const len = nums.length;\r\n  return (len * (len + 1)) / 2 - sum(nums);\r\n};\r\n\r\nfunction sum(arr) {\r\n  return arr.reduce((ac, el) => ac + el, 0);\r\n}\r\n"
    }
  },
  {
    "name": "269-alien-dictionary",
    "code": {
      "JS": "/**\n\nThere is a new alien language which uses the latin alphabet. \nHowever, the order among letters are unknown to you. \nYou receive a list of non-empty words from the dictionary, \nwhere words are sorted lexicographically by the rules of\nthis new language. Derive the order of letters in this language.\n\nExample 1:\n\nInput:\n[\n  \"wrt\",\n  \"wrf\",\n  \"er\",\n  \"ett\",\n  \"rftt\"\n]\n\nOutput: \"wertf\"\nExample 2:\n\nInput:\n[\n  \"z\",\n  \"x\"\n]\n\nOutput: \"zx\"\nExample 3:\n\nInput:\n[\n  \"z\",\n  \"x\",\n  \"z\"\n] \n\nOutput: \"\" \n\nExplanation: The order is invalid, so return \"\".\nNote:\n\nYou may assume all letters are in lowercase.\nYou may assume that if a is a prefix of b, then a must appear before b in the given dictionary.\nIf the order is invalid, return an empty string.\nThere may be multiple valid order of letters, return any one of them is fine.\n\n*/\n\n/**\n * @param {string[]} words\n * @return {string}\n */\nconst alienOrder = function(words) {\n  const graph = {}\n  words.forEach(w => w.split('').forEach(ch => (graph[ch] = new Set())))\n  words.reduce((prev, curr) => {\n    for (let i = 0; i < Math.min(prev.length, curr.length); i++) {\n      if (prev[i] !== curr[i]) {\n        graph[prev[i]].add(curr[i])\n        break\n      }\n    }\n    return curr\n  })\n  const marked = {},\n    visited = {}\n  let str = ''\n  let hasCycle = false\n  Object.keys(graph).map(visit)\n  return hasCycle ? '' : str\n  function visit(n) {\n    if (marked[n]) return\n    if (visited[n]) {\n      hasCycle = true\n      return\n    }\n    visited[n] = true\n    graph[n].forEach(visit)\n    marked[n] = true\n    str = n + str\n  }\n}\n"
    }
  },
  {
    "name": "27-remove-element",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n * @param {number} val\r\n * @return {number}\r\n */\r\nconst removeElement = function(nums, val) {\r\n  let j = 0;\r\n  for (let i = 0; i < nums.length; i++) {\r\n    if (nums[i] !== val) {\r\n      nums[j] = nums[i];\r\n      j++;\r\n    }\r\n  }\r\n  return j;\r\n};\r\n"
    }
  },
  {
    "name": "270-closest-binary-search-tree-value",
    "code": {
      "JS": "/**\n\nGiven a non-empty binary search tree and a target value,\nfind the value in the BST that is closest to the target.\n\nNote:\n\nGiven target value is a floating point.\nYou are guaranteed to have only one unique value\nin the BST that is closest to the target.\n\nExample:\n\nInput: root = [4,2,5,1,3], target = 3.714286\n\n    4\n   / \\\n  2   5\n / \\\n1   3\n\nOutput: 4\n\n*/\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} target\n * @return {number}\n */\nconst closestValue = function(root, target) {\n  let res = root.val\n  while(root) {\n    if(Math.abs(root.val - target) < Math.abs(res - target)) {\n      res = root.val\n    }\n    root = root.val > target ? root.left : root.right\n  }\n  return res\n};\n\n// another\n\nconst closestValue = function(root, target) {\n  const child = target < root.val ? root.left : root.right;\n  if (!child) return root.val;\n  const closest = closestValue(child, target);\n  return Math.abs(closest - target) < Math.abs(root.val - target)\n    ? closest\n    : root.val;\n};\n\n// another\n\nconst closestValue = function(root, target) {\n  if(root == null) return -1\n  let node = root\n  const stack = []\n  const res = []\n  const K = 1\n  while(node || stack.length) {\n    if(node) {\n      stack.push(node)\n      node = node.left\n    } else {\n      node = stack.pop()\n      if(res.length === K) {\n        if(Math.abs(res[0] - target) < Math.abs(node.val - target)) {\n          return res[0]   \n        }\n        res.shift()\n      }\n      res.push(node.val)\n      node = node.right\n    }\n  }\n  return res[0]\n};\n"
    }
  },
  {
    "name": "271-encode-and-decode-strings",
    "code": {
      "JS": "/**\n * Encodes a list of strings to a single string.\n *\n * @param {string[]} strs\n * @return {string}\n */\nconst encode = function(strs) {\n  let s = ''\n  for(let e of strs) {\n    s += e.length + '/' + e\n  }\n  return s\n};\n\n/**\n * Decodes a single string to a list of strings.\n *\n * @param {string} s\n * @return {string[]}\n */\nconst decode = function(s) {\n  const res = []\n  let i = 0\n  while(i < s.length) {\n    const idx = s.indexOf('/', i)\n    const size = s.slice(i, idx)\n    i = idx + (+size) + 1\n    res.push(s.slice(idx + 1, i))\n  }\n  return res\n};\n\n/**\n * Your functions will be called as such:\n * decode(encode(strs));\n */\n"
    }
  },
  {
    "name": "272-closest-binary-search-tree-value-ii",
    "code": {
      "JS": "/**\n\nGiven a non-empty binary search tree and a target value,\nfind k values in the BST that are closest to the target.\n\nNote:\n\nGiven target value is a floating point.\nYou may assume k is always valid, that is: k ≤ total nodes.\nYou are guaranteed to have only one unique set of k values\nin the BST that are closest to the target.\nExample:\n\nInput: root = [4,2,5,1,3], target = 3.714286, and k = 2\n\n    4\n   / \\\n  2   5\n / \\\n1   3\n\nOutput: [4,3]\nFollow up:\nAssume that the BST is balanced, could you solve it in\nless than O(n) runtime (where n = total nodes)?\n\n*/\n\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} target\n * @param {number} k\n * @return {number[]}\n */\nconst closestKValues = function(root, target, k) {\n  const res = []\n  let node = root\n  const stack = []\n  while (node || stack.length) {\n    if (node) {\n      stack.push(node)\n      node = node.left\n    } else {\n      node = stack.pop()\n      if (res.length === k) {\n        if (Math.abs(res[0] - target) <= Math.abs(node.val - target)) {\n          return res\n        }\n        res.shift()\n      }\n      res.push(node.val)\n      node = node.right\n    }\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "273-integer-to-english-words",
    "code": {
      "JS": "/**\n * @param {number} num\n * @return {string}\n */\nconst numberToWords = function(num) {\n  if (num === 0) return \"Zero\";\n  if (num <= 20) return translations.get(num);\n  const result = [];\n\n  for (let [value, translation] of translations) {\n    const times = Math.floor(num / value);\n    if (times === 0) continue;\n    num -= times * value;\n    if (times === 1 && value >= 100) {\n      result.push(\"One\", translation);\n      continue;\n    }\n    if (times === 1) {\n      result.push(translation);\n      continue;\n    }\n    result.push(numberToWords(times), translation);\n  }\n  return result.join(\" \");\n};\n\nconst translations = new Map([\n  [1000000000, \"Billion\"],\n  [1000000, \"Million\"],\n  [1000, \"Thousand\"],\n  [100, \"Hundred\"],\n  [90, \"Ninety\"],\n  [80, \"Eighty\"],\n  [70, \"Seventy\"],\n  [60, \"Sixty\"],\n  [50, \"Fifty\"],\n  [40, \"Forty\"],\n  [30, \"Thirty\"],\n  [20, \"Twenty\"],\n  [19, \"Nineteen\"],\n  [18, \"Eighteen\"],\n  [17, \"Seventeen\"],\n  [16, \"Sixteen\"],\n  [15, \"Fifteen\"],\n  [14, \"Fourteen\"],\n  [13, \"Thirteen\"],\n  [12, \"Twelve\"],\n  [11, \"Eleven\"],\n  [10, \"Ten\"],\n  [9, \"Nine\"],\n  [8, \"Eight\"],\n  [7, \"Seven\"],\n  [6, \"Six\"],\n  [5, \"Five\"],\n  [4, \"Four\"],\n  [3, \"Three\"],\n  [2, \"Two\"],\n  [1, \"One\"]\n]);\n"
    }
  },
  {
    "name": "274-h-index",
    "code": {
      "JS": "/**\n * @param {number[]} citations\n * @return {number}\n */\nconst hIndex = function(citations) {\n  const n = citations.length\n  const arr = Array(n + 1).fill(0)\n  for(let e of citations) {\n    if(e >= n) arr[n]++\n    else arr[e]++\n  }\n  for(let i = n, sum = 0; i >= 0; i--) {\n    sum += arr[i]\n    if(sum >= i) return i\n  }\n  return 0\n};\n\n// another\n\n/**\n * @param {number[]} citations\n * @return {number}\n */\nconst hIndex = function(citations) {\n  citations = citations.sort((a, b) => b - a)\n\n  for (let i = 0, len = citations.length; i < len; i++) {\n    if (i >= citations[i]) return i\n  }\n\n  return citations.length\n}\n\n// another\n\n\nconst hIndex = function(citations) {\n  const buckets = Array(citations.length + 1).fill(0)\n  citations.forEach(citation => {\n    buckets[citation >= citations.length ? citations.length : citation]++\n  })\n  for (let i = citations.length, count = 0; i >= 0; i--) {\n    count += buckets[i]\n    if (count >= i) return i\n  }\n  return 0\n}\n"
    }
  },
  {
    "name": "275-h-index-ii",
    "code": {
      "JS": "/**\n * @param {number[]} citations\n * @return {number}\n */\nconst hIndex = function(citations) {\n  let left = 0,\n    len = citations.length,\n    right = len - 1,\n    mid\n  while (left <= right) {\n    mid = left + ((right - left) >> 1)\n    if (citations[mid] >= len - mid) right = mid - 1\n    else left = mid + 1\n  }\n  return len - left\n}\n\n// another\n\n/**\n * @param {number[]} citations\n * @return {number}\n */\nconst hIndex = function(citations) {\n  const len = citations.length\n  let lo = 0,\n    hi = len - 1\n  while (lo <= hi) {\n    let med = lo + ((hi - lo) >> 1)\n    if (citations[med] === len - med) {\n      return len - med\n    } else if (citations[med] < len - med) {\n      lo = med + 1\n    } else {\n      hi = med - 1\n    }\n  }\n  return len - lo\n}\n"
    }
  },
  {
    "name": "276-paint-fence",
    "code": {
      "JS": "/**\n\nThere is a fence with n posts, each post can be painted with one of the k colors.\n\nYou have to paint all the posts such that no more than two adjacent fence posts have the same color.\n\nReturn the total number of ways you can paint the fence.\n\nNote:\nn and k are non-negative integers.\n\nExample:\n\nInput: n = 3, k = 2\nOutput: 6\nExplanation: Take c1 as color 1, c2 as color 2. All possible ways are:\n\n            post1  post2  post3      \n -----      -----  -----  -----       \n   1         c1     c1     c2 \n   2         c1     c2     c1 \n   3         c1     c2     c2 \n   4         c2     c1     c1  \n   5         c2     c1     c2\n   6         c2     c2     c1\n\n*/\n\n/**\n * @param {number} n\n * @param {number} k\n * @return {number}\n */\nconst numWays = function(n, k) {\n  if (n === 0) return 0;\n  if (n === 1) return k;\n  let diff = k * (k - 1);\n  let same = k;\n  for (let i = 2; i < n; i ++) {\n    const temp = diff;\n    diff = (diff + same) * (k - 1);\n    same = temp;\n  }\n  return diff + same;\n}\n"
    }
  },
  {
    "name": "277-find-the-celebrity",
    "code": {
      "JS": "/**\n * Definition for knows()\n *\n * @param {integer} person a\n * @param {integer} person b\n * @return {boolean} whether a knows b\n * knows = function(a, b) {\n *     ...\n * };\n */\n\n/**\n * @param {function} knows()\n * @return {function}\n */\nconst solution = function(knows) {\n  /**\n   * @param {integer} n Total people\n   * @return {integer} The celebrity\n   */\n  return function(n) {\n    if (n < 1) return -1\n    let celebrity = 0\n    for (let i = 1; i < n; i++) {\n      if (knows(celebrity, i)) {\n        celebrity = i\n      }\n    }\n    for (let i = 0; i < celebrity; i++) {\n      if (knows(celebrity, i)) {\n        return -1\n      }\n    }\n    for (let i = 0; i < n; i++) {\n      if (i != celebrity && !knows(i, celebrity)) {\n        return -1\n      }\n    }\n    return celebrity\n  }\n}\n\n// another\n\n/**\n * Definition for knows()\n *\n * @param {integer} person a\n * @param {integer} person b\n * @return {boolean} whether a knows b\n * knows = function(a, b) {\n *     ...\n * };\n */\n\n/**\n * @param {function} knows()\n * @return {function}\n */\nconst solution = function(knows) {\n  /**\n   * @param {integer} n Total people\n   * @return {integer} The celebrity\n   */\n  return function(n) {\n    if (n < 1) return -1\n    let candidate = 0\n    for (let i = 1; i < n; i++) {\n      if (knows(candidate, i)) candidate = i\n    }\n    for (let i = 0; i < n; i++) {\n      if (i < candidate && (knows(candidate, i) || !knows(i, candidate)))\n        return -1\n      if (i > candidate && !knows(i, candidate)) return -1\n    }\n    return candidate\n  }\n}\n\n"
    }
  },
  {
    "name": "278-first-bad-version",
    "code": {
      "JS": "/**\n * Definition for isBadVersion()\n * \n * @param {integer} version number\n * @return {boolean} whether the version is bad\n * isBadVersion = function(version) {\n *     ...\n * };\n */\n\n/**\n * @param {function} isBadVersion()\n * @return {function}\n */\nconst solution = function(isBadVersion) {\n    /**\n     * @param {integer} n Total versions\n     * @return {integer} The first bad version\n     */\n    return function(n) {\n      let left = 1;\n      let right = n;\n      while (left < right) {\n        let mid = left + Math.floor( (right - left) / 2 );\n        if (isBadVersion(mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n      }\n      return left;\n    };\n};\n"
    }
  },
  {
    "name": "279-perfect-squares",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst numSquares = function(n) {\n    const dp = new Array(n+1).fill(Number.MAX_VALUE)\n    dp[0] = 0\n    for(let i = 1; i <= n; i++) {\n        let min = Number.MAX_VALUE\n        let j = 1\n        while(i - j*j >= 0) {\n            min = Math.min(min, dp[i-j*j] + 1)\n            ++j\n        }\n        dp[i] = min\n    }\n    return dp[n]\n};\n\n// another\n\n/**\n * @param {number} n\n * @return {number}\n */\nconst numSquares = function (n) {\n  if (n <= 0) return 0\n  // cntPerfectSquares[i] = the least number of perfect square numbers\n  const cntPerfectSquares = [0]\n  // While cntPerfectSquares.length <= n, we need to incrementally\n  // calculate the next result until we get the result for n.\n  while (cntPerfectSquares.length <= n) {\n    const m = cntPerfectSquares.length\n    let cntSquares = Number.MAX_VALUE\n    for (let i = 1; i * i <= m; i++) {\n      cntSquares = Math.min(cntSquares, cntPerfectSquares[m - i * i] + 1)\n    }\n    cntPerfectSquares.push(cntSquares)\n  }\n  return cntPerfectSquares[n]\n}\n\n// another\n\n/**\n * @param {number} n\n * @return {number}\n */\nconst numSquares = function (n) {\n  // Based on Lagrange's Four Square theorem, there\n  // are only 4 possible results: 1, 2, 3, 4.\n  // If n is a perfect square, return 1.\n  if (is_square(n)) {\n    return 1\n  }\n  // The result is 4 if and only if n can be written in the\n  // form of 4^k*(8*m + 7). Please refer to\n  // Legendre's three-square theorem.\n  while ((n & 3) === 0) {\n    // n%4 == 0\n    n >>= 2\n  }\n  if ((n & 7) === 7) {\n    // n%8 == 7\n    return 4\n  }\n  // Check whether 2 is the result.\n  let sqrt_n = Math.sqrt(n) >> 0\n  for (let i = 1; i <= sqrt_n; i++) {\n    if (is_square(n - i * i)) {\n      return 2\n    }\n  }\n  return 3\n  function is_square(n) {\n    const sqrt_n = Math.sqrt(n) >> 0\n    return sqrt_n * sqrt_n == n\n  }\n}\n\n"
    }
  },
  {
    "name": "28-implement-strStr()",
    "code": {
      "JS": "/**\r\n * @param {string} haystack\r\n * @param {string} needle\r\n * @return {number}\r\n */\r\nconst strStr = function(a, b) {\r\n  if(b === '') return 0\r\n  if(a.length < b.length) return -1\r\n  if(a.length === b.length) return a === b ? 0 : -1\r\n  const m = a.length, n = b.length\r\n  const fail = Array(n).fill(-1)\r\n  // DFA\r\n  for(let i = 1; i < n; i++) {\r\n    let j = fail[i - 1]\r\n    while(j !== -1 && b[j + 1] !== b[i]) {\r\n      j = fail[j]      \r\n    }\r\n    if(b[j + 1] === b[i]) fail[i] = j + 1\r\n  }\r\n  let pos = -1\r\n  for(let i = 0; i < m; i++) {\r\n    while(pos !== -1 && a[i] !== b[pos + 1]) pos = fail[pos]\r\n    if(a[i] === b[pos + 1]) {\r\n      pos++\r\n      if(pos === n - 1) return i - n + 1\r\n    }\r\n  }\r\n  return -1\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * @param {string} haystack\r\n * @param {string} needle\r\n * @return {number}\r\n */\r\nconst strStr = function(haystack, needle) {\r\n  if (needle === \"\") return 0;\r\n  for (let i = 0; ; i++) {\r\n    for (let j = 0; ; j++) {\r\n      if (j === needle.length) {\r\n        return i;\r\n      }\r\n      if (i + j === haystack.length) return -1;\r\n      if (haystack.charAt(i + j) !== needle.charAt(j)) {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n};\r\n"
    }
  },
  {
    "name": "280-wiggle-sort",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nconst wiggleSort = function(nums) {\n  for (let i = 1; i < nums.length; i++) {\n    let a = nums[i - 1]\n    if ((i % 2 === 1) === a > nums[i]) {\n      nums[i - 1] = nums[i]\n      nums[i] = a\n    }\n  }\n}\n"
    }
  },
  {
    "name": "281-zigzag-iterator",
    "code": {
      "JS": "/**\n * @constructor\n * @param {Integer[]} v1\n * @param {Integer[]} v1\n */\nconst ZigzagIterator = function ZigzagIterator(v1, v2) {\n  this.collection = []\n  if (v1 !== null && v1.length !== 0) {\n    this.collection.push(v1)\n  }\n  if (v2 !== null && v2.length !== 0) {\n    this.collection.push(v2)\n  }\n}\n\n/**\n * @this ZigzagIterator\n * @returns {boolean}\n */\nZigzagIterator.prototype.hasNext = function hasNext() {\n  return this.collection.length > 0\n}\n\n/**\n * @this ZigzagIterator\n * @returns {integer}\n */\nZigzagIterator.prototype.next = function next() {\n  if (this.collection[0].length === 1) {\n    return this.collection.shift()[0]\n  } else {\n    let v = this.collection.shift()\n    this.collection.push(v)\n    return v.shift()\n  }\n}\n\n/**\n * Your ZigzagIterator will be called like this:\n * var i = new ZigzagIterator(v1, v2), a = [];\n * while (i.hasNext()) a.push(i.next());\n */\n\n// another\n\n/**\n * @constructor\n * @param {Integer[]} v1\n * @param {Integer[]} v1\n */\nconst ZigzagIterator = function ZigzagIterator(v1, v2) {\n  const A = [v1, v2]\n  this.A = A\n  this.n = A.length\n  this.m = Math.max(v1.length, v2.length)\n  this.j = 0\n  this.i = 0\n}\n\n/**\n * @this ZigzagIterator\n * @returns {boolean}\n */\nZigzagIterator.prototype.hasNext = function hasNext() {\n  return this.j < this.m\n}\n\n/**\n * @this ZigzagIterator\n * @returns {integer}\n */\nZigzagIterator.prototype.incrementPointers = function incrementPointers() {\n  this.i += 1\n  if (this.i === this.n) {\n    this.j += 1\n    this.i = 0\n  }\n}\n\nZigzagIterator.prototype.next = function next() {\n  let next = undefined\n  while (next === undefined) {\n    next = this.A[this.i][this.j]\n    this.incrementPointers()\n  }\n  while (this.hasNext()) {\n    if (this.A[this.i][this.j] !== undefined) break\n    this.incrementPointers()\n  }\n  return next\n}\n\n/**\n * Your ZigzagIterator will be called like this:\n * var i = new ZigzagIterator(v1, v2), a = [];\n * while (i.hasNext()) a.push(i.next());\n */\n\n// another\n\n/**\n * @constructor\n * @param {Integer[]} v1\n * @param {Integer[]} v1\n */\nconst ZigzagIterator = function ZigzagIterator(v1, v2) {\n  this.queue = []\n  if (v1.length > 0) {\n    const it = v1[Symbol.iterator]()\n    const res = it.next()\n    this.queue.push({ it, res })\n  }\n  if (v2.length > 0) {\n    const it = v2[Symbol.iterator]()\n    const res = it.next()\n    this.queue.push({ it, res })\n  }\n}\n/**\n * @this ZigzagIterator\n * @returns {boolean}\n */\nZigzagIterator.prototype.hasNext = function hasNext() {\n  return this.queue.length > 0\n}\n/**\n * @this ZigzagIterator\n * @returns {integer}\n */\nZigzagIterator.prototype.next = function next() {\n  const { it, res } = this.queue.shift()\n  const { value } = res\n  const res1 = it.next()\n  if (!res1.done) this.queue.push({ it, res: res1 })\n  return value\n}\n/**\n * Your ZigzagIterator will be called like this:\n * var i = new ZigzagIterator(v1, v2), a = [];\n * while (i.hasNext()) a.push(i.next());\n */\n\n"
    }
  },
  {
    "name": "282-expression-add-operators",
    "code": {
      "JS": "/**\n * @param {string} num\n * @param {number} target\n * @return {string[]}\n */\nconst addOperators = function(num, target) {\n  let res = [];\n  let n = num.length;\n  function recursive(k, str, add, mul, last) {\n    let sum = add + mul * last;\n    if (k === n) {\n      if (sum === target) {\n        res.push(str);\n      }\n      return;\n    }\n    let x = num[k] - \"0\";\n    if (last !== 0) {\n      recursive(k + 1, str + num[k], add, mul, last * 10 + x);\n    }\n    recursive(k + 1, str + \"*\" + num[k], add, mul * last, x);\n    recursive(k + 1, str + \"+\" + num[k], sum, 1, x);\n    recursive(k + 1, str + \"-\" + num[k], sum, -1, x);\n  }\n  if (n) recursive(1, num[0], 0, 1, num[0] - \"0\");\n  return res;\n};\n"
    }
  },
  {
    "name": "283-move-zeroes",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n * @return {void} Do not return anything, modify nums in-place instead.\r\n */\r\nconst moveZeroes = function(nums) {\r\n  const len = nums.length;\r\n  let l = len;\r\n  for (let i = 0; i < l; ) {\r\n    if (nums[i] === 0) {\r\n      nums.splice(i, 1);\r\n      nums.push(0);\r\n      l -= 1;\r\n    } else {\r\n      i += 1;\r\n    }\r\n  }\r\n};\r\n"
    }
  },
  {
    "name": "285-inorder-successor-in-bst",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} p\n * @return {TreeNode}\n */\nconst inorderSuccessor = function(root, p) {\n  const res = { node: null }\n  dfs(root, [], res, p)\n  return res.node\n};\n\nfunction dfs(node, arr, res, target) {\n  if(node === null) return\n  dfs(node.left, arr, res, target)\n  if(arr.length && arr[arr.length - 1] === target) res.node = node\n  arr.push(node)\n  dfs(node.right, arr, res, target)\n} \n\n// another\n\nconst inorderSuccessor = function(root, p) {\n  let last = null\n  const chk = node => {\n    if(!node) return\n    const l = chk(node.left)\n    if(l !== undefined) return l\n    if(last === p) return node\n    last = node\n    return chk(node.right)\n  }\n  return chk(root)\n};\n\n// another\n\nconst inorderSuccessor = function(root, p) {\n  while (root != null && root.val <= p.val) root = root.right\n  const left = root == null ? null : inorderSuccessor(root.left, p)\n  return left != null && left.val > p.val ? left : root\n}\n\n// another\n\nconst inorderSuccessor = function(root, p) {\n  let succ = null\n  while(root) {\n    if (p.val < root.val) {\n      succ = root\n      root = root.left\n    } else {\n      root = root.right\n    }\n  }\n  return succ\n}\n"
    }
  },
  {
    "name": "286-walls-and-gates",
    "code": {
      "JS": "/**\n\nYou are given a m x n 2D grid initialized with these three possible values.\n\n-1 - A wall or an obstacle.\n0 - A gate.\nINF - Infinity means an empty room. We use the value 231 - 1 = 2147483647\nto represent INF as you may assume that the distance to a gate\nis less than 2147483647.\n\nFill each empty room with the distance to its nearest gate.\nIf it is impossible to reach a gate, it should be filled with INF.\n\nExample: \n\nGiven the 2D grid:\n\nINF  -1  0  INF\nINF INF INF  -1\nINF  -1 INF  -1\n  0  -1 INF INF\nAfter running your function, the 2D grid should be:\n\n  3  -1   0   1\n  2   2   1  -1\n  1  -1   2  -1\n  0  -1   3   4\n\n*/\n\n/**\n * @param {number[][]} rooms\n * @return {void} Do not return anything, modify rooms in-place instead.\n */\nconst wallsAndGates = function(rooms) {\n  const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n  const rows = rooms.length\n  const cols = rows === 0 ? 0 : rooms[0].length\n  const q = []\n  const INF = 2147483647\n  for(let i = 0; i < rows; i++) {\n    for(let j = 0; j < cols; j++) {\n      if(rooms[i][j] === 0) q.push([i, j])\n    }\n  }\n  while(q.length) {\n    const el = q.shift()\n    for(let d of dirs) {\n      const r = el[0] + d[0]\n      const c = el[1] + d[1]\n      if(r < 0 || c < 0 || r >= rows || c >= cols || rooms[r][c] !== INF) continue\n      rooms[r][c] = rooms[el[0]][el[1]] + 1\n      q.push([r, c])\n    }\n  }\n};\n\n// another\n\n/**\n * @param {number[][]} rooms\n * @return {void} Do not return anything, modify rooms in-place instead.\n */\nconst wallsAndGates = function(rooms) {\n  const dirs = [\n    [1, 0],\n    [-1, 0],\n    [0, 1],\n    [0, -1]\n  ];\n  const rows = rooms.length;\n  const cols = rows === 0 ? 0 : rooms[0].length;\n  const q = [];\n  const INF = 2147483647;\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (rooms[i][j] === 0) dfs(dirs, rooms, i, j, rows, cols, 0);\n    }\n  }\n};\n\nfunction dfs(dirs, rooms, i, j, rows, cols, dis) {\n  if (\n    i < 0 ||\n    j < 0 ||\n    i >= rows ||\n    j >= cols ||\n    rooms[i][j] === -1 ||\n    rooms[i][j] < dis\n  ) {\n    return;\n  }\n  rooms[i][j] = dis;\n  for (let dir of dirs) {\n    dfs(dirs, rooms, i + dir[0], j + dir[1], rows, cols, dis + 1);\n  }\n}\n\n"
    }
  },
  {
    "name": "287-find-the-duplicate-number",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nconst findDuplicate = function(nums) {\r\n  const len = nums.length\r\n  if(len > 0) {\r\n    let slow = nums[0]\r\n    let fast = nums[nums[0]]\r\n    while(slow !== fast) {\r\n      slow = nums[slow]\r\n      fast = nums[nums[fast]]\r\n    }\r\n    slow = 0\r\n    while(slow !== fast) {\r\n      slow = nums[slow]\r\n      fast = nums[fast]\r\n    }\r\n    return slow\r\n  }\r\n  return -1;\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nconst findDuplicate = function(nums) {\r\n  let n = nums.length - 1,\r\n    res = 0\r\n  for (let p = 0; p < 32; ++p) {\r\n    let bit = 1 << p,\r\n      a = 0,\r\n      b = 0\r\n    for (let i = 0; i <= n; ++i) {\r\n      if (i > 0 && (i & bit) > 0) ++a\r\n      if ((nums[i] & bit) > 0) ++b\r\n    }\r\n    if (b > a) res += bit\r\n  }\r\n  return res\r\n}\r\n\r\n// another\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nconst findDuplicate = function(nums) {\r\n  const hash = {};\r\n  for (let i = 0; i < nums.length; i++) {\r\n    if (hash.hasOwnProperty(nums[i])) {\r\n      return nums[i];\r\n    } else {\r\n      hash[nums[i]] = 1;\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n\r\n# File: FindDuplicate.py\r\n# Author: Keith Schwarz (htiek@cs.stanford.edu)\r\n#\r\n# An algorithm for solving the following (classic) hard interview problem:\r\n#\r\n# \"You are given an array of integers of length n, where each element ranges\r\n#  from 0 to n - 2, inclusive.  Prove that at least one  duplicate element must\r\n#  exist, and give an O(n)-time, O(1)-space algorithm for finding some\r\n#  duplicated element.  You must not modify the array elements during this \r\n#  process.\"\r\n#\r\n# This problem (reportedly) took CS legend Don Knuth twenty-four hours to solve\r\n# and I have only met one person (Keith Amling) who could solve it in less time\r\n# than this.\r\n#\r\n# The first part of this problem - proving that at least one duplicate element\r\n# must exist - is a straightforward application of the pigeonhole principle.\r\n# If the values range from 0 to n - 2, inclusive, then there are only n - 1\r\n# different values.  If we have an array of n elements, one must necessarily be\r\n# duplicated.\r\n#\r\n# The second part of this problem - finding the duplicated element subject to\r\n# the given constraints - is much harder.  To solve this, we're going to need a\r\n# series of nonobvious insights that transform the problem into an instance of\r\n# something entirely different.\r\n#\r\n# The main trick we need to use to solve this problem is to notice that because\r\n# we have an array of n elements ranging from 0 to n - 2, we can think of the\r\n# array as defining a function f from the set {0, 1, ..., n - 1} onto itself.\r\n# This function is defined by f(i) = A[i].  Given this setup, a duplicated\r\n# value corresponds to a pair of indices i != j such that f(i) = f(j).  Our\r\n# challenge, therefore, is to find this pair (i, j).  Once we have it, we can\r\n# easily find the duplicated value by just picking f(i) = A[i].\r\n#\r\n# But how are we to find this repeated value?  It turns out that this is a\r\n# well-studied problem in computer science called cycle detection.  The general\r\n# form of the problem is as follows.  We are given a function f.  Define the\r\n# sequence x_i as\r\n#\r\n#    x_0     = k       (for some k)\r\n#    x_1     = f(x_0)\r\n#    x_2     = f(f(x_0))\r\n#    ...\r\n#    x_{n+1} = f(x_n)\r\n#\r\n# Assuming that f maps from a domain into itself, this function will have one\r\n# of three forms.  First, if the domain is infinite, then the sequence could be\r\n# infinitely long and nonrepeating.  For example, the function f(n) = n + 1 on\r\n# the integers has this property - no number is ever duplicated.  Second, the\r\n# sequence could be a closed loop, which means that there is some i so that\r\n# x_0 = x_i.  In this case, the sequence cycles through some fixed set of\r\n# values indefinitely.  Finally, the sequence could be \"rho-shaped.\"  In this\r\n# case, the sequence looks something like this:\r\n#\r\n#     x_0 -> x_1 -> ... x_k -> x_{k+1} ... -> x_{k+j}\r\n#                        ^                       |\r\n#                        |                       |\r\n#                        +-----------------------+\r\n#\r\n# That is, the sequence begins with a chain of elements that enters a cycle,\r\n# then cycles around indefinitely.  We'll denote the first element of the cycle\r\n# that is reached in the sequence the \"entry\" of the cycle.\r\n#\r\n# For our particular problem of finding a duplicated element in the array,\r\n# consider the sequence formed by starting at position n - 1 and then\r\n# repeatedly applying f.  That is, we start at the last position in the array,\r\n# then go to the indicated index, repeating this process.  My claim is that\r\n# this sequence is rho-shaped.  To see this, note that it must contains a cycle\r\n# because the array is finite and after visiting n elements, we necessarily\r\n# must visit some element twice.  This is true no matter where we start off in\r\n# the array.  Moreover, note that since the array elements range from 0 to\r\n# n - 2 inclusive, there is no array index that contains n - 1 as a value.\r\n# Consequently, when we leave index n - 1 after applying the function f one\r\n# time, we can never get back there.  This means that n - 1 can't be part of a\r\n# cycle, but if we follow indices starting there we must eventually hit some\r\n# other node twice.  The concatenation of the chain starting at n - 1 with the\r\n# cycle it hits must be rho-shaped.\r\n#\r\n# Moreover, think about the node we encounter that starts at the entry of the\r\n# cycle.  Since this node is at the entry of the cycle, there must be two\r\n# inputs to the function f that both result in that index being generated.  For\r\n# this to be possible, it must be that there are indices i != j with\r\n# f(i) = f(j), meaning that A[i] = A[j].  Thus the index of the entry of the\r\n# cycle must be one of the values that is duplicated in the array.\r\n#\r\n# There is a famous algorithm due to Robert Floyd that, given a rho-shaped\r\n# sequence, finds the entry point of the cycle in linear time and using only\r\n# constant space.  This algorithm is often referred to as the \"tortoise and\r\n# hare\" algorithm, for reasons that will become clearer shortly.\r\n#\r\n# The idea behind the algorithm is to define two quantities.  First, let c be\r\n# the length of the chain that enters the cycle, and let l be the length of the\r\n# cycle.  Next, let l' be the smallest multiple of l that's larger than c.\r\n# I claim that for any rho-shaped sequence l' defined above, that\r\n#\r\n#    x_{l'} = x_{2l'}\r\n#\r\n# The proof is actually straightforward and very illustrative - it's one of my\r\n# favorite proofs in computer science.  The idea is that since l' is at least\r\n# c, it must be contained in the cycle.  Moreover, since l' is a multiple of\r\n# the length of the loop, we can write it as ml for some constant m.  If we\r\n# start at position x_{l'}, which is inside the loop, then take l' more steps\r\n# forward to get to x_{2l'}, then we will just walk around the loop m times,\r\n# ending up right back where we started.\r\n#\r\n# One key trick of Floyd's algorithm is that even if we don't explicitly know l\r\n# or c, we can still find the value l' in O(l') time.  The idea is as follows.\r\n# We begin by keeping track of two values \"slow\" and \"fast,\" both starting at\r\n# x_0.  We then iteratively compute\r\n#\r\n#    slow = f(slow)\r\n#    fast = f(f(fast))\r\n#\r\n# We repeat this process until we find that slow and fast are equal to one\r\n# another.  When this happens, we know that slow = x_j for some j, and\r\n# fast = x_{2j} for that same j.  Since x_j = x_{2j}, we know that j must be at\r\n# least c, since it has to be contained in the cycle.  Moreover, we know that j\r\n# must be a multiple of l, since the fact that x_j = x_{2j} means that taking j\r\n# steps while in the cycle ends up producing the same result.  Finally, j must\r\n# be the smallest multiple of l greater than c, since if there were a smaller\r\n# multiple of l greater than c then we would have reached that multiple before\r\n# we reached j.  Consequently, we must have that j = l', meaning that we can\r\n# find l' without knowing anything about the length or shape of the cycle!\r\n#\r\n# To complete the construction, we need to show how to use our information\r\n# about l' to find the entry to the cycle (which is at position x_c).  To do\r\n# this, we start off one final variable, which we call \"finder,\" at x_0.  We\r\n# then iteratively repeat the following:\r\n#\r\n#   finder = f(finder)\r\n#   slow   = f(slow)\r\n#\r\n# until finder = slow.  We claim that (1) the two will eventually hit each\r\n# other, and (2) they will hit each other at the entry to the cycle.  To see\r\n# this, we remark that since slow is at position x_{l'}, if we take c steps\r\n# forward, then we have that slow will be at position x_{l' + c}.  Since l' is\r\n# a multiple of the loop length, this is equivalent to taking c steps forward,\r\n# then walking around the loop some number of times back to where you started.\r\n# In other words, x_{l' + c} = x_c.  Moreover, consider the position of the\r\n# finder variable after c steps.  It starts at x_0, so after c steps it will be\r\n# at position x_c.  This proves both (1) and (2), since we've shown that the\r\n# two must eventually hit each other, and when they do they hit at position x_c\r\n# at the entry to the cycle.\r\n#\r\n# The beauty of this algorithm is that it uses only O(1) external memory to\r\n# keep track of two different pointers - the slow pointer, and then the fast\r\n# pointer (for the first half) and the finder pointer (for the second half).\r\n# But on top of that, it runs in O(n) time.  To see this, note that the time\r\n# required for the slow pointer to hit the fast pointer is O(l').  Since l' is\r\n# the smallest multiple of l greater than c, we have two cases to consider.\r\n# First, if l > c, then this is l.  Otherwise, if l < c, then we have that\r\n# there must be some multiple of l between c and 2c.  To see this, note that\r\n# in the range c and 2c there are c different values, and since l < c at least\r\n# one of them must be equal to 0 mod l.  Finally, the time required to find the\r\n# start of the cycle from this point is O(c).  This gives a total runtime of at\r\n# most O(c + max{l, 2c}).  All of these values are at most n, so this algorithm\r\n# runs in time O(n).\r\n\r\ndef findArrayDuplicate(array):\r\n    assert len(array) > 0\r\n\r\n    # The \"tortoise and hare\" step.  We start at the end of the array and try\r\n    # to find an intersection point in the cycle.\r\n    slow = len(array) - 1\r\n    fast = len(array) - 1\r\n\r\n    # Keep advancing 'slow' by one step and 'fast' by two steps until they\r\n    # meet inside the loop.\r\n    while True:\r\n        slow = array[slow]\r\n        fast = array[array[fast]]\r\n\r\n        if slow == fast:\r\n            break\r\n\r\n    # Start up another pointer from the end of the array and march it forward\r\n    # until it hits the pointer inside the array.\r\n    finder = len(array) - 1\r\n    while True:\r\n        slow   = array[slow]\r\n        finder = array[finder]\r\n\r\n        # If the two hit, the intersection index is the duplicate element.\r\n        if slow == finder:\r\n            return slow\r\n\r\n\r\n*/\r\n"
    }
  },
  {
    "name": "288-unique-word-abbreviation",
    "code": {
      "JS": "/**\n * @param {string[]} dictionary\n */\nconst ValidWordAbbr = function(dictionary) {\n  this.map = new Map()\n  for (let i = 0; i < dictionary.length; i++) {\n    let w = dictionary[i]\n    if (w.length < 3) this.map.set(w, true)\n    else {\n      let key = this.toAbbr(w)\n      let val = this.map.has(key) ? false : w\n      this.map.set(key, val)\n    }\n  }\n}\n/**\n * @param {string} word\n * @return {boolean}\n */\nValidWordAbbr.prototype.isUnique = function(word) {\n  let len = word.length\n  if (len < 3) return true\n  let key = this.toAbbr(word)\n  if (this.map.has(key)) {\n    let val = this.map.get(key)\n    if (val === false) return false\n    return word === val\n  }\n  return true\n}\nValidWordAbbr.prototype.toAbbr = word => {\n  let len = word.length\n  if (len < 3) return word\n  return word[0] + (len - 2) + word[len - 1]\n}\n/**\n * Your ValidWordAbbr object will be instantiated and called as such:\n * var obj = new ValidWordAbbr(dictionary)\n * var param_1 = obj.isUnique(word)\n */\n"
    }
  },
  {
    "name": "289-game-of-life",
    "code": {
      "JS": "/**\n * @param {number[][]} board\n * @return {void} Do not return anything, modify board in-place instead.\n */\nconst gameOfLife = function(board) {\n  const DIRECTIONS = [\n    [1, 0],\n    [1, 1],\n    [0, 1],\n    [-1, 1],\n    [-1, 0],\n    [-1, -1],\n    [0, -1],\n    [1, -1]\n  ];\n\n  const isValid = function(x, y) {\n    if (x >= 0 && y >= 0 && x < board.length && y < board[0].length)\n      return true;\n    else return false;\n  };\n\n  const getAliveNeighbors = function(x, y) {\n    let aliveNeighs = 0;\n    for (let dir of DIRECTIONS) {\n      let newX = x + dir[0];\n      let newY = y + dir[1];\n      if (!isValid(newX, newY)) continue;\n      if (board[newX][newY] === 1 || board[newX][newY] === -1) {\n        aliveNeighs++;\n      }\n    }\n\n    return aliveNeighs;\n  };\n\n  for (let row = 0; row < board.length; row++) {\n    for (let col = 0; col < board[0].length; col++) {\n      let aliveNeighbors = getAliveNeighbors(row, col);\n      if (board[row][col] === 0) {\n        if (aliveNeighbors === 3) board[row][col] = 2;\n        else board[row][col] = 0;\n      } else {\n        if (aliveNeighbors === 2 || aliveNeighbors === 3) board[row][col] = 1;\n        else board[row][col] = -1;\n      }\n    }\n  }\n\n  for (let row = 0; row < board.length; row++) {\n    for (let col = 0; col < board[0].length; col++) {\n      if (board[row][col] > 0) board[row][col] = 1;\n      else board[row][col] = 0;\n    }\n  }\n};\n"
    }
  },
  {
    "name": "29-divide-two-integers",
    "code": {
      "JS": "/**\r\n * @param {number} dividend\r\n * @param {number} divisor\r\n * @return {number}\r\n */\r\nconst divide = function(dividend, divisor) {\r\n  if (!divisor || (dividend === Number.MIN_SAFE_INTEGER && divisor === -1)) {\r\n    return Number.MAX_SAFE_INTEGER;\r\n  }\r\n  const MAX_INT = Math.pow(2, 31) - 1;\r\n  if (dividend === -2147483648 && divisor === -1) return MAX_INT;\r\n\r\n  const sign = (dividend < 0) ^ (divisor < 0) ? -1 : 1;\r\n  let dvd = Math.abs(dividend);\r\n  let dvs = Math.abs(divisor);\r\n  let res = 0;\r\n\r\n  while (dvd >= dvs) {\r\n    let tmp = dvs;\r\n    let multiple = 1;\r\n    while (dvd >= tmp << 1 && tmp << 1 > 0) {\r\n      tmp <<= 1;\r\n      multiple <<= 1;\r\n    }\r\n    dvd -= tmp;\r\n    res += multiple;\r\n  }\r\n  return sign === 1 ? res : -res;\r\n};\r\n"
    }
  },
  {
    "name": "290-word-pattern",
    "code": {
      "JS": "/**\n * @param {string} pattern\n * @param {string} str\n * @return {boolean}\n */\nconst wordPattern = function(pattern, str) {\n  const pm = {}\n  const sm = {}\n  const sa = str.trim().split(' ')\n  if(pattern.length !== sa.length) return false\n  for(let i = 0; i< pattern.length; i++) {\n    if(!pm.hasOwnProperty(pattern[i])) {\n       pm[pattern[i]] = sa[i]\n    }\n    if(!sm.hasOwnProperty(sa[i])) {\n       sm[sa[i]] = pattern[i]\n    }\n\n    if( !(pm[pattern[i]] === sa[i] && sm[sa[i]] === pattern[i] ) ) {\n      return false   \n    }\n    \n  }\n  return true\n};\n"
    }
  },
  {
    "name": "291-word-pattern-ii",
    "code": {
      "JS": "/**\n * @param {string} pattern\n * @param {string} str\n * @return {boolean}\n */\nconst wordPatternMatch = function(pattern, str) {\n  const map = new Map()\n  const set = new Set()\n  return isMatch(str, 0, pattern, 0, map, set)\n};\nfunction isMatch(str, i, pat, j, map, set) {\n  if(i === str.length && j === pat.length) return true\n  if(i === str.length || j === pat.length) return false\n  let c = pat.charAt(j)\n  if(map.has(c)) {\n    let s = map.get(c)\n    if(!str.startsWith(s, i)) return false\n    return isMatch(str, i + s.length, pat, j + 1, map, set)\n  }\n  for(let k = i; k < str.length; k++) {\n    let p = str.slice(i, k + 1)\n    if(set.has(p)) continue\n    map.set(c, p)\n    set.add(p)\n    if(isMatch(str, k + 1, pat, j + 1, map, set)) return true\n    map.delete(c)\n    set.delete(p)\n  }\n  return false\n}\n\n// another\n\n/**\n * @param {string} pattern\n * @param {string} s\n * @return {boolean}\n */\nconst wordPatternMatch = function(pattern, s) {\n  const obj = { res: false }\n  const hash = {}\n  helper(pattern, s, 0, 0, hash, obj)\n  return obj.res\n};\n\nfunction helper(p, s, i, j, hash, obj) {\n  if(obj.res) return\n  if(i === p.length && j === s.length) {\n    obj.res = true\n    return\n  }\n  if(i >= p.length || j >= s.length) return\n  for(let m = j; m < s.length && obj.res === false; m++) {\n    const tmp = s.slice(j, m + 1)\n    if(hash[p[i]]) {\n      if(tmp === hash[p[i]]) {\n        helper(p, s, i + 1, m + 1, hash, obj)\n      }\n    } else {\n      const set = new Set(Object.values(hash))\n      if (!set.has(tmp)) {\n        hash[p[i]] = tmp\n        helper(p, s, i + 1, m + 1, hash, obj)\n        delete hash[p[i]]\n      }\n    }\n  }\n}\n"
    }
  },
  {
    "name": "292-nim-game",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {boolean}\n */\nconst canWinNim = function(n) {\n  return n % 4 !== 0 ;  \n};\n"
    }
  },
  {
    "name": "293-flip-game",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {string[]}\n */\nconst generatePossibleNextMoves = function(s) {\n  const list = []\n  for (let i = -1; (i = s.indexOf('++', i + 1)) >= 0; )\n    list.push(s.slice(0, i) + '--' + s.slice(i + 2))\n  return list\n}\n"
    }
  },
  {
    "name": "294-flip-game-ii",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {boolean}\n */\nconst canWin = function(s) {\n  const ss = s.split('')\n  const len = s.length\n  return chk()\n  function chk() {\n    for (let i = 0; i <= len - 2; i++) {\n      if (ss[i] === '+' && ss[i + 1] === '+') {\n        ss[i] = '-'\n        ss[i + 1] = '-'\n        const wins = !chk()\n        ss[i] = '+'\n        ss[i + 1] = '+'\n        if (wins) return true\n      }\n    }\n    return false\n  }\n}\n"
    }
  },
  {
    "name": "295-find-median-from-data-stream",
    "code": {
      "JS": "/**\n * initialize your data structure here.\n */\nconst MedianFinder = function() {\n  this.arr = [];\n};\n/**\n * @param {number} num\n * @return {void}\n */\nMedianFinder.prototype.addNum = function(num) {\n  const bs = n => {\n    let start = 0;\n    let end = this.arr.length;\n    while (start < end) {\n      let mid = ~~((start + end) / 2);\n      if (n > this.arr[mid]) start = mid + 1;\n      else end = mid;\n    }\n    this.arr.splice(start, 0, n);\n  };\n  if (this.arr.length === 0) this.arr.push(num);\n  else bs(num);\n};\n\n/**\n * @return {number}\n */\nMedianFinder.prototype.findMedian = function() {\n  const mid = ~~(this.arr.length / 2);\n  return this.arr.length % 2 === 0\n    ? (this.arr[mid - 1] + this.arr[mid]) / 2\n    : this.arr[mid];\n};\n/**\n * Your MedianFinder object will be instantiated and called as such:\n * var obj = new MedianFinder()\n * obj.addNum(num)\n * var param_2 = obj.findMedian()\n */\n\n// another\n\n/**\n * initialize your data structure here.\n */\nconst MedianFinder = function() {\n  this.minPQ = new PriorityQueue()\n  this.maxPQ = new PriorityQueue((a, b) => a < b)\n};\n\n/** \n * @param {number} num\n * @return {void}\n */\nMedianFinder.prototype.addNum = function(num) {\n  this.minPQ.push(num)\n  this.maxPQ.push(this.minPQ.pop())\n  if(this.minPQ.size() < this.maxPQ.size()) {\n    this.minPQ.push(this.maxPQ.pop())\n  }\n};\n\n/**\n * @return {number}\n */\nMedianFinder.prototype.findMedian = function() {\n  if(this.minPQ.size() > this.maxPQ.size()) return this.minPQ.peek()\n  else return (this.minPQ.peek() + this.maxPQ.peek()) / 2\n};\n\n/** \n * Your MedianFinder object will be instantiated and called as such:\n * var obj = new MedianFinder()\n * obj.addNum(num)\n * var param_2 = obj.findMedian()\n */\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n"
    }
  },
  {
    "name": "296-best-meeting-point",
    "code": {
      "JS": "/**\n\nA group of two or more people wants to meet and minimize the total travel distance.\nYou are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group.\nThe distance is calculated using Manhattan Distance,\nwhere distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.\n\nExample:\n\nInput: \n\n1 - 0 - 0 - 0 - 1\n|   |   |   |   |\n0 - 0 - 0 - 0 - 0\n|   |   |   |   |\n0 - 0 - 1 - 0 - 0\n\nOutput: 6 \n\nExplanation: Given three people living at (0,0), (0,4), and (2,2):\n             The point (0,2) is an ideal meeting point, as the total travel distance \n             of 2+2+2=6 is minimal. So return 6.\n\n*/\n\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nconst minTotalDistance = function(grid) {\n  const m = grid.length\n  if(!m) return 0\n  const n = grid[0].length\n  const I = []\n  const J = []\n  for(let i = 0; i < m; i++) {\n    for(let j = 0; j < n; j++) {\n      if(grid[i][j] === 1) I.push(i)\n    }\n  }\n  for(let j = 0; j < n; j++) {\n    for(let i = 0; i < m; i++) {\n      if(grid[i][j] === 1) J.push(j)\n    }\n  }\n  return min(I) + min(J)\n};\n\nfunction min(arr) {\n  let i = 0, j = arr.length - 1, sum = 0\n  while(i < j) {\n    sum += arr[j--] - arr[i++]\n  }\n  return sum\n}\n"
    }
  },
  {
    "name": "297-serialize-and-deserialize-binary-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nconst serialize = function(root) {\n  return rserialize(root, \"\");\n};\n\nfunction rserialize(root, str) {\n  if (root === null) {\n    str += \"null,\";\n  } else {\n    str += root.val + \",\";\n    str = rserialize(root.left, str);\n    str = rserialize(root.right, str);\n  }\n\n  return str;\n}\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nconst deserialize = function(data) {\n  let data_array = data.split(\",\").filter(el => el !== \"\");\n  return rdeserialize(data_array);\n};\n\nfunction rdeserialize(l) {\n  if (l[0] === \"null\") {\n    l.shift();\n    return null;\n  }\n  const root = new TreeNode(+l[0]);\n  l.shift();\n  root.left = rdeserialize(l);\n  root.right = rdeserialize(l);\n  return root;\n}\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */\n"
    }
  },
  {
    "name": "298-binary-tree-longest-consecutive-sequence",
    "code": {
      "JS": "/**\n\nGiven a binary tree, find the length of the longest consecutive sequence path.\n\nThe path refers to any sequence of nodes from some starting node to any node\nin the tree along the parent-child connections.\nThe longest consecutive path need to be from parent to child (cannot be the reverse).\n\nExample 1:\n\nInput:\n\n   1\n    \\\n     3\n    / \\\n   2   4\n        \\\n         5\n\nOutput: 3\n\nExplanation: Longest consecutive sequence path is 3-4-5, so return 3.\n\nExample 2:\n\nInput:\n\n   2\n    \\\n     3\n    / \n   2    \n  / \n 1\n\nOutput: 2 \n\nExplanation: Longest consecutive sequence path is 2-3, not 3-2-1, so return 2.\n\n*/\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nconst longestConsecutive = function(root) {\n  const res = { max: 0 }\n  dfs(root, null, 0, res)\n  return res.max\n};\n\nfunction dfs(node, p, cur, res) {\n  if(node === null) {\n    return\n  }\n  let s = 0\n  if(p === null) s = 1\n  else if(node.val - p.val === 1) s = cur + 1\n  else s = 1\n  if(s > res.max) res.max = s\n  dfs(node.left, node, s, res)\n  dfs(node.right, node, s, res)\n}\n"
    }
  },
  {
    "name": "299-bulls-and-cows",
    "code": {
      "JS": "/**\n * @param {string} secret\n * @param {string} guess\n * @return {string}\n */\nconst getHint = function(secret, guess) {\n  let bulls = 0\n  let cows = 0\n  const h = {}\n  for(let i = 0, len = secret.length; i < len; i++) {\n    if(secret[i] === guess[i]) {\n      bulls++\n    } else {\n      if(!h.hasOwnProperty(secret[i])) h[secret[i]] = 0\n      h[secret[i]]++\n    }\n  }\n  \n  for(let i = 0, len = secret.length; i < len; i++) {\n    if(secret[i] !== guess[i]) {\n      if(h.hasOwnProperty(guess[i]) && h[guess[i]] > 0) {\n        cows++\n        h[guess[i]]--\n      }\n    }\n  }\n\n  return `${bulls}A${cows}B`\n};\n"
    }
  },
  {
    "name": "3-longest-substring-without-repeating-characters",
    "code": {
      "JS": "/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nconst lengthOfLongestSubstring = function(s) {\r\n  if(s.length < 2) return s.length\r\n  const hash = {}\r\n  let max = 0\r\n  for(let i = 0, j = -1, len = s.length; i < len; i++) {\r\n    const cur = s[i]\r\n    if(hash[cur] != null) j = Math.max(j, hash[cur])\r\n    \r\n    hash[cur] = i\r\n    max = Math.max(max, i - j)\r\n  }\r\n  \r\n  return max\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nconst lengthOfLongestSubstring = function(s) {\r\n  // var p=0, q=0; //p: start of the sub, q: end of the queue\r\n\r\n  //hashmap in js????? Array.indexOf\r\n  const sub = [];\r\n  let max = 0;\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    let index = sub.indexOf(s.charAt(i));\r\n    if (index == -1) {\r\n      sub.push(s.charAt(i));\r\n      // q++;\r\n    } else {\r\n      //find repeat, get index of repeat el, remve all el before that index\r\n      sub = sub.slice(index + 1, sub.length);\r\n      sub.push(s.charAt(i));\r\n    }\r\n    max = Math.max(max, sub.length);\r\n  }\r\n  return max;\r\n};\r\n"
    }
  },
  {
    "name": "30-substring-with-concatenation-of-all-words",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nconst findSubstring = function(s, words) {\n  if (words == null || words.length === 0 || !s) return []\n  const wh = {}\n  const slen = s.length\n  const wl = words[0].length\n  const len = words[0].length * words.length\n  words.forEach(el => {\n    if (wh[el]) wh[el]++\n    else wh[el] = 1\n  })\n  const res = []\n  for (let i = 0; i < slen - len + 1; i++) {\n    if (chk(wh, s.slice(i, i + len), wl, words.length)) res.push(i)\n  }\n  return res\n}\n\nfunction chk(hash, str, wl, num) {\n  const oh = {}\n  for (let i = 0; i < num; i++) {\n    let tmp = str.slice(i * wl, i * wl + wl)\n    if (oh[tmp]) oh[tmp]++\n    else oh[tmp] = 1\n  }\n  const keys = Object.keys(hash)\n  for (let i = 0; i < keys.length; i++) {\n    if (oh[keys[i]] !== hash[keys[i]]) return false\n  }\n  return true\n}\n\n// another\n\n/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nconst findSubstring = function(s, words) {\n  if (s === \"\" || words.length === 0) return []\n  const wordMap = new Map()\n  words.forEach(item => {\n    if (wordMap.has(item)) {\n      wordMap.set(item, wordMap.get(item) + 1)\n    } else {\n      wordMap.set(item, 1)\n    }\n  })\n  const w = words[0].length\n  const wlen = words.length\n  const ans = []\n  const n = s.length\n  for (let i = 0; i < w; i++) {\n    let left = i\n    let count = 0\n    let sMap = new Map()\n    for (let j = i; j <= n - w; j += w) {\n      let sub = s.substring(j, j + w)\n      if (wordMap.has(sub)) {\n        if (sMap.has(sub)) {\n          sMap.set(sub, sMap.get(sub) + 1)\n        } else {\n          sMap.set(sub, 1)\n        }\n        if (sMap.get(sub) <= wordMap.get(sub)) {\n          count++\n        } else {\n          while (sMap.get(sub) > wordMap.get(sub)) {\n            let next = s.substring(left, left + w)\n            sMap.set(next, sMap.get(next) - 1)\n            if (sMap.get(next) < wordMap.get(next)) {\n              count--\n            }\n            left += w\n          }\n        }\n        if (count === wlen) {\n          ans.push(left)\n          let first = s.substring(left, left + w)\n          sMap.set(first, sMap.get(first) - 1)\n          left += w\n          count--\n        }\n      } else {\n        sMap.clear()\n        count = 0\n        left = j + w\n      }\n    }\n  }\n  return ans\n}\n"
    }
  },
  {
    "name": "300-longest-increasing-subsequence",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst lengthOfLIS = function(nums) {\n  const stack = []\n  for(let e of nums) {\n    if(stack.length === 0 || e > stack[stack.length - 1]) {\n      stack.push(e)\n      continue\n    }\n    let l = 0, r = stack.length - 1, mid\n    while(l < r) {\n      const mid = l + ((r - l) >> 1)\n      if(e > stack[mid]) l = mid + 1\n      else r = mid\n    }\n    stack[l] = e\n  }\n  return stack.length\n};\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst lengthOfLIS = function(nums) {\n    if (nums.length === 0) {\n        return 0\n    }\n    const dp = new Array(nums.length).fill(0)\n    dp[0] = 1\n    let maxans = 1\n    for(let i = 1; i < dp.length; i++) {\n        let maxval = 0\n        for(let j = 0; j < i; j++) {\n            if(nums[i] > nums[j]) {\n                maxval = Math.max(maxval, dp[j])\n            }\n        }\n        dp[i] = maxval + 1\n        maxans = Math.max(maxans, dp[i])\n    }\n    return maxans\n};\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst lengthOfLIS = function(nums) {\n  const n = nums.length\n  const tails = []\n  let res = 0\n  for(let e of nums) {\n    let i = 0, j = res\n    while(i !== j) {\n      const mid = i + ((j - i) >> 1)\n      if(tails[mid] < e) i = mid + 1\n      else j = mid\n    }\n    tails[i] = e\n    if(i === res) res++\n  }\n  return res\n};\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst lengthOfLIS = function(nums) {\n  const n = nums.length, stack = []\n  let res = 0\n  stack.push(nums[0])\n  for(let i = 1; i < n; i++) {\n    const cur = nums[i]\n    if(cur > stack[stack.length - 1]) {\n      stack.push(cur)\n    } else {\n      let l = 0, r = stack.length - 1\n      while(l < r) {\n        let mid = ~~((l + r) / 2)\n        if(stack[mid] < cur) {\n          l = mid + 1\n        } else {\n          r = mid\n        }\n      }\n      stack[l] = cur\n    }\n  }\n  \n  return stack.length\n};\n"
    }
  },
  {
    "name": "301-remove-invalid-parentheses",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {string[]}\n */\nconst removeInvalidParentheses = function(s) {\n  const res = []\n  helper(s, 0, 0, ['(', ')'])\n  return res\n\n  function helper(str, lastI, lastJ, pair) {\n    let openNum = 0, closeNum = 0\n    for(let i = lastI; i < str.length; i++) {\n      if(str[i] === pair[0]) openNum++\n      if(str[i] === pair[1]) closeNum++\n      if(closeNum > openNum) {\n        for(let j = lastJ; j <= i; j++) {\n          if(str[j] === pair[1] && (j === lastJ || str[j - 1] !== pair[1])) {\n            helper(str.slice(0, j) + str.slice(j + 1), i, j, pair)\n          }\n        }\n        return\n      }\n    }\n    let rev = str.split('').reverse().join('')\n    if(pair[0] === '(') {\n      helper(rev, 0, 0, [')', '('])\n    } else {\n      res.push(rev)\n    }\n  }\n};\n\n// another\n\n/**\n * @param {string} s\n * @return {string[]}\n */\nconst removeInvalidParentheses = function(s) {\n  const ans = [];\n  remove(s, ans, 0, 0, [\"(\", \")\"]);\n  return ans;\n};\n\nfunction remove(s, ans, last_i, last_j, par) {\n  for (let stack = 0, i = last_i; i < s.length; i++) {\n    if (s.charAt(i) === par[0]) stack++;\n    if (s.charAt(i) === par[1]) stack--;\n    if (stack >= 0) continue;\n    for (let j = last_j; j <= i; j++) {\n      if (\n        s.charAt(j) === par[1] &&\n        (j === last_j || s.charAt(j - 1) != par[1])\n      ) {\n        remove(s.slice(0, j) + s.slice(j + 1), ans, i, j, par);\n      }\n    }\n    return;\n  }\n  const reversed = s\n    .split(\"\")\n    .reverse()\n    .join(\"\");\n  if (par[0] === \"(\") {\n    remove(reversed, ans, 0, 0, [\")\", \"(\"]);\n  } else {\n    ans.push(reversed);\n  }\n}\n"
    }
  },
  {
    "name": "302-smallest-rectangle-enclosing-black-pixels",
    "code": {
      "JS": "/**\n * @param {character[][]} image\n * @param {number} x\n * @param {number} y\n * @return {number}\n */\nconst minArea = function(image, x, y) {\n  const m = image.length,\n    n = image[0].length;\n  const left = searchColumns(0, y, 0, m, true);\n  const right = searchColumns(y + 1, n, 0, m, false);\n  const top = searchRows(0, x, left, right, true);\n  const bottom = searchRows(x + 1, m, left, right, false);\n  return (right - left) * (bottom - top);\n  function searchColumns(i, j, top, bottom, opt) {\n    while (i != j) {\n      let k = top,\n        mid = ((i + j) >> 1);\n      while (k < bottom && image[k][mid] === \"0\") ++k;\n      if (k < bottom === opt) j = mid;\n      else i = mid + 1;\n    }\n    return i;\n  }\n  function searchRows(i, j, left, right, opt) {\n    while (i != j) {\n      let k = left,\n        mid = ((i + j) >> 1);\n      while (k < right && image[mid][k] === \"0\") ++k;\n      if (k < right === opt) j = mid;\n      else i = mid + 1;\n    }\n    return i;\n  }\n};\n\n// another\n\n/**\n * @param {character[][]} image\n * @param {number} x\n * @param {number} y\n * @return {number}\n */\nconst minArea = function(image, x, y) {\n  let top = x,\n    bottom = x\n  let left = y,\n    right = y\n  function dfs(x, y) {\n    if (\n      x < 0 ||\n      y < 0 ||\n      x >= image.length ||\n      y >= image[0].length ||\n      image[x][y] === '0'\n    )\n      return\n    image[x][y] = '0'\n    top = Math.min(top, x)\n    bottom = Math.max(bottom, x)\n    left = Math.min(left, y)\n    right = Math.max(right, y)\n    dfs(x + 1, y)\n    dfs(x - 1, y)\n    dfs(x, y - 1)\n    dfs(x, y + 1)\n  }\n\n  if (image.length === 0 || image[0].length === 0) return 0\n  dfs(x, y)\n  return (right - left + 1) * (bottom - top + 1)\n}\n\n"
    }
  },
  {
    "name": "304-range-sum-query-2d-immutable",
    "code": {
      "JS": "/**\n * @param {number[][]} matrix\n */\nconst NumMatrix = function(matrix) {\n  const dp = [];\n  if (matrix.length == 0 || matrix[0].length == 0) return;\n  for (let i = 0; i <= matrix.length; i++) {\n    let t = new Array(matrix[0].length + 1).fill(0);\n    dp.push(t);\n  }\n\n  for (let i = 0; i < matrix.length; i++) {\n    for (let j = 0; j < matrix[0].length; j++) {\n      dp[i + 1][j + 1] = dp[i][j + 1] + dp[i + 1][j] + matrix[i][j] - dp[i][j];\n    }\n  }\n\n  this.cache = dp;\n};\n\n/**\n * @param {number} row1\n * @param {number} col1\n * @param {number} row2\n * @param {number} col2\n * @return {number}\n */\nNumMatrix.prototype.sumRegion = function(row1, col1, row2, col2) {\n  const dp = this.cache;\n  return (\n    dp[row2 + 1][col2 + 1] -\n    dp[row1][col2 + 1] -\n    dp[row2 + 1][col1] +\n    dp[row1][col1]\n  );\n};\n\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * var obj = Object.create(NumMatrix).createNew(matrix)\n * var param_1 = obj.sumRegion(row1,col1,row2,col2)\n */\n\n// another\n\n/**\n * @param {number[][]} matrix\n */\nconst NumMatrix = function(matrix) {\n  const m = matrix.length, n = matrix[0].length\n  const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0))\n  for(let i = 1; i <= m; i++) {\n    for(let j = 1; j <= n; j++) {\n      dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + matrix[i - 1][j - 1]\n    }\n  }\n  this.dp = dp\n};\n\n/** \n * @param {number} row1 \n * @param {number} col1 \n * @param {number} row2 \n * @param {number} col2\n * @return {number}\n */\nNumMatrix.prototype.sumRegion = function(row1, col1, row2, col2) {\n  const dp = this.dp\n  return dp[row2 + 1][col2 + 1] - dp[row2 + 1][col1] - dp[row1][col2 + 1] + dp[row1][col1]\n};\n\n/** \n * Your NumMatrix object will be instantiated and called as such:\n * var obj = new NumMatrix(matrix)\n * var param_1 = obj.sumRegion(row1,col1,row2,col2)\n */\n"
    }
  },
  {
    "name": "305-number-of-islands-ii",
    "code": {
      "JS": "/**\n\nA 2d grid map of m rows and n columns is initially filled with water.\nWe may perform an addLand operation which turns the water at position (row, col) into a land.\nGiven a list of positions to operate, count the number of islands after each addLand operation.\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.\nYou may assume all four edges of the grid are all surrounded by water.\n\nExample:\n\nInput: m = 3, n = 3, positions = [[0,0], [0,1], [1,2], [2,1]]\nOutput: [1,1,2,3]\nExplanation:\n\nInitially, the 2d grid grid is filled with water. (Assume 0 represents water and 1 represents land).\n\n0 0 0\n0 0 0\n0 0 0\nOperation #1: addLand(0, 0) turns the water at grid[0][0] into a land.\n\n1 0 0\n0 0 0   Number of islands = 1\n0 0 0\nOperation #2: addLand(0, 1) turns the water at grid[0][1] into a land.\n\n1 1 0\n0 0 0   Number of islands = 1\n0 0 0\nOperation #3: addLand(1, 2) turns the water at grid[1][2] into a land.\n\n1 1 0\n0 0 1   Number of islands = 2\n0 0 0\nOperation #4: addLand(2, 1) turns the water at grid[2][1] into a land.\n\n1 1 0\n0 0 1   Number of islands = 3\n0 1 0\n\n*/\n\n/**\n * @param {number} m\n * @param {number} n\n * @param {number[][]} positions\n * @return {number[]}\n */\nconst numIslands2 = function(m, n, positions) {\n  const result = []\n  if (m <= 0 || n <= 0) return result\n  const dirs = [\n    [0, 1],\n    [0, -1],\n    [1, 0],\n    [-1, 0]\n  ]\n  let count = 0\n  const roots = new Array(m * n).fill(-1)\n  for (let p of positions) {\n    let root = n * p[0] + p[1]\n    if (roots[root] !== -1) {\n      result.push(count)\n      continue\n    }\n    roots[root] = root\n    count++\n    for (let dir of dirs) {\n      const x = p[0] + dir[0]\n      const y = p[1] + dir[1]\n      const nb = n * x + y\n      if (x < 0 || x >= m || y < 0 || y >= n || roots[nb] === -1) continue\n      const rootNb = findIsland(roots, nb)\n      if (root !== rootNb) {\n        roots[root] = rootNb\n        root = rootNb\n        count--\n      }\n    }\n    result.push(count)\n  }\n  return result\n}\n\nfunction findIsland(roots, id) {\n  while (id !== roots[id]) {\n    roots[id] = roots[roots[id]]\n    id = roots[id]\n  }\n  return id\n}\n"
    }
  },
  {
    "name": "306-additive-number",
    "code": {
      "JS": "/**\n\nAdditive number is a string whose digits can form additive sequence.\nA valid additive sequence should contain at least three numbers.\nExcept for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.\nGiven a string containing only digits '0'-'9', write a function to determine if it's an additive number.\nNote: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.\n\nExample 1:\n\nInput: \"112358\"\nOutput: true\nExplanation: The digits can form an additive sequence: 1, 1, 2, 3, 5, 8. \n             1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8\n\nExample 2:\n\nInput: \"199100199\"\nOutput: true\nExplanation: The additive sequence is: 1, 99, 100, 199. \n             1 + 99 = 100, 99 + 100 = 199\n \nConstraints:\n\nnum consists only of digits '0'-'9'.\n1 <= num.length <= 35\n\n*/\n\n/**\n * @param {string} num\n * @return {boolean}\n */\nconst isAdditiveNumber = function(num) {\n  const n = num.length\n  for (let i = 1; i <= (n / 2) >> 0; ++i) {\n    if (num.charAt(0) === '0' && i > 1) return false\n    const x1 = +num.slice(0, i)\n    for (let j = 1; Math.max(j, i) <= n - i - j; ++j) {\n      if (num.charAt(i) == '0' && j > 1) break\n      const x2 = +num.slice(i, i + j)\n      if (isValid(x1, x2, j + i, num)) return true\n    }\n  }\n  return false\n}\n\nfunction isValid(x1, x2, start, num) {\n  if (start === num.length) return true\n  x2 = x2 + x1\n  x1 = x2 - x1\n  const sum = x2 + ''\n  return num.startsWith(sum, start) && isValid(x1, x2, start + sum.length, num)\n}\n"
    }
  },
  {
    "name": "307-range-sum-query-mutable",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n */\nconst NumArray = function(nums) {\n    this.arr = nums\n};\n\n/** \n * @param {number} i \n * @param {number} val\n * @return {void}\n */\nNumArray.prototype.update = function(i, val) {\n    this.arr[i] = val\n};\n\n/** \n * @param {number} i \n * @param {number} j\n * @return {number}\n */\nNumArray.prototype.sumRange = function(i, j) {\n    let sum = 0;\n    for (let k = i; k <= j; k++) {\n        sum += this.arr[k];\n    }\n    return sum;\n};\n\n/** \n * Your NumArray object will be instantiated and called as such:\n * var obj = Object.create(NumArray).createNew(nums)\n * obj.update(i,val)\n * var param_2 = obj.sumRange(i,j)\n */\n"
    }
  },
  {
    "name": "308-range-sum-query-2d-mutable",
    "code": {
      "JS": "/**\n * @param {number[][]} matrix\n */\nconst NumMatrix = function(matrix) {\n  this.matrix = matrix\n  if (matrix.length === 0) {\n    this.sums = []\n  } else {\n    this.sums = new Array(matrix.length + 1)\n      .fill()\n      .map(() => new Array(matrix[0].length + 1).fill(0))\n  }\n  this.insert = (i, j, diff) => {\n    for (let n = i; n < this.sums.length; n += n & -n) {\n      for (let m = j; m < this.sums[n].length; m += m & -m) {\n        this.sums[n][m] += diff\n      }\n    }\n  }\n  this.search = (i, j) => {\n    let sum = 0\n    for (let n = i; n > 0; n -= n & -n) {\n      for (let m = j; m > 0; m -= m & -m) {\n        sum += this.sums[n][m]\n      }\n    }\n    return sum\n  }\n  for (let n = 0; n < matrix.length; n++) {\n    for (let m = 0; m < matrix[n].length; m++) {\n      this.insert(n + 1, m + 1, matrix[n][m])\n    }\n  }\n}\n\n/**\n * @param {number} row\n * @param {number} col\n * @param {number} val\n * @return {void}\n */\nNumMatrix.prototype.update = function(row, col, val) {\n  this.insert(row + 1, col + 1, val - this.matrix[row][col])\n  this.matrix[row][col] = val\n}\n\n/**\n * @param {number} row1\n * @param {number} col1\n * @param {number} row2\n * @param {number} col2\n * @return {number}\n */\nNumMatrix.prototype.sumRegion = function(row1, col1, row2, col2) {\n  return (\n    this.search(row2 + 1, col2 + 1) -\n    this.search(row1, col2 + 1) -\n    this.search(row2 + 1, col1) +\n    this.search(row1, col1)\n  )\n}\n\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * var obj = new NumMatrix(matrix)\n * obj.update(row,col,val)\n * var param_2 = obj.sumRegion(row1,col1,row2,col2)\n */\n"
    }
  },
  {
    "name": "309-best-time-to-buy-and-sell-stock-with-cooldown",
    "code": {
      "JS": "/**\r\n * @param {number[]} prices\r\n * @return {number}\r\n */\r\nconst maxProfit = function(prices) {\r\n  if (prices === null || prices.length < 1) {\r\n    return 0;\r\n  }\r\n\r\n  const length = prices.length;\r\n  // buy[i]: max profit if the first \"i\" days end with a \"buy\" day\r\n  const buy = Array(length + 1).fill(0); \r\n  // buy[i]: max profit if the first \"i\" days end with a \"sell\" day\r\n  const sell = Array(length + 1).fill(0); \r\n\r\n  buy[1] = -prices[0];\r\n\r\n  for (let i = 2; i <= length; i++) {\r\n    const price = prices[i - 1];\r\n    buy[i] = Math.max(buy[i - 1], sell[i - 2] - price);\r\n    sell[i] = Math.max(sell[i - 1], buy[i - 1] + price);\r\n  }\r\n\r\n  // sell[length] >= buy[length]\r\n  return sell[length];\r\n};\r\n"
    }
  },
  {
    "name": "31-next-permutation",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nconst nextPermutation = function(nums) {\n    let i = nums.length - 2;\n    while (i >= 0 && nums[i + 1] <= nums[i]) {\n        i--;\n    }\n    if (i >= 0) {\n        let j = nums.length - 1;\n        while (j >= 0 && nums[j] <= nums[i]) {\n            j--;\n        }\n        swap(nums, i, j);\n    }\n    reverse(nums, i + 1);\n  \n};\n\nfunction reverse(nums, start) {\n    let i = start, j = nums.length - 1;\n    while (i < j) {\n        swap(nums, i, j);\n        i++;\n        j--;\n    }\n}\n\nfunction swap(arr, i, j) {\n  arr[i] ^= arr[j];\n  arr[j] ^= arr[i];\n  arr[i] ^= arr[j];\n}\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nconst nextPermutation = function(nums) {\n  const n = nums.length\n  let start, end\n  for(let i = n - 2; i >= 0; i--) {\n    if(nums[i] < nums[i + 1]) {\n      start = i\n      break\n    }\n  }\n  if(start == null) {\n    reverse(nums, 0, n - 1)\n  } else {\n    for(let i = n - 1; i >= 0; i--) {\n      if(nums[i] > nums[start]) {\n        end = i\n        break\n      }\n    }\n    swap(nums, start, end)\n    reverse(nums, start + 1, n - 1)\n  }\n};\nfunction reverse(arr, start, end) {\n  while(start < end) {\n    swap(arr, start++, end--)\n  }\n}\nfunction swap(arr, i, j) {\n  const tmp = arr[i]\n  arr[i] = arr[j]\n  arr[j] = tmp\n}\n"
    }
  },
  {
    "name": "310-minimum-height-trees",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {number[]}\n */\n const findMinHeightTrees = function(n, edges) {\n  if(n === 1) return [0]\n  const res = [], graph = {}\n  for(const [u, v] of edges) {\n    if(graph[u] == null) graph[u] = new Set()\n    if(graph[v] == null) graph[v] = new Set()\n    graph[u].add(v)\n    graph[v].add(u)\n  }\n\n  let leaves = []\n  Object.keys(graph).forEach(k => {\n    if(graph[k].size === 1) leaves.push(+k)\n  })\n  while(n > 2) {\n    const newLeaves = []\n    const size = leaves.length\n    for (let i = 0; i < size; i++) {\n      const cur = leaves.pop()\n      for (const next of graph[cur]) {\n        graph[next].delete(cur)\n        if(graph[next].size === 1) newLeaves.push(next)\n      }\n    }\n    n -= size\n    leaves = newLeaves\n  }\n  \n  return leaves\n};\n\n// another\n\n/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {number[]}\n */\nconst findMinHeightTrees = function(n, edges) {\n  if (n === 1) {\n    return [0];\n  }\n  const adj = [];\n  for (let i = 0; i < n; i++) {\n    adj.push([]);\n  }\n  for (let edge of edges) {\n    adj[edge[0]].push(edge[1]);\n    adj[edge[1]].push(edge[0]);\n  }\n  let leaves = [];\n  for (let i = 0; i < n; i++) {\n    if (adj[i].length === 1) {\n      leaves.push(i);\n    }\n  }\n\n  while (n > 2) {\n    n -= leaves.length;\n    let newLeaves = [];\n    for (let i of leaves) {\n      let j = adj[i].shift();\n      let idx = adj[j].indexOf(i);\n      adj[j].splice(idx, 1);\n      if (adj[j].length === 1) newLeaves.push(j);\n    }\n    leaves = newLeaves;\n  }\n\n  return leaves;\n};\n"
    }
  },
  {
    "name": "311-sparse-matrix-multiplication",
    "code": {
      "JS": "/**\n\nGiven two sparse matrices A and B, return the result of AB.\nYou may assume that A's column number is equal to B's row number.\n\nExample:\n\nInput:\n\nA = [\n  [ 1, 0, 0],\n  [-1, 0, 3]\n]\n\nB = [\n  [ 7, 0, 0 ],\n  [ 0, 0, 0 ],\n  [ 0, 0, 1 ]\n]\n\nOutput:\n\n     |  1 0 0 |   | 7 0 0 |   |  7 0 0 |\nAB = | -1 0 3 | x | 0 0 0 | = | -7 0 3 |\n                  | 0 0 1 |\n\n*/\n\n/**\n * @param {number[][]} A\n * @param {number[][]} B\n * @return {number[][]}\n */\nconst multiply = function(A, B) {\n  const aLen = A.length, bLen = B.length\n  if(aLen === 0 || bLen === 0) return []\n  const aCol = A[0].length, bCol = B[0].length\n  const res = Array.from({ length: aLen }, () => new Array(bCol).fill(0))\n  for(let i = 0; i < aLen; i++) {\n    for(let j = 0; j < bCol; j++) {\n      let tmp = 0\n      for(let k = 0; k < bLen; k++) {\n        tmp += A[i][k] * B[k][j]\n      }\n      res[i][j] = tmp\n    }\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "312-burst-balloons",
    "code": {
      "JS": "function maxCoins(arr) {\n  const len = arr.length\n  const nums = Array(len + 2).fill(0);\n  let n = 1;\n  for (const x of arr) if (x > 0) nums[n++] = x;\n  nums[0] = nums[n++] = 1;\n\n  const dp = Array.from({ length: n }, () => Array(n).fill(0));\n  for (let k = 2; k < n; k++) {\n    for (let left = 0; left < n - k; left++) {\n      let right = left + k;\n      for (let i = left + 1; i < right; i++) {\n        dp[left][right] = Math.max(\n          dp[left][right],\n          nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right],\n        );\n      }\n    }\n  }\n\n  return dp[0][n - 1];\n}\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst maxCoins = iNums => {\n  const nums = new Array(iNums.length + 2);\n  let n = 1;\n  for (let x of iNums) if (x > 0) nums[n++] = x;\n  nums[0] = nums[n++] = 1;\n\n  const memo = Array.from({ length: n }, () => new Array(n));\n  return burst(memo, nums, 0, n - 1);\n};\n\nfunction burst(memo, nums, left, right) {\n  if (left + 1 === right) return 0;\n  if (memo[left][right] > 0) return memo[left][right];\n  let ans = 0;\n  for (let i = left + 1; i < right; ++i)\n    ans = Math.max(\n      ans,\n      nums[left] * nums[i] * nums[right] +\n        burst(memo, nums, left, i) +\n        burst(memo, nums, i, right)\n    );\n  memo[left][right] = ans;\n  return ans;\n}\n"
    }
  },
  {
    "name": "313-super-ugly-number",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[]} primes\n * @return {number}\n */\nconst nthSuperUglyNumber = function(n, primes) {\n  if (n === 1) return 1\n  const indexes = new Array(primes.length).fill(0)\n  const arr = [1]\n  for (let i = 1; i <= n - 1; i++) {\n    arr[i] = +Infinity\n    for (let j = 0; j < primes.length; j++) {\n      arr[i] = Math.min(arr[i], arr[indexes[j]] * primes[j])\n    }\n    for (let j = 0; j < primes.length; j++) {\n      if (arr[i] === arr[indexes[j]] * primes[j]) {\n        indexes[j]++\n      }\n    }\n  }\n  return arr[n - 1]\n}\n\n// another\n\n/**\n * @param {number} n\n * @param {number[]} primes\n * @return {number}\n */\nconst nthSuperUglyNumber = function(n, primes) {\n  const ugly = Array(n).fill(0)\n  const pq = new PriorityQueue((a, b) => a[0] < b[0])\n  \n  for(let i = 0; i < primes.length; i++) pq.push([primes[i], 1, primes[i]])\n  ugly[0] = 1\n  for(let i = 1; i < n; i++) {\n    ugly[i] = pq.peek()[0]\n    while(pq.peek()[0] === ugly[i]) {\n      const next = pq.pop()\n      pq.push([next[2] * ugly[next[1]], next[1] + 1, next[2]])\n    }\n  }\n  \n  return ugly[n - 1]\n};\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n"
    }
  },
  {
    "name": "314-binary-tree-vertical-order-traversal",
    "code": {
      "JS": "/**\n\nGiven a binary tree, return the vertical order traversal of its\nnodes' values. (ie, from top to bottom, column by column).\n\nIf two nodes are in the same row and column, the order\nshould be from left to right.\n\nExamples 1:\n\nInput: [3,9,20,null,null,15,7]\n\n   3\n  /\\\n /  \\\n 9  20\n    /\\\n   /  \\\n  15   7 \n\nOutput:\n\n[\n  [9],\n  [3,15],\n  [20],\n  [7]\n]\n\nExamples 2:\n\nInput: [3,9,8,4,0,1,7]\n\n     3\n    /\\\n   /  \\\n   9   8\n  /\\  /\\\n /  \\/  \\\n 4  01   7 \n\nOutput:\n\n[\n  [4],\n  [9],\n  [3,0,1],\n  [8],\n  [7]\n]\n\nExamples 3:\n\nInput: [3,9,8,4,0,1,7,null,null,null,2,5] (0's right child is 2 and 1's left child is 5)\n\n     3\n    /\\\n   /  \\\n   9   8\n  /\\  /\\\n /  \\/  \\\n 4  01   7\n    /\\\n   /  \\\n   5   2\n\nOutput:\n\n[\n  [4],\n  [9,5],\n  [3,0,1],\n  [8,2],\n  [7]\n]\n\n*/\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nconst verticalOrder = function(root) {\n  const res = []\n  if(root == null) return res\n  const map = new Map()\n  const q = []\n  const cols = []\n  q.push(root)\n  cols.push(0)\n  let min = 0\n  let max = 0\n  while(q.length) {\n    const node = q.shift()\n    const col = cols.shift()\n    if(!map.has(col)) {\n      map.set(col, [])\n    }\n    map.get(col).push(node.val)\n    if(node.left !== null) {\n      q.push(node.left)\n      cols.push(col - 1)\n      min = Math.min(min, col - 1)\n    }\n    if(node.right !== null) {\n      q.push(node.right)\n      cols.push(col + 1)\n      max = Math.max(max, col + 1)\n    }\n  }\n  for(let i = min; i <= max; i++) {\n    res.push(map.get(i))\n  }\n  return res\n};\n\n// another\n\nconst verticalOrder = function(root) {\n  if (!root) return []\n  let result = []\n  function recurse(root, col, row) {\n    if (!root) return\n    recurse(root.left, col - 1, row + 1)\n    recurse(root.right, col + 1, row + 1)\n    result[col] = result[col] || []\n    result[col][row] = result[col][row] || []\n    result[col][row].push(root.val)\n  }\n\n  recurse(root, 100, 0)\n  return result\n    .filter(x => x)\n    .map(row => row.reduce((acc, val) => acc.concat(val), []))\n}\n\n\n"
    }
  },
  {
    "name": "315-count-of-smaller-numbers-after-self",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nconst countSmaller = function(nums) {\n  const numsAndIndexes = nums.map((x, i) => [x, i])\n  const output = [...new Array(nums.length)].map(_ => 0)\n  mergeSort(numsAndIndexes, output)\n  return output\n}\n\nfunction mergeSort(arr, output) {\n  if (arr.length <= 1) return arr\n  const middle = Math.floor(arr.length / 2)\n  const left = mergeSort(arr.slice(0, middle), output),\n    right = mergeSort(arr.slice(middle), output)\n  const sorted = []\n  let i = 0,\n    j = 0\n  while (i < left.length || j < right.length) {\n    if (i >= left.length) {\n      sorted.push(right[j])\n      j++\n    } else if (j >= right.length) {\n      sorted.push(left[i])\n      i++\n    } else {\n      if (left[i][0] > right[j][0]) {\n        sorted.push(left[i])\n        output[left[i][1]] += right.length - j\n        i++\n      } else {\n        sorted.push(right[j])\n        j++\n      }\n    }\n  }\n\n  return sorted\n}\n\n// another\n\nclass Node {\n  constructor(v, s) {\n    this.val = v\n    this.sum = s\n    this.left = null\n    this.right = null\n    this.dup = 1\n  }\n}\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\nconst countSmaller = function(nums) {\n  const ans = new Array(nums.length).fill(0)\n  let root = null\n  for (let i = nums.length - 1; i >= 0; i--) {\n    root = insert(nums[i], root, ans, i, 0)\n  }\n  return ans\n}\n\nfunction insert(num, node, ans, i, preSum) {\n  if (node == null) {\n    node = new Node(num, 0)\n    ans[i] = preSum\n  } else if (node.val == num) {\n    node.dup++\n    ans[i] = preSum + node.sum\n  } else if (node.val > num) {\n    node.sum++\n    node.left = insert(num, node.left, ans, i, preSum)\n  } else {\n    node.right = insert(num, node.right, ans, i, preSum + node.dup + node.sum)\n  }\n  return node\n}\n"
    }
  },
  {
    "name": "316-remove-duplicate-letters",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {string}\n */\nconst removeDuplicateLetters = function(s) {\n  const last = {}\n  for (let i = 0; i < s.length; i++) last[s.charAt(i)] = i\n  const added = {}\n  const stack = []\n  for (let i = 0; i < s.length; i++) {\n    const char = s.charAt(i)\n    if (added[char]) continue\n    while (stack.length && char < stack[0] && last[stack[0]] > i) {\n      added[stack[0]] = false\n      stack.shift()\n    }\n    stack.unshift(char)\n    added[char] = true\n  }\n  return stack.reverse().join('')\n}\n\n// another\n\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst removeDuplicateLetters = function(s) {\n  const m = new Array(26)\n  const a = 'a'.charCodeAt(0)\n  for (let i = 0; i < s.length; i++) {\n    const k = s.charCodeAt(i) - a\n    m[k] = m[k] ? m[k] + 1 : 1\n  }\n  const aChNo = []\n  const visited = {}\n  for (let i = 0; i < s.length; i++) {\n    const k = s.charCodeAt(i) - a\n    m[k]--\n    if (visited[k]) continue\n    while (aChNo.length > 0) {\n      const last = aChNo[aChNo.length - 1] - a\n      if (last > k && m[last] > 0) {\n        visited[last] = 0\n        aChNo.pop()\n      } else break\n    }\n    visited[k] = 1\n    aChNo.push(k + a)\n  }\n  return String.fromCharCode(...aChNo)\n}\n\n// another\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst removeDuplicateLetters = function(s) {\n  const last = {}\n  for (let i = 0; i < s.length; i++) last[s.charAt(i)] = i\n  const added = {}\n  const stack = []\n  for (let i = 0; i < s.length; i++) {\n    const char = s.charAt(i)\n    if (added[char]) continue\n    while (stack.length && char < stack[stack.length - 1] && last[stack[stack.length - 1]] > i) {\n      added[stack[stack.length - 1]] = false\n      stack.pop()\n    }\n    stack.push(char)\n    added[char] = true\n  }\n  return stack.join('')\n}\n"
    }
  },
  {
    "name": "317-shortest-distance-from-all-buildings",
    "code": {
      "JS": "const DIRECTIONS = [\n  [0, 1],\n  [1, 0],\n  [0, -1],\n  [-1, 0]\n]\n\nfunction distanceFromBuilding(grid, r, c, distance, start) {\n  const rows = grid.length\n  const cols = grid[0].length\n  const queue = [[r, c, 1]]\n  let qIndex = 0\n  let minDistance = Infinity\n  while (qIndex < queue.length) {\n    const [r0, c0, d] = queue[qIndex]\n    for (const [dr, dc] of DIRECTIONS) {\n      const r1 = r0 + dr\n      const c1 = c0 + dc\n      if (\n        0 <= r1 &&\n        r1 < rows &&\n        0 <= c1 &&\n        c1 < cols &&\n        grid[r1][c1] === start\n      ) {\n        distance[r1][c1] += d\n        minDistance = Math.min(minDistance, distance[r1][c1])\n        grid[r1][c1] -= 1\n        queue.push([r1, c1, d + 1])\n      }\n    }\n    qIndex += 1\n  }\n  return minDistance\n}\n\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nconst shortestDistance = function(grid) {\n  const rows = grid.length\n  const cols = grid[0].length\n  const distance = new Array(rows).fill(null).map(() => new Array(cols).fill(0))\n  let start = 0\n  let minDistance = 0\n  for (let r = 0; r < rows; r += 1) {\n    for (let c = 0; c < cols; c += 1) {\n      if (grid[r][c] === 1) {\n        minDistance = distanceFromBuilding(grid, r, c, distance, start)\n        if (minDistance === Infinity) {\n          return -1\n        }\n        start -= 1\n      }\n    }\n  }\n  return minDistance\n}\n"
    }
  },
  {
    "name": "318-maximum-product-of-word-lengths",
    "code": {
      "JS": "/**\r\n * @param {string[]} words\r\n * @return {number}\r\n */\r\nconst maxProduct = function(words) {\r\n  if (words == null || words.length === 0) return 0;\r\n  let len = words.length;\r\n  let value = [];\r\n  for (let i = 0; i < len; i++) {\r\n    let tmp = words[i];\r\n    value[i] = 0;\r\n    for (let j = 0; j < tmp.length; j++) {\r\n      value[i] |= 1 << (tmp.charAt(j).charCodeAt(0) - \"a\".charCodeAt(0));\r\n    }\r\n  }\r\n  let maxProductNum = 0;\r\n  for (let i = 0; i < len; i++)\r\n    for (let j = i + 1; j < len; j++) {\r\n      if (\r\n        (value[i] & value[j]) === 0 &&\r\n        words[i].length * words[j].length > maxProductNum\r\n      )\r\n        maxProductNum = words[i].length * words[j].length;\r\n    }\r\n  return maxProductNum;\r\n};\r\n"
    }
  },
  {
    "name": "319-bulb-switcher",
    "code": {
      "JS": "/**\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nconst bulbSwitch = function(n) {\r\n  return Math.floor(Math.sqrt(n));\r\n};\r\n"
    }
  },
  {
    "name": "32-longest-valid-parentheses",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst longestValidParentheses = function(s) {\n  const arr = s.split(\"\")\n  const dp = new Array(arr.length).fill(0)\n  let open = 0\n  let max = 0\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === \"(\") open++\n    if (arr[i] === \")\" && open > 0) {\n      dp[i] = 2 + dp[i - 1]\n      if (i - dp[i] > 0) dp[i] += dp[i - dp[i]]\n      open--\n    }\n    if (dp[i] > max) max = dp[i]\n  }\n  return max\n}\n\n// another\n\nconst longestValidParentheses = function(s) {\n  let longest = 0\n  let stack = [-1]\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === \"(\") {\n      stack.push(i)\n    } else {\n      stack.pop()\n      if (!stack.length) stack.push(i)\n      else longest = Math.max(longest, i - stack[stack.length - 1])\n    }\n  }\n\n  return longest\n}\n\n// another\n\n/**\n * @param {string} s\n * @return {number}\n */\nconst longestValidParentheses = function (s) {\n  let res = 0,\n    stk = [],\n    n = s.length,\n    idxStk = []\n  for (let i = 0; i < n; i++) {\n    const ch = s[i]\n    if (stk.length && stk[stk.length - 1] === '(' && ch === ')')\n      stk.pop(), idxStk.pop()\n    else stk.push(ch), idxStk.push(i)\n    res = Math.max(res, i - (idxStk.length ? idxStk[idxStk.length - 1] : -1))\n  }\n  return res\n}\n/**\n * @param {string} s\n * @return {number}\n */\nconst longestValidParentheses = function (s) {\n  let res = 0,\n    stk = [],\n    n = s.length,\n    idxStk = []\n  for (let i = 0; i < n; i++) {\n    const ch = s[i]\n    if (stk.length && stk[stk.length - 1] === '(' && ch === ')')\n      stk.pop(), idxStk.pop()\n    else stk.push(ch), idxStk.push(i)\n    res = Math.max(res, i - (idxStk.length ? idxStk[idxStk.length - 1] : -1))\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "320-generalized-abbreviation",
    "code": {
      "JS": "/**\n\nWrite a function to generate the generalized abbreviations of a word. \nNote: The order of the output does not matter.\n\nExample:\n\nInput: \"word\"\nOutput:\n[\"word\", \"1ord\", \"w1rd\", \"wo1d\", \"wor1\", \"2rd\", \"w2d\", \"wo2\", \"1o1d\", \"1or1\", \"w1r1\", \"1o2\", \"2r1\", \"3d\", \"w3\", \"4\"]\n\n*/\n\n/**\n * @param {string} word\n * @return {string[]}\n */\nconst generateAbbreviations = function(word) {\n  const arr = []\n  dfs(arr, word, 0, '', 0)\n  return arr\n};\n\nfunction dfs(res, word, pos, cur, cnt) {\n  if(pos === word.length) {\n    if(cnt > 0) cur += cnt\n    res.push(cur)\n  } else {\n    dfs(res, word, pos + 1, cur, cnt + 1)\n    dfs(res, word, pos + 1, cur + (cnt > 0 ? cnt : '') + word.charAt(pos), 0)\n  }\n}\n"
    }
  },
  {
    "name": "321-create-maximum-number",
    "code": {
      "JS": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @param {number} k\n * @return {number[]}\n */\nconst maxNumber = function(nums1, nums2, k) {\n  const n = nums1.length\n  const m = nums2.length\n  let ans = new Array(k).fill(0)\n  for (let i = Math.max(0, k - m); i <= k && i <= n; i++) {\n    const candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k)\n    if (greater(candidate, 0, ans, 0)) ans = candidate\n  }\n  return ans\n}\n\nfunction merge(nums1, nums2, k) {\n  const ans = new Array(k)\n  for (let i = 0, j = 0, r = 0; r < k; r++) {\n    ans[r] = greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++]\n  }\n  return ans\n}\n\nfunction greater(nums1, i, nums2, j) {\n  while (i < nums1.length && j < nums2.length && nums1[i] === nums2[j]) {\n    i++\n    j++\n  }\n  return j === nums2.length || (i < nums1.length && nums1[i] > nums2[j])\n}\n\nfunction maxArray(nums, k) {\n  const n = nums.length\n  const ans = new Array(k)\n  for (let i = 0, j = 0; i < n; i++) {\n    while (n - i > k - j && j > 0 && ans[j - 1] < nums[i]) j--\n    if (j < k) ans[j++] = nums[i]\n  }\n  return ans\n}\n"
    }
  },
  {
    "name": "322-coin-change",
    "code": {
      "JS": "/**\n * @param {number[]} coins\n * @param {number} amount\n * @return {number}\n */\nconst coinChange = function(coins, amount) {\n  const dp = new Array(amount + 1).fill(amount + 1)\n  dp[0] = 0\n  for (let i = 1; i <= amount; i++) {\n    for (let coin of coins) {\n      if (coin <= i) dp[i] = Math.min(dp[i], dp[i - coin] + 1)\n    }\n  }\n  return dp[amount] === amount + 1 ? -1 : dp[amount]\n}\n"
    }
  },
  {
    "name": "322-reconstruct-itinerary",
    "code": {
      "JS": "/**\n * @param {string[][]} tickets\n * @return {string[]}\n */\nconst findItinerary = function (tickets) {\n  const result = []\n  const map = new Map()\n  for (const [from, to] of tickets) {\n    if (!map.has(from)) {\n      map.set(from, [])\n    }\n    map.get(from).push(to)\n  }\n  for (const key of map.keys()) {\n    map.get(key).sort()\n  }\n  function dfs(departure) {\n    const destination = map.get(departure)\n    while (destination && destination.length) {\n      const newDeparture = destination.shift()\n      dfs(newDeparture)\n    }\n    result.push(departure)\n  }\n  dfs('JFK')\n  return result.reverse()\n}\n"
    }
  },
  {
    "name": "323-number-of-connected-components-in-an-undirected-graph",
    "code": {
      "JS": "/**\n\nGiven n nodes labeled from 0 to n - 1 and a list of undirected\nedges (each edge is a pair of nodes), write a function to find\nthe number of connected components in an undirected graph.\n\nExample 1:\n\nInput: n = 5 and edges = [[0, 1], [1, 2], [3, 4]]\n\n     0          3\n     |          |\n     1 --- 2    4 \n\nOutput: 2\n\nExample 2:\n\nInput: n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]]\n\n     0           4\n     |           |\n     1 --- 2 --- 3\n\nOutput:  1\n\nNote:\nYou can assume that no duplicate edges will appear in edges.\nSince all edges are undirected, [0, 1] is the same\nas [1, 0] and thus will not appear together in edges.\n\n*/\n\n/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {number}\n */\nconst countComponents = function(n, edges) {\n  const nums = Array(n).fill(-1)\n  for (let i = 0; i < edges.length; i++) {\n    const x = find(nums, edges[i][0])\n    const y = find(nums, edges[i][1])\n    if (x !== y) nums[x] = y\n  }\n  return nums.filter(num => num === -1).length\n}\n\nconst find = (nums, i) => {\n  if (nums[i] === -1) return i\n  return find(nums, nums[i])\n}\n"
    }
  },
  {
    "name": "324-wiggle-sort-ii",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nconst wiggleSort = function(nums) {\n  nums.sort((a, b) => a - b)\n  const ref = [...nums]\n  let j = nums.length - 1\n  for (let i = 1; i < nums.length; i += 2, j--) nums[i] = ref[j]\n  for (let i = 0; i < nums.length; i += 2, j--) nums[i] = ref[j]\n}\n"
    }
  },
  {
    "name": "325-maximum-size-subarray-sum-equals-k",
    "code": {
      "JS": "/**\n\nGiven an array nums and a target value k,\nfind the maximum length of a subarray that sums to k.\nIf there isn't one, return 0 instead.\n\nNote:\nThe sum of the entire nums array is guaranteed to fit within the 32-bit signed integer range.\n\nExample 1:\n\nInput: nums = [1, -1, 5, -2, 3], k = 3\nOutput: 4 \nExplanation: The subarray [1, -1, 5, -2] sums to 3 and is the longest.\n\nExample 2:\n\nInput: nums = [-2, -1, 2, 1], k = 1\nOutput: 2 \nExplanation: The subarray [-1, 2] sums to 1 and is the longest.\n\nFollow Up:\nCan you do it in O(n) time?\n\n*/\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nconst maxSubArrayLen = function(nums, k) {\n  let sum = 0, max = 0\n  const m = new Map()\n  for(let i = 0, len = nums.length; i < len; i++) {\n    sum += nums[i]\n    if(sum === k) max = i + 1\n    else if(m.has(sum - k)) max = Math.max(max, i - m.get(sum - k))\n    if(!m.has(sum)) m.set(sum, i)\n  }\n  return max\n};\n"
    }
  },
  {
    "name": "326-power-of-three",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {boolean}\n */\nconst isPowerOfThree = function(n) {\n  const maxInt = Math.pow(3,30)\n  if(n < 0) {\n    return false\n  }\n  return maxInt % n === 0\n} \n\n// another\n\nconst isPowerOfThree = function(n) {\n  if (n == 1) return true\n  if (n === 0) return false\n  if (n % 3 !== 0) return false\n  if (n == 3) return true\n  return isPowerOfThree(n / 3)\n}\n\n// another\n\nconst isPowerOfThree = function(n) {\n  if(n == null || n === 0) return false\n  let num = 1\n  while(num < n) {\n    num *= 3\n  }  \n  return num > n ? false : true\n}\n"
    }
  },
  {
    "name": "327-count-of-range-sum",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} lower\n * @param {number} upper\n * @return {number}\n */\nconst countRangeSum = function (nums, lower, upper) {\n  if (nums.length === 0) return 0\n  const sums = [nums[0]]\n  for (let i = 1; i < nums.length; i++) {\n    sums[i] = sums[i - 1] + nums[i]\n  }\n  function merge_sort(A, lo, hi) {\n    if (hi - lo === 1) {\n      return sums[lo] >= lower && sums[lo] <= upper ? 1 : 0\n    }\n    const mid = lo + Math.floor((hi - lo) / 2)\n    let counter = merge_sort(A, lo, mid) + merge_sort(A, mid, hi)\n    let m = mid,\n      n = mid\n    for (let i = lo; i < mid; i++) {\n      while (m !== hi && sums[m] - sums[i] < lower) {\n        m++\n      }\n      while (n !== hi && sums[n] - sums[i] <= upper) {\n        n++\n      }\n      counter += n - m\n    }\n    const M = A.slice(lo, mid)\n    const N = A.slice(mid, hi)\n    M.push(Number.MAX_SAFE_INTEGER)\n    N.push(Number.MAX_SAFE_INTEGER)\n    for (let k = lo, i = 0, j = 0; k < hi; k++) {\n      A[k] = M[i] < N[j] ? M[i++] : N[j++]\n    }\n    return counter\n  }\n  return merge_sort(sums, 0, nums.length)\n}\n"
    }
  },
  {
    "name": "328-odd-even-linked-list",
    "code": {
      "JS": "/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nconst oddEvenList = function(head) {\r\n  if (head === null) return null;\r\n  let odd = head,\r\n    even = head.next,\r\n    evenHead = even;\r\n  while (even !== null && even.next !== null) {\r\n    odd.next = even.next;\r\n    odd = odd.next;\r\n    even.next = odd.next;\r\n    even = even.next;\r\n  }\r\n  odd.next = evenHead;\r\n  return head;\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nfunction oddEvenList(head) {\r\n  if(head == null) return head\r\n  const dummyOdd = new ListNode()\r\n  const dummyEven = new ListNode()\r\n  \r\n  dummyOdd.next = head\r\n  let odd = head, even = dummyEven\r\n  let idx = 2, cur = head.next\r\n  while(cur) {\r\n    if (idx % 2 === 1) {\r\n      odd.next = cur\r\n      odd = odd.next\r\n    } else {\r\n      even.next = cur\r\n      even = even.next\r\n    }\r\n    cur = cur.next\r\n    idx++\r\n  }\r\n  odd.next = dummyEven.next\r\n  even.next = null\r\n  return dummyOdd.next\r\n}\r\n"
    }
  },
  {
    "name": "329-longest-increasing-path-in-a-matrix",
    "code": {
      "JS": "/**\n * @param {number[][]} matrix\n * @return {number}\n */\nconst longestIncreasingPath = function (matrix) {\n  const dirs = [\n    [-1, 0],\n    [1, 0],\n    [0, -1],\n    [0, 1],\n  ]\n  const m = matrix.length,\n    n = matrix[0].length\n  let res = 1\n  const memo = Array.from({ length: m }, () => Array(n).fill(0))\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      const tmp = dfs(matrix, i, j, m, n, memo, dirs)\n      res = Math.max(tmp, res)\n    }\n  }\n  return res\n}\n\nfunction dfs(matrix, i, j, m, n, memo, dirs) {\n  if (memo[i][j] !== 0) return memo[i][j]\n  let res = 1\n  for (let [dx, dy] of dirs) {\n    const nx = i + dx,\n      ny = j + dy\n    if (\n      nx < 0 ||\n      nx >= m ||\n      ny < 0 ||\n      ny >= n ||\n      matrix[nx][ny] <= matrix[i][j]\n    )\n      continue\n    const tmp = 1 + dfs(matrix, nx, ny, m, n, memo, dirs)\n    res = Math.max(res, tmp)\n  }\n  memo[i][j] = res\n  return res\n}\n"
    }
  },
  {
    "name": "33-search-in-rotated-sorted-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nconst search = function(nums, target) {\n    const len = nums.length\n    let r = false\n    let ridx = 0\n    if(len === 0) return -1\n    if(nums[0] === target) return 0\n    for(let i = 1; i < len; i++) {\n        if(nums[i] === target) return i\n        if(nums[i] < nums[i - 1]) {\n          r = true\n          ridx = i\n          break\n        }\n    }\n    \n    if(r === true) {\n       for(let i = len - 1; i >= ridx; i--) {\n           if(nums[i] === target) return i\n       }\n    }\n    \n    return -1\n};\n\n// another\n\nconst search = function(nums, target) {\n  const len = nums.length\n  for(let i = 0; nums[i] <= target; i++){\n    if(nums[i] === target){\n      return i\n    }\n  }\n  for(let j = len - 1; nums[j] >= target; j--){\n    if(nums[j] === target){\n      return j\n    }\n  }\n  return -1 \n};\n\n// another \nconst search = function(nums, target) {\n  let low = 0\n  let high = nums.length - 1\n  while (low <= high) {\n    let mid = low + ((high - low) >> 1)\n    if (nums[mid] === target) return mid\n\n    if (nums[low] <= nums[mid] ) {\n      if (target < nums[mid] && target >= nums[low]) {\n        high = mid - 1\n      } else {\n        low = mid + 1\n      }\n    } else {\n      if (target > nums[mid] && target <= nums[high]) {\n        low = mid + 1\n      } else {\n        high = mid - 1\n      }\n    }\n\n  }\n  return -1\n};\n"
    }
  },
  {
    "name": "330-patching-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} n\n * @return {number}\n */\nconst minPatches = function(nums, n) {\n  let answer = 0\n  for (let i = 0, next = 1; next <= n; ) {\n    if (i >= nums.length || nums[i] > next) {\n      answer++\n      next *= 2\n    } else next += nums[i++]\n  }\n  return answer\n}\n"
    }
  },
  {
    "name": "331-verify-preorder-serialization-of-a-binary-tree",
    "code": {
      "JS": "/**\n * @param {string} preorder\n * @return {boolean}\n */\nconst isValidSerialization = function(preorder) {\n    const nodes = preorder.split(',')\n    let diff = 1\n    for(let node of nodes) {\n      if(--diff < 0) return false\n      if(node !== '#') diff += 2\n    }\n    return diff === 0\n};\n"
    }
  },
  {
    "name": "333-largest-bst-subtree",
    "code": {
      "JS": "/**\n\nGiven a binary tree, find the largest subtree\nwhich is a Binary Search Tree (BST),\nwhere largest means subtree with largest number of nodes in it.\n\nNote:\nA subtree must include all of its descendants.\n\nExample:\n\nInput: [10,5,15,1,8,null,7]\n\n   10 \n   / \\ \n  5  15 \n / \\   \\ \n1   8   7\n\nOutput: 3\nExplanation: The Largest BST Subtree in this case is the highlighted one.\n             The return value is the subtree's size, which is 3.\n\n*/\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nconst largestBSTSubtree = function(root) {\n  const res = helper(root)\n  return res[2]\n}\n\nfunction helper(node) {\n  if (!node) return [Number.MAX_VALUE, -Number.MAX_VALUE, 0]\n  const left = helper(node.left)\n  const right = helper(node.right)\n  if (node.val > left[1] && node.val < right[0]) {\n    return [\n      Math.min(node.val, left[0]),\n      Math.max(node.val, right[1]),\n      left[2] + right[2] + 1\n    ]\n  } else {\n    return [-Number.MAX_VALUE, Number.MAX_VALUE, Math.max(left[2], right[2])]\n  }\n}\n\n// another\n\nconst largestBSTSubtree = function(root) {\n  function dfs(node) {\n    if (!node) return [0, 0, Number.MAX_VALUE, -Number.MAX_VALUE]\n    const [N1, n1, min1, max1] = dfs(node.left)\n    const [N2, n2, min2, max2] = dfs(node.right)\n    const n =\n      max1 < node.val && min2 > node.val ? n1 + 1 + n2 : -Number.MAX_VALUE\n    return [\n      Math.max(N1, N2, n),\n      n,\n      Math.min(min1, node.val),\n      Math.max(max2, node.val)\n    ]\n  }\n  return dfs(root)[0]\n}\n"
    }
  },
  {
    "name": "334-increasing-triplet-subsequence",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nconst increasingTriplet = function(nums) {\n    // start with two largest values, as soon as we find a number bigger than both, while both have been updated, return true.\n    let small = Number.MAX_VALUE, big = Number.MAX_VALUE;\n    for (let n of nums) {\n        if (n <= small) { small = n; } // update small if n is smaller than both\n        else if (n <= big) { big = n; } // update big only if greater than small but smaller than big\n        else return true; // return if you find a number bigger than both\n    }\n    return false;\n};\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\nconst increasingTriplet = function(nums) {\n  const n = nums.length, stk = []\n  for(let e of nums) {\n    let l = 0, r = stk.length\n    while(l < r) {\n      const mid = l + Math.floor((r - l) / 2)\n      if (e > stk[mid]) l = mid + 1\n      else r = mid \n    }\n\n    stk[l] = e\n    if(stk.length > 2) return true\n  }\n\n  return false\n};\n"
    }
  },
  {
    "name": "335-self-crossing",
    "code": {
      "JS": "/**\n * @param {number[]} x\n * @return {boolean}\n */\nconst isSelfCrossing = function(x) {\n  for (let i = 3, l = x.length; i < l; i++) {\n    // Case 1: current line crosses the line 3 steps ahead of it\n    if (x[i] >= x[i - 2] && x[i - 1] <= x[i - 3]) return true\n    // Case 2: current line crosses the line 4 steps ahead of it\n    else if (i >= 4 && x[i - 1] == x[i - 3] && x[i] + x[i - 4] >= x[i - 2])\n      return true\n    // Case 3: current line crosses the line 6 steps ahead of it\n    else if (\n      i >= 5 &&\n      x[i - 2] >= x[i - 4] &&\n      x[i] + x[i - 4] >= x[i - 2] &&\n      x[i - 1] <= x[i - 3] &&\n      x[i - 1] + x[i - 5] >= x[i - 3]\n    )\n      return true\n  }\n  return false\n}\n"
    }
  },
  {
    "name": "336-palindrome-pairs",
    "code": {
      "JS": "/**\n\nGiven a list of unique words, find all pairs of distinct indices (i, j) in the given list,\nso that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome.\n\nExample 1:\n\nInput: [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]\nOutput: [[0,1],[1,0],[3,2],[2,4]] \nExplanation: The palindromes are [\"dcbaabcd\",\"abcddcba\",\"slls\",\"llssssll\"]\nExample 2:\n\nInput: [\"bat\",\"tab\",\"cat\"]\nOutput: [[0,1],[1,0]] \nExplanation: The palindromes are [\"battab\",\"tabbat\"]\n\n*/\n\n/**\n * @param {string[]} words\n * @return {number[][]}\n */\nconst palindromePairs = function(words) {\n  const root = new Trie();\n  const pairs = [];\n  words.forEach((word, index) => addWord(word, index, root));\n  words.forEach((word, index) => searchWord(word, index, root, pairs));\n  return pairs;\n};\n\nconst addWord = (word, wordIndex, root) => { \n  const length = word.length;\n  let curr = root;\n  for (let i = length - 1; i >= 0; i--) {\n    let char = word.charAt(i);\n    if (!curr.children[char]) curr.children[char] = new Trie();\n    if (isPalindrome(0, i, word)) curr.words.push(wordIndex);\n    curr = curr.children[char];\n  }\n  curr.wordIndex = wordIndex;\n  curr.words.push(wordIndex);\n}\n\nconst searchWord = (word, wordIndex, root, pairs) => {\n  const length = word.length;\n  let curr = root;\n  for (let i = 0; i < length; i++) {\n    let char = word.charAt(i);\n    if (curr.wordIndex >= 0 && curr.wordIndex !== wordIndex && isPalindrome(i, length - 1, word)) {\n      pairs.push([wordIndex, curr.wordIndex]);\n    }\n    curr = curr.children[char];\n    if (!curr) return;\n  }\n  \n  curr.words.forEach((suffix) => {\n    if (suffix !== wordIndex) pairs.push([wordIndex, suffix]);\n  })\n}\n\nconst isPalindrome = (left, right, word) => {\n  while (left < right) {\n    if (word.charAt(left++) !== word.charAt(right--)) return false;\n  }\n  return true;\n}\n\nclass Trie {\n  constructor() {\n    this.wordIndex = -1;\n    this.children = {};\n    this.words = [];\n  }\n}\n\n// another\n\nconst reverseStr = s => {\n  let str = ''\n  for (let i = 0; i < s.length; i++) {\n    str = s[i] + str\n  }\n  return str\n}\nconst isPalindrome = str => {\n  for (let i = 0; i < str.length / 2; i++) {\n    if (str[i] !== str[str.length - 1 - i]) return false\n  }\n  return true\n}\n/**\n * @param {string[]} words\n * @return {number[][]}\n */\nconst palindromePairs = function(words) {\n  const map = new Map()\n  words.forEach((word, idx) => map.set(word, idx))\n  const result = []\n  if (map.has('')) {\n    const idx = map.get('')\n    words.forEach((word, i) => {\n      if (i !== idx && isPalindrome(word)) {\n        result.push([idx, map.get(word)])\n        result.push([map.get(word), idx])\n      }\n    })\n  }\n  map.delete('')\n  words.forEach((word, idx) => {\n    for (let i = 0; i < word.length; i++) {\n      const left = word.slice(0, i)\n      const right = word.slice(i)\n      if (isPalindrome(left)) {\n        const reversedRight = reverseStr(right)\n        if (map.has(reversedRight) && map.get(reversedRight) !== idx) {\n          result.push([map.get(reversedRight), idx])\n        }\n      }\n      if (isPalindrome(right)) {\n        const reversedLeft = reverseStr(left)\n        if (map.has(reversedLeft) && map.get(reversedLeft) !== idx) {\n          result.push([idx, map.get(reversedLeft)])\n        }\n      }\n    }\n  })\n  return result\n}\n"
    }
  },
  {
    "name": "337-house-robber-iii",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nconst rob = function(root) {\n  return Math.max(...dfs(root))\n}\n\nfunction dfs(node) {\n  if (node == null) return [0, 0]\n  const left = dfs(node.left)\n  const right = dfs(node.right)\n  return [\n    node.val + left[1] + right[1],\n    Math.max(left[0], left[1]) + Math.max(right[0], right[1])\n  ]\n}\n"
    }
  },
  {
    "name": "338-counting-bits",
    "code": {
      "JS": "/**\n * @param {number} num\n * @return {number[]}\n */\nconst countBits = function (num) {\n  const f = new Array(num + 1).fill(0)\n  for (let i = 1; i <= num; i++) f[i] = f[i >> 1] + (i & 1)\n  return f\n}\n"
    }
  },
  {
    "name": "339-nested-list-weight-sum",
    "code": {
      "JS": "/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * function NestedInteger() {\n *\n *     Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     @return {boolean}\n *     this.isInteger = function() {\n *         ...\n *     };\n *\n *     Return the single integer that this NestedInteger holds, if it holds a single integer\n *     Return null if this NestedInteger holds a nested list\n *     @return {integer}\n *     this.getInteger = function() {\n *         ...\n *     };\n *\n *     Set this NestedInteger to hold a single integer equal to value.\n *     @return {void}\n *     this.setInteger = function(value) {\n *         ...\n *     };\n *\n *     Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\n *     @return {void}\n *     this.add = function(elem) {\n *         ...\n *     };\n *\n *     Return the nested list that this NestedInteger holds, if it holds a nested list\n *     Return null if this NestedInteger holds a single integer\n *     @return {NestedInteger[]}\n *     this.getList = function() {\n *         ...\n *     };\n * };\n */\n/**\n * @param {NestedInteger[]} nestedList\n * @return {number}\n */\nconst depthSum = function(nestedList) {\n  return h(nestedList, 1)\n};\n\nfunction h(arr, level) {\n  if(arr == null || arr.length === 0) return 0\n  let sum = 0\n  for(let i = 0, len = arr.length; i < len; i++) {\n    if(arr[i].isInteger()) sum += arr[i].getInteger() * level\n    else {\n      sum += h(arr[i].getList(), level + 1)\n    }\n  }\n  return sum\n}\n\n// another\n\nconst depthSum = function(nestedList) {\n  if(nestedList == null) return 0\n  let sum = 0\n  let level = 1\n  const q = [...nestedList]\n  while(q.length) {\n    const len = q.length\n    for(let i = 0; i < len; i++) {\n      const el = q.shift()\n      if(el.isInteger()) sum += el.getInteger() * level\n      else q.push(...(el.getList()))\n    }\n    level++\n  }\n  return sum\n};\n"
    }
  },
  {
    "name": "34-find-first-and-last-position-of-element-in-sorted-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nconst searchRange = function(nums, target) {\n  let len = nums.length;\n  let start = 0;\n  let end = len - 1;\n  let res = [];\n  let idx;\n  while (start <= end) {\n    let mid = Math.floor((start + end) / 2);\n    if (target === nums[mid]) {\n      idx = mid;\n      break;\n    } else if (target < nums[mid]) end = mid - 1;\n    else start = mid + 1;\n  }\n  if (idx == null) return [-1, -1];\n  let li = idx;\n  let hi = idx;\n  while (nums[li - 1] === target) {\n    li--;\n  }\n  while (nums[hi + 1] === target) {\n    hi++;\n  }\n  res = [li, hi];\n  return res;\n};\n"
    }
  },
  {
    "name": "340-longest-substring-with-at-most-k-distinct-characters",
    "code": {
      "JS": "/**\n\nGiven a string, find the length of the longest substring T that contains at most k distinct characters.\n\nExample 1:\n\nInput: s = \"eceba\", k = 2\nOutput: 3\nExplanation: T is \"ece\" which its length is 3.\nExample 2:\n\nInput: s = \"aa\", k = 1\nOutput: 2\nExplanation: T is \"aa\" which its length is 2.\n\n*/\n\n/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nconst lengthOfLongestSubstringKDistinct = function(s, k) {\n  const map = new Map()\n  let left = 0\n  let best = 0\n  for(let i = 0; i < s.length; i++) {\n    const c = s.charAt(i)\n    map.set(c, (map.get(c) || 0) + 1)\n    while(map.size > k) {\n      const lc = s.charAt(left)\n      map.set(lc, map.get(lc) - 1)\n      if(map.get(lc) === 0) map.delete(lc)\n      left++\n    }\n    best = Math.max(best, i - left + 1)\n  }\n  return best\n};\n"
    }
  },
  {
    "name": "341-flatten-nested-list-iterator",
    "code": {
      "JS": "/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * function NestedInteger() {\n *\n *     Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     @return {boolean}\n *     this.isInteger = function() {\n *         ...\n *     };\n *\n *     Return the single integer that this NestedInteger holds, if it holds a single integer\n *     Return null if this NestedInteger holds a nested list\n *     @return {integer}\n *     this.getInteger = function() {\n *         ...\n *     };\n *\n *     Return the nested list that this NestedInteger holds, if it holds a nested list\n *     Return null if this NestedInteger holds a single integer\n *     @return {NestedInteger[]}\n *     this.getList = function() {\n *         ...\n *     };\n * };\n */\n/**\n * @constructor\n * @param {NestedInteger[]} nestedList\n */\nfunction flat(arr, res) {\n    for(let i = 0; i < arr.length; i++) {\n        if(arr[i].isInteger()) {\n           res.push(arr[i].getInteger())\n        } else {\n           flat(arr[i].getList() ,res)            \n        }\n\n    }\n}\nconst NestedIterator = function(nestedList) {\n    this.arr = []\n    this.idx = -1\n    flat(nestedList, this.arr)\n};\n\n\n/**\n * @this NestedIterator\n * @returns {boolean}\n */\nNestedIterator.prototype.hasNext = function() {\n    return this.idx + 1 < this.arr.length\n};\n\n/**\n * @this NestedIterator\n * @returns {integer}\n */\nNestedIterator.prototype.next = function() {\n    this.idx += 1\n    return this.arr[this.idx]\n};\n\n/**\n * Your NestedIterator will be called like this:\n * var i = new NestedIterator(nestedList), a = [];\n * while (i.hasNext()) a.push(i.next());\n*/\n"
    }
  },
  {
    "name": "342-power-of-four",
    "code": {
      "JS": "/**\n * @param {number} num\n * @return {boolean}\n */\nconst isPowerOfFour = function(num) {\n  if (num === 1) { return true; }\n  let f = 4;\n  while (f <= num) {\n      if (f === num) {\n          return true;\n      }\n      f *= 4;\n  }\n  return false;\n};\n"
    }
  },
  {
    "name": "343-integer-break",
    "code": {
      "JS": "/**\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nconst integerBreak = function(n) {\r\n  const dp = Array(n + 1).fill(0)\r\n  dp[2] = 1\r\n  for(let i = 3; i <= n; i++) {\r\n    for(let j = 1; j < i; j++) {\r\n      dp[i] = Math.max(dp[i], j * Math.max(i - j, dp[i - j]))\r\n    }\r\n  }\r\n  return dp[n]\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nconst integerBreak = function(n) {\r\n  if (n <= 2) return 1;\r\n\r\n  const maxArr = [];\r\n  for (let i = 0; i < n + 1; i++) {\r\n    maxArr[i] = 0;\r\n  }\r\n\r\n  /** For a number i: write i as a sum of integers, then take the product of those integers.\r\n   maxArr[i] = maximum of all the possible products */\r\n\r\n  maxArr[1] = 0;\r\n  maxArr[2] = 1; // 2=1+1 so maxArr[2] = 1*1\r\n\r\n  for (let i = 3; i <= n; i++) {\r\n    for (let j = 1; j < i; j++) {\r\n      /** Try to write i as: i = j + S where S=i-j corresponds to either one number or a sum of two or more numbers\r\n        \r\n        Assuming that j+S corresponds to the optimal solution for maxArr[i], we have two cases:\r\n        (1) i is the sum of two numbers, i.e. S=i-j is one number, and so maxArr[i]=j*(i-j)\r\n        (2) i is the sum of at least three numbers, i.e. S=i-j is a sum of at least 2 numbers,\r\n        and so the product of the numbers in this sum for S is maxArr[i-j]\r\n        (=maximum product after breaking up i-j into a sum of at least two integers):\r\n        maxArr[i] = j*maxArr[i-j]\r\n        */\r\n      maxArr[i] = Math.max(maxArr[i], j * (i - j), j * maxArr[i - j]);\r\n    }\r\n  }\r\n  return maxArr[n];\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nconst integerBreak = function(n) {\r\n  if(n === 2) return 1\r\n  if(n === 3) return 2\r\n  let num = ~~(n / 3)\r\n  let rem = n % 3\r\n  if(rem === 1) {\r\n    rem += 3\r\n    num--\r\n  }\r\n  return rem === 0 ? Math.pow(3, num) : Math.pow(3, num) * rem\r\n};\r\n\r\n/**\r\n\r\nIf an optimal product contains a factor f >= 4, \r\nthen you can replace it with factors 2 and f-2 without losing optimality,\r\nas 2*(f-2) = 2f-4 >= f. So you never need a factor greater than or equal to 4,\r\nmeaning you only need factors 1, 2 and 3 (and 1 is of course wasteful and you'd only use it for n=2 and n=3, where it's needed).\r\n\r\nFor the rest I agree, 3*3 is simply better than 2*2*2, so you'd never use 2 more than twice.\r\n\r\n*/\r\n"
    }
  },
  {
    "name": "344-reverse-string",
    "code": {
      "JS": "/**\n * @param {character[]} s\n * @return {void} Do not return anything, modify s in-place instead.\n */\nconst reverseString = function(s) {\n  s.reverse()\n};\n\n// another\n\n/**\n * @param {character[]} s\n * @return {void} Do not return anything, modify s in-place instead.\n */\nconst reverseString = function(s) {\n\tfor(let i = 0; i < s.length / 2; i++){\n\t\t[ s[i] , s[s.length - 1 - i] ] = [ s[s.length - 1 - i] , s[i] ];\n\t}\n};\n"
    }
  },
  {
    "name": "345-reverse-vowels-of-a-string",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {string}\n */\nconst reverseVowels = function(s) {\n  if(s == null || s === '') return ''\n  const arr = s.split('')\n  let p = 0\n  const len = s.length\n  let e = s.length - 1\n  const v = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  while(p < e) {\n    while(v.indexOf(arr[p]) === -1 && p < e) p++\n    while(v.indexOf(arr[e]) === -1 && p < e) e--\n    const tmp = arr[p]\n    arr[p] = arr[e]\n    arr[e] = tmp          \n    p++\n    e--\n  }\n  return arr.join('')\n};\n\n\n// another\n\nconst reverseVowels = function(s) {\n  let vowels = s.match(/[aeiou]/gi)\n  let k = 0\n  if (vowels) {\n    vowels = vowels.reverse``\n  } else {\n    return s\n  }\n  return s.replace(/[aeiou]/gi, () => vowels[k++])\n}\n"
    }
  },
  {
    "name": "346-moving-average-from-data-stream",
    "code": {
      "JS": "/**\n * Initialize your data structure here.\n * @param {number} size\n */\nconst MovingAverage = function(size) {\n  this.limit = size\n  this.arr = []\n  this.sum = 0\n};\n\n/** \n * @param {number} val\n * @return {number}\n */\nMovingAverage.prototype.next = function(val) {\n  this.arr.push(val)\n  this.sum += val\n  if(this.arr.length > this.limit) {\n    const tmp = this.arr[0]\n    this.arr.shift()\n    this.sum -= tmp\n  }\n  return this.sum / this.arr.length\n};\n\n/** \n * Your MovingAverage object will be instantiated and called as such:\n * var obj = new MovingAverage(size)\n * var param_1 = obj.next(val)\n */\n"
    }
  },
  {
    "name": "347-top-k-frequent-elements",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nconst topKFrequent = function(nums, k) {\r\n  const hash = {}\r\n  for(let i = 0; i < nums.length; i++) {\r\n    if(hash.hasOwnProperty(nums[i])) hash[nums[i]]++\r\n    else hash[nums[i]] = 1\r\n  }\r\n  const res = new Array()\r\n  const keys = Object.keys(hash)\r\n  \r\n  const bucket = new Array(nums.length)\r\n  \r\n  for(let k of keys) {\r\n    let freq = hash[k]\r\n    if(bucket[freq] == null) {\r\n      bucket[freq] = []\r\n    }\r\n    bucket[freq].push(k)\r\n  }\r\n  \r\n  for(let i = bucket.length - 1; i >= 0 && res.length < k; i--) {\r\n    if(bucket[i] != null) {\r\n      res.push(...bucket[i])\r\n    }\r\n  }\r\n  \r\n  return res\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nconst topKFrequent = function(nums, k) {\r\n  const hash = {}\r\n  for(let n of nums) {\r\n    if(hash[n] == null) hash[n] = 0\r\n    hash[n]++\r\n  }\r\n  const entries = Object.entries(hash)\r\n  let min = Infinity, max = -Infinity\r\n  const reverse = {}\r\n  for(let [k, freq] of entries) {\r\n    if(freq < min) min = freq\r\n    if(freq > max) max = freq\r\n    if(reverse[freq] == null) reverse[freq] = []\r\n    reverse[freq].push(k)\r\n  }\r\n  const n = max - min + 1\r\n  const arr = Array(n)\r\n  let res = []\r\n  let limit = max\r\n  while(limit) {\r\n    if(reverse[limit]) res.push(...reverse[limit])\r\n    limit--\r\n    if(res.length >= k) break\r\n  }\r\n  res.splice(k)\r\n  return res\r\n};\r\n\r\n// another\r\n\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\n const topKFrequent = function(nums, k) {\r\n  const n = nums.length\r\n  const freq = Array(n + 1).fill(null)\r\n  const hash = {}\r\n  for(let e of nums) {\r\n    if(hash[e] == null) hash[e] = 0\r\n    hash[e]++\r\n  }\r\n  for(let k in hash) {\r\n    if(hash.hasOwnProperty(k)) {\r\n      const v = hash[k]\r\n      if(freq[v] == null) freq[v] = []\r\n      freq[v].push(k)\r\n    }\r\n  }\r\n  const res = []\r\n  for(let i = n; i >= 0; i--) {\r\n    if(freq[i] != null) res.push(...freq[i])\r\n    if(res.length >= k) break\r\n  }\r\n  if(res.length > k) res.splice(k)\r\n  return res\r\n};\r\n"
    }
  },
  {
    "name": "348-design-tic-tac-toe",
    "code": {
      "JS": "/**\n * Initialize your data structure here.\n * @param {number} n\n */\nconst TicTacToe = function(n) {\n  this.n = n\n  this.cols = new Array(n).fill(0)\n  this.rows = new Array(n).fill(0)\n  this.diagonal = 0\n  this.antiDiagonal = 0\n}\n\n/**\n * Player {player} makes a move at ({row}, {col}).\n        @param row The row of the board.\n        @param col The column of the board.\n        @param player The player, can be either 1 or 2.\n        @return The current winning condition, can be either:\n                0: No one wins.\n                1: Player 1 wins.\n                2: Player 2 wins. \n * @param {number} row \n * @param {number} col \n * @param {number} player\n * @return {number}\n */\nTicTacToe.prototype.move = function(row, col, player) {\n  const { n } = this\n  const toAdd = player === 1 ? 1 : -1\n  this.rows[row] += toAdd\n  this.cols[col] += toAdd\n  if (row === col) {\n    this.diagonal += toAdd\n  }\n  if (col === n - row - 1) {\n    this.antiDiagonal += toAdd\n  }\n  if (\n    Math.abs(this.rows[row]) === n ||\n    Math.abs(this.cols[col]) === n ||\n    Math.abs(this.diagonal) === n ||\n    Math.abs(this.antiDiagonal) === n\n  ) {\n    return player\n  }\n  return 0\n}\n\n/**\n * Your TicTacToe object will be instantiated and called as such:\n * var obj = new TicTacToe(n)\n * var param_1 = obj.move(row,col,player)\n */\n"
    }
  },
  {
    "name": "349-intersection-of-two-arrays",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums1\r\n * @param {number[]} nums2\r\n * @return {number[]}\r\n */\r\n\r\nconst intersection = function(nums1, nums2) {\r\n  const obj = {};\r\n  nums1.forEach(i => (obj[i] = true));\r\n\r\n  return nums2.filter(j => {\r\n    if (obj[j]) {\r\n      delete obj[j];\r\n      return true;\r\n    }\r\n    return false;\r\n  });\r\n};\r\n"
    }
  },
  {
    "name": "35-search-insert-position",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n * @param {number} target\r\n * @return {number}\r\n */\r\nconst searchInsert = function(nums, target) {\r\n  for (let i = 0; i < nums.length; i++) {\r\n    if (nums[i] >= target) {\r\n      return i;\r\n    } else {\r\n      if (i === nums.length - 1) {\r\n        return i + 1;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} target\r\n * @return {number}\r\n */\r\nconst searchInsert = function(nums, target) {\r\n  const n = nums.length\r\n  let l = 0, r = n - 1\r\n  while(l <= r) {\r\n    const mid = l + ((r - l) >> 1)\r\n    if(nums[mid] === target) return mid\r\n    if(nums[mid] > target) r = mid - 1\r\n    else l = mid + 1\r\n  }\r\n  return l\r\n};\r\n"
    }
  },
  {
    "name": "350-intersection-of-two-arrays-ii",
    "code": {
      "JS": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number[]}\n */\nconst intersect = function(nums1, nums2) {\n    const res = []\n    const map = {}\n    for(let i = 0; i < nums1.length; i++) {\n        if(map.hasOwnProperty(nums1[i])) {\n            map[nums1[i]] += 1\n        } else {\n            map[nums1[i]] = 1\n        }\n    }\n    \n    for(let j = 0; j < nums2.length; j++) {\n        if(map.hasOwnProperty(nums2[j]) && map[nums2[j]] > 0) {\n           res.push(nums2[j])\n           map[nums2[j]] -= 1\n        }\n    }\n    \n    return res\n};\n"
    }
  },
  {
    "name": "351-android-unlock-patterns",
    "code": {
      "JS": "/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nconst numberOfPatterns = function(m, n) {\n  // Skip array represents number to skip between two pairs\n  const skip = Array.from({ length: 10 }, () => new Array(10).fill(0))\n  skip[1][3] = skip[3][1] = 2\n  skip[1][7] = skip[7][1] = 4\n  skip[3][9] = skip[9][3] = 6\n  skip[7][9] = skip[9][7] = 8\n  skip[1][9] = skip[9][1] = skip[2][8] = skip[8][2] = skip[3][7] = skip[7][3] = skip[4][6] = skip[6][4] = 5\n  const vis = new Array(10).fill(false)\n  let rst = 0\n  // DFS search each length from m to n\n  for (let i = m; i <= n; ++i) {\n    rst += DFS(vis, skip, 1, i - 1) * 4 // 1, 3, 7, 9 are symmetric\n    rst += DFS(vis, skip, 2, i - 1) * 4 // 2, 4, 6, 8 are symmetric\n    rst += DFS(vis, skip, 5, i - 1) // 5\n  }\n  return rst\n}\n\n// cur: the current position\n// remain: the steps remaining\nfunction DFS(vis, skip, cur, remain) {\n  if (remain < 0) return 0\n  if (remain === 0) return 1\n  vis[cur] = true\n  let rst = 0\n  for (let i = 1; i <= 9; ++i) {\n    // If vis[i] is not visited and (two numbers are adjacent or skip number is already visited)\n    if (!vis[i] && (skip[cur][i] === 0 || vis[skip[cur][i]])) {\n      rst += DFS(vis, skip, i, remain - 1)\n    }\n  }\n  vis[cur] = false\n  return rst\n}\n"
    }
  },
  {
    "name": "352-data-stream-as-disjoint-intervals",
    "code": {
      "JS": "/**\n * Initialize your data structure here.\n */\nvar SummaryRanges = function() {\n  this.intervals = []\n}\n\n/**\n * @param {number} val\n * @return {void}\n */\nSummaryRanges.prototype.addNum = function(val) {\n  const current = [val, val]\n  const intervals = this.intervals\n  const less = []\n  const more = []\n  for (let vals of intervals) {\n    if (vals[0] > current[1] + 1) {\n      more.push(vals)\n    } else if (vals[1] + 1 < current[0]) {\n      less.push(vals)\n    } else {\n      current[0] = Math.min(current[0], vals[0])\n      current[1] = Math.max(current[1], vals[1])\n    }\n  }\n  this.intervals = [...less, current, ...more]\n}\n\n/**\n * @return {number[][]}\n */\nSummaryRanges.prototype.getIntervals = function() {\n  return this.intervals\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * var obj = new SummaryRanges()\n * obj.addNum(val)\n * var param_2 = obj.getIntervals()\n */\n"
    }
  },
  {
    "name": "353-design-snake-game",
    "code": {
      "JS": "/**\n * Initialize your data structure here.\n        @param width - screen width\n        @param height - screen height \n        @param food - A list of food positions\n        E.g food = [[1,1], [1,0]] means the first food is positioned at [1,1], the second is at [1,0].\n * @param {number} width\n * @param {number} height\n * @param {number[][]} food\n */\nconst SnakeGame = function(width, height, food) {\n  this.width = width\n  this.height = height\n  this.food = food\n  this.foodIdx = 0\n  this.row = 0\n  this.col = 0\n  this.queue = [0]\n  this.visited = new Set([0])\n}\n\n/**\n * Moves the snake.\n        @param direction - 'U' = Up, 'L' = Left, 'R' = Right, 'D' = Down \n        @return The game's score after the move. Return -1 if game over. \n        Game over when snake crosses the screen boundary or bites its body. \n * @param {string} direction\n * @return {number}\n */\nSnakeGame.prototype.move = function(direction) {\n  if (direction === 'U') {\n    this.row--\n  }\n  if (direction === 'R') {\n    this.col++\n  }\n  if (direction === 'D') {\n    this.row++\n  }\n  if (direction === 'L') {\n    this.col--\n  }\n  const head = this.row * this.width + this.col\n\n  // in the next move, head can be the previous tail, so check head !== this.queue[0]\n  if (head !== this.queue[0] && this.visited.has(head)) {\n    return -1\n  }\n\n  if (\n    this.row >= 0 &&\n    this.row < this.height &&\n    this.col >= 0 &&\n    this.col < this.width\n  ) {\n    // check if can eat food\n    if (\n      this.foodIdx < this.food.length &&\n      this.food[this.foodIdx][0] === this.row &&\n      this.food[this.foodIdx][1] === this.col\n    ) {\n      this.foodIdx++\n    } else {\n      this.visited.delete(this.queue[0])\n      this.queue.shift()\n    }\n\n    this.queue.push(head)\n    this.visited.add(head)\n    return this.foodIdx\n  }\n  return -1\n}\n\n/**\n * Your SnakeGame object will be instantiated and called as such:\n * var obj = new SnakeGame(width, height, food)\n * var param_1 = obj.move(direction)\n */\n"
    }
  },
  {
    "name": "354-russian-doll-envelopes",
    "code": {
      "JS": "/**\n * @param {number[][]} envelopes\n * @return {number}\n */\nconst maxEnvelopes = function(envelopes) {\n  envelopes.sort((a, b) => {\n    if (a[0] == b[0]) {\n      return b[1] - a[1]\n    } else {\n      return a[0] - b[0]\n    }\n  })\n  const n = envelopes.length\n  const dp = []\n  for (let i = 0; i < n; i++) {\n    let l = 0,\n      r = dp.length,\n      t = envelopes[i][1]\n    while (l < r) {\n      let m = l + ~~((r - l) / 2)\n      if (dp[m] < t) l = m + 1\n      else r = m\n    }\n    if (r >= dp.length) dp.push(t)\n    else dp[r] = t\n  }\n  return dp.length\n}\n\n// another\n\n/**\n * @param {number[][]} envelopes\n * @return {number}\n */\nconst maxEnvelopes = function(envelopes) {\n  envelopes.sort((a, b) => a[0] === b[0] ? b[1] - a[1] : a[0] - b[0])\n  const stack = []\n  for(let e of envelopes) {\n    if(stack.length === 0 || e[1] > stack[stack.length - 1][1]) {\n      stack.push(e)\n      continue\n    }\n    let l = 0, r = stack.length - 1\n    while(l < r) {\n      const mid = ~~((l+r)/2)\n      if(stack[mid][1] < e[1]) {\n        l = mid + 1\n      } else r = mid\n    }\n    stack[l] = e\n  }\n  return stack.length\n};\n"
    }
  },
  {
    "name": "355-design-twitter",
    "code": {
      "JS": "/**\n * Initialize your data structure here.\n */\nconst Twitter = function() {\n  this.userTweets = new Map()\n  this.userFollowing = new Map()\n  this.lastIndex = 1\n}\n\n/**\n * Compose a new tweet.\n * @param {number} userId\n * @param {number} tweetId\n * @return {void}\n */\nTwitter.prototype.postTweet = function(userId, tweetId) {\n  let tweets = this.userTweets.get(userId)\n  if (!tweets) {\n    tweets = []\n    this.userTweets.set(userId, tweets)\n  }\n  tweets.unshift({ id: tweetId, index: this.lastIndex })\n  this.lastIndex = this.lastIndex + 1\n}\n\n/**\n * Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\n * @param {number} userId\n * @return {number[]}\n */\nTwitter.prototype.getNewsFeed = function(userId) {\n  const followings = this.userFollowing.get(userId)\n  let tweets = (this.userTweets.get(userId) || []).slice(0, 10)\n  followings &&\n    followings.forEach(uid => {\n      if (uid === userId) return\n\n      const userTweets = this.userTweets.get(uid)\n      if (userTweets) {\n        tweets = tweets.concat(userTweets)\n      }\n    })\n  return tweets\n    .sort((a, b) => b.index - a.index)\n    .map(tweet => tweet.id)\n    .slice(0, 10)\n}\n\n/**\n * Follower follows a followee. If the operation is invalid, it should be a no-op.\n * @param {number} followerId\n * @param {number} followeeId\n * @return {void}\n */\nTwitter.prototype.follow = function(followerId, followeeId) {\n  let followings = this.userFollowing.get(followerId)\n  if (!followings) {\n    followings = new Set()\n    this.userFollowing.set(followerId, followings)\n  }\n  followings.add(followeeId)\n}\n\n/**\n * Follower unfollows a followee. If the operation is invalid, it should be a no-op.\n * @param {number} followerId\n * @param {number} followeeId\n * @return {void}\n */\nTwitter.prototype.unfollow = function(followerId, followeeId) {\n  const followings = this.userFollowing.get(followerId)\n  followings && followings.delete(followeeId)\n}\n\n/**\n * Your Twitter object will be instantiated and called as such:\n * var obj = new Twitter()\n * obj.postTweet(userId,tweetId)\n * var param_2 = obj.getNewsFeed(userId)\n * obj.follow(followerId,followeeId)\n * obj.unfollow(followerId,followeeId)\n */\n"
    }
  },
  {
    "name": "356-line-reflection",
    "code": {
      "JS": "/**\n * @param {number[][]} points\n * @return {boolean}\n */\nconst isReflected = function(points) {\n  let max = -Infinity,\n    min = +Infinity,\n    sum = 0,\n    length = points.length\n  const set = new Set()\n  for (let i = 0; i < length; i++) {\n    max = Math.max(max, points[i][0])\n    min = Math.min(min, points[i][0])\n    let curStr = points[i][0] + 'a' + points[i][1]\n    set.add(curStr)\n  }\n  sum = max + min\n  for (let j = 0; j < length; j++) {\n    let cur = sum - points[j][0] + 'a' + points[j][1]\n    if (!set.has(cur)) {\n      return false\n    }\n  }\n  return true\n}\n"
    }
  },
  {
    "name": "357-count-numbers-with-unique-digits",
    "code": {
      "JS": "/**\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nconst countNumbersWithUniqueDigits = function(n) {\r\n  if (n === 0) return 1;\r\n  let res = 10;\r\n  let tmp = 9;\r\n  let remainDigitNum = 9;\r\n  while (n - 1 > 0 && remainDigitNum > 0) {\r\n    tmp = tmp * remainDigitNum;\r\n    res += tmp;\r\n    n -= 1;\r\n    remainDigitNum -= 1;\r\n  }\r\n\r\n  return res;\r\n};\r\n"
    }
  },
  {
    "name": "358-rearrange-string-k-distance-apart",
    "code": {
      "JS": "/**\n\nGiven a non-empty string s and an integer k,\nrearrange the string such that the same characters are at least distance k from each other.\n\nAll input strings are given in lowercase letters.\nIf it is not possible to rearrange the string, return an empty string \"\".\n\nExample 1:\n\nInput: s = \"aabbcc\", k = 3\nOutput: \"abcabc\" \nExplanation: The same letters are at least distance 3 from each other.\nExample 2:\n\nInput: s = \"aaabc\", k = 3\nOutput: \"\" \nExplanation: It is not possible to rearrange the string.\nExample 3:\n\nInput: s = \"aaadbbcc\", k = 2\nOutput: \"abacabcd\"\nExplanation: The same letters are at least distance 2 from each other.\n\n*/\n\n/**\n * @param {string} s\n * @param {number} k\n * @return {string}\n */\nconst rearrangeString = function(s, k) {\n  if(k > 26) return ''\n  const length = s.length\n  const count = new Array(26).fill(0)\n  const valid = new Array(26).fill(0)\n  const a = 'a'.charCodeAt(0)\n  for (let i = 0; i < length; i++) {\n    count[s.charCodeAt(i) - a]++\n  }\n  let sb = ''\n  for (let index = 0; index < length; index++) {\n    let candidatePos = findValidMax(count, valid, index)\n    if (candidatePos == -1) return ''\n    count[candidatePos]--\n    valid[candidatePos] = index + k\n    sb += String.fromCharCode(a + candidatePos)\n  }\n  return sb\n}\n\nfunction findValidMax(count, valid, index) {\n  let max = Number.MIN_VALUE\n  let candidatePos = -1\n  for (let i = 0; i < count.length; i++) {\n    if (count[i] > 0 && count[i] > max && index >= valid[i]) {\n      max = count[i]\n      candidatePos = i\n    }\n  }\n  return candidatePos\n}\n\n"
    }
  },
  {
    "name": "359-logger-rate-limiter",
    "code": {
      "JS": "/**\n * Initialize your data structure here.\n */\nconst Logger = function() {\n  this.m = new Map()\n};\n\n/**\n * Returns true if the message should be printed in the given timestamp, otherwise returns false.\n        If this method returns false, the message will not be printed.\n        The timestamp is in seconds granularity. \n * @param {number} timestamp \n * @param {string} message\n * @return {boolean}\n */\nLogger.prototype.shouldPrintMessage = function(timestamp, message) {\n  if(!this.m.has(message)) {\n    this.m.set(message, timestamp)\n    return true\n  }\n  const p = this.m.get(message)\n  const res = timestamp - p >= 10 ? true : false\n  if(res) {\n    this.m.set(message, timestamp)\n    return true\n  }\n  return false\n};\n\n/** \n * Your Logger object will be instantiated and called as such:\n * var obj = new Logger()\n * var param_1 = obj.shouldPrintMessage(timestamp,message)\n */\n"
    }
  },
  {
    "name": "36-valid-sudoku",
    "code": {
      "JS": "/**\n * @param {character[][]} board\n * @return {boolean}\n */\nconst isValidSudoku = function(board) {\n  const n = 9\n  const m = 3\n  const row = [],\n    col = [],\n    block = []\n  for (let i = 0; i < n; i++) {\n    row[i] = new Set()\n    col[i] = new Set()\n    block[i] = new Set()\n  }\n  for (let r = 0; r < n; r++) {\n    for (let c = 0; c < n; c++) {\n      const ch = board[r][c]\n      if (ch === '.') continue\n      const b = Math.floor(r / m) * m + Math.floor(c / m)\n      if (row[r].has(ch) || col[c].has(ch) || block[b].has(ch)) return false\n      row[r].add(ch)\n      col[c].add(ch)\n      block[b].add(ch)\n    }\n  }\n  return true\n}\n\n// another\n\n/**\n * @param {character[][]} board\n * @return {boolean}\n */\nconst isValidSudoku = function(board) {\n  let seen = new Set()\n  for (let i = 0; i < 9; ++i) {\n    for (let j = 0; j < 9; ++j) {\n      let number = board[i][j]\n      if (number != '.')\n        if (\n          !hset(seen, number + ' in row ' + i) ||\n          !hset(seen, number + ' in column ' + j) ||\n          !hset(seen, number + ' in block ' + ~~(i / 3) + '-' + ~~(j / 3))\n        )\n          return false\n    }\n  }\n  return true\n}\nfunction hset(s, val) {\n  if (s.has(val)) return false\n  else {\n    s.add(val)\n    return true\n  }\n}\n"
    }
  },
  {
    "name": "360-sort-transformed-array",
    "code": {
      "JS": "/**\n\nGiven a sorted array of integers nums and integer values a, b and c.\nApply a quadratic function of the form f(x) = ax2 + bx + c to each element x in the array.\n\nThe returned array must be in sorted order.\n\nExpected time complexity: O(n)\n\nExample 1:\n\nInput: nums = [-4,-2,2,4], a = 1, b = 3, c = 5\nOutput: [3,9,15,33]\nExample 2:\n\nInput: nums = [-4,-2,2,4], a = -1, b = 3, c = 5\nOutput: [-23,-5,1,7]\n\n*/\n\n/**\n * @param {number[]} nums\n * @param {number} a\n * @param {number} b\n * @param {number} c\n * @return {number[]}\n */\nconst sortTransformedArray = function(nums, a, b, c) {\n  const n = nums.length\n  const sorted = new Array(n)\n  let i = 0,\n    j = n - 1\n  let index = a >= 0 ? n - 1 : 0\n  while (i <= j) {\n    if (a >= 0) {\n      sorted[index--] =\n        quad(nums[i], a, b, c) >= quad(nums[j], a, b, c)\n          ? quad(nums[i++], a, b, c)\n          : quad(nums[j--], a, b, c)\n    } else {\n      sorted[index++] =\n        quad(nums[i], a, b, c) >= quad(nums[j], a, b, c)\n          ? quad(nums[j--], a, b, c)\n          : quad(nums[i++], a, b, c)\n    }\n  }\n  return sorted\n}\n\nfunction quad(x, a, b, c) {\n  return a * x * x + b * x +c\n}\n\n// another\n\n/**\n * @param {number[]} nums\n * @param {number} a\n * @param {number} b\n * @param {number} c\n * @return {number[]}\n */\nconst sortTransformedArray = function(nums, a, b, c) {\n  const ret = []\n  const sum = v => a * v * v + b * v + c\n  if (a > 0) {\n    const point = (b / a / 2) * -1\n    let i = 0,\n      j = nums.length\n    while (i < j) {\n      let ax = nums[i]\n      if (Math.abs(nums[i] - point) - Math.abs(nums[j - 1] - point) > 0) {\n        ++i\n      } else {\n        ax = nums[--j]\n      }\n      ret.unshift(sum(ax))\n    }\n    return ret\n  } else if (a < 0) {\n    const point = (b / a / 2) * -1\n    let i = 0,\n      j = nums.length\n    while (i < j) {\n      let ax = nums[i]\n      if (Math.abs(ax - point) - Math.abs(nums[j - 1] - point) > 0) {\n        ++i\n      } else {\n        ax = nums[--j]\n      }\n      ret.push(sum(ax))\n    }\n    return ret\n  } else {\n    if (b > 0) {\n      return nums.map(v => sum(v))\n    } else {\n      nums.forEach(v => {\n        ret.unshift(sum(v))\n      })\n      return ret\n    }\n  }\n}\n\n"
    }
  },
  {
    "name": "361-bomb-enemy",
    "code": {
      "JS": "/**\n\nGiven a 2D grid, each cell is either a wall 'W',\nan enemy 'E' or empty '0' (the number zero),\nreturn the maximum enemies you can kill using one bomb.\nThe bomb kills all the enemies in the same row and column\nfrom the planted point until it hits the wall since the wall\nis too strong to be destroyed.\n\nNote: You can only put the bomb at an empty cell.\n\nExample:\n\nInput: [[\"0\",\"E\",\"0\",\"0\"],[\"E\",\"0\",\"W\",\"E\"],[\"0\",\"E\",\"0\",\"0\"]]\nOutput: 3 \nExplanation: For the given grid,\n\n0 E 0 0 \nE 0 W E \n0 E 0 0\n\nPlacing a bomb at (1,1) kills 3 enemies.\n\n*/\n\n/**\n * @param {character[][]} grid\n * @return {number}\n */\nconst maxKilledEnemies = function(grid) {\n  const m = grid.length\n  const n = m !== 0 ? grid[0].length : 0\n  let result = 0\n  let rowhits = 0\n  const colhits = new Array(n).fill(0)\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (j === 0 || grid[i][j - 1] === 'W') {\n        rowhits = 0\n        for (let k = j; k < n && grid[i][k] !== 'W'; k++)\n          rowhits += grid[i][k] === 'E' ? 1 : 0\n      }\n      if (i === 0 || grid[i - 1][j] === 'W') {\n        colhits[j] = 0\n        for (let k = i; k < m && grid[k][j] !== 'W'; k++)\n          colhits[j] += grid[k][j] === 'E' ? 1 : 0\n      }\n      if (grid[i][j] === '0') result = Math.max(result, rowhits + colhits[j])\n    }\n  }\n  return result\n}\n\n// another\n\n/**\n * @param {character[][]} grid\n * @return {number}\n */\nconst maxKilledEnemies = function(grid) {\n  if (grid == null || grid.length === 0 || grid[0].length === 0) return 0\n  const rows = grid.length\n  const cols = grid[0].length\n  let max = 0\n  const dp = Array.from({ length: rows }, () => new Array(cols).fill(0))\n  //travel each column twice: from left and from right\n  for (let i = 0; i < rows; i++) {\n    let cnt = 0\n    for (let k = 0; k < cols; k++) {\n      if (grid[i][k] === '0') {\n        dp[i][k] = cnt\n      } else if (grid[i][k] === 'E') {\n        cnt++\n      } else {\n        cnt = 0\n      }\n    }\n    cnt = 0\n    for (let k = cols - 1; k >= 0; k--) {\n      if (grid[i][k] === '0') {\n        dp[i][k] += cnt\n      } else if (grid[i][k] === 'E') {\n        cnt++\n      } else {\n        cnt = 0\n      }\n    }\n  }\n  //travel each row twice: from top and from bottom\n  for (let i = 0; i < cols; i++) {\n    let cnt = 0\n    for (let k = 0; k < rows; k++) {\n      if (grid[k][i] === '0') {\n        dp[k][i] += cnt\n      } else if (grid[k][i] === 'E') {\n        cnt++\n      } else {\n        cnt = 0\n      }\n    }\n    cnt = 0\n    for (let k = rows - 1; k >= 0; k--) {\n      if (grid[k][i] === '0') {\n        dp[k][i] += cnt\n        max = Math.max(max, dp[k][i])\n      } else if (grid[k][i] === 'E') {\n        cnt++\n      } else {\n        cnt = 0\n      }\n    }\n  }\n  return max\n}\n\n"
    }
  },
  {
    "name": "362-design-hit-counter",
    "code": {
      "JS": "/**\n\nDesign a hit counter which counts the number of hits received in the past 5 minutes.\nEach function accepts a timestamp parameter (in seconds granularity) and you may\nassume that calls are being made to the system in chronological order (ie,\nthe timestamp is monotonically increasing). You may assume that the earliest timestamp starts at 1.\nIt is possible that several hits arrive roughly at the same time.\n\nExample:\n\nHitCounter counter = new HitCounter();\n\n// hit at timestamp 1.\ncounter.hit(1);\n\n// hit at timestamp 2.\ncounter.hit(2);\n\n// hit at timestamp 3.\ncounter.hit(3);\n\n// get hits at timestamp 4, should return 3.\ncounter.getHits(4);\n\n// hit at timestamp 300.\ncounter.hit(300);\n\n// get hits at timestamp 300, should return 4.\ncounter.getHits(300);\n\n// get hits at timestamp 301, should return 3.\ncounter.getHits(301); \n\nFollow up:\nWhat if the number of hits per second could be very large? Does your design scale?\n\n*/\n\n\n/**\n * Initialize your data structure here.\n */\nconst HitCounter = function() {\n  this.times = []\n  this.hits = []\n}\n\n/**\n * Record a hit.\n        @param timestamp - The current timestamp (in seconds granularity). \n * @param {number} timestamp\n * @return {void}\n */\nHitCounter.prototype.hit = function(timestamp) {\n  const idx = timestamp % 300\n  const times = this.times\n  const hits = this.hits\n  if (times[idx] !== timestamp) {\n    times[idx] = timestamp\n    hits[idx] = 1\n  } else {\n    hits[idx]++\n  }\n}\n\n/**\n * Return the number of hits in the past 5 minutes.\n        @param timestamp - The current timestamp (in seconds granularity). \n * @param {number} timestamp\n * @return {number}\n */\nHitCounter.prototype.getHits = function(timestamp) {\n  let total = 0\n  const times = this.times\n  const hits = this.hits\n  for (let i = 0; i < 300; i++) {\n    if (timestamp - times[i] < 300) {\n      total += hits[i]\n    }\n  }\n  return total\n}\n\n/**\n * Your HitCounter object will be instantiated and called as such:\n * var obj = new HitCounter()\n * obj.hit(timestamp)\n * var param_2 = obj.getHits(timestamp)\n */\n"
    }
  },
  {
    "name": "363-max-sum-of-rectangle-no-larger-than-k",
    "code": {
      "JS": "/**\n * @param {number[][]} matrix\n * @param {number} k\n * @return {number}\n */\nconst maxSumSubmatrix = function(matrix, k) {\n  const row = matrix.length,\n    col = matrix[0].length\n  let result = -Infinity\n  for (let i = 0; i < col; i++) {\n    let rowSum = Array(row).fill(0)\n    for (let j = i; j < col; j++) {\n      let sum = 0,\n        max = -Infinity\n      for (let r = 0; r < row; r++) {\n        rowSum[r] += matrix[r][j]\n        if (sum < 0) sum = 0\n        sum += rowSum[r]\n        max = Math.max(max, sum)\n      }\n      if (max <= k) result = Math.max(result, max)\n      else {\n        max = -Infinity\n        for (let m = 0; m < row; m++) {\n          sum = 0\n          for (let n = m; n < row; n++) {\n            sum += rowSum[n]\n            if (sum <= k) max = Math.max(max, sum)\n          }\n        }\n        result = Math.max(result, max)\n      }\n      if (result === k) return k\n    }\n  }\n  return result\n}\n"
    }
  },
  {
    "name": "364-nested-list-weight-sum-ii",
    "code": {
      "JS": "/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * function NestedInteger() {\n *\n *     Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     @return {boolean}\n *     this.isInteger = function() {\n *         ...\n *     };\n *\n *     Return the single integer that this NestedInteger holds, if it holds a single integer\n *     Return null if this NestedInteger holds a nested list\n *     @return {integer}\n *     this.getInteger = function() {\n *         ...\n *     };\n *\n *     Set this NestedInteger to hold a single integer equal to value.\n *     @return {void}\n *     this.setInteger = function(value) {\n *         ...\n *     };\n *\n *     Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\n *     @return {void}\n *     this.add = function(elem) {\n *         ...\n *     };\n *\n *     Return the nested list that this NestedInteger holds, if it holds a nested list\n *     Return null if this NestedInteger holds a single integer\n *     @return {NestedInteger[]}\n *     this.getList = function() {\n *         ...\n *     };\n * };\n */\n/**\n * @param {NestedInteger[]} nestedList\n * @return {number}\n */\nconst depthSumInverse = function(nestedList) {\n  const maxDepth = nestedList.reduce(\n    (max, list) => Math.max(max, getMaxDepth(list)),\n    1\n  )\n  return nestedList.reduce((total, list) => total + sum(list, maxDepth), 0)\n}\n\nfunction getMaxDepth(nestedList) {\n  if (nestedList.isInteger()) return 1\n  return nestedList\n    .getList()\n    .reduce((max, list) => Math.max(max, 1 + getMaxDepth(list)), 1)\n}\n\nfunction sum(nestedList, n) {\n  if (nestedList.isInteger()) return n * nestedList.getInteger()\n  return nestedList\n    .getList()\n    .reduce((total, list) => total + sum(list, n - 1), 0)\n}\n\n// another\n\nconst depthSumInverse = function(nestedList) {\n  const Q = []\n  let temp = []\n  while (nestedList.length) {\n    temp = []\n    for (let i = 0; i < nestedList.length; i++) {\n      if (nestedList[i].isInteger()) {\n        Q.push(nestedList[i].getInteger())\n      } else {\n        let list = nestedList[i].getList()\n        temp.push(...list)\n      }\n    }\n    Q.push('level')\n    nestedList = temp\n  }\n  let sum = 0\n  let level = 0\n  while (Q.length) {\n    let item = Q.pop()\n    if (item === 'level') {\n      level++\n    } else {\n      sum += item * level\n    }\n  }\n  return sum\n}\n"
    }
  },
  {
    "name": "365-water-and-jug-problem",
    "code": {
      "JS": "/**\n * @param {number} x\n * @param {number} y\n * @param {number} z\n * @return {boolean}\n */\nconst canMeasureWater = function(x, y, z) {\n  return z === 0 || (x + y >= z && z % gcd(x, y) === 0)\n}\nfunction gcd(x, y) {\n  if (y === 0) {\n    return x\n  }\n  return gcd(y, x % y)\n}\n"
    }
  },
  {
    "name": "366-find-leaves-of-binary-tree",
    "code": {
      "JS": "/**\n\nGiven a binary tree, collect a tree's nodes as if you were doing this:\nCollect and remove all leaves, repeat until the tree is empty. \n\nExample:\n\nInput: [1,2,3,4,5]\n  \n          1\n         / \\\n        2   3\n       / \\     \n      4   5    \n\nOutput: [[4,5,3],[2],[1]]\n \nExplanation:\n\n1. Removing the leaves [4,5,3] would result in this tree:\n\n          1\n         / \n        2          \n \n2. Now removing the leaf [2] would result in this tree:\n\n          1          \n \n3. Now removing the leaf [1] would result in the empty tree:\n\n          []   \n\n*/\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nconst findLeaves = function(root) {\n  const res = []\n  if(root == null) return res\n  while(root.left || root.right) {\n    const tmp = []\n    leaves(root, null, tmp)\n    res.push(tmp)\n  }\n  res.push([root.val])\n  return res\n};\n\nfunction leaves(node, p, res) {\n  if(node == null) return\n  if(node.left === null && node.right === null) {\n    res.push(node.val)\n    if(p && p.left === node) p.left = null\n    if(p && p.right === node) p.right = null\n    return\n  }\n  leaves(node.left, node, res)\n  leaves(node.right, node, res)\n}\n\n// another\n\nconst findLeaves = function(root) {\n  const res = []\n  dfs(root, res)\n  return res\n};\n\nfunction dfs(node, res) {\n  if(node == null) return -1\n  const i = 1 + Math.max(dfs(node.left, res), dfs(node.right, res))\n  if(!res[i]) res[i] = []\n  res[i].push(node.val)\n  return i\n}\n"
    }
  },
  {
    "name": "367-valid-perfect-square",
    "code": {
      "JS": "/**\n * @param {number} num\n * @return {boolean}\n */\nconst isPerfectSquare = function(num) {\n  let s = 0\n  let e = num\n  while(s <= e) {\n    const mid = s + ((e - s) >> 1)\n    const res = mid ** 2\n    if(res === num) return true\n    if(res < num) s = mid + 1\n    else e = mid - 1\n  }\n  return false\n};\n"
    }
  },
  {
    "name": "368-largest-divisible-subset",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nconst largestDivisibleSubset = function(nums) {\n  const n = nums.length;\n  if(n === 0 || n === 1) return nums\n  let maxSize = 0;\n  const dp = Array(n).fill(1)\n  nums.sort((a, b) => a - b)\n  for(let i = 1; i < n; i++) {\n    for(let j = i - 1; j >= 0; j--) {\n      if(nums[i] % nums[j] === 0) {\n        const tmp = dp[j] + 1\n        if(tmp > dp[i]) dp[i] = tmp         \n      }\n    }\n    if(dp[i] > maxSize) maxSize = dp[i]\n  }\n  const res = []\n  let pivot = 0\n  for(let i = n - 1; i >= 0; i--) {\n    if(dp[i] === maxSize && (pivot % nums[i] === 0)) {\n      pivot = nums[i]\n      maxSize--\n      res.push(nums[i])\n    }\n  }\n  \n  return res\n};\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\nconst largestDivisibleSubset = function(nums) {\n  let len = nums.length;\n  let maxSize = 0;\n  let maxSizeLastIdx;\n  // T[n] should be the length of the largest divisible subset whose smallest number is a[n]\n  const T = new Array(len).fill(0);\n  const son = new Array(len).fill(0);\n  nums.sort((a, b) => a - b);\n  for (let i = 0; i < len; i++) {\n    for (let j = i; j >= 0; j--) {\n      if (nums[i] % nums[j] === 0 && T[j] + 1 > T[i]) {\n        T[i] = T[j] + 1;\n        son[i] = j;\n      }\n    }\n    if (T[i] > maxSize) {\n      maxSize = T[i];\n      maxSizeLastIdx = i;\n    }\n  }\n  const re = [];\n  for (let i = 0; i < maxSize; i++) {\n    re.unshift(nums[maxSizeLastIdx]);\n    maxSizeLastIdx = son[maxSizeLastIdx];\n  }\n  return re;\n};\n"
    }
  },
  {
    "name": "369-plus-one-linked-list",
    "code": {
      "JS": "/**\n\nGiven a non-negative integer represented as non-empty a singly linked list of digits, plus one to the integer.\nYou may assume the integer do not contain any leading zero, except the number 0 itself.\nThe digits are stored such that the most significant digit is at the head of the list.\n\nExample :\n\nInput: [1,2,3]\nOutput: [1,2,4]\n\n*/\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nconst plusOne = function(head) {\n  const dummy = new ListNode(1)\n  dummy.next = head\n  const carry = plusOneRecursion(head)\n  return carry ? dummy : dummy.next\n}\nconst plusOneRecursion = node => {\n  if (!node) return 1\n  node.val += plusOneRecursion(node.next)\n  if (node.val > 9) {\n    node.val %= 10\n    return 1\n  }\n  return 0\n}\n\n// another\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nconst plusOne = function(head) {\n  const dummy = new ListNode(0)\n  dummy.next = head\n  let node = head\n  let lastNotNine = dummy\n  while(node) {\n    if(node.val !== 9) lastNotNine = node\n    node = node.next\n  }\n  lastNotNine.val++\n  node = lastNotNine.next\n  while(node) {\n    node.val = 0\n    node = node.next\n  }\n  return dummy.val === 1 ? dummy : dummy.next\n}\n\n\n"
    }
  },
  {
    "name": "37-sudoku-solver",
    "code": {
      "JS": "/**\n * @param {character[][]} board\n * @return {void} Do not return anything, modify board in-place instead.\n */\nconst solveSudoku = function(board) {\n  dfs(0, 0)\n  function dfs(row, col) {\n    if (row === 9) return true\n    if (col === 9) return dfs(row + 1, 0)\n    if (board[row][col] === \".\") {\n      for (let num = 1; num <= 9; num++) {\n        if (isValid(row, col, `${num}`)) {\n          board[row][col] = `${num}`\n          if (dfs(row, col + 1)) return true\n          board[row][col] = \".\"\n        }\n      }\n    } else {\n      return dfs(row, col + 1)\n    }\n    return false\n  }\n  function isValid(row, col, num) {\n    for (let rowIdx = 0; rowIdx < 9; rowIdx++) if (board[rowIdx][col] === num) return false\n    for (let colIdx = 0; colIdx < 9; colIdx++) if (board[row][colIdx] === num) return false\n\n    let squareRowStart = row - (row % 3)\n    let squareColStart = col - (col % 3)\n    for (let rIdx = 0; rIdx < 3; rIdx++) {\n      for (let cIdx = 0; cIdx < 3; cIdx++) {\n        if (board[squareRowStart + rIdx][squareColStart + cIdx] === num) return false\n      }\n    }\n    return true\n  }\n}\n\n\n// another\n\n/**\n * @param {character[][]} board\n * @return {void} Do not return anything, modify board in-place instead.\n */\nconst solveSudoku = function(board) {\n  helper(board, 0 , 0)\n};\n\nfunction helper(board, row, col) {\n  if(row >= 9) return true\n  if(col >= 9) return helper(board, row + 1, 0)\n  if(board[row][col] !== '.') return helper(board, row, col + 1)\n  for(let i = 1; i <= 9; i++) {\n    const ch = `${i}`\n    if(valid(board, row, col, ch)) {\n      board[row][col] = ch\n      if(helper(board, row, col + 1)) return true\n      board[row][col] = '.'\n    }\n  }\n  return false\n}\n\nfunction valid(board, row, col, ch) {\n  const blkRow = ~~(row / 3), blkCol = ~~(col / 3)\n  for(let i = 0; i < 9; i++) {\n    if(board[row][i] === ch) return false\n    if(board[i][col] === ch) return false\n    if(board[blkRow * 3 + Math.floor(i / 3)][blkCol * 3 + (i % 3)] === ch) return false\n  }\n  return true\n}\n"
    }
  },
  {
    "name": "370-range-addition",
    "code": {
      "JS": "/**\n\nAssume you have an array of length n initialized with all 0's and are given k update operations.\nEach operation is represented as a triplet:\n[startIndex, endIndex, inc] which increments each element of\nsubarray A[startIndex ... endIndex] (startIndex and endIndex inclusive) with inc.\n\nReturn the modified array after all k operations were executed.\n\nExample:\n\nInput: length = 5, updates = [[1,3,2],[2,4,3],[0,2,-2]]\nOutput: [-2,0,3,5,3]\nExplanation:\n\nInitial state:\n[0,0,0,0,0]\n\nAfter applying operation [1,3,2]:\n[0,2,2,2,0]\n\nAfter applying operation [2,4,3]:\n[0,2,5,5,3]\n\nAfter applying operation [0,2,-2]:\n[-2,0,3,5,3]\n\n*/\n/**\n * @param {number} length\n * @param {number[][]} updates\n * @return {number[]}\n */\nconst getModifiedArray = function(length, updates) {\n  const res = new Array(length).fill(0)\n  for (let update of updates) {\n    const [start, end, value] = update\n    res[start] += value\n    if (end < length - 1) res[end + 1] -= value\n  }\n  let sum = 0\n  for (let i = 0; i < length; i++) {\n    sum += res[i]\n    res[i] = sum\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "371-sum-of-two-integers",
    "code": {
      "JS": "/**\r\n * @param {number} a\r\n * @param {number} b\r\n * @return {number}\r\n */\r\nconst getSum = function(a, b) {\r\n  return b === 0 ? a : getSum(a ^ b, (a & b) << 1);\r\n};\r\n"
    }
  },
  {
    "name": "372-super-pow",
    "code": {
      "JS": "/**\n * @param {number} a\n * @param {number[]} b\n * @return {number}\n */\nconst superPow = function(a, b) {\n   const base = 1337\n   function powmod(a, k) {\n     a %= base\n     let res = 1\n     for(let i = 0; i < k; i++) res = res * a % base\n     return res\n   }\n   if(b.length === 0) return 1\n   const last = b.pop()\n   return powmod(superPow(a, b), 10) * powmod(a, last) % base\n}; \n"
    }
  },
  {
    "name": "373-find-k-pairs-with-smallest-sums",
    "code": {
      "JS": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @param {number} k\n * @return {number[][]}\n */\nconst kSmallestPairs = function (nums1, nums2, k) {\n  const pq = new PriorityQueue((a, b) => a[0] + a[1] < b[0] + b[1])\n  for(let i = 0; i < nums1.length && i < k; i++) {\n    pq.push([nums1[i], nums2[0], 0])\n  }\n  const res = []\n  while(k > 0 && !pq.isEmpty()) {\n    const [e1, e2, e2i] = pq.pop()\n    res.push([e1, e2])\n    if(e2i + 1 < nums2.length) pq.push([e1, nums2[e2i + 1], e2i + 1])\n    k--\n  }\n  \n  return res\n}\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n\n\n// another\n\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @param {number} k\n * @return {number[][]}\n */\nconst kSmallestPairs = function(nums1, nums2, k) {\n  let len1 = nums1.length,\n    len2 = nums2.length\n  let arr = Array(len1).fill(0),\n    resList = []\n  while (k-- > 0) {\n    let min = Infinity,\n      index = -1,\n      lastj = Infinity\n    for (let i = 0; i < len1; i++) {\n      const j = arr[i]\n      if (j < lastj && j < len2) {\n        const sum = nums1[i] + nums2[j]\n        if (sum < min) {\n          min = sum\n          index = i\n        }\n        lastj = j\n      }\n    }\n    if (index == -1) {\n      break\n    }\n    resList.push([nums1[index], nums2[arr[index]]])\n    arr[index]++\n  }\n  return resList\n}\n"
    }
  },
  {
    "name": "375-guess-number-higher-or-lower-ii",
    "code": {
      "JS": "/**\n\nWe are playing the Guess Game. The game is as follows:\nI pick a number from 1 to n. You have to guess which number I picked.\nEvery time you guess wrong, I'll tell you whether the number I picked is higher or lower.\nHowever, when you guess a particular number x, and you guess wrong, you pay $x.\nYou win the game when you guess the number I picked.\n\nExample:\n\nn = 10, I pick 8.\n\nFirst round:  You guess 5, I tell you that it's higher. You pay $5.\nSecond round: You guess 7, I tell you that it's higher. You pay $7.\nThird round:  You guess 9, I tell you that it's lower. You pay $9.\n\nGame over. 8 is the number I picked.\n\nYou end up paying $5 + $7 + $9 = $21.\nGiven a particular n ≥ 1, find out how much money you need to have to guarantee a win.\n\n*/\n\n/**\n * @param {number} n\n * @return {number}\n */\nconst getMoneyAmount = function(n) {\n  const dp = Array.from({length: n + 1}, () => new Array(n + 1).fill(0))\n  return helper(dp, 1, n)\n};\n\nfunction helper(dp, s, e) {\n  if(s >= e) return 0\n  if(dp[s][e] !== 0) return dp[s][e]\n  let res = Number.MAX_VALUE\n  for(let i = s; i <= e; i++) {\n    const tmp = i + Math.max(helper(dp, s, i - 1), helper(dp, i + 1, e))\n    res = Math.min(res, tmp)\n  }\n  dp[s][e] = res\n  return res\n}\n"
    }
  },
  {
    "name": "376-wiggle-subsequence",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst wiggleMaxLength = function(nums) {\n  if (nums.length < 2) return nums.length\n  let prevdiff = nums[1] - nums[0]\n  let count = prevdiff !== 0 ? 2 : 1\n  for (let i = 2; i < nums.length; i++) {\n    let diff = nums[i] - nums[i - 1]\n    if ((diff > 0 && prevdiff <= 0) || (diff < 0 && prevdiff >= 0)) {\n      count++\n      prevdiff = diff\n    }\n  }\n  return count\n}\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst wiggleMaxLength = function(nums) {\n  const len = nums.length\n  if (len === 0) return 0\n  let up = 1\n  let down = 1\n  for (let i = 1; i < len; i++) {\n    if (nums[i] > nums[i - 1]) {\n      up = down + 1\n    } else if (nums[i] < nums[i - 1]) {\n      down = up + 1\n    }\n  }\n  return Math.max(up, down)\n}\n"
    }
  },
  {
    "name": "377-combination-sum-IV",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n * @param {number} target\r\n * @return {number}\r\n */\r\nconst combinationSum4 = function(nums, target) {\r\n  const comb = [1];\r\n  for (let i = 1; i <= target; i++) {\r\n    comb[i] || (comb[i] = 0);\r\n    for (let j = 0; j < nums.length; j++) {\r\n      if (i >= nums[j]) {\r\n        comb[i] += comb[i - nums[j]];\r\n      }\r\n    }\r\n  }\r\n  return comb[target];\r\n};\r\n"
    }
  },
  {
    "name": "378-kth-smallest-element-in-a-sorted-matrix",
    "code": {
      "JS": "/**\r\n * @param {number[][]} matrix\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nconst kthSmallest = function(matrix, k) {\r\n  let lo = matrix[0][0],\r\n    hi = matrix[matrix.length - 1][matrix[0].length - 1] + 1; //[lo, hi)\r\n  while (lo < hi) {\r\n    let mid = Math.floor(lo + (hi - lo) / 2);\r\n    let count = 0,\r\n      j = matrix[0].length - 1;\r\n    for (let i = 0; i < matrix.length; i++) {\r\n      while (j >= 0 && matrix[i][j] > mid) j--;\r\n      count += j + 1;\r\n    }\r\n    if (count < k) lo = mid + 1;\r\n    else hi = mid;\r\n  }\r\n  return lo;\r\n};\r\n\r\nconsole.log(kthSmallest([[-5]], 1));\r\nconsole.log(kthSmallest([[1, 2], [1, 3]], 4));\r\nconsole.log(kthSmallest([[1, 5, 9], [10, 11, 13], [12, 13, 15]], 8));\r\nconsole.log(kthSmallest([[1, 2], [1, 3]], 2));\r\n"
    }
  },
  {
    "name": "379-design-phone-directory",
    "code": {
      "JS": "/**\n * Initialize your data structure here\n        @param maxNumbers - The maximum numbers that can be stored in the phone directory.\n * @param {number} maxNumbers\n */\nconst PhoneDirectory = function(maxNumbers) {\n  this.len = maxNumbers\n  this.used = new Set()\n  this.free = []\n}\n\n/**\n * Provide a number which is not assigned to anyone.\n        @return - Return an available number. Return -1 if none is available.\n * @return {number}\n */\nPhoneDirectory.prototype.get = function() {\n  if (this.used.size === this.len) return -1\n  const tmp = this.free.length === 0 ? this.used.size : this.free.pop()\n  this.used.add(tmp)\n  return tmp\n}\n\n/**\n * Check if a number is available or not.\n * @param {number} number\n * @return {boolean}\n */\nPhoneDirectory.prototype.check = function(number) {\n  return !this.used.has(number)\n}\n\n/**\n * Recycle or release a number.\n * @param {number} number\n * @return {void}\n */\nPhoneDirectory.prototype.release = function(number) {\n  if(this.used.has(number)) {\n    this.used.delete(number)\n    this.free.push(number)\n  }\n}\n\n/**\n * Your PhoneDirectory object will be instantiated and called as such:\n * var obj = new PhoneDirectory(maxNumbers)\n * var param_1 = obj.get()\n * var param_2 = obj.check(number)\n * obj.release(number)\n */\n"
    }
  },
  {
    "name": "38-count-and-say",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {string}\n */\nconst countAndSay = function(n) {\n  let str = '1'\n  for (let i = 2; i <= n; i++) {\n    let tempStr = ''\n    let count = 0\n    for (let j = 0, m = str.length; j < m; j++) {\n      const char = str.charAt(j)\n      count += 1\n      if (char !== str.charAt(j + 1)) {\n        tempStr += count + char\n        count = 0\n      }\n    }\n    str = tempStr\n  }\n  return str\n}\n"
    }
  },
  {
    "name": "380-insert-delete-getrandom-o1",
    "code": {
      "JS": "/**\n * Initialize your data structure here.\n */\nconst RandomizedSet = function () {\n  this.arr = []\n  this.map = new Map()\n}\n\n/**\n * Inserts a value to the set. Returns true if the set did not already contain the specified element.\n * @param {number} val\n * @return {boolean}\n */\nRandomizedSet.prototype.insert = function (val) {\n  const {arr, map} = this\n  if(map.has(val)) return false\n  const size = arr.length\n  arr.push(val)\n  map.set(val, size)\n  return true\n}\n\n/**\n * Removes a value from the set. Returns true if the set contained the specified element.\n * @param {number} val\n * @return {boolean}\n */\nRandomizedSet.prototype.remove = function (val) {\n  const {arr, map} = this\n  if(!map.has(val)) return false\n  const idx = map.get(val), last = arr[arr.length - 1]\n  arr[idx] = last\n  map.set(last, idx)\n  arr.pop()\n  map.delete(val)\n  return true\n}\n\n/**\n * Get a random element from the set.\n * @return {number}\n */\nRandomizedSet.prototype.getRandom = function () {\n  return this.arr[~~(this.arr.length * Math.random())]\n}\n\n/**\n * Your RandomizedSet object will be instantiated and called as such:\n * var obj = new RandomizedSet()\n * var param_1 = obj.insert(val)\n * var param_2 = obj.remove(val)\n * var param_3 = obj.getRandom()\n */\n"
    }
  },
  {
    "name": "381-insert-delete-getrandom-o1-duplicates-allowed",
    "code": {
      "JS": "/**\n * Initialize your data structure here.\n */\nconst RandomizedCollection = function() {\n  this.map = new Map()\n  this.list = []\n}\n\n/**\n * Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\n * @param {number} val\n * @return {boolean}\n */\nRandomizedCollection.prototype.insert = function(val) {\n  const index = this.list.length\n  const node = { val, index }\n  this.list[index] = node\n\n  const nodeList = this.map.get(val)\n  const isNew = nodeList === undefined || nodeList.length === 0\n  if (nodeList === undefined) {\n    this.map.set(val, [node])\n  } else {\n    nodeList.push(node)\n  }\n  return isNew\n}\n\n/**\n * Removes a value from the collection. Returns true if the collection contained the specified element.\n * @param {number} val\n * @return {boolean}\n */\nRandomizedCollection.prototype.remove = function(val) {\n  const nodeList = this.map.get(val)\n  if (!nodeList || nodeList.length === 0) return false\n  const node = nodeList.pop()\n  const replacement = this.list.pop()\n  if (replacement.index !== node.index) {\n    replacement.index = node.index\n    this.list[replacement.index] = replacement\n  }\n  return true\n}\n\n/**\n * Get a random element from the collection.\n * @return {number}\n */\nRandomizedCollection.prototype.getRandom = function() {\n  const index = Math.floor(Math.random() * this.list.length)\n  return this.list[index].val\n}\n\n/**\n * Your RandomizedCollection object will be instantiated and called as such:\n * var obj = new RandomizedCollection()\n * var param_1 = obj.insert(val)\n * var param_2 = obj.remove(val)\n * var param_3 = obj.getRandom()\n */\n"
    }
  },
  {
    "name": "382-linked-list-random-node",
    "code": {
      "JS": "/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n/**\r\n * @param head The linked list's head.\r\n        Note that the head is guaranteed to be not null, so it contains at least one node.\r\n * @param {ListNode} head\r\n */\r\nconst Solution = function(head) {\r\n  this.list = head;\r\n  this.arr = [];\r\n  loop(head, this.arr);\r\n};\r\n\r\n/**\r\n * Returns a random node's value.\r\n * @return {number}\r\n */\r\nSolution.prototype.getRandom = function() {\r\n  const len = this.arr.length;\r\n  return this.arr[Math.floor(Math.random() * len)].val;\r\n};\r\n\r\n/**\r\n * Your Solution object will be instantiated and called as such:\r\n * var obj = Object.create(Solution).createNew(head)\r\n * var param_1 = obj.getRandom()\r\n */\r\nfunction loop(node, arr) {\r\n  if (node == null) return;\r\n  arr.push(node);\r\n  loop(node.next, arr);\r\n}\r\n"
    }
  },
  {
    "name": "383-ransom-note",
    "code": {
      "JS": "/**\r\n * @param {string} ransomNote\r\n * @param {string} magazine\r\n * @return {boolean}\r\n */\r\nconst canConstruct = function(ransomNote, magazine) {\r\n  const m = new Map()\r\n  for(let c of magazine) {\r\n    m.set(c, (m.get(c) || 0) + 1 )\r\n  }\r\n  for(let c of ransomNote) {\r\n    if(!m.has(c) || m.get(c) <= 0) return false\r\n    m.set(c, m.get(c) - 1)\r\n  }\r\n  return true\r\n};\r\n"
    }
  },
  {
    "name": "384-shuffle-an-array",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n */\r\nconst Solution = function(nums) {\r\n  this.original = nums;\r\n};\r\n/**\r\n * Resets the array to its original configuration and return it.\r\n * @return {number[]}\r\n */\r\nSolution.prototype.reset = function() {\r\n  return this.original;\r\n};\r\n\r\n/**\r\n * Returns a random shuffling of the array.\r\n * @return {number[]}\r\n */\r\nSolution.prototype.shuffle = function() {\r\n  const res = [];\r\n  const len = this.original.length;\r\n  let idx = 0;\r\n  let i = 0;\r\n  while (idx <= len - 1) {\r\n    i = Math.floor(Math.random() * len);\r\n    if (res[i] == null) {\r\n      res[i] = this.original[idx];\r\n      idx += 1;\r\n    }\r\n  }\r\n  return res;\r\n};\r\n\r\n/**\r\n * Your Solution object will be instantiated and called as such:\r\n * var obj = Object.create(Solution).createNew(nums)\r\n * var param_1 = obj.reset()\r\n * var param_2 = obj.shuffle()\r\n */\r\n"
    }
  },
  {
    "name": "385-mini-parser",
    "code": {
      "JS": "/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * function NestedInteger() {\n *\n *     Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     @return {boolean}\n *     this.isInteger = function() {\n *         ...\n *     };\n *\n *     Return the single integer that this NestedInteger holds, if it holds a single integer\n *     Return null if this NestedInteger holds a nested list\n *     @return {integer}\n *     this.getInteger = function() {\n *         ...\n *     };\n *\n *     Set this NestedInteger to hold a single integer equal to value.\n *     @return {void}\n *     this.setInteger = function(value) {\n *         ...\n *     };\n *\n *     Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\n *     @return {void}\n *     this.add = function(elem) {\n *         ...\n *     };\n *\n *     Return the nested list that this NestedInteger holds, if it holds a nested list\n *     Return null if this NestedInteger holds a single integer\n *     @return {NestedInteger[]}\n *     this.getList = function() {\n *         ...\n *     };\n * };\n */\n/**\n * @param {string} s\n * @return {NestedInteger}\n */\nconst deserialize = function(s) {\n  const recursion = s => {\n    const re = new NestedInteger()\n    if (!s || s.length === 0) {\n      return re\n    }\n    if (s.charAt(0) !== '[') {\n      re.setInteger(parseInt(s, 10))\n    } else if (s.length > 2) {\n      let start = 1\n      let cnt = 0\n      for (let i = 1; i < s.length; i++) {\n        const char = s.charAt(i)\n        if (cnt === 0 && (char === ',' || i === s.length - 1)) {\n          re.add(recursion(s.substring(start, i)))\n          start = i + 1\n        } else if (char === '[') {\n          cnt++\n        } else if (char === ']') {\n          cnt--\n        }\n      }\n    }\n    return re\n  }\n  return recursion(s)\n}\n"
    }
  },
  {
    "name": "386-lexicographical-numbers",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number[]}\n */\nconst lexicalOrder = function(n) {\n  const result = []\n  for (let i = 1; i < 10; i++) {\n    dfs(i)\n  }\n  function dfs(n) {\n    if (n <= num) result.push(n)\n    if (10 * n <= num) {\n      for (let j = 0; j < 10; j++) {\n        dfs(10 * n + j)\n      }\n    }\n  }\n  return result\n}\n\n// another\n\nconst lexicalOrder = function(n) {\n  function getNumberByOrder(start, end) {\n    for (let i = start; i <= end; i++) {\n      if (i > n) {\n        break\n      }\n      res.push(i)\n      getNumberByOrder(i * 10, i * 10 + 9)\n    }\n  }\n  const res = []\n  getNumberByOrder(1, 9)\n  return res\n}\n"
    }
  },
  {
    "name": "387-first-unique-character-in-a-string",
    "code": {
      "JS": "/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nconst firstUniqChar = function(s) {\r\n  const arr = [];\r\n  const res = [];\r\n  const hash = {};\r\n  let tmp;\r\n  let idx;\r\n  for (let i = 0; i < s.length; i++) {\r\n    tmp = s.charAt(i);\r\n    if (hash.hasOwnProperty(tmp)) {\r\n      idx = arr.indexOf(tmp);\r\n      if (idx >= 0) {\r\n        arr.splice(idx, 1);\r\n        res.splice(idx, 1);\r\n      }\r\n\r\n      hash[tmp] += 1;\r\n    } else {\r\n      arr.push(tmp);\r\n      res.push(i);\r\n      hash[tmp] = 1;\r\n    }\r\n  }\r\n  return res[0] == null ? -1 : res[0];\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nconst firstUniqChar = function(s) {\r\n    if(s === '') return -1\r\n    const map = new Map()\r\n    for(let i = 0, len = s.length; i < len; i++) {\r\n      if(!map.has(s[i])) map.set(s[i], [i, 0])\r\n      map.get(s[i])[1] += 1\r\n    }\r\n    for(let [key, val] of map) {\r\n      if(val[1] === 1) return val[0]\r\n    }\r\n    return -1\r\n    \r\n};\r\n"
    }
  },
  {
    "name": "388-longest-absolute-file-path",
    "code": {
      "JS": "/**\n * @param {string} input\n * @return {number}\n */\nconst lengthLongestPath = function(input) {\n  const stack = []\n  return input.split('\\n').reduce((max, p) => {\n    const level = p.lastIndexOf('\\t') + 1\n    stack[level] = p.length - level + (level ? stack[level - 1] : 0)\n    return p.indexOf('.') === -1 ? max : Math.max(max, stack[level] + level)\n  }, 0)\n}\n"
    }
  },
  {
    "name": "389-find-the-difference",
    "code": {
      "JS": "/**\r\n * @param {string} s\r\n * @param {string} t\r\n * @return {character}\r\n */\r\nconst findTheDifference = function(s, t) {\r\n  let xor = 0\r\n  for(let i = 0, len = s.length; i < len; i++) xor = xor ^ s.charCodeAt(i) ^ t.charCodeAt(i)\r\n  xor = xor ^ t.charCodeAt(t.length - 1)\r\n  return String.fromCharCode(xor)\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * @param {string} s\r\n * @param {string} t\r\n * @return {character}\r\n */\r\nconst findTheDifference = function(s, t) {\r\n  const arr = s.split(\"\");\r\n  let idx;\r\n  for (let i = 0; i < t.length; i++) {\r\n    idx = arr.indexOf(t[i]);\r\n    if (idx === -1) {\r\n      return t[i];\r\n    } else {\r\n      arr.splice(idx, 1);\r\n    }\r\n  }\r\n};\r\n\r\nconsole.log(findTheDifference(\"abcd\", \"abcde\"));\r\n"
    }
  },
  {
    "name": "39-combination-sum",
    "code": {
      "JS": "/**\r\n * @param {number[]} candidates\r\n * @param {number} target\r\n * @return {number[][]}\r\n */\r\nconst combinationSum = function(candidates, target) {\r\n  candidates.sort((a, b) => a - b);\r\n  const res = [];\r\n  bt(candidates, target, res, [], 0);\r\n  return res;\r\n};\r\n\r\nfunction bt(candidates, target, res, combination, start) {\r\n  if (target === 0) {\r\n    res.push(combination.slice(0));\r\n    return;\r\n  }\r\n  for (let i = start; i < candidates.length && target >= candidates[i]; i++) {\r\n    combination.push(candidates[i]);\r\n    bt(candidates, target - candidates[i], res, combination, i);\r\n    combination.pop();\r\n  }\r\n}\r\n"
    }
  },
  {
    "name": "390-elimination-game",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst lastRemaining = function(n) {\n  let left = true\n  let remaining = n\n  let step = 1\n  let head = 1\n  while (remaining > 1) {\n    if (left || remaining % 2 === 1) {\n      head = head + step\n    }\n    remaining = remaining >> 1\n    step = step * 2\n    left = !left\n  }\n  return head\n}\n"
    }
  },
  {
    "name": "391-perfect-rectangle",
    "code": {
      "JS": "/**\n * @param {number[][]} rectangles\n * @return {boolean}\n */\nconst isRectangleCover = function(rectangles) {\n  let tls = new Set()\n  let trs = new Set()\n  let bls = new Set()\n  let brs = new Set()\n  let corner = (x, y) => `${x} ${y}`\n  for (let [l, b, r, t] of rectangles) {\n    let tl = corner(t, l)\n    let tr = corner(t, r)\n    let bl = corner(b, l)\n    let br = corner(b, r)\n    if (tls.has(tl) || trs.has(tr) || bls.has(bl) || brs.has(br)) return false\n    if (!bls.delete(tl) && !trs.delete(tl)) tls.add(tl)\n    if (!brs.delete(tr) && !tls.delete(tr)) trs.add(tr)\n    if (!brs.delete(bl) && !tls.delete(bl)) bls.add(bl)\n    if (!bls.delete(br) && !trs.delete(br)) brs.add(br)\n  }\n  return tls.size === 1 && trs.size === 1 && bls.size === 1 && brs.size === 1\n}\n"
    }
  },
  {
    "name": "392-is-subsequence",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nconst isSubsequence = function(s, t) {\n  const sl = s.length\n  const tl = t.length\n  if(sl > tl) return false\n  if(sl === 0) return true\n  let si = 0\n  for(let i = 0; i < tl && si < sl; i++) {\n    if(s[si] === t[i]) si++\n  }\n  return si === sl\n};\n\n// another\n\n/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nconst isSubsequence = function(s, t) {\n  let ti = 0\n  let tmp = 0\n  for (let i = 0; i < s.length; i++) {\n    if ((tmp = chk(t, ti, s.charAt(i))) === -1) {\n      return false\n    } else {\n      ti = tmp + 1\n    }\n  }\n\n  return true\n}\n\nfunction chk(str, start, target) {\n  let idx = start\n  for (let i = start; i < str.length; i++) {\n    if (str.charAt(i) === target) {\n      return i\n    }\n  }\n  return -1\n}\n"
    }
  },
  {
    "name": "393-utf-8-validation",
    "code": {
      "JS": "/**\n * @param {number[]} data\n * @return {boolean}\n */\nconst validUtf8 = function(data) {\n  let count = 0\n  for (let c of data) {\n    if (count === 0) {\n      if (c >> 5 === 0b110) count = 1\n      else if (c >> 4 === 0b1110) count = 2\n      else if (c >> 3 === 0b11110) count = 3\n      else if (c >> 7) return false\n    } else {\n      if (c >> 6 !== 0b10) return false\n      count--\n    }\n  }\n  return count == 0\n}\n"
    }
  },
  {
    "name": "394-decode-string",
    "code": {
      "JS": "/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nconst decodeString = function(s) {\r\n  const repeated = [];\r\n  const sbStack = [];\r\n\r\n  let mul = 0;\r\n  let sb = \"\";\r\n  for (let i = 0; i < s.length; i++) {\r\n    const c = s.charAt(i);\r\n    if (isDigit(c)) {\r\n      if (mul === 0) sbStack.push(sb); // here is the trick\r\n      mul = mul * 10 + +c;\r\n    } else if (c === \"[\") {\r\n      repeated.push(mul);\r\n      mul = 0;\r\n      sb = \"\";\r\n    } else if (isLetter(c)) {\r\n      sb += c;\r\n    } else if (c === \"]\") {\r\n      let top = sbStack.pop();\r\n      let r = repeated.pop();\r\n      while (r-- > 0) top += sb;\r\n      sb = top;\r\n    }\r\n  }\r\n\r\n  return sb;\r\n};\r\n\r\nfunction isDigit(c) {\r\n  return c.charCodeAt(0) >= 48 && c.charCodeAt(0) <= 57;\r\n}\r\n\r\nfunction isLetter(c) {\r\n  return (\r\n    (c.charCodeAt(0) >= 65 && c.charCodeAt(0) <= 90) ||\r\n    (c.charCodeAt(0) >= 97 && c.charCodeAt(0) <= 122)\r\n  );\r\n}\r\n"
    }
  },
  {
    "name": "395-longest-substring-with-at-least-k-repeating-characters",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nconst longestSubstring = function (s, k) {\n  if (s == null || s.length === 0) return 0\n  const chars = new Array(26).fill(0)\n  const aCode = 'a'.charCodeAt(0)\n  for (let i = 0; i < s.length; i++) chars[s.charCodeAt(i) - aCode] += 1\n  let flag = true\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i] < k && chars[i] > 0) flag = false\n  }\n  if (flag === true) {\n    return s.length\n  }\n  let result = 0\n  let start = 0\n  let cur = 0\n  while (cur < s.length) {\n    if (chars[s.charCodeAt(cur) - aCode] < k) {\n      result = Math.max(result, longestSubstring(s.slice(start, cur), k))\n      start = cur + 1\n    }\n    cur++\n  }\n  result = Math.max(result, longestSubstring(s.slice(start), k))\n  return result\n}\n"
    }
  },
  {
    "name": "396-rotate-function",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @return {number}\n */\nconst maxRotateFunction = function(A) {\n    if(A.length === 0) return 0;\n    let sum = 0, iteration = 0, len = A.length;\n    for(let i = 0; i < len; i++){\n        sum += A[i];\n        iteration += (A[i] * i);\n    }\n    let max = iteration;\n    for(let j = 1; j < len; j++){\n        // for next iteration lets remove one entry value\n        // of each entry and the prev 0 * k\n        iteration = iteration - sum + A[j-1]*len;\n        max = Math.max(max, iteration);\n    }\n    return max;\n};\n"
    }
  },
  {
    "name": "397-integer-replacement",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst integerReplacement = function(n, memo = {}) {\n    if (n === 1) return 0;\n    if (memo[n]) return memo[n];\n    memo[n] = n % 2 === 0 ? integerReplacement(n/2, memo) + 1 : Math.min(integerReplacement(n+1, memo), integerReplacement(n-1, memo)) + 1;\n    return memo[n]; \n};\n\n// another\nconst integerReplacement = function(n) {\n    let c = 0;\n    while (n !== 1) {\n        if ((n & 1) === 0) {\n            n >>>= 1;\n        } else if (n === 3 || ((n >>> 1) & 1) === 0) {\n            --n;\n        } else {\n            ++n;\n        }\n        ++c;\n    }\n    return c;  \n};\n"
    }
  },
  {
    "name": "398-random-pick-index",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n */\r\nconst Solution = function(nums) {\r\n  this.nums = nums;\r\n};\r\n\r\n/**\r\n * @param {number} target\r\n * @return {number}\r\n */\r\nSolution.prototype.pick = function(target) {\r\n  const res = [];\r\n  for (let i = 0; i < this.nums.length; i++) {\r\n    if (this.nums[i] === target) {\r\n      res.push(i);\r\n    }\r\n  }\r\n  return res[Math.floor(Math.random() * res.length)];\r\n};\r\n\r\n/**\r\n * Your Solution object will be instantiated and called as such:\r\n * var obj = Object.create(Solution).createNew(nums)\r\n * var param_1 = obj.pick(target)\r\n */\r\n"
    }
  },
  {
    "name": "399-evaluate-division",
    "code": {
      "JS": "/**\r\n * @param {string[][]} equations\r\n * @param {number[]} values\r\n * @param {string[][]} queries\r\n * @return {number[]}\r\n */\r\nconst calcEquation = function(equations, values, queries) {\r\n  const m = {};\r\n  for (let i = 0; i < values.length; i++) {\r\n    if (!m.hasOwnProperty(equations[i][0])) m[equations[i][0]] = {};\r\n    if (!m.hasOwnProperty(equations[i][1])) m[equations[i][1]] = {};\r\n    m[equations[i][0]][equations[i][1]] = values[i];\r\n    m[equations[i][1]][equations[i][0]] = 1 / values[i];\r\n  }\r\n  const r = [];\r\n  for (let i = 0; i < queries.length; i++) {\r\n    r[i] = dfs(queries[i][0], queries[i][1], 1, m, []);\r\n  }\r\n  return r;\r\n};\r\n\r\nfunction dfs(s, t, r, m, seen) {\r\n  if (!m.hasOwnProperty(s) || !hsetAdd(seen, s)) return -1;\r\n  if (s === t) return r;\r\n  let next = m[s];\r\n  for (let c of Object.keys(next)) {\r\n    let result = dfs(c, t, r * next[c], m, seen);\r\n    if (result !== -1) return result;\r\n  }\r\n  return -1;\r\n}\r\n\r\nfunction hsetAdd(arr, el) {\r\n  if (arr.indexOf(el) === -1) {\r\n    arr.push(el);\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\n"
    }
  },
  {
    "name": "4-median-of-two-sorted-arrays",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums1\r\n * @param {number[]} nums2\r\n * @return {number}\r\n */\r\nconst findMedianSortedArrays = function(nums1, nums2) {\r\n  if(nums1.length > nums2.length) return findMedianSortedArrays(nums2, nums1)\r\n  const m = nums1.length, n = nums2.length\r\n  let low = 0, high = m\r\n  while(low <= high) {\r\n    \r\n    const px = Math.floor((low + high) / 2)\r\n    const py = Math.floor(( m + n + 1 ) / 2) - px\r\n    \r\n    const maxLeft1 = px === 0 ? -Infinity : nums1[px - 1]\r\n    const minRight1 = px === m ? Infinity : nums1[px]\r\n    \r\n    const maxLeft2 = py === 0 ? -Infinity : nums2[py - 1]\r\n    const minRight2 = py === n ? Infinity : nums2[py]\r\n    \r\n    if(maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {\r\n      if((m + n) % 2 === 0) {\r\n        return (Math.max(maxLeft1, maxLeft2) + Math.min(minRight1, minRight2)) / 2\r\n      } else {\r\n        return Math.max(maxLeft1, maxLeft2)\r\n      }\r\n    } else if(maxLeft1 > minRight2) {\r\n      high = px - 1        \r\n    } else {\r\n      low = px + 1\r\n    }\r\n    \r\n  }\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * @param {number[]} A\r\n * @param {number[]} B\r\n * @return {number}\r\n */\r\n\r\nconst findMedianSortedArrays = function(A, B) {\r\n  let m = A.length,\r\n    n = B.length;\r\n\r\n  if (m > n) {\r\n    return findMedianSortedArrays(B, A);\r\n  }\r\n\r\n  let imin = 0,\r\n    imax = m,\r\n    i,\r\n    j;\r\n  while (imin <= imax) {\r\n    i = (imin + imax) >> 1;\r\n    j = ((m + n + 1) >> 1) - i;\r\n    if (j > 0 && i < m && B[j - 1] > A[i]) {\r\n      imin = i + 1;\r\n    } else if (i > 0 && j < n && A[i - 1] > B[j]) {\r\n      imax = i - 1;\r\n    } else {\r\n      if (i === 0) {\r\n        num1 = B[j - 1];\r\n      } else if (j === 0) {\r\n        num1 = A[i - 1];\r\n      } else {\r\n        num1 = Math.max(A[i - 1], B[j - 1]);\r\n      }\r\n\r\n      if ((m + n) & 1) {\r\n        return num1;\r\n      }\r\n\r\n      if (i === m) {\r\n        num2 = B[j];\r\n      } else if (j === n) {\r\n        num2 = A[i];\r\n      } else {\r\n        num2 = Math.min(A[i], B[j]);\r\n      }\r\n      return (num1 + num2) / 2.0;\r\n    }\r\n  }\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * @param {number[]} nums1\r\n * @param {number[]} nums2\r\n * @return {number}\r\n */\r\nconst findMedianSortedArrays = function (nums1, nums2) {\r\n  if (nums1.length > nums2.length) {\r\n    return findMedianSortedArrays(nums2, nums1)\r\n  }\r\n  const x = nums1.length\r\n  const y = nums2.length\r\n\r\n  let low = 0\r\n  let high = x\r\n\r\n  while (low <= high) {\r\n    const partX = Math.floor((low + high) / 2)\r\n    const partY = Math.floor((x + y + 1) / 2) - partX\r\n\r\n    const maxX = partX === 0 ? Number.NEGATIVE_INFINITY : nums1[partX - 1]\r\n    const maxY = partY === 0 ? Number.NEGATIVE_INFINITY : nums2[partY - 1]\r\n\r\n    const minX =\r\n      partX === nums1.length ? Number.POSITIVE_INFINITY : nums1[partX]\r\n    const minY =\r\n      partY === nums2.length ? Number.POSITIVE_INFINITY : nums2[partY]\r\n\r\n    if (maxX <= minY && maxY <= minX) {\r\n      const lowMax = Math.max(maxX, maxY)\r\n\r\n      if ((x + y) % 2 == 1) {\r\n        return Math.max(maxX, maxY)\r\n      } else {\r\n        return (Math.max(maxX, maxY) + Math.min(minX, minY)) / 2\r\n      }\r\n    } else if (maxX < minY) {\r\n      low = partX + 1\r\n    } else {\r\n      high = partX - 1\r\n    }\r\n  }\r\n}\r\n\r\n\r\n"
    }
  },
  {
    "name": "40-combination-sum-II",
    "code": {
      "JS": "/**\r\n * @param {number[]} candidates\r\n * @param {number} target\r\n * @return {number[][]}\r\n */\r\nconst combinationSum2 = function(candidates, target) {\r\n  candidates.sort((a, b) => a - b);\r\n  const res = [];\r\n  bt(candidates, target, res, [], 0);\r\n  return res;\r\n};\r\n\r\nfunction bt(candidates, target, res, combination, start) {\r\n  if (target === 0) {\r\n    res.push(combination.slice(0));\r\n    return;\r\n  }\r\n  for (let i = start; i < candidates.length && target >= candidates[i]; i++) {\r\n    if (i > 0 && candidates[i] === candidates[i - 1] && i > start) continue;\r\n    combination.push(candidates[i]);\r\n    bt(candidates, target - candidates[i], res, combination, i + 1);\r\n    combination.pop();\r\n  }\r\n}\r\n"
    }
  },
  {
    "name": "400-nth-digit",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst findNthDigit = function(n) {\n    let start = 1\n    let len = 1\n    let base = 9\n    while(n > len * base) {\n      n = n - len * base\n      len++\n      start *= 10\n      base *= 10\n    }\n    let target = start + (n - 1) / len\n    let reminder = (n - 1) % len\n    return (''+target).charAt(reminder)\n};\n"
    }
  },
  {
    "name": "401-binary-watch",
    "code": {
      "JS": "/**\n * @param {number} num\n * @return {string[]}\n */\nconst readBinaryWatch = function(num) {\n  const output = []\n  for (let h = 0; h < 12; h++) {\n    for (let m = 0; m < 60; m++) {\n      const ones = Number(h * 64 + m)\n        .toString(2)\n        .split('')\n        .filter(d => d === '1').length\n      if (ones === num) output.push(m < 10 ? `${h}:0${m}` : `${h}:${m}`)\n    }\n  }\n  return output\n}\n"
    }
  },
  {
    "name": "402-remove-k-digits",
    "code": {
      "JS": "/**\n * @param {string} num\n * @param {number} k\n * @return {string}\n */\nconst removeKdigits = function(num, k) {\n  const digits = num.length - k;\n  const stk = new Array(num.length);\n  let top = 0;\n  // k keeps track of how many characters we can remove\n  // if the previous character in stk is larger than the current one\n  // then removing it will get a smaller number\n  // but we can only do so when k is larger than 0\n  for (let i = 0; i < num.length; i++) {\n    let c = num.charAt(i);\n    while (top > 0 && stk[top - 1] > c && k > 0) {\n      top -= 1;\n      k -= 1;\n    }\n    stk[top++] = c;\n  }\n  // find the index of first non-zero digit\n  let idx = 0;\n  while (idx < digits && stk[idx] === \"0\") idx++;\n  return idx === digits ? \"0\" : stk.slice(idx, digits + idx).join(\"\");\n};\n\n\n// another\n\n/**\n * @param {string} num\n * @param {number} k\n * @return {string}\n */\nconst removeKdigits = function(num, k) {\n  const n = num.length, stack = []\n  if(n === k) return '0'\n  let i = 0\n  while(i < n) {\n    while(k > 0 && stack.length && stack[stack.length - 1] > num[i]) {\n      k--\n      stack.pop()\n    }\n    stack.push(num[i++])\n  }\n  while(k-- > 0) stack.pop()\n  while(stack[0] === '0') stack.shift()\n  return stack.length ? stack.join('') : '0'\n};\n\n// another\n\n/**\n * @param {string} num\n * @param {number} k\n * @return {string}\n */\nconst removeKdigits = function(num, k) {\n  const n = num.length, stack = []\n  for(let i = 0; i < n; i++) {\n    const ch = num[i]\n    while(stack.length && k > 0 && ch < stack[stack.length - 1]) {\n      stack.pop()\n      k--\n    }\n    stack.push(ch)\n  }\n  while(k > 0) {\n    stack.pop()\n    k--\n  }\n  while(stack[0] === '0') stack.shift()\n  return stack.length ? stack.join('') : '0'\n};\n"
    }
  },
  {
    "name": "403-frog-jump",
    "code": {
      "JS": "/**\n * @param {number[]} stones\n * @return {boolean}\n */\nconst canCross = function(stones) {\n  for (let i = 3; i < stones.length; i++) {\n    if (stones[i] > stones[i - 1] * 2) {\n      return false\n    }\n  }\n  const count = new Set(stones)\n  const lastStone = stones[stones.length - 1]\n  const position = [0]\n  const jump = [0]\n  while (position.length > 0) {\n    const nextPosition = position.pop()\n    const nextDistance = jump.pop()\n    for (let i = nextDistance - 1; i <= nextDistance + 1; i++) {\n      if (i <= 0) {\n        continue\n      }\n      const nextStone = nextPosition + i\n      if (nextStone == lastStone) {\n        return true\n      } else if (count.has(nextStone)) {\n        position.push(nextStone)\n        jump.push(i)\n      }\n    }\n  }\n  return false\n}\n"
    }
  },
  {
    "name": "404-sum-of-left-leaves",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nconst sumOfLeftLeaves = function(root) {\n  if(root == null) return 0\n  let res = 0\n  function dfs(node, side) {\n    if(node === null) return\n    if(node.left === null && node.right === null) {\n      if(side === 'left') res += node.val\n      return\n    }\n    dfs(node.left, 'left')\n    dfs(node.right, 'right')\n  }\n  dfs(root.left, 'left')\n  dfs(root.right, 'right')\n\n  return res\n};\n"
    }
  },
  {
    "name": "405-convert-a-number-to-hexadecimal",
    "code": {
      "JS": "/**\n * @param {number} num\n * @return {string}\n */\nconst toHex = function(num) {\n    const bin = (num >>> 0).toString(2)\n    const arr = ['0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f']\n    const mod = bin.length % 4\n    const r = []\n    if(mod !== 0 ){\n        r.push(arr[ parseInt(bin.slice(0, mod),2) ])\n    }\n    \n    for(let i = mod; i < bin.length; i = i + 4) {\n        r.push(arr[ parseInt(bin.slice(i, i+4),2) ])\n    }\n    return r.join('')\n};\n"
    }
  },
  {
    "name": "406-queue-reconstruction-by-height",
    "code": {
      "JS": "/**\n * @param {number[][]} people\n * @return {number[][]}\n */\nconst reconstructQueue = function (people) {\n  const h = 0\n  const k = 1\n  people.sort((a, b) => (a[h] == b[h] ? a[k] - b[k] : b[h] - a[h]))\n  let queue = []\n  for (let person of people) {\n    queue.splice(person[k], 0, person)\n  }\n  return queue\n}\n\n// another\n\n/**\n * @param {number[][]} people\n * @return {number[][]}\n */\nconst reconstructQueue = function(people) {\n  if (!people) return [];\n  const peopledct = {};\n  let height = [];\n  const res = [];\n  people.forEach((el, idx) => {\n    if (peopledct.hasOwnProperty(el[0])) {\n      peopledct[el[0]].push([el[1], idx]);\n    } else {\n      peopledct[el[0]] = [[el[1], idx]];\n      height.push(el[0]);\n    }\n  });\n  height = height.sort((a, b) => b - a);\n\n  for (let i = 0; i < height.length; i++) {\n    peopledct[height[i]] = peopledct[height[i]].sort((a, b) => a[0] - b[0]);\n    for (el of peopledct[height[i]]) {\n      res.splice(el[0], 0, people[el[1]]);\n    }\n  }\n  return res;\n};\n\nconsole.log(reconstructQueue([[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]));\n"
    }
  },
  {
    "name": "407-trapping-rain-water-ii",
    "code": {
      "JS": "/**\n * @param {number[][]} heightMap\n * @return {number}\n */\n\nconst trapRainWater = function (heightMap) {\n  const pq = new PriorityQueue((a, b) => a[2] < b[2])\n  const m = heightMap.length, n = heightMap[0].length\n  \n  const visited = Array.from({ length: m }, () => Array(n).fill(false))\n  \n  for(let i = 0; i < m; i++) {\n    visited[i][0] = visited[i][n - 1] = true\n    pq.push([i, 0, heightMap[i][0]])\n    pq.push([i, n - 1, heightMap[i][n - 1]])\n  }\n  for(let j = 1; j < n - 1; j++) {\n    visited[0][j] = visited[m - 1][j] = true\n    pq.push([0, j, heightMap[0][j]], [m - 1, j, heightMap[m - 1][j]])\n  }\n  \n  let res = 0\n  const dirs = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n  while(!pq.isEmpty()) {\n    const cur = pq.pop()\n    const [r, c, h] = cur\n    for(let dir of dirs) {\n      const newR = r + dir[0], newC = c + dir[1]\n      if(newR < 0 || newR >= m || newC < 0 || newC >= n || visited[newR][newC]) continue\n      visited[newR][newC] = true\n      res += Math.max(0, h - heightMap[newR][newC])\n      pq.push([newR, newC, Math.max(h, heightMap[newR][newC])])\n    }\n  }\n  \n  return res\n\n}\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n\n\n\n// another\n\n/**\n * @param {number[][]} heightMap\n * @return {number}\n */\n\nconst trapRainWater = function (heightMap) {\n  const pq = new PriorityQueue((a, b) => a[2] < b[2])\n  const visited = []\n  for (let i = 0; i < heightMap.length; i++) {\n    visited[i] = []\n    for (let j = 0; j < heightMap[0].length; j++) {\n      if (\n        i > 0 &&\n        i < heightMap.length - 1 &&\n        j > 0 &&\n        j < heightMap[0].length - 1\n      )\n        continue\n      pq.push([i, j, heightMap[i][j]])\n      visited[i][j] = true\n    }\n  }\n\n  let max = -Infinity,\n    count = 0\n  while (!pq.isEmpty()) {\n    const cur = pq.pop()\n    if (cur[2] > max) max = cur[2]\n    check(cur[0], cur[1])\n  }\n  function check(row, col) {\n    const step = [\n      [-1, 0],\n      [1, 0],\n      [0, -1],\n      [0, 1],\n    ]\n    for (let i = 0; i < step.length; i++) {\n      let newR = row + step[i][0],\n        newC = col + step[i][1]\n      if (\n        newR < 0 ||\n        newR >= heightMap.length ||\n        newC < 0 ||\n        newC >= heightMap[0].length\n      )\n        continue\n      if (visited[newR][newC]) continue\n      visited[newR][newC] = true\n      const newVal = heightMap[newR][newC]\n      if (newVal < max) {\n        count += max - newVal\n        check(newR, newC)\n      } else {\n        pq.push([newR, newC, newVal])\n      }\n    }\n  }\n\n  return count\n}\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n\n\n// another\n\n/**\n * @param {number[][]} heightMap\n * @return {number}\n */\nconst trapRainWater = function(heightMap) {\n\n    function PriorityQueueMin(){\n      let heap=[null]\n      function swim(idx){\n        if(idx<2)return\n        let k=Math.floor(idx/2)\n        if(heap[idx][2]-heap[k][2]<0){\n          swap(heap,idx,k)\n          idx=k\n          swim(idx)\n        }\n      }\n      function sink(idx){\n        let k=Math.floor(idx*2)\n        if(k>=heap.length)return\n        if(k<heap.length && heap[k+1] && heap[k][2]-heap[k+1][2]>0) k++\n        if(heap[idx][2]-heap[k][2]>0){\n          swap(heap,idx,k)\n          idx=k\n          sink(idx)\n        }\n      }\n      function swap(arr,i,j){\n        let temp=arr[i]\n        arr[i]=arr[j]\n        arr[j]=temp\n      }\n      this.insert=function (v) {\n        heap.push(v)\n        swim(heap.length-1)\n      }\n      this.delMin=function () {\n        swap(heap,1,heap.length-1)\n        let min=heap.pop()\n        sink(1)\n        return min\n      }\n      this.isEmpty=function () {\n        return heap.length===1\n      }\n    }\n  \n    let pq=new PriorityQueueMin()\n    let visited=[]\n    for(let i=0;i<heightMap.length;i++){\n      visited[i]=[]\n      for(let j=0;j<heightMap[0].length;j++){\n        if((i>0 && i<heightMap.length-1) && (j>0 && j<heightMap[0].length-1))continue\n        pq.insert([i,j,heightMap[i][j]])\n        visited[i][j]=true\n      }\n    }\n  \n    let max=-Infinity,count=0\n    while(!pq.isEmpty()){\n      let cur=pq.delMin()\n      if(cur[2]>max)max=cur[2]\n      check(cur[0],cur[1])\n    }\n    function check(row,col){\n      let step=[[-1,0],[1,0],[0,-1],[0,1]]\n      for(let i=0;i<step.length;i++){\n        let newR=row+step[i][0],newC=col+step[i][1]\n        if((newR<0 || newR>=heightMap.length) || (newC<0 || newC>=heightMap[0].length))continue\n        if(visited[newR][newC])continue\n        visited[newR][newC]=true\n        let newVal=heightMap[newR][newC]\n        if(newVal<max){\n          count+=max-newVal\n          check(newR,newC)\n        }else{\n          pq.insert([newR,newC,newVal])\n        }\n      }\n    }\n  \n    return count\n  };\n"
    }
  },
  {
    "name": "408-valid-word-abbreviation",
    "code": {
      "JS": "/**\n * @param {string} word\n * @param {string} abbr\n * @return {boolean}\n */\nconst validWordAbbreviation = (word, abbr) => {\n  if (word == null || abbr == null) return false\n  let i = 0\n  let j = 0\n  const len = word.length\n  const aLen = abbr.length\n  while (i < len && j < aLen) {\n    if (isNum(abbr[j])) {\n      if (abbr[j] === '0') return false\n      let n = 0\n      while (j < aLen && isNum(abbr[j])) {\n        n = n * 10 + Number(abbr[j])\n        j++\n      }\n      i += n\n    } else {\n      if (word[i] !== abbr[j]) return false\n      i++\n      j++\n    }\n  }\n  return i === word.length && j === aLen\n}\nconst isNum = c => !isNaN(c)\n\n// another\n\n/**\n * @param {string} word\n * @param {string} abbr\n * @return {boolean}\n */\nconst validWordAbbreviation = (word, abbr) => {\n  let i = 0,\n    j = 0\n  while (i < word.length && j < abbr.length) {\n    if (word.charAt(i) === abbr.charAt(j)) {\n      ++i\n      ++j\n      continue\n    }\n    if (abbr.charAt(j) <= '0' || abbr.charAt(j) > '9') {\n      return false\n    }\n    let start = j\n    while (j < abbr.length && abbr.charAt(j) >= '0' && abbr.charAt(j) <= '9') {\n      ++j\n    }\n    let num = +abbr.slice(start, j)\n    i += num\n  }\n  return i == word.length && j == abbr.length\n}\n"
    }
  },
  {
    "name": "409-longest-palindrome",
    "code": {
      "JS": "/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nconst longestPalindrome = function (s) {\r\n  const set = new Set()\r\n  let counter = 0\r\n  for (let i = 0; i < s.length; i++) {\r\n    const currentChar = s[i]\r\n    if (set.has(currentChar)) {\r\n      counter++\r\n      set.delete(currentChar)\r\n    } else {\r\n      set.add(currentChar)\r\n    }\r\n  }\r\n  counter *= 2\r\n  if (set.size > 0) counter++\r\n  return counter\r\n}\r\n\r\n// another\r\n\r\n/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nconst longestPalindrome = function(s) {\r\n  const hash = {};\r\n  let c;\r\n  for (let i = 0; i < s.length; i++) {\r\n    c = s.charAt(i);\r\n    if (hash.hasOwnProperty(c)) {\r\n      hash[c] += 1;\r\n    } else {\r\n      hash[c] = 1;\r\n    }\r\n  }\r\n  let res = 0;\r\n  let val;\r\n  for (let k in hash) {\r\n    if (hash.hasOwnProperty(k)) {\r\n      val = hash[k];\r\n      res += Math.floor(val / 2) * 2;\r\n      if (res % 2 === 0 && val % 2 === 1) {\r\n        res += 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n"
    }
  },
  {
    "name": "41-first-missing-positive",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst firstMissingPositive = function(nums) {\n   if(nums.length === 0) return 1\n   const arr = []\n   let max = Number.MIN_SAFE_INTEGER\n   for(let i = 0, len = nums.length; i < len; i++) {\n     if(nums[i] > 0) arr[nums[i]] = nums[i]\n     if(nums[i] > max) max = nums[i]\n   }\n   for(let i = 1; i < max; i++) {\n     if(arr[i] == null) return i\n   }\n   return max < 0 ? 1 : max + 1\n};\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nfunction firstMissingPositive(nums) {\n  const n = nums.length\n  for (let i = 0; i < n; i++) {\n    while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] !== nums[i])\n      swap(nums, i, nums[i] - 1)\n  }\n\n  for (let i = 0; i < n; i++) {\n    if (nums[i] !== i + 1) return i + 1\n  }\n  return n + 1\n}\n\nfunction swap(arr, i, j) {\n  const tmp = arr[i]\n  arr[i] = arr[j]\n  arr[j] = tmp\n}\n\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst firstMissingPositive = function(nums) {\n  const n = nums.length\n  for(let i = 0; i < n; i++) {\n    while(nums[i] < n && nums[nums[i] - 1] !== nums[i]) {\n      swap(nums, i, nums[i] - 1)\n    }\n  }\n  \n  for(let i = 0; i < n; i++) {\n    if(nums[i] !== i + 1) return i + 1\n  }\n  \n  return n + 1\n};\n\nfunction swap(arr, i, j) {\n  const tmp = arr[i]\n  arr[i] = arr[j]\n  arr[j] = tmp\n}\n"
    }
  },
  {
    "name": "410-split-array-largest-sum",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} m\n * @return {number}\n */\nfunction doable(nums, cuts, max) {\n    let acc = 0\n    for(let num of nums) {\n        if(num > max) return false\n        else if(acc + num <= max) acc += num\n        else {\n            --cuts;\n            acc = num;\n            if(cuts < 0) return false\n        }\n    }\n    return true\n}\n\n\nfunction splitArray(nums, m) {\n    let left = 0\n    let right = 0\n    for(let num of nums) {\n        left = Math.max(left, num)\n        right += num\n    }\n    while(left < right) {\n        let mid = Math.floor(left + (right - left) / 2)\n        if(doable(nums, m - 1, mid)) right = mid\n        else left = mid + 1 \n    }\n    return left\n}\n\n\n/**\n * @param {number[]} nums\n * @param {number} m\n * @return {number}\n */\nconst splitArray = function(nums, m) {\n  let l = 0,\n    r = 0\n  for (let el of nums) {\n    if (el > l) l = el\n    r += el\n  }\n  while (l < r) {\n    let mid = Math.floor((l + r) / 2)\n    if (numOfSubArrLessOrEqualThanM(nums, mid, m)) r = mid\n     else l = mid + 1\n  }\n  return l\n}\n\nfunction numOfSubArrLessOrEqualThanM(nums, target, m) {\n  let sum = 0,\n    count = 1\n  for (let el of nums) {\n    sum += el\n    if (sum > target) {\n      sum = el\n      count++\n    }\n    if (count > m) return false\n  }\n  return true\n}\n\n/**\n\nIntroduction to this problem:\nWe can break this problem into two smaller problems:\n\nGiven an array (A), number of cuts (CUTS), and the Largest sum of sub-arrays (MAX). Can you use at most CUTS cuts to segment array A into CUTS + 1 sub-arrays, such that the sum of each sub-array is smaller or equal to MAX?\nGiven a lower bound (left), an upper bound (right), an unknown bool array (B), and an API uses i as input and tells you whether B[i] is true. If we know there exists an index k, that B[i] is false when i < k, and B[i] is true when i >= k. What is the fastest way to find this k (the lower bound)?\nSolution to the first sub-problem (Skip this part if you already knew how to solve 1st sub-problem):\nFor the first question, we can follow these steps:\n\nFor each element in the array, if its value is larger than MAX, we know it's not possible to cut this array into groups that the sum of all groups are smaller than MAX. (Reason is straightforward, if A is [10, 2, 3, 5] and MAX is 6, even you have 3 cuts by which you can cut A as [[10], [2], [3], [5]], the group containing 10 will still be larger than 6).\nUse greedy algorithm to cut A. Use an accumulator ACC to store the sum of the currently processed group, and process elements in A one by one. For each element num, if we add num with ACC and the new sum is still no larger than MAX, we update ACC to ACC + num, which means we can merge num into the current group. If not, we must use a cut before num to segment this array, then num will be the first element in the new group.\nIf we didn't go through A but already used up all cuts, then it's not possible only using CUTS cuts to segment this array into groups to make sure sum of each sub-array is smaller than MAX. Otherwise, if we can reach the end of A with cuts left (or use exactly CUTS cuts). It's possible to do so.\nThen the first question is solved.\n\nSolution to the second sub-problem(Skip this part if you already knew how to solve 2nd sub-problem):\nThe array B will be something like [false, false, ..., false, true, true, ..., true]. We want to find the index of the first true.\nUse binary search to find this k. Keep a value mid, mid = (left + right) / 2. If B[mid] = false, then move the search range to the upper half of the original search range, a.k.a left = mid + 1, otherwise move search range to the lower half, a.k.a right = mid.\nWhy this algorithm is correct...\nNo matter how we cut the array A, the Largest sum of sub-arrays will fall into a range [left, right]. Left is the value of the largest element in this array. right is the sum of this array. (e.g., Given array [1, 2, 3, 4, 5], if we have 4 cuts and cut it as [[1], [2], [3], [4], [5]], the Largest sum of sub-arrays is 5, it cannot be smaller. And if we have 0 cut, and the only sub-array is [[1, 2, 3, 4, 5]], the Largest sum of sub-arrays is 15, it cannot be larger).\nHowever, we cannot decide the number of cuts (CUTS), this is an given constraint. But we know there must be a magic number k, which is the smallest value of the Largest sum of sub-arrays when given CUTS cuts. When the Largest sum of sub-arrays is larger than k, we can always find a way to cut A within CUTS cuts. When the Largest sum of sub-arrays is smaller than k, there is no way to do this.\nExample\nFor example, given array A [1, 2, 3, 4, 5]. We can use 2 cuts.\n\nNo matter how many cuts are allowed, the range of the possible value of the Largest sum of sub-arrays is [5, 15].\nWhen given 2 cuts, we can tell the magic number k here is 6, the result of segmentation is [[1, 2, 3], [4], [5]].\nWhen Largest sum of sub-arrays is in range [6, 15], we can always find a way to cut this array within two cuts. You can have a try.\nHowever, when Largest sum of sub-arrays is in range [5, 5], there is no way to do this.\nThis mapped this problem into the second sub-problem. Bool array B here is [5:false, 6:true, 7:true, 8:true, ..., 15:true]. We want to find the index i of the first true in B, which is the answer of this entire question, and by solving the first sub-problem, we have an API that can tell us given an i (Largest sum of sub-arrays), whether B[i] is true (whether we can find a way to cut A to satisfy the constraint). \n */\n\n\n// another\n\n/**\n * @param {number[]} nums\n * @param {number} m\n * @return {number}\n */\nconst splitArray = (nums, m) => {\n  let max = -Infinity, sum = 0\n  for(let num of nums) {\n    sum += num\n    max = Math.max(max, num)\n  }\n  if (m === 1) return sum\n  let l = max, r = sum\n  while(l < r) {\n    let mid = l + ((r - l) >> 1)\n    if(valid(mid, nums, m)) {\n      r = mid\n    } else {\n      l = mid + 1\n    }\n  }\n  return l\n}\n\nfunction valid(target, nums, m) {\n  let cnt = 1, sum = 0\n  for(let num of nums) {\n    sum += num\n    if(sum > target) {\n      cnt++\n      sum = num\n      if(cnt > m) return false\n    }\n  }\n\n  return true\n}\n"
    }
  },
  {
    "name": "411-minimum-unique-word-abbreviation",
    "code": {
      "JS": "/**\n * @param {string} target\n * @param {string[]} dictionary\n * @return {string}\n */\nconst minAbbreviation = function(target, dictionary) {\n  let n = target.length,\n    bn = 1 << n,\n    cand = 0,\n    minlen = Number.MAX_VALUE\n  let minab = 0\n  const dict = []\n  let res = ''\n\n  for (let w of dictionary) {\n    let word = 0\n    if (w.length != n) continue\n    for (let i = n - 1, bit = 1; i >= 0; --i, bit <<= 1)\n      if (target[i] != w[i]) word += bit\n    dict.push(word)\n    cand |= word\n  }\n  dfs(1, 0)\n\n  for (let i = n - 1, pre = i; i >= 0; --i, minab >>= 1) {\n    if (minab & 1) {\n      if (pre - i > 0) res = pre - i + res\n      pre = i - 1\n      res = target[i] + res\n    } else if (i == 0) res = pre - i + 1 + res\n  }\n  return res\n  \n  function abbrLen(mask) {\n    let count = n\n    for (let b = 3; b < bn; b <<= 1) if ((mask & b) == 0) count--\n    return count\n  }\n\n  function dfs(bit, mask) {\n    const len = abbrLen(mask)\n    if (len >= minlen) return\n    let match = true\n    for (let d of dict) {\n      if ((mask & d) == 0) {\n        match = false\n        break\n      }\n    }\n    if (match) {\n      minlen = len\n      minab = mask\n    } else\n      for (let b = bit; b < bn; b <<= 1) if (cand & b) dfs(b << 1, mask + b)\n  }\n}\n"
    }
  },
  {
    "name": "412-fizz-buzz",
    "code": {
      "JS": "/**\r\n * @param {number} n\r\n * @return {string[]}\r\n */\r\nconst fizzBuzz = function(n) {\r\n  const res = [];\r\n  for (let i = 1; i <= n; i++) {\r\n    res.push(single(i));\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\nfunction single(num) {\r\n  let str = \"\";\r\n  if (num % 3 === 0) {\r\n    str += \"Fizz\";\r\n  }\r\n  if (num % 5 === 0) {\r\n    str += \"Buzz\";\r\n  }\r\n  if (str === \"\") {\r\n    str += num;\r\n  }\r\n  return str;\r\n}\r\n\r\nconsole.log(fizzBuzz(15));\r\n"
    }
  },
  {
    "name": "413-arithmetic-slices",
    "code": {
      "JS": "/**\r\n * @param {number[]} A\r\n * @return {number}\r\n */\r\nconst numberOfArithmeticSlices = function(A) {\r\n  const arr = [];\r\n  let count = 0;\r\n  for (let i = 1; i < A.length - 1; i++) {\r\n    if (A[i] - A[i - 1] === A[i + 1] - A[i]) {\r\n      count += 1;\r\n    } else {\r\n      arr.push(count);\r\n      count = 0;\r\n    }\r\n  }\r\n  arr.push(count);\r\n  return arr.reduce((ac, el) => ac + calc(el), 0);\r\n};\r\n\r\nfunction calc(num) {\r\n  return (num * (num + 1)) / 2;\r\n}\r\n\r\nconsole.log(numberOfArithmeticSlices([1, 2, 3, 4]));\r\n"
    }
  },
  {
    "name": "414-third-maximum-number",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst thirdMax = function(nums) {\n    let count = 0, max=mid=small=Number.MIN_SAFE_INTEGER;\n    for (let i in nums) {\n        if (count > 0 && nums[i] === max || count > 1 && nums[i] === mid) continue;\n        count++;\n        if (nums[i] > max) {\n            small = mid;\n            mid = max;\n            max = nums[i];\n        } else if (nums[i] > mid) {\n            small = mid;\n            mid = nums[i];\n        } else if (nums[i] > small) {\n            small = nums[i];\n        }\n    }\n    return count < 3 ? max : small;\n};\n"
    }
  },
  {
    "name": "415-add-strings",
    "code": {
      "JS": "/**\r\n * @param {string} num1\r\n * @param {string} num2\r\n * @return {string}\r\n */\r\nconst addStrings = function(num1, num2) {\r\n  let sb = \"\";\r\n  let carry = 0;\r\n  for (\r\n    let i = num1.length - 1, j = num2.length - 1;\r\n    i >= 0 || j >= 0 || carry == 1;\r\n    i--, j--\r\n  ) {\r\n    let x = i < 0 ? 0 : +num1.charAt(i);\r\n    let y = j < 0 ? 0 : +num2.charAt(j);\r\n    sb = (+(x + y + carry) % 10) + sb;\r\n    carry = x + y + carry >= 10 ? 1 : 0;\r\n  }\r\n  return sb;\r\n};\r\n"
    }
  },
  {
    "name": "416-partition-equal-subset-sum",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nconst canPartition = function(nums) {\n    let sum = 0\n    for(let num of nums) {\n      sum += num\n    }\n    \n    if(sum & 1 === 1) {\n       return false\n    }\n    \n    sum /= 2\n    let n = nums.length\n    const dp = Array.from(new Array(n+1), () => [])\n    for(let i = 0; i < dp.length; i++) {\n      dp[i] = new Array(sum+1).fill(false)\n    }\n    dp[0][0] = true\n    for(let i = 1; i < n + 1; i++) {\n      dp[i][0] = true\n    }\n    for(let j = 1; j < sum + 1; j++) {\n      dp[0][j] = false\n    }\n    for(let i = 1; i < n + 1; i++) {\n      for(let j = 1; j < sum + 1; j++) {\n        if(j >= nums[i - 1]) {\n          dp[i][j] = (dp[i -1][j] || dp[i - 1][j - nums[i - 1]])\n        }\n      }\n    }\n    return dp[n][sum]\n};\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\nconst canPartition = function(nums) {\n  if (nums.length < 2) return false\n\n  const total = nums.reduce((a, c) => a + c)\n  if (total % 2 !== 0) return false\n\n  nums.sort((a, b) => b - a)\n  const target = total / 2\n\n  if (nums[0] > target) return false\n  return findCombination(nums, target, 0)\n}\n\nfunction findCombination(nums, target, start) {\n  if (target === 0) {\n    return true\n  } else {\n    for (let i = start; i < nums.length; i++) {\n      if (nums[i] <= target) {\n        if (findCombination(nums, target - nums[i], i + 1)) {\n          return true\n        }\n      }\n    }\n    return false\n  }\n}\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\nfunction helper(nums, target, pos) {\n  for (let i = pos; i <= nums.length; i++) {\n    if (i != pos && nums[i] == nums[i - 1]) continue\n    if (nums[i] === target) return true\n    if (nums[i] > target) break\n    if (helper(nums, target - nums[i], i + 1)) return true\n  }\n  return false\n}\nconst canPartition = function(nums) {\n  const sum = nums.reduce((sum, n) => (sum += n), 0) / 2\n  if (sum % 1 != 0) {\n    return false\n  }\n\n  return helper(nums, sum, 0)\n}\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\nconst canPartition = function (nums) {\n  const sumA = nums.reduce((acc, curr) => acc + curr, 0)\n  if (sumA % 2) return false\n  let row = 1n << BigInt(sumA / 2)\n  for (const weight of nums) row = row | (row >> BigInt(weight))\n  /*\n     check the the column corresponding to my target by bitwise ANDing\n     it with just 1,so if the first bit is 1,\n     it will return true, otherwise false\n     */\n  return row & 1n\n}\n\n"
    }
  },
  {
    "name": "417-pacific-atlantic-water-flow",
    "code": {
      "JS": "/**\n * @param {number[][]} matrix\n * @return {number[][]}\n */\nconst pacificAtlantic = function(matrix) {\n  const res = []\n  if (!matrix || matrix.length === 0 || matrix[0].length === 0) return res\n  const rows = matrix.length\n  const cols = matrix[0].length\n  const dirs = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n  const pacific = Array.from({ length: rows }, () => new Array(cols).fill(false))\n  const atlantic = Array.from({ length: rows }, () => new Array(cols).fill(false))\n  for (let y = 0; y < rows; y++) {\n    helper(0, y, pacific, -1, matrix, cols, rows, dirs)\n    helper(cols - 1, y, atlantic, -1, matrix, cols, rows, dirs)\n  }\n  for (let x = 0; x < cols; x++) {\n    helper(x, 0, pacific, -1, matrix, cols, rows, dirs)\n    helper(x, rows - 1, atlantic, -1, matrix, cols, rows, dirs)\n  }\n\n  for (let y = 0; y < rows; y++) {\n    for (let x = 0; x < cols; x++) {\n      if (pacific[y][x] && atlantic[y][x]) {\n        res.push([y, x])\n      }\n    }\n  }\n  return res\n}\n\nfunction helper(x, y, visited, height, matrix, cols, rows, dirs) {\n  if (x < 0 || x >= cols || y < 0 || y >= rows || visited[y][x] || matrix[y][x] < height) return\n  visited[y][x] = true\n  for (let dir of dirs)\n    helper(x + dir[0], y + dir[1], visited, matrix[y][x], matrix, cols, rows, dirs)\n}\n"
    }
  },
  {
    "name": "418-sentence-screen-fitting",
    "code": {
      "JS": "/**\n * @param {string[]} sentence\n * @param {number} rows\n * @param {number} cols\n * @return {number}\n */\nconst wordsTyping = function(sentence, rows, cols) {\n  let start = 0\n  const s = sentence.join(' ') + ' '\n  const l = s.length\n  for (let i = 0; i < rows; i++) {\n    start += cols\n    while (start >= 0 && s[start % l] !== ' ') start--\n    start++\n  }\n  return Math.floor(start / l)\n}\n"
    }
  },
  {
    "name": "42-trapping-rain-water",
    "code": {
      "JS": "/**\n * @param {number[]} height\n * @return {number}\n */\nconst trap = function(height) {\n    \n    let s = height.length\n    if(s === 0) return 0\n    let res = 0\n    const left_max = [height[0]]\n    const right_max = []\n    right_max[s - 1] = height[s - 1]\n    for(let i = 1; i < s; i++) {\n        left_max[i] = Math.max(height[i], left_max[i - 1])\n    }\n    for(let i = s - 2; i >= 0; i--) {\n        right_max[i] = Math.max(height[i], right_max[i + 1])\n    }\n    for(let i = 1; i < s - 1; i++) {\n        res += Math.min(left_max[i], right_max[i]) - height[i] \n    }\n    return res\n};\n\n// another\n\n/**\n * @param {number[]} height\n * @return {number}\n */\nconst trap = function(height) {\n  const len = height.length\n  if (len === 0) return 0\n  const leftMax = [height[0]]\n  const rightMax = []\n  rightMax[len - 1] = height[len - 1]\n  for (let i = len - 2; i >= 0; i--) {\n    rightMax[i] = Math.max(height[i], rightMax[i + 1])\n  }\n  let res = 0\n  for (let i = 1; i < len; i++) {\n    leftMax[i] = Math.max(height[i], leftMax[i - 1])\n    res += Math.min(leftMax[i], rightMax[i]) - height[i]\n  }\n  return res\n}\n\n// another\n\n/**\n * @param {number[]} height\n * @return {number}\n */\nconst trap = function(height) {\n  const n = height.length\n  let l = 0, r = n - 1, res = 0, leftMax = 0, rightMax = 0\n  while(l <= r) {\n    if(height[l] <= height[r]) {\n      if(height[l] >= leftMax) leftMax = height[l]\n      else res += leftMax - height[l]\n      l++\n    } else {\n      if(height[r] >= rightMax) rightMax = height[r]\n      else res += rightMax - height[r]\n      r--\n    }\n  }\n  return res\n};\n\n// another\n\n/**\n * @param {number[]} height\n * @return {number}\n */\nconst trap = function(height) {\n    const n = height.length\n    if(n === 0) return 0\n    let res = 0\n    let l = 0, r = n - 1, leftMax = height[l], rightMax = height[r]\n    while(l < r) {\n      if(height[l] <= height[r]) {\n        l++\n        leftMax = Math.max(leftMax, height[l])\n        res += (leftMax - height[l]) \n      } else {\n        r--\n        rightMax = Math.max(rightMax, height[r])\n        res += rightMax - height[r]\n      }\n    }\n\n    return res\n};\n\n// another\n\n/**\n * @param {number[]} height\n * @return {number}\n */\nconst trap = function(height) {\n  const n = height.length, { max } = Math\n  let res = 0, l = 0, r = n - 1, leftMax = height[0], rightMax = height[n - 1]\n  while(l <= r) {\n    if(leftMax < rightMax) {\n      leftMax = max(leftMax, height[l])\n      res += leftMax - height[l]\n      l++\n    } else {\n      rightMax = max(rightMax, height[r])\n      res += rightMax - height[r]\n      r--\n    }\n  }\n\n  return res\n};\n"
    }
  },
  {
    "name": "420-strong-password-checker",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst strongPasswordChecker = function(s) {\n  let n = s.length,\n    toAdd = Math.max(0, 6 - n),\n    toDel = Math.max(n - 20, 0),\n    repeat = Array.from({ length: 3 }, _ => []),\n    lower = 1,\n    upper = 1,\n    digit = 1,\n    add = 0,\n    del = 0,\n    rep = 0,\n    k = 0;\n\n  for (let i = 0; i <= n; i++) {\n    if (s[i] != s[k]) {\n      let len = i - k;\n      if (len >= 3) repeat[len % 3].push(len);\n      k = i;\n    }\n    if (i == n) break;\n    if (/\\d/.test(s[i])) digit = 0;\n    if (/[a-z]/.test(s[i])) lower = 0;\n    if (/[A-Z]/.test(s[i])) upper = 0;\n  }\n\n  repeat.map((arr, mod) => {\n    for (let len of arr) {\n      if (toAdd - add > 0) {\n        len -= 2;\n        add++;\n      }\n\n      if (toDel - del > 0) {\n        del += mod + 1;\n        len -= mod + 1;\n      }\n      rep += (len / 3) | 0;\n    }\n  });\n  toDel - del > 0\n    ? (rep = Math.max(0, rep - Math.floor((toDel - del) / 3)))\n    : (rep += del - toDel);\n  return toDel + Math.max(digit + lower + upper, rep + toAdd);\n};\n\n"
    }
  },
  {
    "name": "421-maximum-xor-of-two-numbers-in-an-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst findMaximumXOR = function(nums) {\n  let res = 0, mask = 0\n  for(let i = 31; i >= 0; i--) {\n    mask = mask | (1 << i)\n    const set = new Set()\n    for(let e of nums) set.add(e & mask)\n    const tmp = res | (1 << i)\n    for(let e of set) {\n      if(set.has(e ^ tmp)) {\n         res = tmp\n         break\n      }\n    }\n  }\n  return res\n};\n\n// another\n\n/*\n\nThis algorithm's idea is:\nto iteratively determine what would be each bit of the final result from left to right.\nAnd it narrows down the candidate group iteration by iteration. e.g. assume input are a,b,c,d,...z, 26 integers in total.\nIn first iteration, if you found that a, d, e, h, u differs on the MSB(most significant bit),\nso you are sure your final result's MSB is set. Now in second iteration,\nyou try to see if among a, d, e, h, u there are at least two numbers make the 2nd MSB differs,\nif yes, then definitely, the 2nd MSB will be set in the final result.\nAnd maybe at this point the candidate group shinks from a,d,e,h,u to a, e, h.\nImplicitly, every iteration, you are narrowing down the candidate group,\nbut you don't need to track how the group is shrinking, you only cares about the final result.\n\n*/\n/*\n * @lc app=leetcode id=421 lang=javascript\n *\n * [421] Maximum XOR of Two Numbers in an Array\n */\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst findMaximumXOR = function(nums) {\n  let maxResult = 0\n  let mask = 0\n  /*The maxResult is a record of the largest XOR we got so far. if it's 11100 at i = 2, it means \n    before we reach the last two bits, 11100 is the biggest XOR we have, and we're going to explore\n    whether we can get another two '1's and put them into maxResult\n    \n    This is a greedy part, since we're looking for the largest XOR, we start \n    from the very begining, aka, the 31st postition of bits. */\n  for (let i = 31; i >= 0; i--) {\n    //The mask will grow like  100..000 , 110..000, 111..000,  then 1111...111\n    //for each iteration, we only care about the left parts\n    mask = mask | (1 << i)\n\n    let set = new Set()\n    for (let num of nums) {\n      /* we only care about the left parts, for example, if i = 2, then we have\n        {1100, 1000, 0100, 0000} from {1110, 1011, 0111, 0010}*/\n      let leftPartOfNum = num & mask\n      set.add(leftPartOfNum)\n    }\n\n    // if i = 1 and before this iteration, the maxResult we have now is 1100,\n    // my wish is the maxResult will grow to 1110, so I will try to find a candidate\n    // which can give me the greedyTry;\n    let greedyTry = maxResult | (1 << i)\n\n    for (let leftPartOfNum of set) {\n      //This is the most tricky part, coming from a fact that if a ^ b = c, then a ^ c = b;\n      // now we have the 'c', which is greedyTry, and we have the 'a', which is leftPartOfNum\n      // If we hope the formula a ^ b = c to be valid, then we need the b,\n      // and to get b, we need a ^ c, if a ^ c exisited in our set, then we're good to go\n      let anotherNum = leftPartOfNum ^ greedyTry\n      if (set.has(anotherNum)) {\n        maxResult = greedyTry\n        break\n      }\n    }\n\n    // If unfortunately, we didn't get the greedyTry, we still have our max,\n    // So after this iteration, the max will stay at 1100.\n  }\n  return maxResult\n}\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst findMaximumXOR = function (nums) {\n  if (nums == null || nums.length == 0) {\n    return 0\n  }\n  const root = new Trie()\n  for (let num of nums) {\n    let curNode = root\n    for (let i = 31; i >= 0; i--) {\n      let curBit = (num >>> i) & 1\n      if (curNode.children[curBit] == null) {\n        curNode.children[curBit] = new Trie()\n      }\n      curNode = curNode.children[curBit]\n    }\n  }\n  let max = Number.MIN_VALUE\n  for (let num of nums) {\n    let curNode = root\n    let curSum = 0\n    for (let i = 31; i >= 0; i--) {\n      let curBit = (num >>> i) & 1\n      if (curNode.children[curBit ^ 1] != null) {\n        curSum += 1 << i\n        curNode = curNode.children[curBit ^ 1]\n      } else {\n        curNode = curNode.children[curBit]\n      }\n    }\n    max = Math.max(curSum, max)\n  }\n  return max\n}\n\nclass Trie {\n  constructor() {\n    this.children = {}\n  }\n}\n"
    }
  },
  {
    "name": "422-valid-word-square",
    "code": {
      "JS": "/**\n * @param {string[]} words\n * @return {boolean}\n */\nconst validWordSquare = function(words) {\n  if (words == null || words.length === 0) return true\n  const n = words.length\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < words[i].length; j++) {\n      if (\n        j >= n ||\n        words[j].length <= i ||\n        words[j].charAt(i) !== words[i].charAt(j)\n      )\n        return false\n    }\n  }\n  return true\n}\n"
    }
  },
  {
    "name": "423-reconstruct-original-digits-from-english",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {string}\n */\nconst originalDigits = function(s) {\n  const count = new Array(10).fill(0);\n  for (let i = 0; i < s.length; i++) {\n    let c = s.charAt(i);\n    if (c === \"z\") count[0]++;\n    if (c === \"w\") count[2]++;\n    if (c === \"x\") count[6]++;\n    if (c === \"s\") count[7]++; //7-6\n    if (c === \"g\") count[8]++;\n    if (c === \"u\") count[4]++;\n    if (c === \"f\") count[5]++; //5-4\n    if (c === \"h\") count[3]++; //3-8\n    if (c === \"i\") count[9]++; //9-8-5-6\n    if (c === \"o\") count[1]++; //1-0-2-4\n  }\n  count[7] -= count[6];\n  count[5] -= count[4];\n  count[3] -= count[8];\n  count[9] = count[9] - count[8] - count[5] - count[6];\n  count[1] = count[1] - count[0] - count[2] - count[4];\n  let ans = \"\";\n  for (let i = 0; i <= 9; i++) {\n    ans += `${i}`.repeat(count[i]);\n  }\n  return ans;\n};\n"
    }
  },
  {
    "name": "424-longest-repeating-character-replacement",
    "code": {
      "JS": "/**\r\n * @param {string} s\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nconst characterReplacement = function(s, k) {\r\n  const len = s.length;\r\n  const count = Array(26).fill(0);\r\n  let start = 0,\r\n    maxCount = 0,\r\n    maxLength = 0;\r\n  const ca = \"A\".charCodeAt(0);\r\n  for (let end = 0; end < len; end++) {\r\n    maxCount = Math.max(maxCount, ++count[s.charCodeAt(end) - ca]);\r\n    if (end - start + 1 - maxCount > k) {\r\n      count[s.charCodeAt(start) - ca]--;\r\n      start++;\r\n    }\r\n    maxLength = Math.max(maxLength, end - start + 1);\r\n  }\r\n  return maxLength;\r\n};\r\n\r\nconsole.log(characterReplacement(\"ABAB\", 2));\r\nconsole.log(characterReplacement(\"AABABBA\", 1));\r\n\r\n\r\n// another\r\n\r\n/**\r\n * @param {string} s\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nconst characterReplacement = function (s, k) {\r\n  const freq = Array(26).fill(0),\r\n    n = s.length,\r\n    { max } = Math,\r\n    A = 'A'.charCodeAt(0)\r\n  let res = 0,\r\n    l = 0,\r\n    r = 0,\r\n    maxFreq = 0\r\n  while (r < n) {\r\n    maxFreq = max(maxFreq, ++freq[s.charCodeAt(r) - A])\r\n    if (r - l + 1 - maxFreq > k) {\r\n      freq[s.charCodeAt(l) - A]--\r\n      l++\r\n    }\r\n    res = max(res, r - l + 1)\r\n    r++\r\n  }\r\n\r\n  return res\r\n}\r\n\r\n"
    }
  },
  {
    "name": "425-word-squares",
    "code": {
      "JS": "/**\n * @param {string[]} words\n * @return {string[][]}\n */\nconst wordSquares = function(words) {\n  const length = words[0].length\n  const createPrefixMap = function(words) {\n    const result = new Map()\n    for (let word of words) {\n      for (let i = 0; i < word.length - 1; ++i) {\n        const prefix = word.slice(0, i + 1)\n        const array = result.get(prefix)\n        if (array) {\n          array.push(word)\n        } else {\n          result.set(prefix, [word])\n        }\n      }\n    }\n    return result\n  }\n  const backtracking = function(step, result, martix, wordsList) {\n    if (step === length) {\n      result.push([...martix])\n      return\n    }\n    for (let word of wordsList) {\n      martix.push(word)\n      let prefix = ''\n      for (let i = 0; i < step + 1; ++i) {\n        prefix += martix[i][step + 1]\n      }\n      let newLists = dictMap.get(prefix)\n      newLists = newLists ? newLists : []\n      backtracking(step + 1, result, martix, newLists)\n      martix.pop()\n    }\n  }\n  const result = []\n  const dictMap = createPrefixMap(words)\n  backtracking(0, result, [], words)\n  return result\n}\n\n// another\n\n/**\n * @param {string[]} words\n * @return {string[][]}\n */\nconst wordSquares = function(words) {\n  let result = []\n  let trie = new Trie()\n  for (let word of words) {\n    trie.add(word)\n  }\n  \n  findWordSquare(result, [], trie)\n  return result\n};\n\nfunction findWordSquare (result, temp, trie) {\n  if (temp.length > 0 && temp.length === temp[0].length) {\n    result.push(temp)\n    return\n  }\n  \n  let prefix = ''\n  let j = temp.length\n  for (let i = 0; i < temp.length; i++) {\n    prefix += temp[i][j]\n  }\n  \n  let startWith = trie.startWith(prefix)\n  for (let word of startWith) {\n    findWordSquare(result, temp.concat([word]), trie)\n  }\n}\n\nfunction Trie () {\n  this.isWord = false\n  this.children = new Map()\n}\n\nTrie.prototype.add = function (word) {\n  let cur = this\n  for (let i = 0; i < word.length; i++) {\n    if (!cur.children.has(word[i])) {\n      cur.children.set(word[i], new Trie())\n    }\n    cur = cur.children.get(word[i])\n  }\n  cur.isWord = true\n}\n\nTrie.prototype.startWith = function (prefix) {\n  let cur = this\n  for (let i = 0; i < prefix.length; i++) {\n    if (cur.children.has(prefix[i])) {\n      cur = cur.children.get(prefix[i])\n    } else {\n      return []\n    }\n  }\n  \n  let res = []\n  const findWords = function (res, cur, str) {\n    if (!cur.isWord) {\n      for (let [key, val] of cur.children) {\n        findWords(res, val, str + key)\n      }\n    } else {\n      res.push(str)\n    }\n  }\n  \n  findWords(res, cur, prefix)\n  return res\n}\n"
    }
  },
  {
    "name": "426-convert-binary-search-tree-to-sorted-doubly-linked-list",
    "code": {
      "JS": "/**\n * // Definition for a Node.\n * function Node(val, left, right) {\n *      this.val = val;\n *      this.left = left;\n *      this.right = right;\n *  };\n */\n/**\n * @param {Node} root\n * @return {Node}\n */\nconst treeToDoublyList = function(root) {\n  let head = null, tail = null;\n  const helper = (node) => {\n    if(!node) return;\n    helper(node.left);\n    if(!head) head = node;\n    if(tail) tail.right = node;\n    node.left = tail;\n    tail = node;\n    helper(node.right);\n  };\n  helper(root);\n  if(head) {\n    head.left = tail;\n    tail.right = head;\n  }\n  return head;\n};\n\n// another\n\n/**\n * @param {Node} root\n * @return {Node}\n */\nconst treeToDoublyList = function(root) {\n  if(root === null) return null\n  const left = treeToDoublyList(root.left)\n  const right = treeToDoublyList(root.right)\n  root.left = root\n  root.right = root\n  return connect(connect(left, root), right)\n};\n\n// n1 is the head of circular DLL as well as n2\nfunction connect(n1, n2) {\n  if(n1 === null) return n2\n  if(n2 === null) return n1\n  const t1 = n1.left\n  const t2 = n2.left\n\n  t1.right = n2\n  n2.left = t1\n  t2.right = n1\n  n1.left = t2\n\n  return n1\n}\n\n// another\n\n/**\n * @param {Node} root\n * @return {Node}\n */\nconst treeToDoublyList = function(root) {\n  if(root == null) return null\n  let cur = root\n  let start = root\n  while(start.left !== null) {\n    start = start.left\n  }\n  let prev = null\n  const stack = []\n  while(stack.length !== 0 || cur !== null) {\n    while(cur !== null) {\n      stack.push(cur)\n      cur = cur.left\n    }\n    cur = stack.pop()\n    if(prev !== null) {\n      prev.right = cur\n      cur.left = prev\n    }\n    prev = cur\n    cur = cur.right\n  }\n  start.left = prev\n  prev.right = start\n  return start\n};\n"
    }
  },
  {
    "name": "427-construct-quad-tree",
    "code": {
      "JS": "/**\n * // Definition for a QuadTree node.\n * function Node(val,isLeaf,topLeft,topRight,bottomLeft,bottomRight) {\n *    this.val = val;\n *    this.isLeaf = isLeaf;\n *    this.topLeft = topLeft;\n *    this.topRight = topRight;\n *    this.bottomLeft = bottomLeft;\n *    this.bottomRight = bottomRight;\n * };\n */\n/**\n * @param {number[][]} grid\n * @return {Node}\n */\nconst construct = function(grid) {\n  const tree = m => {\n    const node = new Node()\n    const isAllOne = m.every(r => r.every(v => v === 1))\n    const isAllZero = m.every(r => r.every(v => v === 0))\n    if (isAllOne) {\n      node.val = true\n      node.isLeaf = true\n    } else if (isAllZero) {\n      node.val = false\n      node.isLeaf = true\n    } else {\n      const len = m.length\n      let left = m.map(r => r.slice(0, len / 2))\n      let right = m.map(r => r.slice(len / 2))\n      node.topLeft = tree(left.slice(0, len / 2))\n      node.topRight = tree(right.slice(0, len / 2))\n      node.bottomLeft = tree(left.slice(len / 2))\n      node.bottomRight = tree(right.slice(len / 2))\n      node.isLeaf = false\n      node.val = true\n    }\n    return node\n  }\n  return tree(grid)\n}\n"
    }
  },
  {
    "name": "428-serialize-and-deserialize-n-ary-tree",
    "code": {
      "JS": "/**\n * // Definition for a Node.\n * function Node(val, children) {\n *    this.val = val;\n *    this.children = children;\n * };\n */\n\nclass Codec {\n  constructor() {}\n  /**\n   * @param {Node} root\n   * @return {string}\n   */\n  // Encodes a tree to a single string.\n  serialize = function(root) {\n    if (root === null) return ''\n    let str = ''\n    function dfs(node) {\n      str += node.val + ',' + node.children.length + ','\n      for (let child of node.children) dfs(child)\n    }\n    dfs(root)\n    return str\n  }\n  /**\n   * @param {string} data\n   * @return {Node}\n   */\n  // Decodes your encoded data to tree.\n  deserialize = function(data) {\n    if (data === '') return null\n    let idx = 0\n    function input() {\n      let j = data.indexOf(',', idx)\n      let n = Number(data.slice(idx, j))\n      idx = j + 1\n      return n\n    }\n    function dfs() {\n      let val = input(),\n        len = input()\n      let node = new Node(val, [])\n      while (len-- > 0) node.children.push(dfs())\n      return node\n    }\n    return dfs()\n  }\n}\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.deserialize(codec.serialize(root));\n\n/**\n * // Definition for a Node.\n * function Node(val, children) {\n *    this.val = val;\n *    this.children = children;\n * };\n */\n\n// another\n\n/**\n * // Definition for a Node.\n * function Node(val, children) {\n *    this.val = val;\n *    this.children = children;\n * };\n */\n\nclass Codec {\n  constructor() {}\n  /**\n   * @param {Node} root\n   * @return {string}\n   */\n  // Encodes a tree to a single string.\n  serialize = function(root) {\n    const ans = []\n    const stack = root ? [root] : []\n    while (stack.length) {\n      const cur = stack.pop()\n      ans.push(cur.val, cur.children.length)\n      for (let i = cur.children.length - 1; i >= 0; i--) {\n        stack.push(cur.children[i])\n      }\n    }\n    return ans.join(',')\n  }\n  /**\n   * @param {string} data\n   * @return {Node}\n   */\n  // Decodes your encoded data to tree.\n  deserialize = function(data) {\n    if (!data) return null\n    const arr = data.split(',')\n    const helper = (index = 0, parent) => {\n      const node = new Node(arr[index++], [])\n      parent.children.push(node)\n      let childCount = arr[index++]\n      while (childCount--) {\n        index = helper(index, node)\n      }\n      return index\n    }\n    const fakeRoot = new Node(null, [])\n    helper(0, fakeRoot)\n    return fakeRoot.children[0]\n  }\n}\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.deserialize(codec.serialize(root));\n\n/**\n * // Definition for a Node.\n * function Node(val, children) {\n *    this.val = val;\n *    this.children = children;\n * };\n */\n\n"
    }
  },
  {
    "name": "429-n-ary-tree-level-order-traversal",
    "code": {
      "JS": "/**\n * // Definition for a Node.\n * function Node(val,children) {\n *    this.val = val;\n *    this.children = children;\n * };\n */\n/**\n * @param {Node} root\n * @return {number[][]}\n */\nconst levelOrder = function(root) {\n  const res = []\n  if(root == null) return res\n  helper(root, 0, res)\n  return res\n};\n\nfunction helper(node, index, res) {\n  if(node == null) return\n  if(res[index] == null) res[index] = []\n  res[index].push(node.val)\n  for(let i = 0, len = node.children.length; i < len; i++) {\n    helper(node.children[i], index + 1, res)\n  }\n}\n\n// another\n\n/**\n * // Definition for a Node.\n * function Node(val,children) {\n *    this.val = val;\n *    this.children = children;\n * };\n */\n/**\n * @param {Node} root\n * @return {number[][]}\n */\nconst levelOrder = function(root) {\n  const res = []\n  if(root == null) return res\n  const q = []\n  q.push(root)\n  while(q.length) {\n    const size = q.length\n    const cur = []\n    for(let i = 0; i < size; i++) {\n      const node = q.shift()\n      cur.push(node.val)\n      q.push(...node.children)\n    }\n    res.push(cur)\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "43-multiply-strings",
    "code": {
      "JS": "/**\n * @param {string} num1\n * @param {string} num2\n * @return {string}\n */\nconst multiply = function(num1, num2) {\n  let m = num1.length,\n    n = num2.length;\n  let pos = new Array(m + n).fill(0);\n\n  for (let i = m - 1; i >= 0; i--) {\n    for (let j = n - 1; j >= 0; j--) {\n      let mul = (num1.charAt(i) - \"0\") * (num2.charAt(j) - \"0\");\n      let p1 = i + j,\n        p2 = i + j + 1;\n      let sum = mul + pos[p2];\n\n      pos[p1] += Math.floor(sum / 10);\n      pos[p2] = sum % 10;\n    }\n  }\n\n  let str = \"\";\n  for (let p of pos) if (!(str.length === 0 && p === 0)) str += p;\n  return str.length === 0 ? \"0\" : str;\n};\n"
    }
  },
  {
    "name": "430-flatten-a-multilevel-doubly-linked-list",
    "code": {
      "JS": "/**\n * // Definition for a Node.\n * function Node(val,prev,next,child) {\n *    this.val = val;\n *    this.prev = prev;\n *    this.next = next;\n *    this.child = child;\n * };\n */\n/**\n * @param {Node} head\n * @return {Node}\n */\nconst flatten = function (head) {\n  const handle = (node, next = null) => {\n    if (!node) return null;\n    handle(node.next, next);\n    const child = handle(node.child, node.next);\n    if (!node.next && next) {\n      node.next = next;\n      next.prev = node;\n    }\n    if (child) {\n      node.next = child;\n      node.child = null;\n      child.prev = node;\n    }\n    return node;\n  };\n  return handle(head);\n};\n"
    }
  },
  {
    "name": "431-encode-n-ary-tree-to-binary-tree",
    "code": {
      "JS": "/**\n * // Definition for a Node.\n * function Node(val, children) {\n *    this.val = val;\n *    this.children = children;\n * };\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\nclass Codec {\n  constructor() {}\n\n  /**\n   * @param {Node} root\n   * @return {TreeNode}\n   */\n  // Encodes an n-ary tree to a binary tree.\n  encode = function(root) {\n    if (root == null) return null\n    let result = new TreeNode(root.val)\n    if (root.children.length > 0) {\n      result.left = this.encode(root.children[0])\n    }\n    let cur = result.left\n    for (let i = 1; i < root.children.length; i++) {\n      cur.right = this.encode(root.children[i])\n      cur = cur.right\n    }\n    return result\n  }\n\n  /**\n   * @param {TreeNode} root\n   * @return {Node}\n   */\n  // Decodes your binary tree to an n-ary tree.\n  decode = function(root) {\n    if (root == null) return null\n    let result = new Node(root.val, [])\n    let cur = root.left\n    while (cur != null) {\n      result.children.push(this.decode(cur))\n      cur = cur.right\n    }\n    return result\n  }\n}\n/*\n * Your Codec object will be instantiated and called as such:\n * codec = Codec()\n * codec.decode(codec.encode(root))\n */\n"
    }
  },
  {
    "name": "432-all-oone-data-structure",
    "code": {
      "JS": "/**\n * Initialize your data structure here.\n */\nconst AllOne = function() {\n  this.map = new Map()\n}\n\n/**\n * Inserts a new key <Key> with value 1. Or increments an existing key by 1.\n * @param {string} key\n * @return {void}\n */\nAllOne.prototype.inc = function(key) {\n  let curCount\n  if (this.map.has(key)) {\n    curCount = this.map.get(key) + 1\n  } else {\n    curCount = 1\n  }\n  this.map.set(key, curCount)\n}\n\n/**\n * Decrements an existing key by 1. If Key's value is 1, remove it from the data structure.\n * @param {string} key\n * @return {void}\n */\nAllOne.prototype.dec = function(key) {\n  if (this.map.has(key)) {\n    if (this.map.get(key) > 1) {\n      this.map.set(key, this.map.get(key) - 1)\n    } else this.map.delete(key)\n  } else {\n    return\n  }\n}\n\n/**\n * Returns one of the keys with maximal value.\n * @return {string}\n */\nAllOne.prototype.getMaxKey = function() {\n  let max = -Infinity,\n    maxStr = ''\n  for (let k of this.map) {\n    if (k[1] > max) {\n      max = k[1]\n      maxStr = k[0]\n    }\n  }\n  return maxStr\n}\n\n/**\n * Returns one of the keys with Minimal value.\n * @return {string}\n */\nAllOne.prototype.getMinKey = function() {\n  let min = Infinity,\n    minStr = ''\n  for (let k of this.map) {\n    if (k[1] < min) {\n      min = k[1]\n      minStr = k[0]\n    }\n  }\n  return minStr\n}\n\n/**\n * Your AllOne object will be instantiated and called as such:\n * var obj = Object.create(AllOne).createNew()\n * obj.inc(key)\n * obj.dec(key)\n * var param_3 = obj.getMaxKey()\n * var param_4 = obj.getMinKey()\n */\n"
    }
  },
  {
    "name": "433-minimum-genetic-mutation",
    "code": {
      "JS": "/**\n * @param {string} start\n * @param {string} end\n * @param {string[]} bank\n * @return {number}\n */\nconst minMutation = function(start, end, bank) {\n  const obj = { res: Number.MAX_VALUE }\n  dfs(start, end, bank, 0, obj, new Set())\n  return obj.res === Number.MAX_VALUE ? -1 : obj.res\n}\n\nfunction dfs(s, e, bank, num, obj, visited) {\n  if(s === e) {\n    obj.res = Math.min(obj.res, num)\n    return\n  }\n  for(let el of bank) {\n    let diff = 0\n    for(let i = 0, len = s.length; i < len; i++) {\n      if(s[i] !== el[i]) {\n        diff++\n        if(diff > 1) break\n      }\n    }\n    if(diff === 1 && !visited.has(el)) {\n      visited.add(el)\n      dfs(el, e, bank, num + 1, obj, visited)\n      visited.delete(el)\n    }\n  }\n} \n\n// another\n\n/**\n * @param {string} start\n * @param {string} end\n * @param {string[]} bank\n * @return {number}\n */\nconst minMutation = function(start, end, bank) {\n  const bankSet = new Set(bank)\n  if (!bankSet.has(end)) return -1\n  const queue = [[start, 0]]\n  const dna = ['A', 'C', 'G', 'T']\n  while (queue.length) {\n    let [node, count] = queue.shift()\n    if (node === end) return count\n    for (let i = 0; i < node.length; i++) {\n      for (let j = 0; j < dna.length; j++) {\n        const d = node.slice(0, i) + dna[j] + node.slice(i + 1)\n        if (bankSet.has(d)) {\n          queue.push([d, count + 1])\n          bankSet.delete(d)\n        }\n      }\n    }\n  }\n  return -1\n}\n"
    }
  },
  {
    "name": "434-number-of-segments-in-a-string",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst countSegments = function(s) {\n    if(s.trim() === '') return 0\n    return s.trim().split(' ').filter(el => el !== '').length\n};\n"
    }
  },
  {
    "name": "435-non-overlapping-intervals",
    "code": {
      "JS": "/**\n * @param {number[][]} intervals\n * @return {number}\n */\nconst eraseOverlapIntervals = function(intervals) {\n  if(intervals == null || intervals.length === 0) return 0\n  intervals.sort((a, b) => a[1] - b[1])\n  let res = 1, end = intervals[0][1]\n  const len = intervals.length\n  for(let i = 1; i < len; i++) {\n    if(intervals[i][0] >= end) {\n      end = intervals[i][1]\n      res++\n    }\n  }\n  \n  return len - res\n};\n\n// another\n\n/**\n * Definition for an interval.\n * function Interval(start, end) {\n *     this.start = start;\n *     this.end = end;\n * }\n */\n/**\n * @param {Interval[]} intervals\n * @return {number}\n */\nconst eraseOverlapIntervals = function(intervals) {\n    intervals.sort((a, b) => a.end - b.end)\n    let count = 0\n    let end = Number.MIN_SAFE_INTEGER\n    const len = intervals.length\n    for(let el of intervals) {\n        if(el.start >= end) {\n            end = el.end\n            count++\n        }\n    }\n    return len - count\n};\n"
    }
  },
  {
    "name": "436-find-right-interval",
    "code": {
      "JS": "/**\n * @param {number[][]} intervals\n * @return {number[]}\n */\nconst findRightInterval = function(intervals) {\n  const res = []\n  const arrary = intervals\n    .map((interval, idx) => ({ interval, idx }))\n    .sort((obj1, obj2) => obj1.interval[0] - obj2.interval[0])\n  for (let interval of intervals) {\n    const val = interval[interval.length - 1]\n    let left = 0,\n      right = intervals.length\n    while (left < right) {\n      const mid = Math.floor((left + right) / 2)\n      if (arrary[mid].interval[0] >= val) {\n        right = mid\n      } else {\n        left = mid + 1\n      }\n    }\n    if (left >= intervals.length) {\n      res.push(-1)\n    } else {\n      res.push(arrary[left].idx)\n    }\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "437-path-sum-iii",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} sum\n * @return {number}\n */\nfunction pathSum(root, sum) {\n    const preSums = new Map([[0, 1]]);\n    let count = 0;\n    visit(root, 0);\n    return count;\n    \n    function visit(node, preSum) {\n        if (!node) return;\n        preSum += node.val;\n        count += preSums.get(preSum - sum) || 0;\n        preSums.set(preSum, (preSums.get(preSum) || 0) + 1);\n        visit(node.left, preSum);\n        visit(node.right, preSum);\n        preSums.set(preSum, preSums.get(preSum) - 1);\n    }\n}\n\n"
    }
  },
  {
    "name": "438-find-all-anagrams-in-a-string",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {string} p\n * @return {number[]}\n */\nconst findAnagrams = function (s, p) {\n  const slen = s.length;\n  const plen = p.length;\n  if (plen > slen) return [];\n  const aCode = \"a\".charCodeAt(0);\n  const count = new Array(26).fill(0);\n  for (let i = 0; i < plen; i++) count[p.charCodeAt(i) - aCode] += 1;\n  const res = [];\n  for (let i = 0; i < slen; i++) {\n    count[s.charCodeAt(i) - aCode] -= 1;\n    if (i >= plen - 1) {\n      if (i - plen >= 0) count[s.charCodeAt(i - plen) - aCode] += 1;\n      if (allZero(count)) res.push(i - plen + 1);\n    }\n  }\n  return res;\n};\nfunction allZero(count) {\n  for (let el of count) {\n    if (el !== 0) return false;\n  }\n  return true;\n}\n"
    }
  },
  {
    "name": "439-ternary-expression-parser",
    "code": {
      "JS": "/**\n * @param {string} expression\n * @return {string}\n */\nconst parseTernary = function(expression) {\n  const N = expression.length\n  const stack = [expression[N - 1]]\n  for (let i = N - 2; i >= 0; i -= 2) {\n    if (expression[i] === ':') {\n      stack.push(expression[i - 1])\n    } else {\n      const l = stack.pop()\n      const r = stack.pop()\n      if (expression[i - 1] === 'T') {\n        stack.push(l)\n      } else {\n        stack.push(r)\n      }\n    }\n  }\n  return stack[0]\n}\n"
    }
  },
  {
    "name": "44-wildcard-matching",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {string} p\n * @return {boolean}\n */\nconst isMatch = function(s, p) {\n  const M = s.length\n  const N = p.length\n  let i = 0,\n    j = 0,\n    lastMatchInS,\n    lastStarPos\n  while (i < M) {\n    if (j < N && (p[j] === s[i] || p[j] === '?')) {\n      i++\n      j++\n    } else if (j < N && p[j] === '*') {\n      lastStarPos = j\n      j++\n      lastMatchInS = i\n    } else if (lastStarPos !== undefined) {\n      // back to previous step\n      j = lastStarPos + 1\n      lastMatchInS++\n      i = lastMatchInS\n    } else {\n      return false\n    }\n  }\n  while (j < N && p[j] === '*') {\n    j++\n  }\n  return j === N\n}\n"
    }
  },
  {
    "name": "440-k-th-smallest-in-lexicographical-order",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number} k\n * @return {number}\n */\nconst findKthNumber = function(n, k) {\n  let curr = 1\n  k = k - 1\n  while (k > 0) {\n    let steps = calSteps(n, curr, curr + 1)\n    if (steps <= k) {\n      curr++\n      k -= steps\n    } else {\n      curr *= 10\n      k--\n    }\n  }\n  return curr\n}\n\n//use long in case of overflow\nfunction calSteps(n, n1, n2) {\n  let steps = 0\n  while (n1 <= n) {\n    steps += Math.min(n + 1, n2) - n1\n    n1 *= 10\n    n2 *= 10\n  }\n  return steps\n}\n"
    }
  },
  {
    "name": "441-arranging-coins",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst arrangeCoins = function(n) {\n    if (n === 0) {\n        return 0\n    }\n    let num = 1\n    let sum = 1\n    while(n >= sum + num + 1) {\n        num += 1\n        sum += num\n    }\n\n    return num\n};\n\n// another\n\n/**\n * @param {number} n\n * @return {number}\n */\nconst arrangeCoins = function(n) {\n  return (-1 + Math.sqrt(1+4*2*n)) >> 1\n};\n"
    }
  },
  {
    "name": "442-find-all-duplicates-in-an-array",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n * @return {number[]}\r\n */\r\n\r\nconst findDuplicates = function(nums) {\r\n  if (nums === null || nums.length <= 1) {\r\n    return [];\r\n  }\r\n\r\n  let dup = [];\r\n  for (let i = 0, n = nums.length; i < n; i++) {\r\n    let next = Math.abs(nums[i]);\r\n    nums[next - 1] < 0 ? dup.push(next) : (nums[next - 1] = -nums[next - 1]);\r\n  }\r\n\r\n  return dup;\r\n};\r\n\r\nconsole.log(findDuplicates([4, 3, 2, 7, 8, 2, 3, 1]));\r\nconsole.log(findDuplicates([10, 2, 5, 10, 9, 1, 1, 4, 3, 7]));\r\n\r\n// another\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @return {number[]}\r\n */\r\nconst findDuplicates = function(nums) {\r\n  const res = []\r\n  for(let i = 0, len = nums.length; i < len; i++) {\r\n    const idx = Math.abs(nums[i]) - 1\r\n    if(nums[idx] < 0) res.push(idx + 1)\r\n    nums[idx] = -nums[idx]\r\n  }\r\n  return res;\r\n};\r\n"
    }
  },
  {
    "name": "443-string-compression",
    "code": {
      "JS": "/**\n * @param {character[]} chars\n * @return {number}\n */\nconst compress = function(chars) {\n    let indexAns = 0\n    let index = 0\n    while(index < chars.length) {\n        let currentChar = chars[index]\n        let count = 0\n        while(index < chars.length && chars[index] === currentChar) {\n            index++\n            count++\n        }\n        chars[indexAns++] = currentChar\n        if(count !== 1) {\n            for(let el of (''+count).split('')) {\n                chars[indexAns++] = el\n            }\n        }\n    }\n    return indexAns\n};\n"
    }
  },
  {
    "name": "444-sequence-reconstruction",
    "code": {
      "JS": "/**\n * @param {number[]} org\n * @param {number[][]} seqs\n * @return {boolean}\n */\nconst sequenceReconstruction = function(org, seqs) {\n  const pairs = {}\n  const idxs = {}\n  for (let i = 0; i < org.length; i++) idxs[org[i]] = i\n  for (let j = 0; j < seqs.length; j++) {\n    const s = seqs[j]\n    for (let i = 0; i < s.length; i++) {\n      if (idxs[s[i]] == null) return false\n      if (i > 0 && idxs[s[i - 1]] >= idxs[s[i]]) return false\n      pairs[`${s[i - 1]}_${s[i]}`] = 1\n    }\n  }\n\n  for (let i = 0; i < org.length; i++)\n    if (pairs[`${org[i - 1]}_${org[i]}`] == null) return false\n\n  return true\n}\n\n// another\n\n/**\n * @param {number[]} org\n * @param {number[][]} seqs\n * @return {boolean}\n */\nconst sequenceReconstruction = function(org, seqs) {\n  const graph = new Map()\n  const indegree = new Map()\n  seqs.forEach(seq => {\n    for (let i = 0; i < seq.length; i++) {\n      if (!graph.has(seq[i])) graph.set(seq[i], [])\n      if (!indegree.has(seq[i])) indegree.set(seq[i], 0)\n      if (i > 0) {\n        graph.get(seq[i - 1]).push(seq[i])\n        indegree.set(seq[i], indegree.get(seq[i]) + 1)\n      }\n    }\n  })\n  if (org.length !== graph.size) return false\n  const array = []\n  for (let [key, val] of indegree.entries()) {\n    if (val === 0) array.push(key)\n  }\n  let index = 0\n  while (array.length > 0) {\n    if (array.length > 1) return false\n    const current = array.shift()\n    if (org[index] !== current) {\n      return false\n    }\n    index++\n    graph.get(current).forEach(next => {\n      indegree.set(next, indegree.get(next) - 1)\n      if (indegree.get(next) === 0) array.push(next)\n    })\n  }\n  return index === org.length\n}\n\n"
    }
  },
  {
    "name": "445-add-two-numbers-II",
    "code": {
      "JS": "/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} l1\r\n * @param {ListNode} l2\r\n * @return {ListNode}\r\n */\r\nconst addTwoNumbers = function(head1, head2) {\r\n  const r1 = reverse(head1), r2 = reverse(head2)\r\n  let l1 = r1, l2 = r2, inc = 0\r\n  let dummy = new ListNode()\r\n  let pre = dummy\r\n  while(l1 || l2) {\r\n    let val = inc\r\n    if(l1) {\r\n      val += l1.val\r\n      l1 = l1.next\r\n    }\r\n    if(l2) {\r\n      val += l2.val\r\n      l2 = l2.next\r\n    }\r\n    if(val > 9) inc = 1\r\n    else inc = 0\r\n    const cur = new ListNode(val % 10)\r\n    pre.next = cur\r\n    pre = cur\r\n  }\r\n  if (inc) {\r\n    pre.next = new ListNode(1)\r\n  }\r\n  return reverse(dummy.next) \r\n};\r\n\r\nfunction reverse(head) {\r\n  const dummy = new ListNode()\r\n  dummy.next = head\r\n  let len = 0, cur = head\r\n  while(cur) {\r\n    len++\r\n    cur = cur.next\r\n  }\r\n  let p = dummy, tail = head, tmp = null\r\n  for(let i = 0; i < len - 1; i++) {\r\n    tmp = p.next\r\n    p.next = tail.next\r\n    tail.next = tail.next.next\r\n    p.next.next = tmp\r\n  }\r\n  return dummy.next\r\n}\r\n\r\n\r\n// another\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} l1\r\n * @param {ListNode} l2\r\n * @return {ListNode}\r\n */\r\nconst addTwoNumbers = function(l1, l2) {\r\n  const s1 = [];\r\n  const s2 = [];\r\n  while (l1 !== null) {\r\n    s1.push(l1.val);\r\n    l1 = l1.next;\r\n  }\r\n  while (l2 !== null) {\r\n    s2.push(l2.val);\r\n    l2 = l2.next;\r\n  }\r\n\r\n  let list = new ListNode(0);\r\n  let sum = 0;\r\n  while (s1.length > 0 || s2.length > 0) {\r\n    if (s1.length > 0) {\r\n      sum += s1.pop();\r\n    }\r\n    if (s2.length > 0) {\r\n      sum += s2.pop();\r\n    }\r\n    list.val = sum % 10;\r\n    const head = new ListNode(Math.floor(sum / 10));\r\n    head.next = list;\r\n    list = head;\r\n    sum = Math.floor(sum / 10);\r\n  }\r\n\r\n  return list.val === 0 ? list.next : list;\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} l1\r\n * @param {ListNode} l2\r\n * @return {ListNode}\r\n */\r\nconst addTwoNumbers = function(l1, l2) {\r\n  const s1 = [], s2 = []\r\n  let h1 = l1, h2 = l2\r\n  while(h1) {\r\n    s1.push(h1.val)\r\n    h1 = h1.next\r\n  }\r\n  while(h2) {\r\n    s2.push(h2.val)\r\n    h2 = h2.next\r\n  }\r\n  let inc = false\r\n  let tail = null\r\n  while(s1.length || s2.length) {\r\n    let tmp = 0\r\n    if(s1.length) tmp += s1.pop()\r\n    if(s2.length) tmp += s2.pop()\r\n    if(inc) tmp++\r\n    if(tmp > 9) {\r\n      inc = true\r\n    } else {\r\n      inc = false\r\n    }\r\n    tmp = tmp % 10\r\n    const cur = new ListNode(tmp)\r\n    if(tail) cur.next = tail\r\n    tail = cur\r\n  }\r\n  \r\n  if(inc) {\r\n    const head = new ListNode(1)\r\n    head.next = tail\r\n    return head\r\n  }\r\n  return tail\r\n  \r\n};\r\n"
    }
  },
  {
    "name": "446-arithmetic-slices-ii-subsequence",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @return {number}\n */\nconst numberOfArithmeticSlices = function(A) {\n  if (!A || A.length < 3) return 0;\n  let res = 0;\n  const dp = Array(A.length);\n  for (let i = 0; i < A.length; i++) {\n    dp[i] = new Map();\n    for (let j = 0; j < i; j++) {\n      const diff = A[i] - A[j];\n      const prevCount = dp[j].get(diff) || 0;\n      res += prevCount;\n      const currCount = (dp[i].get(diff) || 0) + 1;\n      dp[i].set(diff, prevCount + currCount);\n    }\n  }\n  return res;\n};\n"
    }
  },
  {
    "name": "447-number-of-boomerangs",
    "code": {
      "JS": "/**\n * @param {number[][]} points\n * @return {number}\n */\nconst numberOfBoomerangs = function(points) {\n  const m = new Map()\n  const len = points.length\n  let res = 0\n  for(let i = 0; i < len; i++) {\n    for(let j = 0; j < len; j++) {\n      if(i === j) continue\n      const d = dis(points[i], points[j])\n      if(!m.has(d)) m.set(d, 0)\n      m.set(d, m.get(d) + 1)\n    }\n    for(let v of m.values()) {\n      res += v * (v - 1)\n    }\n    m.clear()\n  }\n  return res\n};\n\nfunction dis(a, b) {\n  return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n}\n"
    }
  },
  {
    "name": "448-find-all-numbers-disappeared-in-an-array",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n * @return {number[]}\r\n */\r\nconst findDisappearedNumbers = function(nums) {\r\n  const res = [];\r\n  nums.forEach((el, idx) => {\r\n    res[el - 1] = 1;\r\n  });\r\n  const arr = [];\r\n  for (let i = 0; i < nums.length; i++) {\r\n    if (res[i] == null) {\r\n      arr.push(i + 1);\r\n    }\r\n  }\r\n  return arr;\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @return {number[]}\r\n */\r\nconst findDisappearedNumbers = function(nums) {\r\n  for(let i = 0, len = nums.length; i < len; i++) {\r\n    const idx = Math.abs(nums[i]) - 1\r\n    nums[idx] = - Math.abs(nums[idx])\r\n  }\r\n  const res = []\r\n  nums.forEach((e, i) => {\r\n    if(e > 0) res.push(i + 1)\r\n  })\r\n  return res\r\n};\r\n"
    }
  },
  {
    "name": "449-serialize-and-deserialize-BST",
    "code": {
      "JS": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n\r\nconst splitter = \",\";\r\n/**\r\n * Encodes a tree to a single string.\r\n *\r\n * @param {TreeNode} root\r\n * @return {string}\r\n */\r\nconst serialize = function(root) {\r\n  const sb = [];\r\n  buildString(root, sb);\r\n  sb.pop();\r\n  return sb.join(\"\");\r\n};\r\nfunction buildString(node, sb) {\r\n  if (node == null) return;\r\n  sb.push(node.val);\r\n  sb.push(splitter);\r\n  buildString(node.left, sb);\r\n  buildString(node.right, sb);\r\n}\r\n/**\r\n * Decodes your encoded data to tree.\r\n *\r\n * @param {string} data\r\n * @return {TreeNode}\r\n */\r\nconst deserialize = function(data) {\r\n  if (data.length === 0) return null;\r\n  const pos = [0];\r\n  return buildTree(\r\n    data.split(splitter),\r\n    pos,\r\n    Number.MIN_SAFE_INTEGER,\r\n    Number.MAX_SAFE_INTEGER\r\n  );\r\n};\r\nfunction buildTree(nodes, pos, min, max) {\r\n  if (pos[0] === nodes.length) return null;\r\n  let val = +nodes[pos[0]];\r\n  if (val < min || val > max) return null;\r\n  const cur = new TreeNode(val);\r\n  pos[0] += 1;\r\n  cur.left = buildTree(nodes, pos, min, val);\r\n  cur.right = buildTree(nodes, pos, val, max);\r\n  return cur;\r\n}\r\n\r\n/**\r\n * Your functions will be called as such:\r\n * deserialize(serialize(root));\r\n */\r\n"
    }
  },
  {
    "name": "45-jump-game-ii",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst jump = function(nums) {\n    if (nums.length <= 1) return 0;\n    let curMax = 0; // to mark the last element in a level\n    let level = 0, i = 0;\n    while (i <= curMax) { \n        let furthest = curMax; // to mark the last element in the next level\n        for (; i <= curMax; i++) {\n            furthest = Math.max(furthest, nums[i] + i);\n            if (furthest >= nums.length - 1) return level + 1;\n        }\n        level++;\n        curMax = furthest;\n    }\n    return -1; // if i < curMax, i can't move forward anymore (the last element in the array can't be reached)\n};\n"
    }
  },
  {
    "name": "450-delete-node-in-a-bst",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} key\n * @return {TreeNode}\n */\nconst deleteNode = function(root, key) {\n  if(root == null) return null\n  if(key < root.val) {\n    root.left = deleteNode(root.left, key)\n  } else if(key > root.val) {\n    root.right = deleteNode(root.right, key)\n  } else {\n    if(root.left == null) {\n      return root.right\n    } else if(root.right == null) {\n      return root.left\n    } else {\n      let smallestRight = root.right\n      while(smallestRight.left !== null) smallestRight = smallestRight.left\n      smallestRight.left = root.left\n      return root.right\n    }\n  }\n  \n  return root\n};\n\n// another\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} key\n * @return {TreeNode}\n */\nconst deleteNode = function(root, key) {\n  if(root == null) return root\n\n  if(root.val < key) root.right = deleteNode(root.right, key)\n  else if(root.val > key) root.left = deleteNode(root.left, key)\n  else {\n    if(root.left == null && root.right === null) root = null\n    else if(root.left == null) root = root.right\n    else if(root.right == null) root = root.left\n    else {\n      const min = findMin(root.right)\n      root.val = min.val\n      root.right = deleteNode(root.right, root.val)\n    }\n  }\n\n  return root\n};\n\nfunction findMin(node) {\n  let cur = node\n  while(cur.left) {\n    cur = cur.left\n  }\n  return cur\n}\n"
    }
  },
  {
    "name": "451-sort-characters-by-frequency",
    "code": {
      "JS": "/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nconst frequencySort = function(s) {\r\n  const charMap = {};\r\n  for (let i = 0; i < s.length; i++) {\r\n    const index = s.charAt(i);\r\n    charMap[index] = (charMap[index] || 0) + 1;\r\n  }\r\n  return Object.entries(charMap)\r\n    .sort((a, b) => {\r\n      return b[1] - a[1];\r\n    })\r\n    .map(x => {\r\n      return x[0].repeat(x[1]);\r\n    })\r\n    .join(\"\");\r\n};\r\n"
    }
  },
  {
    "name": "452-minimum-number-of-arrows-to-burst-balloons",
    "code": {
      "JS": "/**\n * @param {number[][]} points\n * @return {number}\n */\nconst findMinArrowShots = function(points) {\n  const sorted = points.sort((a, b) => a[0] - b[0])\n  let ans = 0\n  let lastX = null\n  for (let i = 0; i < sorted.length; i += 1) {\n    if (lastX && sorted[i][0] <= lastX) {\n      lastX = Math.min(sorted[i][1], lastX)\n    } else {\n      ans += 1\n      lastX = sorted[i][1]\n    }\n  }\n  return ans\n}\n\n// another\n\n/**\n * @param {number[][]} points\n * @return {number}\n */\nconst findMinArrowShots = function(points) {\n  if(points == null || points.length === 0) return 0\n  points.sort((a, b) => a[1] - b[1])\n  let end = points[0][1], res = 1\n  for(let i = 1, len = points.length; i < len; i++) {\n    if(points[i][0] > end) {\n      end = points[i][1]\n      res++\n    }\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "453-minimum-moves-to-equal-array-elements",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nconst minMoves = function(nums) {\r\n  let min = Number.MAX_SAFE_INTEGER;\r\n  let sum = 0;\r\n  for (let i = 0; i < nums.length; i++) {\r\n    min = Math.min(min, nums[i]);\r\n    sum += nums[i];\r\n  }\r\n  return sum - min * nums.length;\r\n};\r\n"
    }
  },
  {
    "name": "454-4sum-ii",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @param {number[]} B\n * @param {number[]} C\n * @param {number[]} D\n * @return {number}\n */\nconst fourSumCount = function(A, B, C, D) {\n  const map = new Map()\n  let res = 0\n  for (let i = 0, clen = C.length; i < clen; i++) {\n    for (let j = 0, dlen = D.length; j < dlen; j++) {\n      map.set(\n        C[i] + D[j],\n        typeof map.get(C[i] + D[j]) == 'undefined'\n          ? 1\n          : map.get(C[i] + D[j]) + 1\n      )\n    }\n  }\n  for (let i = 0, alen = A.length; i < alen; i++) {\n    for (let j = 0, blen = B.length; j < blen; j++) {\n      res +=\n        typeof map.get((A[i] + B[j]) * -1) == 'undefined'\n          ? 0\n          : map.get((A[i] + B[j]) * -1)\n    }\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "455-assign-cookies",
    "code": {
      "JS": "/**\r\n * @param {number[]} g\r\n * @param {number[]} s\r\n * @return {number}\r\n */\r\nconst findContentChildren = function(g, s) {\r\n  s.sort((a, b) => a - b);\r\n  g.sort((a, b) => a - b);\r\n\r\n  let i = 0;\r\n  for (let j = 0; i < g.length && j < s.length; j++) {\r\n    if (g[i] <= s[j]) i++;\r\n  }\r\n  return i;\r\n};\r\n"
    }
  },
  {
    "name": "456-132-pattern",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nconst find132pattern = function(nums) {\n  let [stack, s3] = [[], -Infinity]\n  for (let i = nums.length - 1; i >= 0; i--) {\n    if (nums[i] < s3) {\n      return true\n    }\n    while (stack[stack.length - 1] < nums[i]) {\n      s3 = stack.pop()\n    }\n    stack.push(nums[i])\n  }\n  return false\n}\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\nconst find132pattern = function(nums) {\n  let idx = nums.length\n  let s3 = Number.NEGATIVE_INFINITY\n  for(let len = nums.length, i = len - 1; i >= 0; i--) {\n    if(nums[i] < s3) return true\n    while(idx < nums.length && nums[i] > nums[idx]) {\n      s3 = nums[idx++]\n    }\n    nums[--idx] = nums[i] \n  }\n  return false\n}\n\n"
    }
  },
  {
    "name": "457-circular-array-loop",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nconst circularArrayLoop = function(nums) {\n  let n = nums.length;\n  for (let i = 0; i < n; i++) {\n    if (nums[i] == 0) {\n      continue;\n    }\n    let j = i,\n      k = getNextIndex(i, nums);\n    while (nums[k] * nums[i] > 0 && nums[getNextIndex(k, nums)] * nums[i] > 0) {\n      if (j === k) {\n        // check for loop with only one element\n        if (j === getNextIndex(j, nums)) {\n          break;\n        }\n        return true;\n      }\n      j = getNextIndex(j, nums);\n      k = getNextIndex(getNextIndex(k, nums), nums);\n    }\n    // loop not found, set all element along the way to 0\n    j = i;\n    let val = nums[i];\n    while (nums[j] * val > 0) {\n      let next = getNextIndex(j, nums);\n      nums[j] = 0;\n      j = next;\n    }\n  }\n  return false;\n};\n\nfunction getNextIndex(i, nums) {\n  const n = nums.length;\n  return i + nums[i] >= 0 ? (i + nums[i]) % n : n + ((i + nums[i]) % n);\n}\n"
    }
  },
  {
    "name": "458-poor-pigs",
    "code": {
      "JS": "/**\n * @param {number} buckets\n * @param {number} minutesToDie\n * @param {number} minutesToTest\n * @return {number}\n */\nconst poorPigs = function(buckets, minutesToDie, minutesToTest) {\n  const index = Math.ceil(minutesToTest / minutesToDie) + 1\n  return Math.ceil(Math.log(buckets) / Math.log(index))\n}\n\n// another\n\n/**\n * @param {number} buckets\n * @param {number} minutesToDie\n * @param {number} minutesToTest\n * @return {number}\n */\nconst poorPigs = function(buckets, minutesToDie, minutesToTest) {\n  let pigs = 0\n  while ((minutesToTest / minutesToDie + 1) ** pigs < buckets) {\n    pigs++\n  }\n  return pigs\n}\n"
    }
  },
  {
    "name": "459-repeated-substring-pattern",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {boolean}\n */\nconst repeatedSubstringPattern = function(s) {\n    const len = s.length\n    let tmp = ''\n    for(let i = 1; i <= len; i++) {\n        tmp = s.substr(0, i)\n        if (tmp.length === len) {\n            return false\n        }\n        if (s === genStr(tmp, len)) {\n            return true\n        }\n    }\n    return false\n};\nfunction genStr(sub, limit) {\n    let str = sub\n    while(str.length < limit) {\n        str += sub\n    }\n    return str\n}\n\n// another\n\n/**\n * @param {string} s\n * @return {boolean}\n */\nconst repeatedSubstringPattern = function (s) {\n  const l = s.length\n  const arr = DFA(s)\n  return arr[l] && arr[l] % (l - arr[l]) === 0\n  function DFA(s) {\n    let i = 1\n    let j = 0\n    const len = s.length\n    const prefix = Array(len + 1).fill(0)\n    prefix[0] = -1\n    prefix[1] = 0\n    while (i < len) {\n      if (s[j] === s[i]) {\n        j++\n        i++\n        prefix[i] = j\n      } else {\n        if (j > 0) j = prefix[j]\n        else i++\n      }\n    }\n    return prefix\n  }\n}\n\n// another\n\n/**\n * @param {string} s\n * @return {boolean}\n */\nconst repeatedSubstringPattern = function(s) {\n    let i = 1, j = 0, n = s.length;\n    const dp = Array(n + 1).fill(0);\n    while( i < s.length ){\n        if( s[i] === s[j] ) dp[++i] = ++j;\n        else if( j === 0 ) i++;\n        else j = dp[j];\n    }\n    return dp[n] && (dp[n] % (n - dp[n]) === 0);   \n};\n"
    }
  },
  {
    "name": "46-permutations",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n * @return {number[][]}\r\n */\r\nfunction permute(nums) {\r\n  const list = [];\r\n  // Arrays.sort(nums); // not necessary\r\n  backtrack(list, [], nums);\r\n  return list;\r\n}\r\n\r\nfunction backtrack(list, tempList, nums) {\r\n  if (tempList.length == nums.length) {\r\n    list.push(tempList.slice(0));\r\n  } else {\r\n    for (let i = 0; i < nums.length; i++) {\r\n      if (tempList.includes(nums[i])) continue; // element already exists, skip\r\n      tempList.push(nums[i]);\r\n      backtrack(list, tempList, nums);\r\n      tempList.pop();\r\n    }\r\n  }\r\n}\r\n\r\n// another\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @return {number[][]}\r\n */\r\nconst permute = function(nums) {\r\n  const res = []\r\n  bt(nums, 0, [], res)\r\n  return res\r\n};\r\n\r\nfunction bt(nums, idx, cur, res) {\r\n  if(idx === nums.length) {\r\n    res.push(cur.slice())\r\n    return\r\n  }\r\n  for(let i = 0; i < nums.length; i++) {\r\n    if(cur.indexOf(nums[i]) !== -1) continue\r\n    cur.push(nums[i])\r\n    bt(nums, idx + 1, cur, res)\r\n    cur.pop()\r\n  }\r\n}\r\n"
    }
  },
  {
    "name": "460-lfu-cache",
    "code": {
      "JS": "/**\n * @param {number} capacity\n */\nconst LFUCache = function(capacity) {\n  this.min = -1;\n  this.capacity = capacity;\n  this.keyToVal = {};\n  this.keyToCount = {};\n  this.countToLRUKeys = {};\n};\n\n/**\n * @param {number} key\n * @return {number}\n */\nLFUCache.prototype.get = function(key) {\n  if (!this.keyToVal.hasOwnProperty(key)) return -1;\n  let count = this.keyToCount[key];\n  let idx = this.countToLRUKeys[count].indexOf(key);\n  if (idx !== -1) this.countToLRUKeys[count].splice(idx, 1);\n  if (count === this.min && this.countToLRUKeys[count].length === 0) this.min++;\n  putCount(key, count + 1, this.keyToCount, this.countToLRUKeys);\n  return this.keyToVal[key];\n};\n\n/**\n * @param {number} key\n * @param {number} value\n * @return {void}\n */\nLFUCache.prototype.put = function(key, value) {\n  if (this.capacity <= 0) return;\n\n  if (this.keyToVal.hasOwnProperty(key)) {\n    this.keyToVal[key] = value; // update key's value\n    this.get(key); // update key's count\n    return;\n  }\n\n  if (Object.keys(this.keyToVal).length >= this.capacity) {\n    evict(\n      this.countToLRUKeys[this.min][0],\n      this.min,\n      this.keyToVal,\n      this.countToLRUKeys\n    ); // evict LRU from this min count bucket\n  }\n\n  this.min = 1;\n  putCount(key, this.min, this.keyToCount, this.countToLRUKeys); // adding new key and count\n  this.keyToVal[key] = value; // adding new key and value\n};\nfunction evict(key, min, keyToVal, countToLRUKeys) {\n  let idx = countToLRUKeys[min].indexOf(key);\n  if (idx !== -1) countToLRUKeys[min].splice(idx, 1);\n  delete keyToVal[key];\n}\nfunction putCount(key, count, keyToCount, countToLRUKeys) {\n  keyToCount[key] = count;\n  if (countToLRUKeys.hasOwnProperty(count)) {\n    countToLRUKeys[count].push(key);\n  } else {\n    countToLRUKeys[count] = [key];\n  }\n}\n\n/**\n * Your LFUCache object will be instantiated and called as such:\n * var obj = Object.create(LFUCache).createNew(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n"
    }
  },
  {
    "name": "461-hamming-distance",
    "code": {
      "JS": "/**\n * @param {number} x\n * @param {number} y\n * @return {number}\n */\nconst hammingDistance = function (x, y) {\n  let d = 0\n  let h = x ^ y\n  while (h > 0) {\n    d++\n    h &= h - 1\n  }\n  return d\n}\n\n// another\n\n/**\n * @param {number} x\n * @param {number} y\n * @return {number}\n */\nconst hammingDistance = function (x, y) {\n  let n = x ^ y\n  n = n - ((n >> 1) & 0x55555555)\n  n = (n & 0x33333333) + ((n >> 2) & 0x33333333)\n  return (((n + (n >> 4)) & 0xf0f0f0f) * 0x1010101) >> 24\n}\n\n// another\n\n/**\n * @param {number} x\n * @param {number} y\n * @return {number}\n */\nconst hammingDistance = function (x, y) {\n  let n = x ^ y\n  let tmp = n - ((n >> 1) & 033333333333) - ((n >> 2) & 011111111111);\n  return ((tmp + (tmp >> 3)) & 030707070707) % 63;\n}\n\n// https://tech.liuchao.me/2016/11/count-bits-of-integer/\n"
    }
  },
  {
    "name": "462-minimum-moves-to-equal-array-elements-II",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nconst minMoves2 = function(nums) {\r\n  nums.sort((a, b) => a - b);\r\n  let i = 0,\r\n    j = nums.length - 1;\r\n  let res = 0;\r\n  while (i < j) {\r\n    res += nums[j] - nums[i];\r\n    i++;\r\n    j--;\r\n  }\r\n  return res;\r\n};\r\n"
    }
  },
  {
    "name": "463-island-perimeter",
    "code": {
      "JS": "/**\r\n * @param {number[][]} grid\r\n * @return {number}\r\n */\r\nconst islandPerimeter = function(grid) {\r\n  let len = 0;\r\n  for (let r = 0; r < grid.length; r++) {\r\n    for (let c = 0; c < grid[0].length; c++) {\r\n      if (grid[r][c] === 1) {\r\n        len += cell(grid, r, c);\r\n      }\r\n    }\r\n  }\r\n  return len;\r\n};\r\n\r\nfunction cell(grid, r, c) {\r\n  let len = 0;\r\n  // top\r\n  if (r === 0 || grid[r - 1][c] !== 1) {\r\n    len += 1;\r\n  }\r\n  // left\r\n  if (c === 0 || grid[r][c - 1] !== 1) {\r\n    len += 1;\r\n  }\r\n  // right\r\n  if (grid[r][c + 1] !== 1) {\r\n    len += 1;\r\n  }\r\n  // bottom\r\n  if (grid[r + 1] == null || grid[r + 1][c] !== 1) {\r\n    len += 1;\r\n  }\r\n  return len;\r\n}\r\n\r\nconsole.log(\r\n  islandPerimeter([[0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 0]])\r\n);\r\n\r\n// another\r\n\r\n/**\r\n * @param {number[][]} grid\r\n * @return {number}\r\n */\r\nconst islandPerimeter = function(grid) {\r\n  const m = grid.length\r\n  const n = grid[0].length\r\n  const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\r\n  let r = 0\r\n  for(let i = 0; i < m; i++) {\r\n    for(let j = 0; j < n; j++) {\r\n      if(grid[i][j] === 1) r += h(i, j)\r\n    }\r\n  }\r\n  \r\n  return r\r\n  \r\n  function h(i, j) {\r\n    let res = 0\r\n    for(let d of dirs) {\r\n      const nr = i + d[0]\r\n      const nc = j + d[1]\r\n      if(nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] === 0) res++\r\n    }\r\n    return res\r\n  }\r\n};\r\n"
    }
  },
  {
    "name": "464-can-i-win",
    "code": {
      "JS": "/**\n * @param {number} maxChoosableInteger\n * @param {number} desiredTotal\n * @return {boolean}\n */\nconst canIWin = function(maxChoosableInteger, desiredTotal) {\n  if (desiredTotal <= 0) return true\n  if ((maxChoosableInteger * (1 + maxChoosableInteger)) / 2 < desiredTotal)\n    return false\n  const dp = new Array(1 << maxChoosableInteger).fill(0)\n  return dfs(dp, 0, maxChoosableInteger, desiredTotal)\n\n  function dfs(dp, chs, max, target) {\n    if (target <= 0) return false\n    if (dp[chs] != 0) return dp[chs] === 1\n    let win = false\n    for (let i = 0; i < max; i++) {\n      if ((chs & (1 << i)) === 0) {\n        //not used\n        win = win || !dfs(dp, chs ^ (1 << i), max, target - i - 1)\n      }\n    }\n    dp[chs] = win ? 1 : -1\n    return win\n  }\n}\n"
    }
  },
  {
    "name": "465-optimal-account-balancing",
    "code": {
      "JS": "/**\n\nA group of friends went on holiday and sometimes lent each other money.\nFor example, Alice paid for Bill's lunch for $10.\nThen later Chris gave Alice $5 for a taxi ride.\nWe can model each transaction as a tuple (x, y, z) which means person x gave person y $z.\nAssuming Alice, Bill, and Chris are person 0, 1, and 2 respectively (0, 1, 2 are the person's ID),\nthe transactions can be represented as [[0, 1, 10], [2, 0, 5]].\n\nGiven a list of transactions between a group of people,\nreturn the minimum number of transactions required to settle the debt.\n\nNote:\n\nA transaction will be given as a tuple (x, y, z). Note that x ≠ y and z > 0.\nPerson's IDs may not be linear, e.g. we could have the persons 0, 1, 2 or we could also have the persons 0, 2, 6.\nExample 1:\n\nInput:\n[[0,1,10], [2,0,5]]\n\nOutput:\n2\n\nExplanation:\nPerson #0 gave person #1 $10.\nPerson #2 gave person #0 $5.\n\nTwo transactions are needed. One way to settle the debt is person #1 pays person #0 and #2 $5 each.\nExample 2:\n\nInput:\n[[0,1,10], [1,0,1], [1,2,5], [2,0,5]]\n\nOutput:\n1\n\nExplanation:\nPerson #0 gave person #1 $10.\nPerson #1 gave person #0 $1.\nPerson #1 gave person #2 $5.\nPerson #2 gave person #0 $5.\n\nTherefore, person #1 only need to give person #0 $4, and all debt is settled.\n\n*/\n\n/**\n * @param {number[][]} transactions\n * @return {number}\n */\nconst minTransfers = function(transactions) {\n  if (transactions.length === 0) return 0;\n  const map = new Map();\n  for (let [a, b, m] of transactions) {\n    if (!map.has(a)) map.set(a, 0);\n    if (!map.has(b)) map.set(b, 0);\n    map.set(a, map.get(a) - m);\n    map.set(b, map.get(b) + m);\n  }\n  const debts = [...map.values()].filter(debt => debt !== 0);\n  const len = debts.length;\n  const dfs = (id, d) => {\n    if (id >= d.length) return 0;\n    const cur = d[id];\n    if (cur === 0) return dfs(id + 1, d);\n\n    let res = Infinity;\n    for (let i = id + 1; i < len; i++) {\n      const next = d[i];\n      if (cur * next < 0) {\n        d[i] = cur + next;\n        res = Math.min(res, 1 + dfs(id + 1, d));\n        d[i] = next;\n        if (next + cur === 0) break;\n      }\n    }\n    return res;\n  };\n  return dfs(0, debts);\n};\n"
    }
  },
  {
    "name": "466-count-the-repetitions",
    "code": {
      "JS": "/**\n * @param {string} s1\n * @param {number} n1\n * @param {string} s2\n * @param {number} n2\n * @return {number}\n */\nconst getMaxRepetitions = function(s1, n1, s2, n2) {\n  let j = 0,\n    i,\n    count = 0,\n    perCycle = 0,\n    firstEnd = -1,\n    lastEnd = -1,\n    nonMatch = 0\n  for (i = 0; i < s1.length * n1; i++) {\n    if (s2[j] === s1[i % s1.length]) {\n      j++\n      nonMatch = 0\n    } else if (++nonMatch >= s1.length) break\n    if (j === s2.length) {\n      count++\n      perCycle++\n      j = 0\n      if (lastEnd !== -1) continue\n      else if (firstEnd === -1) {\n        firstEnd = i\n        perCycle = 0\n      } else if ((i - firstEnd) % s1.length === 0) {\n        let cycleLen = i - firstEnd\n        let remainLen = s1.length * n1 - i - 1\n        let cycles = Math.floor(remainLen / cycleLen)\n        count += cycles * perCycle\n        i += cycles * cycleLen\n      }\n    }\n  }\n  return Math.floor(count / n2)\n}\n"
    }
  },
  {
    "name": "467-unique-substrings-in-wraparound-string",
    "code": {
      "JS": "/**\n * @param {string} p\n * @return {number}\n */\nconst findSubstringInWraproundString = function(p) {\n    // count[i] is the maximum unique substring end with ith letter.\n    // 0 - 'a', 1 - 'b', ..., 25 - 'z'.\n    const count = new Array(26).fill(0);\n\n    // store longest contiguous substring ends at current position.\n    let maxLengthCur = 0; \n\n    for (let i = 0; i < p.length; i++) {\n        if (i > 0\n            && (p.charCodeAt(i) - p.charCodeAt(i - 1) === 1 \n            || (p.charCodeAt(i - 1) - p.charCodeAt(i) === 25))) {\n            maxLengthCur++;\n        }\n        else {\n            maxLengthCur = 1;\n        }\n\n        let index = p.charCodeAt(i) - ('a').charCodeAt(0);\n        count[index] = Math.max(count[index], maxLengthCur);\n    }\n\n    // Sum to get result\n    let sum = 0;\n    for (let i = 0; i < 26; i++) {\n        sum += count[i];\n    }\n    return sum;\n};\n"
    }
  },
  {
    "name": "468-validate-ip-address",
    "code": {
      "JS": "/**\n * @param {string} IP\n * @return {string}\n */\nconst validIPAddress = function (IP) {\n  if (IP.indexOf('.') > 0) return validIPv4(IP) ? 'IPv4' : 'Neither'\n  else return validIPv6(IP) ? 'IPv6' : 'Neither'\n}\n\nconst validIPv4 = function (IP) {\n  const strs = IP.split('.')\n  if (strs.length !== 4) return false\n  for (let str of strs) {\n    if (str.length === 0) return false\n    if (str.match(/[^0-9]/)) return false\n    if (str.length > 1 && str.charAt(0) === '0') return false\n    if (+str > 255) return false\n  }\n  return true\n}\n\nconst validIPv6 = function (IP) {\n  const strs = IP.split(':')\n  if (strs.length !== 8) return false\n  for (let str of strs) {\n    if (str.length === 0) return false\n    if (str.length > 4) return false\n    if (str.match(/[^0-9a-fA-F]/g)) return false\n  }\n  return true\n}\n\n// another\n\n/**\n * @param {string} IP\n * @return {string}\n */\nconst validIPAddress = function(IP) {\n  const ipv4 = /^((\\d|[1-9]\\d|1\\d\\d|2([0-4]\\d|5[0-5]))\\.){4}$/\n  const ipv6 = /^([\\da-f]{1,4}:){8}$/i\n  return ipv4.test(IP + '.') ? 'IPv4' : ipv6.test(IP + ':') ? 'IPv6' : 'Neither'\n}\n\n// another\n\n/**\n * @param {string} IP\n * @return {string}\n */\nconst validIPAddress = function(IP) {\n  if (IP.indexOf('.') != -1) {\n    const arr = IP.split('.')\n    if (arr.length !== 4) return 'Neither'\n    for (let i = 0; i < arr.length; i++) {\n      const numVal = parseInt(arr[i])\n      if (\n        numVal < 0 ||\n        numVal >= 256 ||\n        arr[i].length !== ('' + numVal).length\n      ) {\n        return 'Neither'\n      }\n    }\n    return 'IPv4'\n  } else if (IP.indexOf(':') != -1) {\n    const arr = IP.split(':')\n    if (arr.length !== 8) return 'Neither'\n    for (let i = 0; i < arr.length; i++) {\n      if (arr[i].length > 4 || arr[i].length === 0) return 'Neither'\n      const re = /[^0-9A-F]/i\n      if (re.test(arr[i])) return 'Neither'\n    }\n    return 'IPv6'\n  } else {\n    return 'Neither'\n  }\n}\n"
    }
  },
  {
    "name": "469-convex-polygon",
    "code": {
      "JS": "/**\n * @param {number[][]} points\n * @return {boolean}\n */\nconst isConvex = function(points) {\n  let negative = false\n  let positive = false\n  const num = points.length\n  for (let p1 = 0; p1 < num; p1 += 1) {\n    const p2 = (p1 + 1) % num\n    const p3 = (p2 + 1) % num\n    const [Ax, Ay] = points[p1]\n    const [Bx, By] = points[p2]\n    const [Cx, Cy] = points[p3]\n    const crossProduct = CrossProductLength(Ax, Ay, Bx, By, Cx, Cy)\n    if (crossProduct < 0) {\n      negative = true\n    } else if (crossProduct > 0) {\n      positive = true\n    }\n    if (negative && positive) return false\n  }\n  return true\n}\n\nfunction CrossProductLength(Ax, Ay, Bx, By, Cx, Cy) {\n  const BAx = Ax - Bx\n  const BAy = Ay - By\n  const BCx = Cx - Bx\n  const BCy = Cy - By\n  return BAx * BCy - BAy * BCx\n}\n"
    }
  },
  {
    "name": "47-permutations-ii",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nconst permuteUnique = function(nums) {\n  const result = [];\n  if (nums == null || nums.length === 0) {\n    return result;\n  }\n  const map = {};\n  for (let n of nums) {\n    map[n] = map.hasOwnProperty(n) ? map[n] + 1 : 1;\n  }\n  permuteUniqueHelper(map, nums.length, [], 0, result);\n  return result;\n};\n\nfunction permuteUniqueHelper(m, l, p, i, r) {\n  if (l === i) {\n    r.push(p.slice(0, l));\n    return;\n  }\n  for (let key of Object.keys(m)) {\n    if (m[key] > 0) {\n      m[key] = m[key] - 1;\n      p[i] = key;\n      permuteUniqueHelper(m, l, p, i + 1, r);\n      m[key] = m[key] + 1;\n    }\n  }\n}\n\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nconst permuteUnique = function(nums) {\n  const set = new Set()\n  const used = new Set()\n  bt(nums, 0, [], used, set)\n  const res = []\n  for(let item of set) {\n    res.push(item.split(','))\n  }\n  return res\n};\n\nfunction bt(nums, i, cur, used, set) {\n  if(i === nums.length) {\n    set.add(cur.slice().join(','))\n    return\n  }\n  for(let idx = 0; idx < nums.length; idx++) {\n    if(used.has(idx)) continue\n    cur.push(nums[idx])\n    used.add(idx)\n    bt(nums, i + 1, cur, used, set)\n    used.delete(idx)\n    cur.pop()\n  }\n}\n"
    }
  },
  {
    "name": "470-implement-rand10-using-rand7",
    "code": {
      "JS": "/**\n * The rand7() API is already defined for you.\n * var rand7 = function() {}\n * @return {number} a random integer in the range 1 to 7\n */\nconst rand10 = function() {\n  let result = 40\n  while (result >= 40) {\n    result = 7 * (rand7() - 1) + (rand7() - 1)\n  }\n  return (result % 10) + 1\n}\n\n// another\n\n/**\n * The rand7() API is already defined for you.\n * var rand7 = function() {}\n * @return {number} a random integer in the range 1 to 7\n */\nconst rand10 = function() {\n  let tmp = 40\n  while(tmp >= 40) tmp = 7 * (rand7() - 1) + (rand7() - 1)\n  \n  return tmp % 10 + 1\n};\n"
    }
  },
  {
    "name": "471-encode-string-with-shortest-length",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {string}\n */\nconst encode = function(s) {\n  let N = s.length\n  let dp = Array(N)\n    .fill(0)\n    .map(() => Array(N))\n  for (let len = 1; len <= N; len++) {\n    for (let i = 0; i <= N - len; i++) {\n      let j = i + len - 1\n      dp[i][j] = s.slice(i, j + 1)\n      if (len > 4) {\n        for (let m = i; m < j; m++) {\n          if (dp[i][j].length > dp[i][m].length + dp[m + 1][j].length) {\n            dp[i][j] = dp[i][m] + dp[m + 1][j]\n          }\n        }\n        let substr = s.slice(i, j + 1)\n        for (let k = 1; k <= Math.floor(len / 2); k++) {\n          if (len % k === 0) {\n            let first = s.slice(i, i + k)\n            if (substr.split(first).join('') === '') {\n              let newStr = len / k + '[' + dp[i][i + k - 1] + ']'\n              if (newStr.length < dp[i][j].length) {\n                dp[i][j] = newStr\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return dp[0][N - 1]\n}\n"
    }
  },
  {
    "name": "472-concatenated-words",
    "code": {
      "JS": "/**\n * @param {string[]} words\n * @return {string[]}\n */\n\nconst findAllConcatenatedWordsInADict = function (words) {\n  const pre = new Set()\n  words.sort((a, b) => a.length - b.length)\n  const res = []\n  for(let i = 0; i < words.length; i++) {\n    if(valid(words[i], pre)) {\n      res.push(words[i])\n    }\n    pre.add(words[i])\n  }\n\n  return res\n\n  function valid(str, set) {\n    if(set.size === 0) return false\n    const dp = Array(str.length + 1).fill(false)\n    dp[0] = true\n    for(let i = 1; i <= str.length; i++) {\n      for(let j = 0; j < i; j++) {\n        if(!dp[j]) continue\n        if(set.has(str.slice(j, i))) {\n          dp[i] = true\n          break\n        }\n      }\n    }\n    \n    return dp[str.length]\n  }\n}\n\n\n\n\n// another\n\n/**\n * @param {string[]} words\n * @return {string[]}\n */\n\nconst findAllConcatenatedWordsInADict = function (words) {\n  const set = new Set(words)\n  const res = []\n  const map = new Map()\n  for (let w of words) {\n    if (w.length < 2) continue\n    if (dfs(w, set, map, 0)) res.push(w)\n  }\n  return res\n\n  function dfs(word, set, map, pos) {\n    if (pos > 0 && map.get(word)) return map.get(word)\n    if (pos > 0 && set.has(word)) {\n      map.set(word, true)\n      return map.get(word)\n    }\n    for (let i = 1; i < word.length; i++) {\n      const left = word.slice(0, i)\n      const right = word.slice(i)\n      if (set.has(right) && dfs(left, set, map, pos + 1)) {\n        map.set(word, true)\n        return map.get(word)\n      }\n    }\n\n    map.set(word, false)\n    return false\n  }\n}\n\n// another\n\n/**\n * @param {string[]} words\n * @return {string[]}\n */\n\nconst findAllConcatenatedWordsInADict = function (words) {\n  const set = new Set(words)\n  const res = []\n  const map = new Map()\n\n  for(let word of words) {\n    if(dfs(word, 0)) res.push(word)\n  }\n  return res\n  function dfs(word, idx) {\n    if(map.has(word)) return map.get(word)\n    if(idx > 0 && set.has(word)) return true\n    let tmp = false\n    for(let i = 1; i < word.length; i++) {\n      const prefix = word.slice(0, i), suffix = word.slice(i)\n      if(set.has(prefix) && set.has(suffix)) {\n        tmp = true\n        break\n      }\n      if(set.has(prefix) && dfs(suffix, idx + 1)) {\n        tmp = true\n        break\n      }\n    }\n    \n    map.set(word, tmp)\n    return tmp\n  }\n}\n\n\n// another\n\n/**\n * @param {string[]} words\n * @return {string[]}\n */\nconst findAllConcatenatedWordsInADict = function(words) {\n  let res = []\n  if (words === null || words.length == 0) return res\n  let set = new Set(words)\n  for (let word of words) {\n    set.delete(word)\n    if (dfs(word, set, '')) res.push(word)\n    set.add(word)\n  }\n  return res\n}\n\nfunction dfs(word, set, prev) {\n  if (prev != '') set.add(prev)\n  if (set.has(word)) return true\n  for (let i = 1; i <= word.length; i++) {\n    const prefix = word.substring(0, i)\n    if (set.has(prefix) && dfs(word.substring(i), set, prev + prefix)) {\n      return true\n    }\n  }\n  return false\n}\n"
    }
  },
  {
    "name": "473-matchsticks-to-square",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nconst makesquare = function(nums) {\n  if (nums == null || nums.length < 4) return false\n  const sum = nums.reduce((ac, el) => ac + el, 0)\n  if (sum % 4 !== 0) return false\n  nums.sort((a, b) => b - a)\n  return dfs(nums, new Array(4).fill(0), 0, sum / 4)\n}\n\nfunction dfs(nums, arr, idx, target) {\n  if (idx === nums.length) {\n    return true\n  }\n  for (let i = 0; i < 4; i++) {\n    if (arr[i] + nums[idx] > target || (i > 0 && arr[i] === arr[i - 1]))\n      continue\n    arr[i] += nums[idx]\n    if (dfs(nums, arr, idx + 1, target)) return true\n    arr[i] -= nums[idx]\n  }\n  return false\n}\n\n\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\nconst makesquare = function(nums) {\n  if (nums.length == 0) return false\n  const edge = nums.reduce((accum, val) => accum + val) / 4\n  nums.sort((val1, val2) => val2 - val1)\n  if (edge !== Math.floor(edge)) return false\n  const findEdge = function(target) {\n    if (target <= 0) return target === 0\n    let newNums = []\n    while (nums.length) {\n      let item = nums.shift()\n      if (findEdge(target - item)) {\n        nums = newNums.concat(nums)\n        return true\n      }\n      newNums.push(item)\n    }\n    nums = newNums\n    return false\n  }\n  let count = 4\n  while (count) {\n    if (!findEdge(edge)) return false\n    count--\n  }\n  return true\n}\n\n"
    }
  },
  {
    "name": "474-ones-and-zeroes",
    "code": {
      "JS": "/**\n * @param {string[]} strs\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\n\nconst findMaxForm = function(strs, m, n) {\n  const memo = Array.from(new Array(m + 1), () => new Array(n + 1).fill(0))\n  let numZeroes\n  let numOnes\n\n  for (let s of strs) {\n    numZeroes = numOnes = 0\n    // count number of zeroes and ones in current string\n    for (let c of s) {\n      if (c === '0') numZeroes++\n      else if (c === '1') numOnes++\n    }\n    // memo[i][j] = the max number of strings that can be formed with i 0's and j 1's\n    // from the first few strings up to the current string s\n    // Catch: have to go from bottom right to top left\n    // Why? If a cell in the memo is updated(because s is selected),\n    // we should be adding 1 to memo[i][j] from the previous iteration (when we were not considering s)\n    // If we go from top left to bottom right, we would be using results from this iteration => overcounting\n    for (let i = m; i >= numZeroes; i--) {\n      for (let j = n; j >= numOnes; j--) {\n        memo[i][j] = Math.max(memo[i][j], memo[i - numZeroes][j - numOnes] + 1)\n      }\n    }\n  }\n  return memo[m][n]\n}\n"
    }
  },
  {
    "name": "475-heaters",
    "code": {
      "JS": "/**\n * @param {number[]} houses\n * @param {number[]} heaters\n * @return {number}\n */\nconst findRadius = function(houses, heaters) {\n  heaters.sort((a, b) => a - b)\n  return Math.max(...houses.map(h => findMinDistance(h, heaters)))\n}\n\nconst findMinDistance = (house, heaters) => {\n  let left = 0\n  let right = heaters.length - 1\n  while (left <= right) {\n    const mid = left + ((right - left) >> 1)\n    if (heaters[mid] <= house && house <= heaters[mid + 1]) {\n      return Math.min(house - heaters[mid], heaters[mid + 1] - house)\n    } else if (heaters[mid] <= house) {\n      left = mid + 1\n    } else {\n      right = mid - 1\n    }\n  }\n  if (left === 0) return heaters[0] - house\n  if (left === heaters.length) return house - heaters[heaters.length - 1]\n}\n\n// another\n\n/**\n * @param {number[]} houses\n * @param {number[]} heaters\n * @return {number}\n */\nconst findRadius = function(houses, heaters) {\n  let res = 0\n  let k = 0\n  houses = houses.sort((a, b) => a - b)\n  heaters = heaters.sort((a, b) => a - b)\n  for (let i = 0; i < houses.length; i++) {\n    const curr = houses[i]\n    while (\n      k < heaters.length &&\n      Math.abs(heaters[k + 1] - curr) <= Math.abs(heaters[k] - curr)\n    ) {\n      k++\n    }\n    res = Math.max(res, Math.abs(heaters[k] - curr))\n  }\n  return res\n}\n\n// another\n\n/**\n * @param {number[]} houses\n * @param {number[]} heaters\n * @return {number}\n */\nconst findRadius = function(houses, heaters) {\n  heaters.sort((a, b) => a - b)\n  houses.sort((a, b) => a - b)\n  let res = 0, i = 0\n  for(let h of houses) {\n    while(i < heaters.length - 1 && heaters[i] + heaters[i + 1] <= h * 2) i++\n    res = Math.max(res, Math.abs(heaters[i] - h))\n  }\n  return res\n}\n\n"
    }
  },
  {
    "name": "476-number-complement",
    "code": {
      "JS": "/**\n * @param {number} num\n * @return {number}\n */\nconst findComplement = function(num) {\n  const toBin = num => (num >>> 0).toString(2)\n  const flip = str => {\n    let res = ''\n    for(let c of str) res += (c === '1' ? '0' : '1')\n    return res\n  }\n  return parseInt(flip(toBin(num)), 2)\n};\n"
    }
  },
  {
    "name": "477-total-hamming-distance",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nconst totalHammingDistance = function(nums) {\r\n  let total = 0,\r\n    n = nums.length;\r\n  for (let j = 0; j < 32; j++) {\r\n    let bitCount = 0;\r\n    for (let i = 0; i < n; i++) bitCount += (nums[i] >> j) & 1;\r\n    total += bitCount * (n - bitCount);\r\n  }\r\n  return total;\r\n};\r\n"
    }
  },
  {
    "name": "478-generate-random-point-in-a-circle",
    "code": {
      "JS": "/**\n * @param {number} radius\n * @param {number} x_center\n * @param {number} y_center\n */\nconst Solution = function(radius, x_center, y_center) {\n  this.radius = radius\n  this.x_center = x_center\n  this.y_center = y_center\n}\n\n/**\n * @return {number[]}\n */\nSolution.prototype.randPoint = function() {\n  let len = Math.sqrt(Math.random()) * this.radius\n  let deg = Math.random() * 2 * Math.PI\n  let x = this.x_center + len * Math.cos(deg)\n  let y = this.y_center + len * Math.sin(deg)\n  return [x, y]\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * var obj = new Solution(radius, x_center, y_center)\n * var param_1 = obj.randPoint()\n */\n"
    }
  },
  {
    "name": "479-largest-palindrome-product",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nfunction largestPalindrome(n) {\n  if(n === 1) return 9\n  let max = BigInt(10 ** n - 1), min = max / 10n + 1n\n  for(let h = max; h >= min; h--) {\n    let left = h, right = 0n\n    for(let i = h; i !== 0n; ) {\n      right = right * 10n + i % 10n\n      i = i / 10n\n      left *= 10n\n    }\n    let pal = left + right\n    for(let i = max; i >= min; i--) {\n      let j = pal / i\n      if(j > i) break\n      if(pal % i === 0n) return pal % 1337n\n    }\n  }\n}\n\n// another\n\n/**\n * @param {number} n\n * @return {number}\n */\nconst largestPalindrome = function (n) {\n  if (n === 1) return 9\n  for (let i = 2, limit = 9 * 10 ** (n - 1); i < limit; i++) {\n    let left = 10 ** n - i\n    let right = +('' + left).split('').reverse().join('')\n    if (i ** 2 - 4 * right < 0) continue\n    const tmp = (i ** 2 - 4 * right) ** 0.5\n    if (tmp === Math.floor(tmp)) {\n      return (\n        (BigInt(right) + 10n ** BigInt(n) * (10n ** BigInt(n) - BigInt(i))) %\n        1337n\n      )\n    }\n  }\n}\n\n// another\n\n/**\n * @param {number} n\n * @return {number}\n */\nconst largestPalindrome = function(n) {\n  if (n === 1) {\n    return 9\n  } else if (n === 8) {\n    return 475\n  }\n  let max = Math.pow(10, n)\n  let min = Math.pow(10, n - 1)\n  let ret = 0\n\n  for (let i = max - 1; i > 0; i--) {\n    ret = i * max + getReverse(i)\n    for (let factor = ~~Math.sqrt(ret); factor < max; factor++) {\n      if (ret % factor == 0 && ret / factor < max) {\n        return ret % 1337\n      }\n    }\n  }\n  return -1\n}\n\nfunction getReverse(n) {\n  let result = 0\n  let num = n\n  while (num > 0) {\n    result = result * 10 + (num % 10)\n    num = ~~(num / 10)\n  }\n  return result\n}\n"
    }
  },
  {
    "name": "48-rotate-image",
    "code": {
      "JS": "/**\n * @param {number[][]} matrix\n * @return {void} Do not return anything, modify matrix in-place instead.\n */\nconst rotate = function(matrix) {\n  let s = 0,\n    e = matrix.length - 1\n  while (s < e) {\n    let temp = matrix[s]\n    matrix[s] = matrix[e]\n    matrix[e] = temp\n    s++\n    e--\n  }\n\n  for (let i = 0; i < matrix.length; i++) {\n    for (let j = i + 1; j < matrix[i].length; j++) {\n      let temp = matrix[i][j]\n      matrix[i][j] = matrix[j][i]\n      matrix[j][i] = temp\n    }\n  }\n}\n\n// another\n\n/**\n * @param {number[][]} matrix\n * @return {void} Do not return anything, modify matrix in-place instead.\n */\nconst rotate = function (matrix) {\n  matrix.reverse()\n  for (let i = 0; i < matrix.length; ++i) {\n    for (let j = i + 1; j < matrix[i].length; ++j) swap(matrix, i, j)\n  }\n}\n\nfunction swap(matrix, i, j) {\n  const tmp = matrix[j][i]\n  matrix[j][i] = matrix[i][j]\n  matrix[i][j] = tmp\n}\n\n// another\n\n/**\n * @param {number[][]} matrix\n * @return {void} Do not return anything, modify matrix in-place instead.\n */\nconst rotate = function (matrix) {\n  matrix.reverse()\n  for (let i = 0; i < matrix.length; ++i) {\n    for (let j = matrix[i].length - 1; j > i; j--) swap(matrix, i, j)\n  }\n}\n\nfunction swap(matrix, i, j) {\n  const tmp = matrix[j][i]\n  matrix[j][i] = matrix[i][j]\n  matrix[i][j] = tmp\n}\n/*\n1 2 3      7 8 9     7 4 1\n4 5 6 ---> 4 5 6 --->8 5 2\n7 8 9      1 2 3     9 6 3\n*/\n"
    }
  },
  {
    "name": "480-sliding-window-median",
    "code": {
      "JS": "/*\n * @lc app=leetcode id=480 lang=javascript\n *\n * [480] Sliding Window Median\n */\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nconst medianSlidingWindow = function(nums, k) {\n  const window = nums.slice(0, k).sort((x, y) => x - y)\n  const resultLen = nums.length - k + 1\n  nums.push(0)\n\n  function insert(arr, val) {\n    let i = 0\n    while (i < arr.length && arr[i] < val) {\n      i++\n    }\n    arr.splice(i, 0, val)\n  }\n\n  const medians = []\n  const rightIdx = (k / 2) >>> 0\n  const leftIdx = k + ~rightIdx\n  for (let i = 0; i < resultLen; i++) {\n    medians.push((window[leftIdx] + window[rightIdx]) / 2)\n    window.splice(window.indexOf(nums[i]), 1)\n    insert(window, nums[k + i])\n  }\n  return medians\n}\n\n// another\n\nconst medianSlidingWindow = function(nums, k) {\n  let pq = []\n  for (let i = 0; i < k; i++) {\n    insert(nums[i])\n  }\n  let res = []\n  res.push(findMid())\n  for (let i = k; i < nums.length; i++) {\n    remove(nums[i - k])\n    insert(nums[i])\n    res.push(findMid())\n  }\n  return res\n  function findMid() {\n    let mid = (pq.length - 1) / 2\n    return (pq[Math.ceil(mid)] + pq[Math.floor(mid)]) / 2\n  }\n  function insert(n) {\n    if (pq.length === 0 || pq[pq.length - 1] <= n) {\n      pq.push(n)\n    } else {\n      let idx = bsEnd(pq, n)\n      pq.splice(idx, 0, n)\n    }\n  }\n  function bsEnd(arr, n) {\n    let lo = 0,\n      hi = arr.length - 1\n    while (lo < hi) {\n      let mid = Math.floor((lo + hi) / 2)\n      if (arr[mid] < n) lo = mid + 1\n      else hi = mid\n    }\n    return hi\n  }\n  function remove(n) {\n    let idx = bsEnd(pq, n)\n    pq.splice(idx, 1)\n  }\n}\n"
    }
  },
  {
    "name": "481-magical-string",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst magicalString = function(n) {\n  const queue = []\n  let one = true\n  let count1 = 0\n  while (n-- > 0) {\n    queue.shift()\n    let c = one ? 1 : 2\n    one = !one\n    queue.push(c)\n    count1 += 2 - c\n    if (queue[0] === 2 && n-- > 0) {\n      queue.push(c)\n      count1 += 2 - c\n    }\n  }\n  return count1\n}\n"
    }
  },
  {
    "name": "482-license-key-formatting",
    "code": {
      "JS": "/**\n * @param {string} S\n * @param {number} K\n * @return {string}\n */\nconst licenseKeyFormatting = function(S, K) {\n  if (S == null || S === \"\") return \"\";\n  const newStr = S.replace(/-/g, \"\").toUpperCase();\n  const arr = newStr.split(\"\");\n  for (let i = arr.length - 1 - K; i >= 0; i -= K) {\n    arr[i] = arr[i] + \"-\";\n  }\n  return arr.join(\"\");\n};\n"
    }
  },
  {
    "name": "483-smallest-good-base",
    "code": {
      "JS": "/**\n * @param {string} n\n * @return {string}\n */\nconst smallestGoodBase = function(n) {\n  const N = BigInt(n),\n    bigint2 = BigInt(2),\n    bigint1 = BigInt(1),\n    bigint0 = BigInt(0)\n  let maxLen = countLength(N, bigint2)\n  for (let length = maxLen; length > 0; length--) {\n    let [found, base] = findMatchInHalf(length)\n    if (found) return '' + base\n  }\n  return '' + (N - 1)\n  function findMatchInHalf(length, smaller = bigint2, bigger = N) {\n    if (smaller > bigger) return [false]\n    if (smaller === bigger) {\n      return [valueOf1s(smaller, length) === N, smaller]\n    }\n    let mid = (smaller + bigger) / bigint2\n    let val = valueOf1s(mid, length)\n    if (val === N) return [true, mid]\n    if (val > N) return findMatchInHalf(length, smaller, mid - bigint1)\n    return findMatchInHalf(length, mid + bigint1, bigger)\n  }\n  function valueOf1s(base, lengthOf1s) {\n    let t = bigint1\n    for (let i = 1; i < lengthOf1s; i++) {\n      t *= base\n      t += bigint1\n    }\n    return t\n  }\n  function countLength(N, base) {\n    let t = N,\n      len = 0\n    while (t > bigint0) {\n      t /= base\n      len++\n    }\n    return len\n  }\n}\n"
    }
  },
  {
    "name": "484-find-permutation",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number[]}\n */\nconst findPermutation = function(s) {\n  const n = s.length\n  const arr = Array.from({ length: n + 1 }, (el, idx) => idx + 1)\n  for(let h = 0; h < n; h++) {\n    if(s.charAt(h) === 'D') {\n      const l = h\n      while(h < n && s.charAt(h) === 'D') h++\n      reverse(arr, l, h)\n    }\n  }\n  return arr\n};\n\nfunction reverse(arr, l, h) {\n  while(l < h) {\n    arr[l] ^= arr[h]\n    arr[h] ^= arr[l]\n    arr[l] ^= arr[h]\n    l++, h--\n  }\n}\n"
    }
  },
  {
    "name": "485-max-consecutive-ones",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst findMaxConsecutiveOnes = function(nums) {\n  let sum = 0,\n    max = 0;\n\n  for (let i = 0; i < nums.length; i++) {\n    let temp = sum;\n    sum += nums[i];\n    if (temp === sum || i === nums.length - 1) {\n      max = Math.max(sum, max);\n      sum = 0;\n    }\n  }\n\n  return max;\n};\n"
    }
  },
  {
    "name": "486-predict-the-winner",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n * @return {boolean}\r\n */\r\nconst PredictTheWinner = function(nums) {\r\n  // The dp[i][j] saves how much more scores that the first-in-action player will get from i to j than the second player.\r\n  const dp = [];\r\n  for (let i = 0; i <= nums.length; i++) {\r\n    dp.push(Array(nums.length).fill(0));\r\n  }\r\n  for (let s = nums.length - 1; s >= 0; s--) {\r\n    dp[s][s] = nums[s];\r\n    for (let e = s + 1; e < nums.length; e++) {\r\n      let a = nums[s] - dp[s + 1][e];\r\n      let b = nums[e] - dp[s][e - 1];\r\n      dp[s][e] = Math.max(a, b);\r\n    }\r\n  }\r\n  return dp[0][nums.length - 1] >= 0;\r\n};\r\n\r\nconsole.log(PredictTheWinner([1, 5, 233, 7]));\r\nconsole.log(PredictTheWinner([3, 5, 3]));\r\n"
    }
  },
  {
    "name": "487-max-consecutive-ones-ii",
    "code": {
      "JS": "/**\n\nGiven a binary array, find the maximum number of consecutive 1s in this array if you can flip at most one 0.\n\nExample 1:\nInput: [1,0,1,1,0]\nOutput: 4\nExplanation: Flip the first zero will get the the maximum number of consecutive 1s.\n    After flipping, the maximum number of consecutive 1s is 4.\nNote:\n\nThe input array will only contain 0 and 1.\nThe length of input array is a positive integer and will not exceed 10,000\nFollow up:\nWhat if the input numbers come in one by one as an infinite stream?\nIn other words, you can't store all numbers coming from the stream as it's too large to hold in memory.\nCould you solve it efficiently?\n\n*/\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst findMaxConsecutiveOnes = function(nums) {\n  let max = 0,\n    k = 1\n  const zeroIndex = []\n  for (let l = 0, h = 0; h < nums.length; h++) {\n    if (nums[h] === 0) zeroIndex.push(h)\n    if (zeroIndex.length > k) l = zeroIndex.shift() + 1\n    max = Math.max(max, h - l + 1)\n  }\n  return max\n}\n"
    }
  },
  {
    "name": "488-zuma-game",
    "code": {
      "JS": "/**\n\nThink about Zuma Game. You have a row of balls on the table, colored red(R), yellow(Y), blue(B), green(G), and white(W).\nYou also have several balls in your hand.\n\nEach time, you may choose a ball in your hand, and insert it into the row (including the leftmost place and rightmost place).\nThen, if there is a group of 3 or more balls in the same color touching, remove these balls.\nKeep doing this until no more balls can be removed.\n\nFind the minimal balls you have to insert to remove all the balls on the table.\nIf you cannot remove all the balls, output -1.\n\nExample 1:\n\nInput: board = \"WRRBBW\", hand = \"RB\"\nOutput: -1\nExplanation: WRRBBW -> WRR[R]BBW -> WBBW -> WBB[B]W -> WW\nExample 2:\n\nInput: board = \"WWRRBBWW\", hand = \"WRBRW\"\nOutput: 2\nExplanation: WWRRBBWW -> WWRR[R]BBWW -> WWBBWW -> WWBB[B]WW -> WWWW -> empty\nExample 3:\n\nInput: board = \"G\", hand = \"GGGGG\"\nOutput: 2\nExplanation: G -> G[G] -> GG[G] -> empty \nExample 4:\n\nInput: board = \"RBYYBBRRB\", hand = \"YRBGB\"\nOutput: 3\nExplanation: RBYYBBRRB -> RBYY[Y]BBRRB -> RBBBRRB -> RRRB -> B -> B[B] -> BB[B] -> empty \n \n\nConstraints:\n\nYou may assume that the initial row of balls on the table won’t have any 3 or more consecutive balls with the same color.\nThe number of balls on the table won't exceed 16, and the string represents these balls is called \"board\" in the input.\nThe number of balls in your hand won't exceed 5, and the string represents these balls is called \"hand\" in the input.\nBoth input strings will be non-empty and only contain characters 'R','Y','B','G','W'.\n\n*/\n\n/**\n * @param {string} board\n * @param {string} hand\n * @return {number}\n */\nconst findMinStep = function(board, hand) {\n  const map = {}\n  for (let c of hand) map[c] = (map[c] || 0) + 1\n  const res = helper(board, map)\n  return res === Number.MAX_VALUE ? -1 : res\n}\n\nfunction helper(s, m) {\n  const str = reduce(s)\n  if (str.length === 0) return 0\n  let res = Number.MAX_VALUE\n  let i = 0\n  while (i < str.length) {\n    const beg = i\n    while (i < str.length && str[i] === str[beg]) {\n      i++\n    }\n    if (m[str[beg]] >= 3 - (i - beg)) {\n      const dval = 3 - i + beg\n      m[str[beg]] -= dval\n      const tmp = helper(s.slice(0, beg) + s.slice(i), m)\n      m[str[beg]] += dval\n      if (tmp !== Number.MAX_VALUE) res = res < tmp + dval ? res : tmp + dval\n    }\n  }\n  return res\n}\nfunction reduce(str) {\n  let res = ''\n  let i = 0\n  while (i < str.length) {\n    const beg = i\n    while (i < str.length && str[beg] === str[i]) {\n      i++\n    }\n    if (i - beg >= 3) {\n      return reduce(str.slice(0, beg) + str.slice(i))\n    }\n  }\n  return str\n}\n"
    }
  },
  {
    "name": "489-robot-room-cleaner",
    "code": {
      "JS": "/**\n * // This is the robot's control interface.\n * // You should not implement it, or speculate about its implementation\n * function Robot() {\n *\n *     // Returns true if the cell in front is open and robot moves into the cell.\n *     // Returns false if the cell in front is blocked and robot stays in the current cell.\n *     @return {boolean}\n *     this.move = function() {\n *         ...\n *     };\n *\n *     // Robot will stay in the same cell after calling turnLeft/turnRight.\n *     // Each turn will be 90 degrees.\n *     @return {void}\n *     this.turnLeft = function() {\n *         ...\n *     };\n *\n *     // Robot will stay in the same cell after calling turnLeft/turnRight.\n *     // Each turn will be 90 degrees.\n *     @return {void}\n *     this.turnRight = function() {\n *         ...\n *     };\n *\n *     // Clean the current cell.\n *     @return {void}\n *     this.clean = function() {\n *         ...\n *     };\n * };\n */\n/**\n * @param {Robot} robot\n * @return {void}\n */\nconst cleanRoom = function(robot) {\n  const visited = new Set()\n  const shift = [\n    [-1, 0],\n    [0, 1],\n    [1, 0],\n    [0, -1]\n  ]\n  dfs(0, 0, 0)\n  function dfs(r, c, dir) {\n    visited.add(r + ',' + c)\n    robot.clean()\n    for (let i = 0; i < 4; i++) {\n      const newDir = (dir + i) % 4\n      const x = shift[newDir][0] + r\n      const y = shift[newDir][1] + c\n      if (!visited.has(x + ',' + y) && robot.move()) {\n        dfs(x, y, newDir)\n        robot.turnRight()\n        robot.turnRight()\n        robot.move()\n        robot.turnRight()\n        robot.turnRight()\n      }\n      robot.turnRight()\n    }\n  }\n}\n\n// another\n\n/**\n * @param {Robot} robot\n * @return {void}\n */\nconst cleanRoom = function(robot) {\n  const dirs = [\n    [-1, 0],\n    [0, 1],\n    [1, 0],\n    [0, -1]\n  ]\n  const visited = new Set()\n  clean(0, 0, 0)\n  function clean( x, y, curDirection) {\n    robot.clean()\n    visited.add(`${x},${y}`)\n    for(let i = curDirection; i < curDirection + 4; i++) {\n      const nx = dirs[i % 4][0] + x\n      const ny = dirs[i % 4][1] + y\n      if(!visited.has(`${nx},${ny}`) && robot.move()) {\n        clean(nx, ny, i % 4)\n      }\n      robot.turnRight()\n    }\n    robot.turnRight()\n    robot.turnRight()\n    robot.move()\n    robot.turnRight()\n    robot.turnRight()\n    \n  }\n};\n\n"
    }
  },
  {
    "name": "49-group-anagrams",
    "code": {
      "JS": "/**\r\n * @param {string[]} strs\r\n * @return {string[][]}\r\n */\r\nconst groupAnagrams = (strs) => {\r\n  const resp = new Array(),\r\n    termsGrouped = new Map()\r\n  strs.forEach((term) => {\r\n    const hashed = hash(term)\r\n    if (!termsGrouped.has(hashed)) termsGrouped.set(hashed, new Array())\r\n    termsGrouped.get(hashed).push(term)\r\n  })\r\n  termsGrouped.forEach((terms) => {\r\n    resp.push(terms)\r\n  })\r\n  return resp\r\n}\r\n\r\nconst hash = (term) => {\r\n  const arr = Array(26).fill(0)\r\n  const a = 'a'.charCodeAt(0)\r\n  for(let i = 0, len = term.length; i < len; i++) {\r\n    arr[term[i].charCodeAt(0) - a]++\r\n  }\r\n  return arr.join('-')\r\n}\r\n\r\n// another\r\n\r\n/**\r\n * @param {string[]} strs\r\n * @return {string[][]}\r\n */\r\nconst groupAnagrams = function(strs) {\r\n  if (strs.length === 0) {\r\n    return [];\r\n  }\r\n  const ans = [];\r\n  const hash = {};\r\n  for (let el of strs) {\r\n    let sel = el\r\n      .split(\"\")\r\n      .sort()\r\n      .join(\"\");\r\n    if (hash.hasOwnProperty(sel)) {\r\n      hash[sel].push(el);\r\n    } else {\r\n      hash[sel] = [el];\r\n    }\r\n  }\r\n  return Object.values(hash);\r\n};\r\n"
    }
  },
  {
    "name": "490-the-maze",
    "code": {
      "JS": "/**\n\nThere is a ball in a maze with empty spaces and walls.\nThe ball can go through empty spaces by rolling up, down, left or right,\nbut it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction.\nGiven the ball's start position, the destination and the maze, determine whether the ball could stop at the destination.\n\nThe maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space.\nYou may assume that the borders of the maze are all walls.\nThe start and destination coordinates are represented by row and column indexes.\n\nExample 1:\n\nInput 1: a maze represented by a 2D array\n\n0 0 1 0 0\n0 0 0 0 0\n0 0 0 1 0\n1 1 0 1 1\n0 0 0 0 0\n\nInput 2: start coordinate (rowStart, colStart) = (0, 4)\nInput 3: destination coordinate (rowDest, colDest) = (4, 4)\n\nOutput: true\n\nExplanation: One possible way is : left -> down -> left -> down -> right -> down -> right.\n\nExample 2:\n\nInput 1: a maze represented by a 2D array\n\n0 0 1 0 0\n0 0 0 0 0\n0 0 0 1 0\n1 1 0 1 1\n0 0 0 0 0\n\nInput 2: start coordinate (rowStart, colStart) = (0, 4)\nInput 3: destination coordinate (rowDest, colDest) = (3, 2)\n\nOutput: false\n\nExplanation: There is no way for the ball to stop at the destination.\n\nNote:\n\nThere is only one ball and one destination in the maze.\nBoth the ball and the destination exist on an empty space, and they will not be at the same position initially.\nThe given maze does not contain border (like the red rectangle in the example pictures),\nbut you could assume the border of the maze are all walls.\nThe maze contains at least 2 empty spaces, and both the width and height of the maze won't exceed 100.\n\n*/\n\n/**\n * @param {number[][]} maze\n * @param {number[]} start\n * @param {number[]} destination\n * @return {boolean}\n */\nconst hasPath = function(maze, start, destination) {\n  const m = maze.length\n  const n = maze[0].length\n  const queue = []\n  const visited = Array.from({ length: m }, () => new Array(n).fill(false))\n  queue.push(start)\n  const dirs = [\n    [-1, 0],\n    [0, -1],\n    [0, 1],\n    [1, 0]\n  ]\n  while (queue.length) {\n    const cur = queue.shift()\n    if (cur[0] === destination[0] && cur[1] === destination[1]) return true\n    if (visited[cur[0]][cur[1]]) continue\n    visited[cur[0]][cur[1]] = true\n    for (let dir of dirs) {\n      let x = cur[0],\n        y = cur[1]\n      while (x >= 0 && x < m && y >= 0 && y < n && maze[x][y] === 0) {\n        x += dir[0]\n        y += dir[1]\n      }\n      x -= dir[0]\n      y -= dir[1]\n      queue.push([x, y])\n    }\n  }\n  return false\n}\n\n// another\n\n/**\n * @param {number[][]} maze\n * @param {number[]} start\n * @param {number[]} destination\n * @return {boolean}\n */\nconst hasPath = function(maze, start, destination) {\n  const visited = Array.from({ length: maze.length }, () =>\n    new Array(maze[0].length).fill(false)\n  )\n  const dirs = [\n    [-1, 0],\n    [0, -1],\n    [0, 1],\n    [1, 0]\n  ]\n  return dfs(maze, start, destination, visited, dirs)\n}\n\nfunction dfs(maze, start, destination, visited, dirs) {\n  if (visited[start[0]][start[1]]) return false\n  if (start[0] === destination[0] && start[1] === destination[1]) return true\n  visited[start[0]][start[1]] = true\n  for (let i = 0; i < dirs.length; i++) {\n    const d = dirs[i]\n    let row = start[0]\n    let col = start[1]\n    while (isValid(maze, row + d[0], col + d[1])) {\n      row += d[0]\n      col += d[1]\n    }\n    if (dfs(maze, [row, col], destination, visited, dirs)) return true\n  }\n  return false\n}\n\nfunction isValid(maze, row, col) {\n  return (\n    row >= 0 &&\n    row < maze.length &&\n    col >= 0 &&\n    col < maze[0].length &&\n    maze[row][col] !== 1\n  )\n}\n"
    }
  },
  {
    "name": "491-increasing-subsequences",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nfunction findSubsequences(nums) {\n  const res = []\n  helper([], 0, nums, res)\n  return res\n}\n\nfunction helper(list, index, nums, res) {\n  if (list.length > 1) {\n    res.push(Array.prototype.slice.call(list, 0))\n  }\n  const used = []\n  for (let i = index; i < nums.length; i++) {\n    if (used.indexOf(nums[i]) !== -1) {\n      continue\n    }\n    if (list.length === 0 || nums[i] >= list[list.length - 1]) {\n      used.push(nums[i])\n      list.push(nums[i])\n      helper(list, i + 1, nums, res)\n      list.pop()\n    }\n  }\n}\n"
    }
  },
  {
    "name": "492-construct-the-rectangle",
    "code": {
      "JS": "/**\n * @param {number} area\n * @return {number[]}\n */\nconst constructRectangle = function(area) {\n  let w = Math.sqrt(area) >> 0;\n  while (area % w != 0) w--;\n  return [(area / w) >> 0, w];\n};\n"
    }
  },
  {
    "name": "493-reverse-pairs",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst reversePairs = function(nums) {\n  return mergeSort(nums, 0, nums.length - 1);\n};\n\nfunction mergeSort(nums, s, e) {\n  if (s >= e) return 0;\n  let mid = s + Math.floor((e - s) / 2);\n  let cnt = mergeSort(nums, s, mid) + mergeSort(nums, mid + 1, e);\n  for (let i = s, j = mid + 1; i <= mid; i++) {\n    while (j <= e && nums[i] / 2.0 > nums[j]) j++;\n    cnt += j - (mid + 1);\n  }\n  sortSubArr(nums, s, e + 1);\n  return cnt;\n}\n\nfunction sortSubArr(arr, s, e) {\n  const tmp = arr.slice(s, e);\n  tmp.sort((a, b) => a - b);\n  arr.splice(s, e - s, ...tmp);\n}\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nfunction merge(A, start, mid, end) {\n  let n1 = mid - start + 1\n  let n2 = end - mid\n  const L = new Array(n1).fill(0)\n  const R = new Array(n2).fill(0)\n\n  for (let i = 0; i < n1; i++) L[i] = A[start + i]\n  for (let j = 0; j < n2; j++) R[j] = A[mid + 1 + j]\n  let i = 0,\n    j = 0\n  for (let k = start; k <= end; k++) {\n    if (j >= n2 || (i < n1 && L[i] <= R[j])) A[k] = L[i++]\n    else A[k] = R[j++]\n  }\n}\n\nfunction mergesort_and_count(A, start, end) {\n  if (start < end) {\n    let mid = start + ((end - start) >> 1)\n    let count =\n      mergesort_and_count(A, start, mid) + mergesort_and_count(A, mid + 1, end)\n    let j = mid + 1\n    for (let i = start; i <= mid; i++) {\n      while (j <= end && A[i] > A[j] * 2) j++\n      count += j - (mid + 1)\n    }\n    merge(A, start, mid, end)\n    return count\n  } else return 0\n}\n\nfunction reversePairs(nums) {\n  return mergesort_and_count(nums, 0, nums.length - 1)\n}\n"
    }
  },
  {
    "name": "494-target-sum",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n * @param {number} S\r\n * @return {number}\r\n */\r\nconst findTargetSumWays = function(nums, s) {\r\n  const sum = nums.reduce((p, n) => p + n, 0);\r\n  return sum < s || (s + sum) % 2 > 0 ? 0 : subsetSum(nums, (s + sum) >>> 1);\r\n};\r\n\r\nfunction subsetSum(nums, s) {\r\n  const dp = Array(s + 1).fill(0);\r\n  dp[0] = 1;\r\n  for (let n of nums) {\r\n    for (let i = s; i >= n; i--) dp[i] += dp[i - n];\r\n  }\r\n  return dp[s];\r\n}\r\n"
    }
  },
  {
    "name": "495-teemo-attacking",
    "code": {
      "JS": "/**\n * @param {number[]} timeSeries\n * @param {number} duration\n * @return {number}\n */\nconst findPoisonedDuration = function(timeSeries, duration) {\n  if (timeSeries == null || timeSeries.length === 0) return 0\n  let res = 0\n  for (let i = 1, len = timeSeries.length; i < len; i++) {\n    const tmp =\n      timeSeries[i - 1] + duration > timeSeries[i]\n        ? timeSeries[i] - timeSeries[i - 1]\n        : duration\n    res += tmp\n  }\n  return res + duration\n}\n"
    }
  },
  {
    "name": "496-next-greater-element-I",
    "code": {
      "JS": "/**\n * @param {number[]} findNums\n * @param {number[]} nums\n * @return {number[]}\n */\nconst nextGreaterElement = function(findNums, nums) {\n  const map = {};\n  const stack = [];\n  for (let num of nums) {\n    while (stack.length && stack[stack.length - 1] < num) {\n      let tmp = stack.pop();\n      map[tmp] = num;\n    }\n    stack.push(num);\n  }\n  for (let i = 0; i < findNums.length; i++) {\n    findNums[i] = map[findNums[i]] == null ? -1 : map[findNums[i]];\n  }\n\n  return findNums;\n};\n\nconsole.log(nextGreaterElement([4, 1, 2], [1, 3, 4, 2]));\nconsole.log(nextGreaterElement([2, 4], [1, 2, 3, 4]));\nconsole.log(nextGreaterElement([1, 2, 3], [9, 8, 7, 3, 2, 1, 6]));\n"
    }
  },
  {
    "name": "497-random-point-in-non-overlapping-rectangles",
    "code": {
      "JS": "/**\n * @param {number[][]} rects\n */\nconst Solution = function(rects) {\n  this.rects = rects\n  this.areas = rects.map(([x1, y1, x2, y2]) => (x2 - x1 + 1) * (y2 - y1 + 1))\n}\n\n/**\n * @return {number[]}\n */\nSolution.prototype.pick = function() {\n  const { rects, areas } = this\n  let areaSum = 0\n  let selected\n  for (let i = 0; i < rects.length; i++) {\n    const area = areas[i]\n    areaSum += area\n    const p = area / areaSum\n    if (Math.random() < p) {\n      selected = rects[i]\n    }\n  }\n  const [x1, y1, x2, y2] = selected\n  return [\n    ((Math.random() * (x2 - x1 + 1)) | 0) + x1,\n    ((Math.random() * (y2 - y1 + 1)) | 0) + y1\n  ]\n}\n/**\n * Your Solution object will be instantiated and called as such:\n * var obj = new Solution(rects)\n * var param_1 = obj.pick()\n */\n\n// another\n\n/**\n * @param {number[][]} rects\n */\nconst Solution = function(rects) {\n  const xywhs = []\n  const acc_sums = [0]\n  let sum = 0\n  for (const [x, y, x2, y2] of rects) {\n    const w = x2 - x + 1\n    const h = y2 - y + 1\n    xywhs.push({ x, y, w, h })\n    sum += w * h\n    acc_sums.push(sum)\n  }\n  this.xywhs = xywhs\n  this.acc_sums = acc_sums\n}\n\n/**\n * @return {number[]}\n */\nSolution.prototype.pick = function() {\n  const picked = Math.floor(\n    Math.random() * this.acc_sums[this.acc_sums.length - 1]\n  )\n  let i = 0\n  for (; i < this.acc_sums.length - 2; i++) {\n    if (picked >= this.acc_sums[i] && picked < this.acc_sums[i + 1]) {\n      break\n    }\n  }\n  const { x, y, w, h } = this.xywhs[i]\n  return [x + Math.floor(Math.random() * w), y + Math.floor(Math.random() * h)]\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * var obj = new Solution(rects)\n * var param_1 = obj.pick()\n */\n\n"
    }
  },
  {
    "name": "498-diagonal-traverse",
    "code": {
      "JS": "/**\n * @param {number[][]} matrix\n * @return {number[]}\n */\nconst findDiagonalOrder = function(matrix) {\n  if (!matrix.length || !matrix[0].length) {\n    return []\n  }\n  const m = matrix.length\n  const n = matrix[0].length\n  const output = []\n  for (let sum = 0; sum <= m + n - 2; sum++) {\n    for (\n      let i = Math.min(m - 1, sum);\n      sum % 2 === 0 && isValid(i, sum - i, m, n);\n      i--\n    ) {\n      const j = sum - i\n      output.push(matrix[i][j])\n    }\n    for (\n      let j = Math.min(n - 1, sum);\n      sum % 2 === 1 && isValid(sum - j, j, m, n);\n      j--\n    ) {\n      const i = sum - j\n      output.push(matrix[i][j])\n    }\n  }\n  return output\n}\n\nfunction isValid(i, j, m, n) {\n  if (i < 0 || i >= m || j < 0 || j >= n) {\n    return false\n  }\n  return true\n}\n\n// another\n\n/**\n * @param {number[][]} matrix\n * @return {number[]}\n */\nconst findDiagonalOrder = function(matrix) {\n  if (matrix.length == 0) return []\n  let r = 0,\n    c = 0,\n    m = matrix.length,\n    n = matrix[0].length,\n    arr = new Array(m * n)\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = matrix[r][c]\n    if ((r + c) % 2 === 0) {\n      // moving up\n      if (c === n - 1) {\n        r++\n      } else if (r === 0) {\n        c++\n      } else {\n        r--\n        c++\n      }\n    } else {\n      // moving down\n      if (r === m - 1) {\n        c++\n      } else if (c === 0) {\n        r++\n      } else {\n        r++\n        c--\n      }\n    }\n  }\n  return arr\n}\n\n\n\n"
    }
  },
  {
    "name": "499-the-maze-iii",
    "code": {
      "JS": "/**\n\nThere is a ball in a maze with empty spaces and walls.\nThe ball can go through empty spaces by rolling up (u), down (d), left (l) or right (r),\nbut it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction.\nThere is also a hole in this maze. The ball will drop into the hole if it rolls on to the hole.\n\nGiven the ball position, the hole position and the maze,\nfind out how the ball could drop into the hole by moving the shortest distance.\nThe distance is defined by the number of empty spaces traveled by the ball from\nthe start position (excluded) to the hole (included).\nOutput the moving directions by using 'u', 'd', 'l' and 'r'.\nSince there could be several different shortest ways, you should output the lexicographically smallest way.\nIf the ball cannot reach the hole, output \"impossible\".\n\nThe maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space.\nYou may assume that the borders of the maze are all walls.\nThe ball and the hole coordinates are represented by row and column indexes.\n\nExample 1:\n\nInput 1: a maze represented by a 2D array\n\n0 0 0 0 0\n1 1 0 0 1\n0 0 0 0 0\n0 1 0 0 1\n0 1 0 0 0\n\nInput 2: ball coordinate (rowBall, colBall) = (4, 3)\nInput 3: hole coordinate (rowHole, colHole) = (0, 1)\n\nOutput: \"lul\"\n\nExplanation: There are two shortest ways for the ball to drop into the hole.\nThe first way is left -> up -> left, represented by \"lul\".\nThe second way is up -> left, represented by 'ul'.\nBoth ways have shortest distance 6, but the first way is lexicographically smaller because 'l' < 'u'. So the output is \"lul\".\n\nExample 2:\n\nInput 1: a maze represented by a 2D array\n\n0 0 0 0 0\n1 1 0 0 1\n0 0 0 0 0\n0 1 0 0 1\n0 1 0 0 0\n\nInput 2: ball coordinate (rowBall, colBall) = (4, 3)\nInput 3: hole coordinate (rowHole, colHole) = (3, 0)\n\nOutput: \"impossible\"\n\nNote:\n\nThere is only one ball and one hole in the maze.\nBoth the ball and hole exist on an empty space, and they will not be at the same position initially.\nThe given maze does not contain border (like the red rectangle in the example pictures),\nbut you could assume the border of the maze are all walls.\nThe maze contains at least 2 empty spaces, and the width and the height of the maze won't exceed 30.\n\n*/\n\n/**\n * @param {number[][]} maze\n * @param {number[]} ball\n * @param {number[]} hole\n * @return {string}\n */\nfunction findShortestWay(maze, ball, hole) {\n  const H = maze.length\n  const W = maze[0].length\n  const costs = [...Array(H)].map(r => Array(W).fill(Number.MAX_VALUE))\n  let minRoute = ''\n  dfs(ball[0], ball[1], 0, '')\n  return minRoute || 'impossible'\n\n  function dfs(r, c, cost, route) {\n    if (cost >= costs[r][c]) return\n    costs[r][c] = cost\n    for (let [dr, dc, d] of [\n      [1, 0, 'd'],\n      [0, -1, 'l'],\n      [0, 1, 'r'],\n      [-1, 0, 'u']\n    ]) {\n      let rr = r\n      let cc = c\n      let steps = 0\n      for (\n        ;\n        rr + dr >= 0 &&\n        rr + dr < H &&\n        cc + dc >= 0 &&\n        cc + dc < W &&\n        maze[rr + dr][cc + dc] !== 1;\n\n      ) {\n        rr += dr\n        cc += dc\n        steps++\n        if (rr === hole[0] && cc === hole[1]) {\n          if (cost + steps < costs[hole[0]][hole[1]]) {\n            costs[hole[0]][hole[1]] = cost + steps\n            minRoute = route + d\n          }\n          return\n        }\n      }\n      dfs(rr, cc, cost + steps, route + d)\n    }\n  }\n}\n\n// another\n\nconst dirs = [\n  [1, 0, 'd'],\n  [0, -1, 'l'],\n  [0, 1, 'r'],\n  [-1, 0, 'u']\n]\n\n/**\n * @param {number[][]} maze\n * @param {number[]} ball\n * @param {number[]} hole\n * @return {string}\n */\nconst findShortestWay = function(maze, ball, hole) {\n  const m = maze.length\n  const n = maze[0].length\n  const dist = [...new Array(m)].map(() => new Array(n).fill(Infinity))\n  dist[ball[0]][ball[1]] = 0\n  const pq = new PriorityQueue({\n    comparator: (a, b) => {\n      if (dist[a[0][0]][a[0][1]] !== dist[b[0][0]][b[0][1]]) {\n        return dist[a[0][0]][a[0][1]] < dist[b[0][0]][b[0][1]]\n      }\n      return a[1] < b[1]\n    }\n  })\n  pq.enqueue([ball, ''])\n  while (pq.length) {\n    const [[x, y], path] = pq.dequeue()\n    if (x === hole[0] && y === hole[1]) {\n      return path\n    }\n    for (const [di, dj, dir] of dirs) {\n      if (isValidPosition(x + di, y + dj, m, n) && maze[x + di][y + dj] === 0) {\n        const [i, j] = walk(maze, x + di, y + dj, di, dj, m, n, hole)\n        const deltaDist = Math.abs(x - i) + Math.abs(y - j)\n        if (dist[x][y] + deltaDist <= dist[i][j]) {\n          dist[i][j] = dist[x][y] + deltaDist\n          pq.enqueue([[i, j], path + dir])\n        }\n      }\n    }\n  }\n  return 'impossible'\n}\n\nfunction walk(maze, x, y, di, dj, m, n, [hi, hj]) {\n  let i = x\n  let j = y\n  while (\n    isValidPosition(i + di, j + dj, m, n) &&\n    maze[i + di][j + dj] === 0 &&\n    !(hi === i && hj === j)\n  ) {\n    i += di\n    j += dj\n  }\n  return [i, j]\n}\n\nfunction isValidPosition(i, j, m, n) {\n  if (i < 0 || i >= m || j < 0 || j >= n) {\n    return false\n  }\n  return true\n}\n\nclass PriorityQueue {\n  constructor({ comparator }) {\n    this.comparator = comparator\n    this.arr = []\n  }\n\n  enqueue(element) {\n    this.arr.push(element)\n    moveUp(this.arr, this.arr.length - 1, this.comparator)\n  }\n\n  dequeue() {\n    const output = this.arr[0]\n    this.arr[0] = this.arr[this.arr.length - 1]\n    this.arr.pop()\n    moveDown(this.arr, 0, this.comparator)\n    return output\n  }\n\n  get length() {\n    return this.arr.length\n  }\n}\n\nfunction moveUp(arr, i, comparator) {\n  const p = Math.floor((i - 1) / 2)\n  const isValid = p < 0 || comparator(arr[p], arr[i])\n  if (!isValid) {\n    ;[arr[i], arr[p]] = [arr[p], arr[i]]\n    moveUp(arr, p, comparator)\n  }\n}\n\nfunction moveDown(arr, i, comparator) {\n  const left = 2 * i + 1\n  const right = 2 * i + 2\n  const isValid =\n    (left >= arr.length || comparator(arr[i], arr[left])) &&\n    (right >= arr.length || comparator(arr[i], arr[right]))\n  if (!isValid) {\n    const next =\n      right >= arr.length || comparator(arr[left], arr[right]) ? left : right\n    ;[arr[i], arr[next]] = [arr[next], arr[i]]\n    moveDown(arr, next, comparator)\n  }\n}\n"
    }
  },
  {
    "name": "5-longest-palindromic-substring",
    "code": {
      "JS": "/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nconst longestPalindrome = function(s) {\r\n  let res = ''\r\n  for(let i = 0, len = s.length; i < len; i++) {\r\n    let s1 = chk(s,i,i), s2 = chk(s,i,i+1)\r\n    if(s1.length > res.length) res = s1\r\n    if(s2.length > res.length) res = s2\r\n  }\r\n  return res\r\n};\r\n\r\nfunction chk(s, i, j) {\r\n  for(; i>= 0 && j < s.length; i--, j++) {\r\n    if(s[i] !== s[j]) break\r\n  }\r\n  return s.slice(i+1, j)\r\n}\r\n\r\n// another\r\n\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nconst longestPalindrome = function(s) {\r\n  let T = preProcess(s);\r\n  let n = T.length;\r\n  let P = [];\r\n  let C = 0,\r\n    R = 0;\r\n  let i_mirror;\r\n  for (let i = 1; i < n - 1; i++) {\r\n    i_mirror = 2 * C - i; // equals to i' = C - (i-C)\r\n\r\n    P[i] = R > i ? Math.min(R - i, P[i_mirror]) : 0;\r\n\r\n    // Attempt to expand palindrome centered at i\r\n    while (T[i + 1 + P[i]] == T[i - 1 - P[i]]) P[i]++;\r\n\r\n    // If palindrome centered at i expand past R,\r\n    // adjust center based on expanded palindrome.\r\n    if (i + P[i] > R) {\r\n      C = i;\r\n      R = i + P[i];\r\n    }\r\n  }\r\n\r\n  // Find the maximum element in P.\r\n  let maxLen = 0;\r\n  let centerIndex = 0;\r\n  for (let j = 1; j < n - 1; j++) {\r\n    if (P[j] > maxLen) {\r\n      maxLen = P[j];\r\n      centerIndex = j;\r\n    }\r\n  }\r\n\r\n  return s.substr((centerIndex - 1 - maxLen) / 2, maxLen);\r\n};\r\n\r\nfunction preProcess(s) {\r\n  let n = s.length;\r\n  if (n === 0) return \"^$\";\r\n  let ret = \"^\";\r\n  for (let i = 0; i < n; i++) ret += \"#\" + s.substr(i, 1);\r\n\r\n  ret += \"#$\";\r\n  return ret;\r\n}\r\n\r\n// another\r\n\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nconst longestPalindrome = function(s) {\r\n  const n = s.length\r\n  let res = ''\r\n  for(let i = 0; i < n; i++) {\r\n    const first = chk(s, i, i, n)\r\n    if(first.length > res.length) res = first\r\n    const second = chk(s, i, i + 1, n)\r\n    if(second.length > res.length) res = second\r\n  }\r\n  return res\r\n};\r\n\r\nfunction chk(str, i, j, n) {\r\n  if(j >= n) return str[i]\r\n  let l = i, r = j\r\n  while(l >= 0 && r < n) {\r\n    if(str[l] === str[r]) {\r\n      l--\r\n      r++\r\n    } else {\r\n      return str.slice(l + 1, r)\r\n    }\r\n  }\r\n  if(l < 0) {\r\n    return str.slice(0, r)\r\n  } else {\r\n    return str.slice(l + 1, n)\r\n  }\r\n}\r\n\r\n"
    }
  },
  {
    "name": "50-powx-n",
    "code": {
      "JS": "/**\n * @param {number} x\n * @param {number} n\n * @return {number}\n */\nconst myPow = function(x, n) {\n  if (n === 0) return 1;\n  if (n === 1) return x;\n  if (x === 0) return 0;\n\n  if (n > 0) {\n    return (n % 2 === 1 ? x : 1) * myPow(x * x, Math.floor(n / 2));\n  } else {\n    return myPow(1 / x, -n);\n  }\n};\n\n// another\n\n/**\n * @param {number} x\n * @param {number} n\n * @return {number}\n */\nconst myPow = function(x, n) {\n  if(n === 0) return 1\n  if(n === 1) return x\n  if(n < 0) {\n    x = 1 / x\n    n = -n\n  }\n  return n % 2 === 1 ? myPow(x, ~~(n / 2)) ** 2 * x : myPow(x, ~~(n / 2)) ** 2\n};\n\n// another\n\n/**\n * @param {number} x\n * @param {number} n\n * @return {number}\n */\nconst myPow = function (x, n) {\n  if (n === 0) return 1\n  if (n < 0) {\n    if (n === -(2 ** 31)) {\n      ++n\n      n = -n\n      x = 1 / x\n      return x * x * myPow(x * x, n / 2)\n    }\n    n = -n\n    x = 1 / x\n  }\n  return n % 2 == 0 ? myPow(x * x, n / 2) : x * myPow(x * x, (n / 2) >> 0)\n}\n\n// another\n\n/**\n * @param {number} x\n * @param {number} n\n * @return {number}\n */\nconst myPow = function (x, n) {\n  if (n === 0) return 1\n  if (n < 0) {\n    n = -n\n    x = 1 / x\n  }\n  let res = 1\n  while (n > 0) {\n    if (n & 1) {\n      res *= x\n      --n\n    }\n    x *= x\n    n /= 2\n  }\n  return res\n}\n\n"
    }
  },
  {
    "name": "500-keyboard-row",
    "code": {
      "JS": "/**\r\n * @param {string[]} words\r\n * @return {string[]}\r\n */\r\nconst findWords = function(words) {\r\n  const regex = /^[qwertyuiop]*$|^[asdfghjkl]*$|^[zxcvbnm]*$/;\r\n  return words.filter(\r\n    s => (s.toLowerCase().match(regex) === null ? false : true)\r\n  );\r\n};\r\nconsole.log(findWords([\"Hello\", \"Alaska\", \"Dad\", \"Peace\"]));\r\n"
    }
  },
  {
    "name": "501-find-mode-in-binary-search-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nconst findMode = function(root) {\n  if(root == null) return []\n  const hash = {}\n  traverse(root, hash)\n  const res = Object.entries(hash).sort((a, b) => b[1] - a[1])\n  const result = [res[0][0]]\n  for(let i = 1; i < res.length; i++) {\n    if(res[i][1] === res[0][1]) result.push(res[i][0])\n    else break\n  }\n  return result\n};\n\nfunction traverse(node, hash) {\n  if(node === null) return\n  hash[node.val] = Object.prototype.hasOwnProperty.call(hash, node.val) ? hash[node.val] + 1 : 1\n  traverse(node.left, hash)\n  traverse(node.right, hash)\n}\n\n\n// another\nconst findMode = function(root) {\n  let res = [];\n  let cnt = 1;\n  let mx = 0;\n  let pre = null;\n  let search = function(node) {\n    if (!node) return;\n    search(node.left);\n    if (pre) {\n      cnt = (node.val === pre.val) ? cnt + 1 : 1;\n    }\n    if (cnt >= mx) {\n      if (cnt > mx) res.length = 0;\n      res.push(node.val);\n      mx = cnt;\n    }\n    pre = node;\n    search(node.right);\n  }\n  search(root);\n  return res;\n};\n"
    }
  },
  {
    "name": "502-ipo",
    "code": {
      "JS": "/**\n * @param {number} k\n * @param {number} W\n * @param {number[]} Profits\n * @param {number[]} Capital\n * @return {number}\n */\nconst findMaximizedCapital = function(k, W, Profits, Capital) {\n  const capPQ = new PriorityQueue((a, b) => a.cap < b.cap)\n  const proPQ = new PriorityQueue((a, b) => a.pro > b.pro)\n  for(let i = 0, len = Profits.length; i < len; i++) {\n    capPQ.push({ cap: Capital[i], pro: Profits[i] })\n  }\n  while(k) {\n    while(!capPQ.isEmpty() && capPQ.peek().cap <= W) {\n      proPQ.push(capPQ.pop())\n    }\n    if(proPQ.isEmpty()) break\n    \n    W += proPQ.pop().pro\n    k--\n  }\n  return W\n};\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n\n// another\n\n/**\n * @param {number} k\n * @param {number} W\n * @param {number[]} Profits\n * @param {number[]} Capital\n * @return {number}\n */\nconst findMaximizedCapital = function(k, W, Profits, Capital) {\n  const idxArr = Profits.map((_, i) => i).sort((ia, ib) => Profits[ib] - Profits[ia]);\n  while (k) {\n    const choose = idxArr.findIndex(i => Capital[i] <= W);\n    if (choose == -1) return W;\n    W += Profits[idxArr[choose]];\n    idxArr.splice(choose, 1);\n    k--;\n  }\n  return W;\n};\n"
    }
  },
  {
    "name": "503-next-greater-element-II",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n * @return {number[]}\r\n */\r\nconst nextGreaterElements = function(nums) {\r\n  const res = [];\r\n  for (let i = 0; i < nums.length; i++) {\r\n    res.push(single(i, nums));\r\n  }\r\n  return res;\r\n};\r\n\r\nfunction single(idx, arr) {\r\n  const base = arr[idx];\r\n  const prev = idx === 0 ? [] : arr.slice(0, idx);\r\n  const next = arr.slice(idx);\r\n  const comb = next.concat(prev);\r\n  for (let i = 0; i < comb.length; i++) {\r\n    if (comb[i] > base) return comb[i];\r\n  }\r\n  return -1;\r\n}\r\n\r\n// another\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @return {number[]}\r\n */\r\n const nextGreaterElements = function(nums) {\r\n  const res = [], n = nums.length\r\n  const stack = []\r\n  for(let i = 2 * n - 1; i >= 0; i--) {\r\n    while(stack.length && nums[stack[stack.length - 1]] <= nums[i % n]) {\r\n      stack.pop()\r\n    }\r\n    res[i % n] = stack.length ? nums[stack[stack.length - 1]] : -1\r\n    stack.push(i % n)\r\n  }\r\n\r\n  return res\r\n};\r\n"
    }
  },
  {
    "name": "504-base-7",
    "code": {
      "JS": "/**\n * @param {number} num\n * @return {string}\n */\nconst convertToBase7 = function(num) {\n  if(num == null) return ''\n  const sign = num >= 0 ? '+' : '-'\n  let res = ''\n  let remain = Math.abs(num)\n  if(num === 0) return '0'\n  while(remain > 0) {\n    res = remain % 7 + res\n    remain = Math.floor(remain / 7)\n  }\n  \n  return sign === '+' ? res : '-' + res\n};\n\n// another\n\nconst convertToBase7 = function(num) {\n  return num.toString(7)\n};\n"
    }
  },
  {
    "name": "505-the-maze-ii",
    "code": {
      "JS": "/**\n\nThere is a ball in a maze with empty spaces and walls.\nThe ball can go through empty spaces by rolling up, down, left or right,\nbut it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction.\n\nGiven the ball's start position, the destination and the maze,\nfind the shortest distance for the ball to stop at the destination.\nThe distance is defined by the number of empty spaces traveled by the ball from the start position (excluded) to\nthe destination (included). If the ball cannot stop at the destination, return -1.\n\nThe maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space.\nYou may assume that the borders of the maze are all walls.\nThe start and destination coordinates are represented by row and column indexes.\n\nExample 1:\n\nInput 1: a maze represented by a 2D array\n\n0 0 1 0 0\n0 0 0 0 0\n0 0 0 1 0\n1 1 0 1 1\n0 0 0 0 0\n\nInput 2: start coordinate (rowStart, colStart) = (0, 4)\nInput 3: destination coordinate (rowDest, colDest) = (4, 4)\n\nOutput: 12\n\nExplanation: One shortest way is : left -> down -> left -> down -> right -> down -> right.\n             The total distance is 1 + 1 + 3 + 1 + 2 + 2 + 2 = 12.\n\nExample 2:\n\nInput 1: a maze represented by a 2D array\n\n0 0 1 0 0\n0 0 0 0 0\n0 0 0 1 0\n1 1 0 1 1\n0 0 0 0 0\n\nInput 2: start coordinate (rowStart, colStart) = (0, 4)\nInput 3: destination coordinate (rowDest, colDest) = (3, 2)\n\nOutput: -1\n\nExplanation: There is no way for the ball to stop at the destination.\n\nNote:\n\nThere is only one ball and one destination in the maze.\nBoth the ball and the destination exist on an empty space, and they will not be at the same position initially.\nThe given maze does not contain border (like the red rectangle in the example pictures),\nbut you could assume the border of the maze are all walls.\nThe maze contains at least 2 empty spaces, and both the width and height of the maze won't exceed 100.\n\n*/\n\n/**\n * @param {number[][]} maze\n * @param {number[]} start\n * @param {number[]} destination\n * @return {number}\n */\nconst shortestDistance = function(maze, start, destination) {\n  const dirs = [\n    [-1, 0],\n    [1, 0],\n    [0, 1],\n    [0, -1]\n  ]\n  if (maze == null || maze.length === 0 || maze[0].length === 0) return -1\n  const m = maze.length\n  const n = maze[0].length\n  const d = Array.from({ length: m }, () => new Array(n).fill(Infinity))\n  const q = [[start[0], start[1], 0]]\n\n  while (q.length) {\n    const cur = q.shift()\n    for (let dir of dirs) {\n      let nextX = cur[0]\n      let nextY = cur[1]\n      let len = cur[2]\n      while (\n        nextX >= 0 &&\n        nextX < m &&\n        nextY >= 0 &&\n        nextY < n &&\n        maze[nextX][nextY] === 0\n      ) {\n        nextX += dir[0]\n        nextY += dir[1]\n        len++\n      }\n      nextX -= dir[0]\n      nextY -= dir[1]\n      len--\n      if (len > d[destination[0]][destination[1]]) continue\n      if (len < d[nextX][nextY]) {\n        d[nextX][nextY] = len\n        q.push([nextX, nextY, len])\n      }\n    }\n  }\n  return d[destination[0]][destination[1]] === Infinity\n    ? -1\n    : d[destination[0]][destination[1]]\n}\n"
    }
  },
  {
    "name": "506-relative-ranks",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {string[]}\n */\nconst findRelativeRanks = function(nums) {\n  const numIndexMapping = {}\n  for (let index = 0; index < nums.length; ++index) {\n    numIndexMapping[nums[index]] = index\n  }\n  let rank = nums.length\n  for (let num in numIndexMapping) {\n    const index = numIndexMapping[num]\n    if (3 < rank) {\n      nums[index] = '' + rank\n    } else if (3 == rank) {\n      nums[index] = 'Bronze Medal'\n    } else if (2 == rank) {\n      nums[index] = 'Silver Medal'\n    } else {\n      nums[index] = 'Gold Medal'\n    }\n    --rank\n  }\n\n  return nums\n}\n"
    }
  },
  {
    "name": "507-perfect-number",
    "code": {
      "JS": "/**\n * @param {number} num\n * @return {boolean}\n */\nconst checkPerfectNumber = function(num) {\n  if (num === 1) return false;\n  return chk(num);\n};\n\nfunction chk(num) {\n  let min = 2;\n  let max = Math.ceil(Math.sqrt(num));\n  const res = [1];\n  for (let i = min; i <= max; i++) {\n    if (Number.isInteger(num / i) && res.indexOf(i) === -1) {\n      res.push(i, num / i);\n    }\n  }\n  if (res.reduce((ac, el) => ac + el, 0) === num) {\n    return true;\n  } else {\n    return false;\n  }\n}\n"
    }
  },
  {
    "name": "508-most-frequent-subtree-sum",
    "code": {
      "JS": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number[]}\r\n */\r\nconst findFrequentTreeSum = function(root) {\r\n  if (root == null) return [];\r\n  const valArr = [];\r\n  calc(root, valArr);\r\n  const hash = {};\r\n  valArr.forEach((el, idx) => {\r\n    if (hash.hasOwnProperty(el)) {\r\n      hash[el] += 1;\r\n    } else {\r\n      hash[el] = 1;\r\n    }\r\n  });\r\n  const arr = Object.entries(hash).sort((a, b) => b[1] - a[1]);\r\n  const max = arr[0][1];\r\n  const res = [+arr[0][0]];\r\n  for (let i = 1; i < arr.length; i++) {\r\n    if (arr[i][1] === max) {\r\n      res.push(+arr[i][0]);\r\n    } else {\r\n      return res;\r\n    }\r\n  }\r\n  return res;\r\n};\r\n\r\nfunction calc(node, arr) {\r\n  let sum = 0;\r\n  if (node.left) {\r\n    sum += calc(node.left, arr);\r\n  }\r\n  if (node.right) {\r\n    sum += calc(node.right, arr);\r\n  }\r\n  sum += node.val;\r\n  arr.push(sum);\r\n  return sum;\r\n}\r\n"
    }
  },
  {
    "name": "5083-occurrences-after-bigram",
    "code": {
      "JS": "/**\n * @param {string} text\n * @param {string} first\n * @param {string} second\n * @return {string[]}\n */\nconst findOcurrences = function(text, first, second) {\n  const res = []\n  let arr = text.split(' ')\n  for(let i = 1, len = arr.length; i < len; i++) {\n    if(arr[i] === second && arr[i - 1] === first) {\n      if(i + 1 < len) res.push(arr[i + 1])\n    }\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "5084-insufficient-nodes-in-root-to-leaf-paths",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} limit\n * @return {TreeNode}\n */\nconst sufficientSubset = function(root, limit) {\n  if (root.left == root.right)\n      return root.val < limit ? null : root;\n  if (root.left != null)\n      root.left = sufficientSubset(root.left, limit - root.val);\n  if (root.right != null)\n      root.right = sufficientSubset(root.right, limit - root.val);\n  return root.left == root.right ? null : root;\n};\n"
    }
  },
  {
    "name": "509-fibonacci-number",
    "code": {
      "JS": "/**\n * @param {number} N\n * @return {number}\n */\nconst cache = {}\nconst fib = function(N) {\n  if(cache[N]) return cache[N]\n  if(N === 0) return 0\n  if(N === 1) return 1\n  let res = fib(N - 1) + fib(N - 2)\n  cache[N] = res\n  return res\n};\n"
    }
  },
  {
    "name": "51-n-queens",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {string[][]}\n */\nconst solveNQueens = function(n) {\n  const res = []\n  const chess = Array.from({length: n}, () => new Array(n).fill('.'))\n  bt(res, chess, 0)\n  return res\n}\n\nfunction bt(res, chess, row) {\n  if(row === chess.length) {\n    res.push(build(chess))\n    return\n  }\n  for(let i = 0, num = chess[0].length; i < num; i++) {\n    if(valid(chess, row, i)) {\n      chess[row][i] = 'Q'\n      bt(res, chess, row + 1)\n      chess[row][i] = '.'\n    }\n  }\n}\n\nfunction valid(chess, row, col) {\n  for(let i = row - 1; i >= 0; i--) {\n    if(chess[i][col] === 'Q') return false\n  }\n  for(let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n    if(chess[i][j] === 'Q') return false\n  }\n  for(let i = row - 1, j = col + 1; i >= 0 && j < chess[0].length; i--, j++) {\n    if(chess[i][j] === 'Q') return false\n  }\n  return true\n}\n\nfunction build(chess) {\n  return chess.map(el => el.join(''))\n}\n\n// another\n\n/**\n * @param {number} n\n * @return {string[][]}\n */\nconst solveNQueens = function(n) {\n  const res = []\n  bt(res, n)\n  return res\n}\n\nfunction bt(res, n, board = [], r = 0) {\n  if (r === n) {\n    res.push(board.map(c => '.'.repeat(c) + 'Q' + '.'.repeat(n - c - 1)))\n    return\n  }\n  for (let c = 0; c < n; c++) {\n    if (\n      !board.some(\n        (bc, br) => bc === c || bc === c + r - br || bc === c - r + br\n      )\n    ) {\n      board.push(c)\n      bt(res, n, board, r + 1)\n      board.pop()\n    }\n  }\n}\n"
    }
  },
  {
    "name": "510-inorder-successor-in-bst-ii",
    "code": {
      "JS": "/**\n * // Definition for a Node.\n * function Node(val) {\n *    this.val = val;\n *    this.left = null;\n *    this.right = null;\n *    this.parent = null;\n * };\n */\n/**\n * @param {Node} node\n * @return {Node}\n */\nconst inorderSuccessor = function(node) {\n  if (node.right == null) {\n    let cur = node\n    while (cur.parent !== null && cur.parent.right === cur) {\n      cur = cur.parent\n    }\n    return cur.parent\n  }\n  let cur = node.right\n  while (cur.left !== null) {\n    cur = cur.left\n  }\n  return cur\n}\n"
    }
  },
  {
    "name": "513-find-bottom-left-tree-value",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nconst findBottomLeftValue = function(root) {\n  const res = [];\n  single(root, 0, res);\n  return res[res.length - 1][0].val;\n};\n\nfunction single(node, row, arr) {\n  if (node == null) {\n    return null;\n  }\n  if (row < arr.length) {\n    arr[row].push(node);\n  } else {\n    arr[row] = [node];\n  }\n  single(node.left, row + 1, arr);\n  single(node.right, row + 1, arr);\n}\n"
    }
  },
  {
    "name": "514-freedom-trail",
    "code": {
      "JS": "/**\n * @param {string} ring\n * @param {string} key\n * @return {number}\n */\nconst findRotateSteps = function(ring, key) {\n  function findLeft(i, j) {\n    let k = i\n    let count = 0\n    while (ring[k] !== key[j]) {\n      k--\n      count++\n      if (k === -1) k += ring.length\n    }\n    return [k, count]\n  }\n  function findRight(i, j) {\n    let k = i\n    let count = 0\n    while (ring[k] !== key[j]) {\n      k++\n      count++\n      if (k === ring.length) k -= ring.length\n    }\n    return [k, count]\n  }\n  const dp = []\n  for (let i = 0; i < ring.length; i++) {\n    dp[i] = []\n  }\n  function f(i, j) {\n    if (dp[i][j] !== undefined) return dp[i][j]\n    if (j === key.length) return (dp[i][j] = 0)\n    const [i1, c1] = findLeft(i, j)\n    const [i2, c2] = findRight(i, j)\n    return (dp[i][j] = Math.min(c1 + 1 + f(i1, j + 1), c2 + 1 + f(i2, j + 1)))\n  }\n  return f(0, 0)\n}\n"
    }
  },
  {
    "name": "515-find-largest-value-in-each-tree-row",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nconst largestValues = function(root) {\n  const res = [];\n  single(root, 0, res);\n  return res;\n};\n\nfunction single(node, row, arr) {\n  if (node == null) {\n    return null;\n  }\n  if (row < arr.length) {\n    if (node.val > arr[row]) {\n      arr[row] = node.val;\n    }\n  } else {\n    arr[row] = node.val;\n  }\n  single(node.left, row + 1, arr);\n  single(node.right, row + 1, arr);\n}\n"
    }
  },
  {
    "name": "516-longest-palindromic-subsequence",
    "code": {
      "JS": "// 区间DP\n\n/**\n * @param {string} s\n * @return {number}\n */\nconst longestPalindromeSubseq = function(s) {\n  const n = s.length\n  const dp = Array.from({ length: n }, () => Array(n).fill(0))\n  for(let i = 0; i < n; i++) dp[i][i] = 1\n  for(let len = 2; len <= n; len++) {\n    for(let i = 0; i + len - 1 < n; i++) {\n      const j = i + len - 1\n      if(s[i] === s[j]) dp[i][j] = 2 + dp[i + 1][j - 1]\n      else dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1])\n    }\n  }\n  return dp[0][n - 1]\n};\n\n// another\n\n/**\n * @param {string} s\n * @return {number}\n */\nconst longestPalindromeSubseq = function(s) {\n  const n = s.length\n  const dp = Array.from({ length: n }, () => Array(n).fill(0))\n  for(let i = 0; i < n; i++) {\n    dp[i][i] = 1\n    for(let j = i - 1; j >= 0; j--) {\n      if(s[i] === s[j]) {\n        dp[i][j] = dp[i - 1][j + 1] + 2\n      } else {\n        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j + 1])\n      }\n    }\n  }\n  \n  return dp[n - 1][0]\n};\n\n// another\n\n/**\n * @param {string} s\n * @return {number}\n */\nconst longestPalindromeSubseq = function(s) {\n  const len = s.length\n  const dp = Array.from({length: len + 1}, () => new Array(len + 1).fill(0))\n  for(let i = len - 1; i >= 0; i--) {\n    dp[i][i] = 1\n    for(let j = i + 1; j < len; j++) {\n      if(s[i] === s[j]) {\n         dp[i][j] = dp[i+1][j-1] + 2\n      } else {\n        dp[i][j] = Math.max(dp[i][j - 1], dp[i+1][j])\n      }\n    }\n  }\n  return dp[0][s.length - 1]\n};\n"
    }
  },
  {
    "name": "517-super-washing-machines",
    "code": {
      "JS": "/**\n * @param {number[]} machines\n * @return {number}\n */\nconst findMinMoves = function(machines) {\n  let total = 0\n  for (let i of machines) total += i\n  if (total % machines.length !== 0) return -1\n  let avg = (total / machines.length) >> 0,\n    cnt = 0,\n    max = 0\n  for (let load of machines) {\n    cnt += load - avg\n    max = Math.max(Math.max(max, Math.abs(cnt)), load - avg)\n  }\n  return max\n}\n"
    }
  },
  {
    "name": "518-coin-change-2",
    "code": {
      "JS": "/**\n * @param {number} amount\n * @param {number[]} coins\n * @return {number}\n */\nfunction change(amount, coins) {\n  const dp = Array.from(new Array(coins.length + 1), () =>\n    new Array(amount + 1).fill(0)\n  )\n  dp[0][0] = 1\n  for (let i = 1; i <= coins.length; i++) {\n    dp[i][0] = 1\n    for (let j = 1; j <= amount; j++) {\n      dp[i][j] =\n        dp[i - 1][j] + (j >= coins[i - 1] ? dp[i][j - coins[i - 1]] : 0)\n    }\n  }\n  return dp[coins.length][amount]\n}\n\n\n// another\n\n/**\n * @param {number} amount\n * @param {number[]} coins\n * @return {number}\n */\nconst change = function (amount, coins) {\n  const dp = Array(amount + 1).fill(0)\n  dp[0] = 1\n  for (let coin of coins) {\n    for (let i = coin; i < amount + 1; i++) dp[i] += dp[i - coin]\n  }\n  return dp[amount]\n}\n\n// another\n\n// another\n\nconst change = function(amount,coins) {\n  const n = coins.length\n  const dp = Array.from({ length: n + 1 }, () => Array(amount + 1))\n  dp[0][0] = 1\n  for(let i = 0; i < n; i++) dp[i][0] = 1\n  helper(0, amount)\n  return dp[0][amount] === undefined ? 0 : dp[0][amount]\n  \n  function helper(i, rem) {\n    if(dp[i][rem] != null) return dp[i][rem]\n    if(rem < 0) return 0\n    if(rem === 0) return 1\n    if(i >= coins.length) return 0\n    let res = 0\n    \n    res += helper(i, rem - coins[i])\n    res += helper(i + 1, rem)\n    \n    dp[i][rem] = res\n      \n    return res\n  } \n}\n"
    }
  },
  {
    "name": "519-random-flip-matrix",
    "code": {
      "JS": "/**\n * @param {number} n_rows\n * @param {number} n_cols\n */\nconst Solution = function(n_rows, n_cols) {\n  this.r = n_rows\n  this.c = n_cols\n  this.total = n_rows * n_cols\n  this.m = new Map()\n}\n\n/**\n * @return {number[]}\n */\nSolution.prototype.flip = function() {\n  const r = (Math.random() * this.total--) >> 0\n  const i = this.m.get(r) || r\n  this.m.set(r, this.m.get(this.total) || this.total)\n  return [(i / this.c) >> 0, i % this.c]\n}\n\n/**\n * @return {void}\n */\nSolution.prototype.reset = function() {\n  this.m.clear()\n  this.total = this.c * this.r\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * var obj = Object.create(Solution).createNew(n_rows, n_cols)\n * var param_1 = obj.flip()\n * obj.reset()\n */\n"
    }
  },
  {
    "name": "52-n-queens-II",
    "code": {
      "JS": "/**\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nconst totalNQueens = function(n) {\r\n  //Keeps track of the # of valid solutions\r\n  let count = 0;\r\n\r\n  //Helps identify valid solutions\r\n  const done = Math.pow(2, n) - 1;\r\n\r\n  //Checks all possible board configurations\r\n  const innerRecurse = function(ld, col, rd) {\r\n    //All columns are occupied,\r\n    //so the solution must be complete\r\n    if (col === done) {\r\n      count++;\r\n      return;\r\n    }\r\n\r\n    //Gets a bit sequence with \"1\"s\r\n    //whereever there is an open \"slot\"\r\n    let poss = ~(ld | rd | col);\r\n\r\n    //Loops as long as there is a valid\r\n    //place to put another queen.\r\n    while (poss & done) {\r\n      let bit = poss & -poss;\r\n      poss -= bit;\r\n      innerRecurse((ld | bit) >> 1, col | bit, (rd | bit) << 1);\r\n    }\r\n  };\r\n\r\n  innerRecurse(0, 0, 0);\r\n\r\n  return count;\r\n};\r\n"
    }
  },
  {
    "name": "520-detect-capital",
    "code": {
      "JS": "/**\r\n * @param {string} word\r\n * @return {boolean}\r\n */\r\nconst ac = \"A\".charCodeAt(0);\r\nconst zc = \"Z\".charCodeAt(0);\r\nconst detectCapitalUse = function(word) {\r\n  if (allCap(word) || noCap(word) || capHead(word)) {\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\nfunction allCap(str) {\r\n  let c;\r\n  for (let i = 0; i < str.length; i++) {\r\n    c = str.charCodeAt(i);\r\n    if (c < ac || c > zc) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction noCap(str) {\r\n  let c;\r\n  for (let i = 0; i < str.length; i++) {\r\n    c = str.charCodeAt(i);\r\n    if (c >= ac && c <= zc) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction capHead(str) {\r\n  let c;\r\n  let first;\r\n  for (let i = 0; i < str.length; i++) {\r\n    c = str.charCodeAt(i);\r\n    if (i === 0) {\r\n      first = c;\r\n    } else if (c >= ac && c <= zc) {\r\n      return false;\r\n    }\r\n  }\r\n  if (first >= ac && first <= zc) {\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\n\r\nconsole.log(detectCapitalUse(\"ffffffffffffffffffffF\"));\r\nconsole.log(detectCapitalUse(\"Leetcode\"));\r\n"
    }
  },
  {
    "name": "521-longest-uncommon-subsequence-i",
    "code": {
      "JS": "/**\n * @param {string} a\n * @param {string} b\n * @return {number}\n */\nconst findLUSlength = function(a, b) {\n  return a === b ? -1 : Math.max(a.length, b.length);\n};\n"
    }
  },
  {
    "name": "522-longest-uncommon-subsequence-ii",
    "code": {
      "JS": "/**\n * @param {string[]} strs\n * @return {number}\n */\nconst findLUSlength = function(strs) {\n  strs.sort((a, b)  => b.length - a.length)\n  const dup = getDuplicates(strs)\n  for(let i = 0; i < strs.length; i++) {\n    if(!dup.has(strs[i])) {\n      if(i === 0) return strs[0].length\n      for(let j = 0; j < i; j++) {\n        if(isSubsequence(strs[j], strs[i])) break\n        if(j === i - 1) return strs[i].length\n      }\n    }\n  }\n  return -1\n};\n\nfunction isSubsequence(a, b) {\n  let i = 0, j = 0\n  while(i < a.length && j < b.length) {\n    if(a.charAt(i) === b.charAt(j)) j++\n    i++\n  }\n  return j === b.length\n}\n\nfunction getDuplicates(arr) {\n  const set = new Set()\n  const dup = new Set()\n  for(let el of arr) {\n    if(set.has(el)) dup.add(el)\n    else set.add(el)\n  }\n  return dup\n}\n\n"
    }
  },
  {
    "name": "523-continuous-subarray-sum",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {boolean}\n */\nconst checkSubarraySum = function(nums, k) {\n    const map = {0: -1}\n    let runningSum = 0\n    for(let i = 0; i < nums.length; i++) {\n      runningSum += nums[i]\n      if(k !== 0) runningSum %= k\n      let prev = map[runningSum]\n      if(prev != null) {\n         if(i - prev > 1) return true\n      } else {\n        map[runningSum] = i\n      }\n    }\n    return false\n};\n\n"
    }
  },
  {
    "name": "524-longest-word-in-dictionary-through-deleting",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {string[]} dictionary\n * @return {string}\n */\n const findLongestWord = function(s, dictionary) {\n  let res = ''\n  for (const word of dictionary) {\n    let j = 0\n    for (let i = 0, len = s.length; i < len; i++) {\n      if(word[j] === s[i]) j++\n      if(j === word.length) {\n        if(word.length > res.length) res = word\n        else if(word.length === res.length && word < res) res = word\n        break\n      }\n    }\n  }\n  return res\n};\n\n// another\n\n/**\n * @param {string} s\n * @param {string[]} dictionary\n * @return {string}\n */\nconst findLongestWord = function(s, dictionary) {\n  let res = ''\n  for(let d of dictionary) {\n    let j = 0\n    for(let i = 0, n = s.length; i < n; i++) {\n      if(d[j] === s[i]) j++\n      if(j === d.length && j >= res.length) {\n        if(j > res.length || d < res) {\n          res = d\n        }\n        break\n      }\n    }\n  }\n  return res\n};\n\n// another\n\n/**\n * @param {string} s\n * @param {string[]} dictionary\n * @return {string}\n */\nconst findLongestWord = function(s, dictionary) {\n  dictionary.sort((a, b) => a.length === b.length ? cmp(a, b) : b.length - a.length)\n  let res = ''\n  for(let d of dictionary) {\n    let j = 0\n    for(let i = 0, n = s.length; i < n; i++) {\n      if(d[j] === s[i]) j++\n      if(j === d.length) return d\n    }\n  }\n  return ''\n  function cmp(s1, s2) {\n    for(let i = 0, n = s1.length; i < n; i++) {\n      if(s1[i] < s2[i]) return -1\n      else if(s1[i] > s2[i]) return 1\n    }\n    return 0\n  }\n};\n\n// another\n\n\n/**\n * @param {string} s\n * @param {string[]} d\n * @return {string}\n */\nconst findLongestWord = function(s, d) {\n  let results = [];\n  let maxLen = 0;\n  for (const word of d) {\n    let j = 0;\n    for (let i = 0; i < s.length; i++) {\n      if (s[i] === word[j]) {\n        j++;\n        if (j === word.length) break;\n      }\n    }\n    if (j === word.length && word.length >= maxLen) {\n      if (word.length > maxLen) {\n        maxLen = word.length;\n        results = [];\n      }\n      results.push(word);\n    }\n  }\n  \n  let result = results[0];\n  for (let i = 1; i < results.length; i++) {\n    if (results[i] < result) result = results[i];\n  }\n  return result || '';\n}\n"
    }
  },
  {
    "name": "525-contiguous-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst findMaxLength = function (nums) {\n  const map = new Map()\n  map.set(0, -1)\n  let count = 0\n  let max = 0\n  for (let i = 0; i < nums.length; i++) {\n    let num = nums[i]\n    if (num === 0) {\n      count -= 1\n    }\n    if (num === 1) {\n      count += 1\n    }\n    if (map.has(count)) {\n      max = Math.max(max, i - map.get(count))\n    } else {\n      map.set(count, i)\n    }\n  }\n  return max\n}\n"
    }
  },
  {
    "name": "526-beautiful-arrangement",
    "code": {
      "JS": "/**\n * @param {number} N\n * @return {number}\n */\nvar countArrangement = function(N) {\n  let used = Array(N + 1).fill(false)\n  let res = 0\n  function backtrack(curIdx) {\n    if (curIdx === 0) return res++\n    for (let i = 1; i <= N; i++) {\n      if (used[i]) continue\n      if (i % curIdx === 0 || curIdx % i === 0) {\n        used[i] = true\n        backtrack(curIdx - 1)\n        used[i] = false\n      }\n    }\n  }\n  backtrack(N)\n  return res\n};\n"
    }
  },
  {
    "name": "527-word-abbreviation",
    "code": {
      "JS": "/**\n * @param {string[]} dict\n * @return {string[]}\n */\nconst wordsAbbreviation = function(dict) {\n  const result = []\n  const prefixLen = new Array(dict.length).fill(1)\n  for (let i = 0; i < dict.length; i++) {\n    result[i] = makeAbbr(dict[i], 1)\n  }\n  for (let i = 0; i < dict.length; i++) {\n    while (true) {\n      const set = new Set()\n      for (let j = i + 1; j < dict.length; j++) {\n        if (result[i] === result[j]) {\n          set.add(j)\n        }\n      }\n      if (set.size === 0) {\n        break\n      }\n      set.add(i)\n      for (let val of set.values()) {\n        result[val] = makeAbbr(dict[val], ++prefixLen[val])\n      }\n    }\n  }\n  return result\n}\n\nfunction makeAbbr(s, prefixLen) {\n  if (prefixLen >= s.length - 2) {\n    return s\n  }\n  let str = ''\n  str += s.slice(0, prefixLen)\n  str += s.length - 1 - prefixLen\n  str += s[s.length - 1]\n  return str\n}\n"
    }
  },
  {
    "name": "528-random-pick-with-weight",
    "code": {
      "JS": "/**\n * @param {number[]} w\n */\nconst Solution = function(w) {\n  this.a = []\n  let sum = 0\n  for (let i = 0, len = w.length; i < len; i++) {\n    sum += w[i]\n    this.a[i] = sum\n  }\n}\n\n/**\n * @return {number}\n */\nSolution.prototype.pickIndex = function() {\n  const len = this.a.length\n  const sum = this.a[len - 1]\n  const rand = ((Math.random() * sum) >> 0) + 1\n  let l = 0,\n    h = len - 1\n  while (l < h) {\n    const mid = (l + h) >> 1\n    if (this.a[mid] === rand) return mid\n    else if (this.a[mid] < rand) l = mid + 1\n    else h = mid\n  }\n  return l\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * var obj = new Solution(w)\n * var param_1 = obj.pickIndex()\n */\n\n// another\n\n/**\n * @param {number[]} w\n */\nconst Solution = function(w) {\n  this.a = []\n  let sum = 0\n  for(let i = 0, len = w.length; i < len; i++) {\n    sum += w[i]\n    this.a[i] = sum\n  }\n};\n\n/**\n * @return {number}\n */\nSolution.prototype.pickIndex = function() {\n  const len = this.a.length\n  const sum = this.a[len - 1]\n  const rand = ((Math.random() * sum) >> 0) + 1\n  let l = 0, h = len - 1\n  while(l <= h) {\n    const mid = (l + h) >> 1\n    if(this.a[mid] === rand) return mid\n    else if(this.a[mid] < rand) l = mid + 1\n    else h = mid - 1\n  }\n  return l\n};\n\n/** \n * Your Solution object will be instantiated and called as such:\n * var obj = new Solution(w)\n * var param_1 = obj.pickIndex()\n */\n\n// another\n\n/**\n * @param {number[]} w\n */\nconst Solution = function(w) {\n  this.a = []\n  let sum = 0\n  for(let i = 0, len = w.length; i < len; i++) {\n    sum += w[i]\n    this.a[i] = sum\n  }\n};\n\n/**\n * @return {number}\n */\nSolution.prototype.pickIndex = function() {\n  const len = this.a.length\n  const sum = this.a[len - 1]\n  const rand = ((Math.random() * sum) >> 0) + 1\n  let l = 0, h = len - 1\n  while(l < h) {\n    const mid = (l + h) >> 1\n    if(this.a[mid] < rand) l = mid + 1\n    else h = mid\n  }\n  return l\n};\n\n/** \n * Your Solution object will be instantiated and called as such:\n * var obj = new Solution(w)\n * var param_1 = obj.pickIndex()\n */\n"
    }
  },
  {
    "name": "529-minesweeper",
    "code": {
      "JS": "/**\n * @param {character[][]} board\n * @param {number[]} click\n * @return {character[][]}\n */\nconst updateBoard = function(board, click) {\n  const visited = new Set();\n  const [clickRow, clickCol] = click;\n  if (board[clickRow][clickCol] === \"M\") {\n    board[clickRow][clickCol] = \"X\";\n    return board;\n  }\n  const directions = [\n    [-1, 0], // top\n    [1, 0], // down\n    [0, -1], // left\n    [0, 1], // right\n    [-1, -1], // top left\n    [1, 1], // bottom right\n    [-1, 1], // top right\n    [1, -1] // bottom left\n  ];\n\n  function dfs(row, col) {\n    visited.add(`${row},${col}`);\n    if (board[row][col] === \"M\") return;\n    let numBombs = 0;\n    for (let dir of directions) {\n      if (\n        board[row + dir[0]] === undefined ||\n        board[row + dir[0]][col + dir[1]] === undefined\n      )\n        continue;\n      if (board[row + dir[0]][col + dir[1]] === \"M\") {\n        numBombs += 1;\n      }\n    }\n    if (numBombs) {\n      board[row][col] = `${numBombs}`;\n      return;\n    }\n    board[row][col] = \"B\";\n    for (let dir of directions) {\n      if (\n        board[row + dir[0]] === undefined ||\n        board[row + dir[0]][col + dir[1]] === undefined ||\n        board[row + dir[0]][col + dir[1]] !== \"E\"\n      )\n        continue;\n      if (!visited.has(`${row + dir[0]},${col + dir[1]}`)) {\n        dfs(row + dir[0], col + dir[1]);\n      }\n    }\n  }\n  dfs(clickRow, clickCol);\n  return board;\n};\n\n"
    }
  },
  {
    "name": "53-maximum-subarray",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nconst maxSubArray = function(nums) {\r\n  let preSum = nums[0];\r\n  let maxSum = preSum;\r\n  for (let i = 1; i < nums.length; i++) {\r\n    preSum = preSum > 0 ? preSum + nums[i] : nums[i];\r\n    maxSum = Math.max(preSum, maxSum);\r\n  }\r\n  return maxSum;\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nconst maxSubArray = function(nums) {\r\n  const n = nums.length, dp = Array(n).fill(0)\r\n  dp[0] = nums[0]\r\n  let res = dp[0]\r\n  for(let i = 1; i < n; i++) {\r\n    dp[i] = Math.max(dp[i - 1], 0) + nums[i]\r\n    res = Math.max(res, dp[i])\r\n  }\r\n  return res\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nconst maxSubArray = function(nums) {\r\n  return helper(nums, 0, nums.length - 1)\r\n};\r\n\r\nfunction helper(arr, l, r) {\r\n  if(l > r) return -Infinity\r\n  const mid = l + ((r - l) >> 1)\r\n  let cur = 0, leftMax = 0, rightMax = 0\r\n  for(let i = mid - 1; i >= l; i--) {\r\n    cur += arr[i]\r\n    leftMax = Math.max(leftMax, cur)\r\n  }\r\n  cur = 0\r\n  for(let i = mid + 1; i <= r; i++) {\r\n    cur += arr[i]\r\n    rightMax = Math.max(rightMax, cur)\r\n  }\r\n  const res = arr[mid] + leftMax + rightMax\r\n  const leftRes = helper(arr, l, mid - 1)\r\n  const rightRes = helper(arr, mid + 1, r)\r\n  \r\n  return Math.max(res, leftRes, rightRes)\r\n}\r\n"
    }
  },
  {
    "name": "530-minimum-absolute-difference-in-BST",
    "code": {
      "JS": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nconst getMinimumDifference = function(root) {\r\n  const arr = [];\r\n  traversal(root, arr);\r\n  let min = Number.MAX_SAFE_INTEGER;\r\n  for (let i = 1; i < arr.length; i++) {\r\n    min = Math.min(min, arr[i] - arr[i - 1]);\r\n  }\r\n  return min;\r\n};\r\n\r\nfunction traversal(node, arr) {\r\n  if (node === null) return;\r\n  if (node.left) {\r\n    traversal(node.left, arr);\r\n  }\r\n  arr.push(node.val);\r\n  if (node.right) {\r\n    traversal(node.right, arr);\r\n  }\r\n}\r\n"
    }
  },
  {
    "name": "531-lonely-pixel-i",
    "code": {
      "JS": "/**\n * @param {character[][]} picture\n * @return {number}\n */\nconst findLonelyPixel = function(picture) {\n  if(picture == null || picture[0].length === 0) return 0\n  const rows = picture.length\n  const cols = picture[0].length\n  const r = new Array(rows).fill(0)\n  const c = new Array(cols).fill(0)\n  for(let i = 0; i < rows; i++) {\n    for(let j = 0; j < cols; j++) {\n      if(picture[i][j] === 'B') {\n        r[i]++\n        c[j]++\n      }\n    }\n  }\n  let res = 0\n  for(let i = 0; i < rows; i++) {\n    if(r[i] === 1) {\n      for(let j = 0; j < cols; j++) {\n        if(picture[i][j] === 'B') {\n          if(c[j] === 1)res++\n          break\n        }\n      }      \n    }\n  }\n  return res\n};\n\n// another\n\n/**\n * @param {character[][]} picture\n * @return {number}\n */\nconst findLonelyPixel = function(picture) {\n  if(picture == null || picture[0].length === 0) return 0\n  const rows = picture.length\n  const cols = picture[0].length\n  const c = new Array(cols).fill(0)\n  for(let i = 0; i < rows; i++) {\n    for(let j = 0; j < cols; j++) {\n      if(picture[i][j] === 'B') c[j]++\n    }\n  }\n  let res = 0\n  for(let i = 0; i < rows; i++) {\n    let cnt = 0, pos = -1\n    for(let j = 0; j < cols; j++) {\n      if(picture[i][j] !== 'B') continue\n      if(++cnt === 1) pos = j\n      else break\n    }\n    if(cnt === 1 && c[pos] === 1) res++\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "532-k-diff-pairs-in-an-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nconst findPairs = function(nums, k) {\n    if(k < 0) return 0\n    let count = 0\n    const hash = {}\n    for(let i = 0; i < nums.length; i++) {\n        hash[nums[i]] = i\n    }\n    for(let i = 0; i < nums.length; i++) {\n        if(hash.hasOwnProperty(nums[i] + k) && hash[nums[i] + k] !== i) {\n           count++\n           delete hash[nums[i] + k]\n        }\n    }\n\n    return count\n};\n"
    }
  },
  {
    "name": "533-lonely-pixel-ii",
    "code": {
      "JS": "/**\n * @param {character[][]} picture\n * @param {number} N\n * @return {number}\n */\nconst findBlackPixel = function(picture, N) {\n  let m = []\n  for (let i = 0; i < picture.length; i++) {\n    let cnt = 0\n    let str = ''\n    for (let j = 0; j < picture[0].length; j++) {\n      if (picture[i][j] === 'W') continue\n      cnt++\n      if (cnt > N) break\n      str += j + ','\n    }\n    if (cnt === N) m[i] = str\n  }\n  let ans = 0\n  for (let j = 0; j < picture[0].length; j++) {\n    let cnt = 0\n    let rowStr = ''\n    for (let i = 0; i < picture.length; i++) {\n      if (picture[i][j] === 'W') continue\n      cnt++\n      if (cnt === 1) rowStr = m[i]\n      else if (cnt > N || m[i] !== rowStr) {\n        rowStr = ''\n        break\n      }\n    }\n    if (cnt === N && rowStr) ans += N\n  }\n  return ans\n}\n\n// another\n\n/**\n * @param {character[][]} picture\n * @param {number} N\n * @return {number}\n */\nconst findBlackPixel = function(picture, N) {\n  const rows = picture.length\n  if(rows === 0) return 0\n  const cols = picture[0].length\n  if(cols === 0) return 0\n  const m = new Map()\n  const colCnt = new Array(cols).fill(0)\n  for(let i = 0; i < rows; i++) {\n    const k = scanRow(picture, i, cols, N, colCnt)\n    if(k) {\n      m.set(k, (m.get(k) || 0) + 1)\n    }\n  }\n  let res = 0\n  for(let [k, v] of m) {\n    if(v === N) {\n      for(let i = 0; i < cols; i++) {\n        if(k[i] === 'B' && colCnt[i] === N) res += N\n      }\n    }\n  }\n  return res\n}\n\nfunction scanRow(p, r, cols, N, arr) {\n  let str = ''\n  let cnt = 0\n  for(let i = 0; i < cols; i++) {\n    if(p[r][i] === 'B') {\n      cnt++\n      arr[i] += 1\n    }\n    str += p[r][i]\n  }\n  if(cnt === N) return str\n  return ''\n}\n\n"
    }
  },
  {
    "name": "536-construct-binary-tree-from-string",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {string} s\n * @return {TreeNode}\n */\nconst str2tree = function(s) {\n  const stack = []\n  for (let i = 0, j = i; i < s.length; i++, j = i) {\n    const c = s.charAt(i)\n    if (c === ')') stack.pop()\n    else if ((c >= '0' && c <= '9') || c === '-') {\n      while (\n        i + 1 < s.length &&\n        s.charAt(i + 1) >= '0' &&\n        s.charAt(i + 1) <= '9'\n      )\n        i++\n      const currentNode = new TreeNode(+s.slice(j, i + 1))\n      if (stack.length) {\n        const parent = stack[stack.length - 1]\n        if (parent.left !== null) parent.right = currentNode\n        else parent.left = currentNode\n      }\n      stack.push(currentNode)\n    }\n  }\n  return stack.length === 0 ? null : stack[0]\n}\n"
    }
  },
  {
    "name": "538-convert-bst-to-greater-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nconst convertBST = function(root) {\n  const arr = []\n  traverse(root, arr)\n  for(let i = arr.length - 2; i >= 0; i--) {\n    arr[i].val += arr[i + 1].val\n  }\n  return root\n};\n\nfunction traverse(node, arr) {\n  if(node == null) return\n  traverse(node.right, arr)\n  arr.unshift(node)\n  traverse(node.left, arr)\n}\n\n\n// another\n\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nconst convertBST = function(root) {\n  const obj = {sum: 0}\n  traverse(root, obj)\n  return root\n};\n\nfunction traverse(node, obj) {\n  if(node == null) return\n  traverse(node.right, obj)\n  node.val += obj.sum\n  obj.sum = node.val\n  traverse(node.left, obj)\n}\n"
    }
  },
  {
    "name": "539-minimum-time-difference",
    "code": {
      "JS": "/**\r\n * @param {string[]} timePoints\r\n * @return {number}\r\n */\r\nconst findMinDifference = function(timePoints) {\r\n  const sortedArr = timePoints\r\n    .map(el => {\r\n      const arr = el.trim().split(\":\");\r\n      return arr[0] === \"00\" && arr[1] === \"00\"\r\n        ? 24 * 60\r\n        : +arr[0] * 60 + +arr[1];\r\n    })\r\n    .sort((a, b) => a - b);\r\n  let prev = sortedArr[0];\r\n  let res = Number.MAX_SAFE_INTEGER;\r\n  const mid = 12 * 60;\r\n  for (let i = 1; i < sortedArr.length; i++) {\r\n    res = Math.min(res, Math.abs(sortedArr[i] - prev));\r\n    prev = sortedArr[i];\r\n  }\r\n  if (sortedArr[0] < mid && sortedArr[sortedArr.length - 1] > mid) {\r\n    res = Math.min(\r\n      res,\r\n      sortedArr[0] + 2 * mid - sortedArr[sortedArr.length - 1]\r\n    );\r\n  }\r\n  return res;\r\n};\r\n\r\nconsole.log(findMinDifference([\"23:59\", \"00:00\"]));\r\nconsole.log(findMinDifference([\"12:12\", \"00:13\"]));\r\nconsole.log(findMinDifference([\"05:31\", \"22:08\", \"00:35\"]));\r\n"
    }
  },
  {
    "name": "54-spiral-matrix",
    "code": {
      "JS": "/**\n * @param {number[][]} matrix\n * @return {number[]}\n */\nconst spiralOrder = function(matrix) {\n    const res = []\n    let dir = 'top'\n    while(matrix.length) {\n        switch (dir) {\n            case 'top':\n                res.push(...matrix.shift())\n                dir = 'right'\n                break;\n            case 'right':\n                for(let i = 0; i < matrix.length - 1; ) {\n                    res.push(matrix[i].pop())\n                    if (matrix[i].length === 0) {\n                        matrix.splice(i, 1)\n                    } else {\n                        i++\n                    }\n                }\n                dir = 'bottom'\n                break;\n            case 'bottom':\n                res.push(...matrix.pop().reverse())\n                dir = 'left'\n                break;\n            case 'left':\n                for(let i = matrix.length - 1; i >= 0; i--) {\n                    res.push(matrix[i].shift())\n                    if (matrix[i].length === 0) {\n                        matrix.splice(i, 1)\n                    }\n                }\n                dir = 'top'\n                break;\n        }\n    }\n    return res\n};\n\n// another\n\n/**\n * @param {number[][]} matrix\n * @return {number[]}\n */\nconst spiralOrder = function(matrix) {\n  const res = [], m = matrix.length, n = matrix[0].length\n  const dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]\n  let di = 0, i = 0, j = 0, nx = 0, ny = 1\n  while(true) {\n    res.push(matrix[i][j])\n    matrix[i][j] = Infinity\n    if(chk(i, j)) {\n      if(di === 0 && (j + 1 >= n || matrix[i][j + 1] === Infinity)) {\n        i++\n        di = 1\n      } else if(di === 1 && (i + 1 >= m || matrix[i + 1][j] === Infinity)) {\n        j--\n        di = 2\n      } else if(di === 2 && (j - 1 < 0 || matrix[i][j - 1] === Infinity)) {\n        i--\n        di = 3\n      } else if(di === 3 && (i - 1 < 0 || matrix[i - 1][j] === Infinity)) {\n        j++\n        di = 0\n      } else {\n        i += dirs[di][0]\n        j += dirs[di][1]\n      }\n    } else break\n  }\n  return res\n\n  function chk(i, j) {\n    for(let dir of dirs) {\n      const nx = i + dir[0], ny = j + dir[1]\n      if(nx >= 0 && nx < matrix.length && ny >= 0 && ny < matrix[0].length && matrix[nx][ny] !== Infinity) return true\n    }\n    return false\n  } \n};\n  \n\n"
    }
  },
  {
    "name": "540-single-element-in-a-sorted-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst singleNonDuplicate = function(nums) {\n  let i = 0;\n  while (true) {\n    if (nums[i] == nums[i + 1]) {\n      i += 2;\n    } else {\n      return nums[i];\n    }\n  }\n};\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst singleNonDuplicate = function(nums) {\n  const n = nums.length\n  let left = 0, right = n - 1\n  while(left < right) {\n    const mid = left + ((right - left) >> 1)\n    if(nums[mid] === nums[mid ^ 1]) left = mid + 1\n    else right = mid\n  }\n  \n  return nums[left]\n};\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst singleNonDuplicate = function(nums) {\n  const n = nums.length\n  let left = 0, right = n - 1\n  while(left < right) {\n    const mid = ~~((left + right) / 2)\n    if((mid % 2 === 0 && nums[mid] === nums[mid + 1]) || (mid % 2 === 1 && nums[mid] === nums[mid - 1])) left = mid + 1\n    else right = mid\n  }\n  \n  return nums[left]\n};\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst singleNonDuplicate = function(nums) {\n  if(nums.length === 0) return 0\n  let res = nums[0]\n  for(let i = 1, len = nums.length; i < len; i++) {\n    res ^= nums[i]\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "541-reverse-string-ii",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {number} k\n * @return {string}\n */\nconst reverseStr = function(s, k) {\n  const arr = s.split('')\n  for(let i = 0, len = s.length; i < len; i += 2 * k) {\n    helper(arr, i, k)\n  }\n  return arr.join('')\n};\n\nfunction helper(arr, start, k) {\n  let s = start\n  let e = arr.length > start + k - 1 ? start + k - 1 : arr.length\n  while(s < e) {\n    swap(arr, s, e)\n    s++\n    e--\n  }\n}\n\nfunction swap(arr, s, e) {\n  const tmp = arr[s]\n  arr[s] = arr[e]\n  arr[e] = tmp\n}\n"
    }
  },
  {
    "name": "542-01-matrix",
    "code": {
      "JS": "/**\n * @param {number[][]} matrix\n * @return {number[][]}\n */\n\nconst updateMatrix = function (matrix) {\n    const rows = matrix.length, cols = matrix[0].length;\n    const maxDist = rows + cols;\n    let dist = new Array(rows).fill(null).map(() => new Array(cols).fill(0));\n  \n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < cols; j++) {\n        if (matrix[i][j] !== 0) {\n          dist[i][j] = hasNeighborZero(i, j, matrix, rows, cols) ? 1 : maxDist;\n        }\n      }\n    }\n  \n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < cols; j++) {\n        if (dist[i][j] === 1) {\n          dfs(dist, i, j, -1);\n        }\n      }\n    }\n  \n    return dist;\n  };\n  \n  const dfs = function (dist, row, col, step) {\n    if (row < 0 || row >= dist.length || col < 0 || col >= dist[0].length || dist[row][col] <= step) return;\n  \n    if (step > 0) dist[row][col] = step;\n  \n    dfs(dist, row + 1, col, dist[row][col] + 1);\n    dfs(dist, row - 1, col, dist[row][col] + 1);\n    dfs(dist, row, col + 1, dist[row][col] + 1);\n    dfs(dist, row, col - 1, dist[row][col] + 1);\n  };\n  \n  const hasNeighborZero = function (row, col, matrix, rows, cols) {\n    if (row < rows - 1 && matrix[row + 1][col] === 0) return true;\n    if (row > 0 && matrix[row - 1][col] === 0) return true;\n    if (col > 0 && matrix[row][col - 1] === 0) return true;\n    if (col < cols - 1 && matrix[row][col + 1] === 0) return true;\n  \n    return false;\n  };\n"
    }
  },
  {
    "name": "543-diameter-of-binary-tree",
    "code": {
      "JS": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nconst diameterOfBinaryTree = function (root) {\r\n  if (root === null) return 0\r\n  let longest = 0\r\n  function dfs(node) {\r\n    if (node === null) return 0\r\n    let leftmax = dfs(node.left)\r\n    let rightmax = dfs(node.right)\r\n    longest = Math.max(longest, leftmax + 1 + rightmax)\r\n    return Math.max(leftmax, rightmax) + 1\r\n  }\r\n  dfs(root)\r\n  return longest - 1\r\n}\r\n\r\n// another\r\n\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nconst diameterOfBinaryTree = function(root) {\r\n  let res = 0\r\n  dfs(root)\r\n  return res\r\n\r\n  function dfs(node) {\r\n    if(node == null) return 0\r\n    const left = dfs(node.left), right = dfs(node.right)\r\n    res = Math.max(res, left + right)\r\n    return Math.max(left, right) + 1\r\n  }\r\n};\r\n\r\n"
    }
  },
  {
    "name": "544-output-contest-matches",
    "code": {
      "JS": "/**\n\nDuring the NBA playoffs, we always arrange the rather strong team to play with the rather weak team,\nlike make the rank 1 team play with the rank nth team, which is a good strategy to make the contest more interesting.\nNow, you're given n teams, you need to output their final contest matches in the form of a string.\n\nThe n teams are given in the form of positive integers from 1 to n, which represents their initial rank.\n(Rank 1 is the strongest team and Rank n is the weakest team.)\nWe'll use parentheses('(', ')') and commas(',') to represent the contest team pairing - parentheses('(' , ')') for\npairing and commas(',') for partition. During the pairing process in each round,\nyou always need to follow the strategy of making the rather strong one pair with the rather weak one.\n\nExample 1:\nInput: 2\nOutput: (1,2)\nExplanation: \nInitially, we have the team 1 and the team 2, placed like: 1,2.\nThen we pair the team (1,2) together with '(', ')' and ',', which is the final answer.\nExample 2:\nInput: 4\nOutput: ((1,4),(2,3))\nExplanation: \nIn the first round, we pair the team 1 and 4, the team 2 and 3 together, as we need to make the strong team and weak team together.\nAnd we got (1,4),(2,3).\nIn the second round, the winners of (1,4) and (2,3) need to play again to generate the final winner,\nso you need to add the paratheses outside them.\nAnd we got the final answer ((1,4),(2,3)).\nExample 3:\nInput: 8\nOutput: (((1,8),(4,5)),((2,7),(3,6)))\nExplanation: \nFirst round: (1,8),(2,7),(3,6),(4,5)\nSecond round: ((1,8),(4,5)),((2,7),(3,6))\nThird round: (((1,8),(4,5)),((2,7),(3,6)))\nSince the third round will generate the final winner, you need to output the answer (((1,8),(4,5)),((2,7),(3,6))).\nNote:\nThe n is in range [2, 212].\nWe ensure that the input n can be converted into the form 2k, where k is a positive integer.\n\n*/\n\n/**\n * @param {number} n\n * @return {string}\n */\nconst findContestMatch = function(n) {\n  const arr = []\n  for(let i = 0; i < n; i++) {\n    arr[i] = i + 1\n  }\n  while(n > 1) {\n    for(let i = 0; i < (n >> 1); i++) {\n      arr[i] = `(${arr[i]},${arr[n - 1 - i]})`\n    }\n    n = n >> 1\n  }\n  return arr[0]\n};\n\n// another\n\n/**\n * @param {number} n\n * @return {string}\n */\nconst findContestMatch = function(n) {\n  const arr = []\n  for(let i = 0; i < n; i++) {\n    arr[i] = i + 1\n  }\n  let l = 0\n  let r = n - 1\n  while(l < r) {\n    while(l < r) {\n      arr[l] = `(${arr[l]},${arr[r]})`\n      l++\n      r--\n    }\n    l = 0\n  }\n  return arr[0]\n};\n"
    }
  },
  {
    "name": "545-boundary-of-binary-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nconst boundaryOfBinaryTree = function (root) {\n  if (!root) return []\n  if (!root.left && !root.right) return [root.val]\n  const res = [root.val]\n  buildSide(root.left, 'left', res)\n  buildBottom(root, res)\n  const right = []\n  buildSide(root.right, 'right', right)\n  return [...res, ...right.reverse()]\n}\n\nfunction buildSide(root, side, res) {\n  if (!root) return\n  if (root.left || root.right) res.push(root.val)\n  if (root[side]) buildSide(root[side], side, res)\n  else buildSide(root[side === 'left' ? 'right' : 'left'], side, res)\n}\n\nfunction buildBottom(root, res) {\n  if (!root) return\n  if (!root.left && !root.right) res.push(root.val)\n  buildBottom(root.left, res)\n  buildBottom(root.right, res)\n}\n"
    }
  },
  {
    "name": "546-remove-boxes",
    "code": {
      "JS": "/**\n * @param {number[]} boxes\n * @return {number}\n */\nconst removeBoxes = function(boxes) {\n    const n = boxes.length\n    const dp = Array.from(new Array(n), () => {\n        return Array.from(new Array(n), () => {\n            return new Array(n).fill(0)\n        })\n    })\n    return removeBoxesSub(boxes, 0, n - 1, 0, dp)\n};\n\nfunction removeBoxesSub(boxes, i, j, k, dp) {\n    if(i > j) return 0;\n    if(dp[i][j][k] > 0) return dp[i][j][k]\n    for(; i + 1 <= j && boxes[i+1] === boxes[i] ; i++, k++) {\n        // optimization: all boxes of the same color counted continuously from the first box should be grouped together\n    }\n    let res = (k+1) * (k+1) + removeBoxesSub(boxes, i + 1, j, 0, dp)\n    for(let m = i + 1; m <= j; m++) {\n        if(boxes[i] === boxes[m]) {\n            res = Math.max(res, removeBoxesSub(boxes, i + 1, m - 1, 0, dp) + removeBoxesSub(boxes, m, j, k + 1, dp) )\n        }\n    }\n    dp[i][j][k] = res\n    return res\n}\n"
    }
  },
  {
    "name": "547-friend-circles",
    "code": {
      "JS": "/**\n * @param {number[][]} M\n * @return {number}\n */\nconst findCircleNum = function(M) {\n  let count = 0\n  const visited = {}\n  const dfs = function(M, i) {\n    for (let j = 0; j < M[i].length; j++) {\n      if (M[i][j] == 1 && !visited[j]) {\n        visited[j] = true\n        dfs(M, j)\n      }\n    }\n  }\n  for (let i = 0; i < M.length; i++) {\n    if (!visited[i]) {\n      dfs(M, i)\n      count++\n    }\n  }\n  return count\n}\n"
    }
  },
  {
    "name": "548-split-array-with-equal-sum",
    "code": {
      "JS": "/**\n\nGiven an array with n integers, you need to find if there are triplets (i, j, k) which satisfies following conditions:\n0 < i, i + 1 < j, j + 1 < k < n - 1\nSum of subarrays (0, i - 1), (i + 1, j - 1), (j + 1, k - 1) and (k + 1, n - 1) should be equal.\nwhere we define that subarray (L, R) represents a slice of the original array starting\nfrom the element indexed L to the element indexed R.\n\nExample:\n\nInput: [1,2,1,2,1,2,1]\nOutput: True\nExplanation:\ni = 1, j = 3, k = 5. \nsum(0, i - 1) = sum(0, 0) = 1\nsum(i + 1, j - 1) = sum(2, 2) = 1\nsum(j + 1, k - 1) = sum(4, 4) = 1\nsum(k + 1, n - 1) = sum(6, 6) = 1\n\nNote:\n1 <= n <= 2000.\nElements in the given array will be in range [-1,000,000, 1,000,000].\n\n*/\n\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\nconst splitArray = function(nums) {\n  if (nums.length < 7) return false\n  const len = nums.lenght\n  const sum = new Array(len.length).fill(0)\n  sum[0] = nums[0]\n  for (let i = 1; i < len; i++) {\n    sum[i] = sum[i - 1] + nums[i]\n  }\n  for (let j = 3; j < len - 3; j++) {\n    const set = new Set()\n    for (let i = 1; i < j - 1; i++) {\n      if (sum[i - 1] === sum[j - 1] - sum[i]) set.add(sum[i - 1])\n    }\n    for (let k = j + 2; k < len - 1; k++) {\n      if (\n        sum[len - 1] - sum[k] === sum[k - 1] - sum[j] &&\n        set.has(sum[k - 1] - sum[j])\n      )\n        return true\n    }\n  }\n  return false\n}\n"
    }
  },
  {
    "name": "549-binary-tree-longest-consecutive-sequence-ii",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nconst longestConsecutive = function (root, res = { val: 0 }) {\n  if (root === null) return 0;\n  let ans = 0;\n  function f(node) {\n    let inc = 1,\n      dec = 1;\n    const child = [node.left, node.right];\n    for (let c of child) {\n      if (c === null) continue;\n      let r = f(c);\n      if (node.val + 1 === c.val) inc = Math.max(inc, r[0] + 1);\n      else if (node.val - 1 === c.val) dec = Math.max(dec, r[1] + 1);\n    }\n    ans = Math.max(ans, inc + dec - 1);\n    return [inc, dec];\n  }\n  f(root);\n  return ans;\n};\n"
    }
  },
  {
    "name": "55-jump-game",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nconst canJump = function(nums) {\n  let max = 0\n  for(let i = 0, len = nums.length; i < len; i++) {\n    if(i <= max && nums[i] > 0) {\n      max = Math.max(max, i + nums[i])\n    }\n  }\n  return max >= nums.length - 1\n};\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\nconst canJump = function(nums) {\n  let max = 0\n  const n = nums.length\n  for(let i = 0; i < n; i++) {\n    if(max < i) return false\n    max = Math.max(max, i + nums[i])\n    if(max >= n - 1) return true\n  }\n};\n"
    }
  },
  {
    "name": "551-student-attendance-record-i",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {boolean}\n */\nconst checkRecord = function(s) {\n  let anum = 0\n  let plidx = -1\n  for(let i = 0, len = s.length; i < len; i++) {\n    if(s[i] === 'A') anum++\n    if(anum > 1) return false\n    if(s[i] === 'L') {\n      if(i === 0) plidx = 0\n      else if(s[i - 1] === 'L') {\n        if(i - plidx + 1 > 2) return false\n      } else {\n        plidx = i\n      }\n    }\n  }\n  return true\n};\n"
    }
  },
  {
    "name": "552-student-attendance-record-ii",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst checkRecord = function(n) {\n  let P = 1\n  let L1 = 1\n  let L2 = 0\n  let A = 1\n  let pureP = 1\n  let pureL1 = 1\n  let pureL2 = 0\n  const mod = 10 ** 9 + 7\n\n  for (let i = 2; i < n + 1; i++) {\n    const newP = (P + L1 + L2 + A) % mod\n    const newL1 = (P + A) % mod\n    const newL2 = L1\n    const newA = (pureP + pureL1 + pureL2) % mod\n    P = newP\n    L1 = newL1\n    L2 = newL2\n    A = newA\n    const newPureP = (pureP + pureL1 + pureL2) % mod\n    const newPureL1 = pureP\n    const newPureL2 = pureL1\n    pureP = newPureP\n    pureL1 = newPureL1\n    pureL2 = newPureL2\n  }\n  return (P + L1 + L2 + A) % (10 ** 9 + 7)\n}\n"
    }
  },
  {
    "name": "553-optimal-division",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {string}\n */\nconst optimalDivision = function(nums) {\n  const len = nums.length\n  if(len <= 2) return len === 2 ? `${nums[0]}/${nums[1]}` : nums.join('')\n  let res = `${nums[0]}/(${nums[1]}`\n  for(let i = 2; i < len; i++) {\n    res += `/${nums[i]}`\n  }\n  return res + ')'\n};\n"
    }
  },
  {
    "name": "554-brick-wall",
    "code": {
      "JS": "/**\r\n * @param {number[][]} wall\r\n * @return {number}\r\n */\r\nconst leastBricks = function(wall) {\r\n  const hash = {};\r\n  let row;\r\n  let rowSum = 0;\r\n  for (let i = 0; i < wall.length; i++) {\r\n    rowSum = 0;\r\n    row = wall[i];\r\n    for (let j = 0; j < row.length - 1; j++) {\r\n      rowSum += row[j];\r\n      hash[rowSum] = hash.hasOwnProperty(rowSum) ? hash[rowSum] + 1 : 1;\r\n    }\r\n  }\r\n  return (\r\n    wall.length -\r\n    (Object.keys(hash).length > 0\r\n      ? Math.max(...Object.keys(hash).map(key => hash[key]))\r\n      : 0)\r\n  );\r\n};\r\n\r\nconsole.log(leastBricks([[1], [1], [1]]));\r\n"
    }
  },
  {
    "name": "555-split-concatenated-strings",
    "code": {
      "JS": "/**\n * @param {string[]} strs\n * @return {string}\n */\nconst splitLoopedString = function (strs) {\n  let ans = ''\n  const n = strs.length\n  if (n === 0) return ''\n  findMaxStrings(strs)\n  for (let i = 0; i < n; ++i) {\n    solve(strs, i, true)\n    solve(strs, i, false)\n  }\n  return ans\n  function findMaxStrings(strs) {\n    for (let i = 0; i < n; ++i) {\n      const temp = strs[i].split('').reverse().join('')\n      strs[i] = strs[i] > temp ? strs[i] : temp\n    }\n  }\n  function solve(strs, i, flag) {\n    let temp = strs[i]\n    if (flag) {\n      temp = temp.split('').reverse().join('')\n    }\n    let size = temp.length\n    let str1 = '',\n      str2 = ''\n    for (let j = i + 1; j < n; ++j) str1 += strs[j]\n    for (let j = 0; j < i; ++j) str2 += strs[j]\n    for (let k = 0; k < size; ++k) {\n      let newOne = temp.substr(k) + str1 + str2 + temp.substr(0, k)\n      ans = ans === '' ? newOne : ans > newOne ? ans : newOne\n    }\n  }\n}\n"
    }
  },
  {
    "name": "556-next-greater-element-iii",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst nextGreaterElement = function(n) {\n  let i, j;\n  const arr = (n + \"\").split(\"\").map(el => +el);\n  for (i = arr.length - 2; i >= 0; i--) {\n    if (arr[i] < arr[i + 1]) {\n      break;\n    }\n  }\n  if (i < 0) return -1;\n  j = arr.length - 1;\n  while (arr[j] <= arr[i]) {\n    j--;\n  }\n  swap(arr, i, j);\n  reverse(arr, i + 1, arr.length - 1);\n\n  const res = arr.reduce((ac, el) => ac + el, \"\");\n  return res > Math.pow(2, 31) - 1 ? -1 : +res\n};\n\nfunction swap(arr, i, j) {\n  arr[i] ^= arr[j];\n  arr[j] ^= arr[i];\n  arr[i] ^= arr[j];\n}\n\nfunction reverse(arr, start, end) {\n  let l = start;\n  let h = end;\n  while (l < h) {\n    swap(arr, l++, h--);\n  }\n}\n"
    }
  },
  {
    "name": "558-logical-or-of-two-binary-grids-represented-as-quad-trees",
    "code": {
      "JS": "/**\n * // Definition for a QuadTree node.\n * function Node(val,isLeaf,topLeft,topRight,bottomLeft,bottomRight) {\n *    this.val = val;\n *    this.isLeaf = isLeaf;\n *    this.topLeft = topLeft;\n *    this.topRight = topRight;\n *    this.bottomLeft = bottomLeft;\n *    this.bottomRight = bottomRight;\n * };\n */\n/**\n * @param {Node} quadTree1\n * @param {Node} quadTree2\n * @return {Node}\n */\nconst intersect = function (quadTree1, quadTree2) {\n  if (quadTree1.isLeaf) {\n    return quadTree1.val ? quadTree1 : quadTree2;\n  }\n\n  if (quadTree2.isLeaf) {\n    return quadTree2.val ? quadTree2 : quadTree1;\n  }\n\n  const topLeft = intersect(quadTree1.topLeft, quadTree2.topLeft);\n  const topRight = intersect(quadTree1.topRight, quadTree2.topRight);\n  const bottomLeft = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);\n  const bottomRight = intersect(quadTree1.bottomRight, quadTree2.bottomRight);\n\n  if (\n    topLeft.isLeaf &&\n    topRight.isLeaf &&\n    bottomLeft.isLeaf &&\n    bottomRight.isLeaf &&\n    topLeft.val == topRight.val &&\n    topRight.val == bottomLeft.val &&\n    bottomLeft.val == bottomRight.val\n  ) {\n    return new Node(topLeft.val, true, null, null, null, null);\n  } else {\n    return new Node(false, false, topLeft, topRight, bottomLeft, bottomRight);\n  }\n};\n"
    }
  },
  {
    "name": "559-maximum-depth-of-n-ary-tree",
    "code": {
      "JS": "/**\n * // Definition for a Node.\n * function Node(val,children) {\n *    this.val = val;\n *    this.children = children;\n * };\n */\n/**\n * @param {Node} root\n * @return {number}\n */\nconst maxDepth = function(root) {\n  let max = 0\n  if(root == null) return 0\n  function dfs(node, depth) {\n    if(node == null || node.children.length === 0) {\n      depth++\n      if(depth > max) max = depth\n      return\n    }\n    depth++\n    for(let n of node.children) {\n      dfs(n, depth)\n    }\n  }\n  dfs(root, 0)\n  return max\n};\n"
    }
  },
  {
    "name": "56-merge-intervals",
    "code": {
      "JS": "/**\n * @param {number[][]} intervals\n * @return {number[][]}\n */\nconst merge = function(intervals) {\n  if(intervals == null || intervals.length === 0) return []\n  intervals.sort((a, b) => a[0] === b[0] ? a[1] - b[1] : a[0] - b[0])\n  const res = [intervals[0]]\n  for(let i = 1, n = intervals.length; i < n; i++) {\n    const last = res[res.length - 1]\n    const lastEnd = last[1]\n    const [s, e] = intervals[i]\n    if(s > lastEnd) {\n      res.push(intervals[i])\n    } else {\n      last[1] = Math.max(last[1], e)\n    }\n  }\n  return res\n};\n\n// another\n\n/**\n * Definition for an interval.\n * function Interval(start, end) {\n *     this.start = start;\n *     this.end = end;\n * }\n */\n/**\n * @param {Interval[]} intervals\n * @return {Interval[]}\n */\nconst merge = function(intervals) {\n    const hash = {}\n    intervals.forEach(el => {\n        if (hash.hasOwnProperty(el.start)) {\n            hash[el.start][1] = Math.max(hash[el.start][1], el.end)\n        } else {\n            hash[el.start] = [el.start, el.end]\n        }\n    })\n\n    const startArr = Object.keys(hash).sort((a, b) => +a - +b)\n    const res = []\n\n    while(startArr.length) {\n        let start = startArr.shift()\n        let end = hash[start][1]\n        \n        for(let i = 0; i < startArr.length; ) {\n            if (+startArr[i] <= end) {\n                end = Math.max(end, hash[startArr[i]][1])\n                startArr.shift()\n            } else {\n                break\n            }\n        }\n        let ins = new Interval(+start, end)\n        res.push(ins)\n\n    }\n    return res\n};\n"
    }
  },
  {
    "name": "560-subarray-sum-equals-k",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nconst subarraySum = function(nums, k) {\n  let totalNum = 0\n  const map = new Map()\n  let cumulativeSum = 0\n  map.set(0, 1)\n  for (let i = 0, len = nums.length; i < len; i++) {\n    cumulativeSum += nums[i]\n    if (map.get(cumulativeSum - k)) {\n      totalNum += map.get(cumulativeSum - k)\n    }\n    if (map.get(cumulativeSum)) {\n      map.set(cumulativeSum, map.get(cumulativeSum) + 1)\n    } else {\n      map.set(cumulativeSum, 1)\n    }\n  }\n  return totalNum\n}\n\n// another\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nconst subarraySum = function (nums, k) {\n  const n = nums.length, hash = { 0: 1 }\n  let pre = 0\n  let res = 0\n  for (let i = 0; i < n; i++) {\n    const cur = pre + nums[i]\n    if (hash[cur - k] != null) res += hash[cur - k]\n    hash[cur] = (hash[cur] || 0) + 1\n    pre = cur\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "562-longest-line-of-consecutive-one-in-matrix",
    "code": {
      "JS": "/**\n * @param {number[][]} M\n * @return {number}\n */\nconst longestLine = function (M) {\n  const m = M.length\n  if (!m) return 0\n  const n = M[0].length\n  if (!n) return 0\n\n  const DP = [...Array(m)].map(() => [...Array(n)].map(() => [0, 0, 0, 0]))\n  let max = 0\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (M[i][j]) {\n        DP[i][j][0] = (i ? DP[i - 1][j][0] : 0) + 1\n        DP[i][j][1] = (j < n - 1 && i ? DP[i - 1][j + 1][1] : 0) + 1\n        DP[i][j][2] = (j && i ? DP[i - 1][j - 1][2] : 0) + 1\n        DP[i][j][3] = (j ? DP[i][j - 1][3] : 0) + 1\n        max = Math.max(max, ...DP[i][j])\n      }\n    }\n  }\n  return max\n}\n"
    }
  },
  {
    "name": "563-binary-tree-tilt",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nconst findTilt = function(root) {\n  const tilt = { val: 0 }\n  dfs(root, tilt)\n  function dfs(root, tilt) {\n    if (!root) return 0\n    let left = dfs(root.left, tilt)\n    let right = dfs(root.right, tilt)\n    tilt.val += Math.abs(left - right)\n    return root.val + left + right\n  }\n  return tilt.val\n}\n"
    }
  },
  {
    "name": "564-find-the-closest-palindrome",
    "code": {
      "JS": "/**\n * @param {bigint | string} n\n * @return {string}\n */\nconst nearestPalindromic = function(n) {\n  let bigInt = null\n\n  if (typeof n === 'bigint') bigInt = n\n  if (typeof n === 'string') bigInt = BigInt(n)\n  if (typeof n == null) throw new Error('unknown input type')\n\n  // take the number, keep adding 1 to it, then check if it's a palindrome\n  const prevPalindrome = getPrevPalindrome(bigInt)\n  const nextPalindrome = getNextPalindrome(bigInt)\n\n  const scalarPrev = bigInt - prevPalindrome\n  const scalarNext = nextPalindrome - bigInt\n\n  if (scalarPrev <= scalarNext) return prevPalindrome.toString()\n  else return nextPalindrome.toString()\n}\n\n/**\n *\n * @param {bigint} number\n */\nfunction getPrevPalindrome(number) {\n  const decrementedNumber =\n    typeof number === 'bigint' ? number - BigInt(1) : BigInt(number) - BigInt(1)\n\n  if (decrementedNumber.toString().length === 1) return decrementedNumber\n\n  const leftSide = getLeftSideNumber(decrementedNumber)\n  const palindromedLeft = getPalindromeAsString(leftSide)\n\n  const rightSide = getRightSideNumberAsString(decrementedNumber)\n  const comparison = compareTwoValues(BigInt(palindromedLeft), BigInt(rightSide))\n  if (comparison === 0) {\n    // the right side is already the palindromedLeft - return the incrementedNumber\n    return decrementedNumber\n  }\n  if (comparison === 1) {\n    // this means the right side is already too far advanced (going downwards) compared to the palindromedLeft,\n    // you need to take the leftSideWithBorder, decrement by 1, then return this new number concatenated with\n    // the leftSide's palindrome - this is the answer\n    const leftWithBorder = getLeftSideNumberWithBorder(decrementedNumber)\n    const decremented = leftWithBorder - BigInt(1)\n\n    if (decremented === BigInt(0)) return BigInt(9)\n\n    const newWhole = BigInt(decremented.toString() + getRightSideNumberAsString(decrementedNumber))\n\n    const newLeft = getLeftSideNumber(newWhole)\n    const palindromedNewLeft = getPalindromeAsString(newLeft)\n    return BigInt(decremented.toString() + palindromedNewLeft.toString())\n  }\n  if (comparison === -1) {\n    // this means the right side can naturally increment to the palindromedLeft,\n    // so you can just return the leftSideWithBorder concatenated with the palindromedLeft\n    const leftSideWithBorder = getLeftSideNumberWithBorder(decrementedNumber)\n    return BigInt(leftSideWithBorder.toString() + palindromedLeft)\n  }\n}\n\n/**\n *\n * @param {bigint} number\n * @returns {*}\n */\nfunction getNextPalindrome(number) {\n  const incrementedNumber =\n    typeof number === 'bigint' ? number + BigInt(1) : BigInt(number) + BigInt(1)\n\n  if (incrementedNumber.toString().length === 1) return incrementedNumber\n\n  const leftSide = getLeftSideNumber(incrementedNumber)\n  const palindromedLeft = getPalindromeAsString(leftSide)\n\n  const rightSide = getRightSideNumberAsString(incrementedNumber)\n  const comparison = compareTwoValues(BigInt(palindromedLeft), BigInt(rightSide))\n  if (comparison === 0) {\n    // the right side is already the palindromedLeft - return the incrementedNumber\n    return incrementedNumber\n  }\n  if (comparison === 1) {\n    // this means the right side can naturally increment to the palindromedLeft,\n    // so you can just return the leftSideWithBorder concatenated with the palindromedLeft\n    const leftSideWithBorder = getLeftSideNumberWithBorder(incrementedNumber)\n    const leftAsString = leftSideWithBorder.toString()\n    const combined = leftAsString + palindromedLeft\n    return BigInt(combined)\n  }\n  if (comparison === -1) {\n    // this means the right side is already too far advanced compared to the palindromedLeft,\n    // you need to take the leftSideWithBorder, increment by 1, then return this new number concatenated with\n    // the leftSide's palindrome - this is the answer\n    const leftWithBorder = getLeftSideNumberWithBorder(incrementedNumber)\n    const incrementedLeftWithBorder = leftWithBorder + BigInt(1)\n    const newWhole = BigInt(\n      incrementedLeftWithBorder.toString() + getRightSideNumberAsString(incrementedNumber)\n    )\n\n    const newLeft = getLeftSideNumber(newWhole)\n    const palindromedNewLeft = getPalindromeAsString(newLeft)\n    return BigInt(incrementedLeftWithBorder.toString() + palindromedNewLeft.toString())\n  }\n}\n\n/**\n *\n * @param {bigint} number\n */\nfunction getLeftSideNumber(number) {\n  const numberAsText = number.toString()\n  const numCharsInLeftSide = Math.floor(numberAsText.length / 2)\n  return BigInt(numberAsText.slice(0, numCharsInLeftSide))\n}\n\n/**\n *\n * @param {bigint} number\n * @returns {bigint}\n */\nfunction getLeftSideNumberWithBorder(number) {\n  const numberAsText = number.toString()\n  const hasOddNumChars = numberAsText.length % 2 === 1\n\n  const left = getLeftSideNumber(number)\n\n  // should return the left side only, if it's an even-digited number\n  // else, return the left side together with the border number (since it's an odd-digited number)\n  if (hasOddNumChars) {\n    const middleChar = numberAsText.charAt(Math.floor(numberAsText.length / 2))\n    return BigInt(left.toString() + middleChar)\n  } else {\n    return BigInt(left.toString())\n  }\n}\n\n/**\n *\n * @param {bigint} number\n * @returns {string}\n */\nfunction getRightSideNumberAsString(number) {\n  const numberAsText = number.toString()\n  const numCharsInRightSide = Math.floor(numberAsText.length / 2)\n  return numberAsText.slice(numberAsText.length - numCharsInRightSide)\n}\n\n/**\n *\n * @param {bigint} number\n * @returns {string}\n */\nfunction getPalindromeAsString(number) {\n  const numberAsText = number.toString()\n  return numberAsText\n    .split('')\n    .reverse()\n    .join('')\n}\n\n/**\n *\n * @param {bigint} number1\n * @param {bigint} number2\n * @returns {number}\n */\nfunction compareTwoValues(number1, number2) {\n  if (number1 < number2) return -1\n  if (number1 === number2) return 0\n  if (number1 > number2) return 1\n}\n"
    }
  },
  {
    "name": "565-array-nesting",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nconst arrayNesting = function(nums) {\r\n  let res = 0;\r\n  for (let i = 0; i < nums.length; i++) {\r\n    if (nums[i] !== Number.MAX_SAFE_INTEGER) {\r\n      let start = nums[i],\r\n        count = 0;\r\n      while (nums[start] !== Number.MAX_SAFE_INTEGER) {\r\n        let temp = start;\r\n        start = nums[start];\r\n        count++;\r\n        nums[temp] = Number.MAX_SAFE_INTEGER;\r\n      }\r\n      res = Math.max(res, count);\r\n    }\r\n  }\r\n  return res;\r\n};\r\n"
    }
  },
  {
    "name": "566-reshape-the-matrix",
    "code": {
      "JS": "/**\r\n * @param {number[][]} nums\r\n * @param {number} r\r\n * @param {number} c\r\n * @return {number[][]}\r\n */\r\nconst matrixReshape = function(nums, r, c) {\r\n  if (isValid(nums, r, c) === false) {\r\n    return nums;\r\n  }\r\n  const arr = [];\r\n  nums.forEach(el => arr.push(...el));\r\n  const res = [];\r\n  for (let start = 0; start < arr.length; start = start + c) {\r\n    res.push(arr.slice(start, start + c));\r\n  }\r\n  return res;\r\n};\r\n\r\nfunction isValid(matrix, r, c) {\r\n  if (matrix.length * matrix[0].length !== r * c) {\r\n    return false;\r\n  } else {\r\n    return true;\r\n  }\r\n}\r\n\r\nconsole.log(matrixReshape([[1, 2], [3, 4]], 1, 4));\r\nconsole.log(matrixReshape([[1, 2], [3, 4]], 2, 4));\r\n"
    }
  },
  {
    "name": "567-permutation-in-string",
    "code": {
      "JS": "/**\n * @param {string} s1\n * @param {string} s2\n * @return {boolean}\n */\nconst checkInclusion = function(s1, s2) {\n  if(s1.length > s2.length) return false\n  const s1map = new Array(26).fill(0)\n  const s2map = new Array(26).fill(0)\n  const aCode = ('a').charCodeAt(0)\n  const zCode = ('z').charCodeAt(0)\n  \n  for(let i = 0; i < s1.length; i++) {\n    s1map[s1.charCodeAt(i) - aCode]++\n    s2map[s2.charCodeAt(i) - aCode]++\n  }\n  \n  for(let i = 0; i < s2.length - s1.length; i++) {\n    if(matches(s1map, s2map)) return true\n    s2map[s2.charCodeAt(i + s1.length) - aCode]++\n    s2map[s2.charCodeAt(i) - aCode]--\n  }\n  \n  return matches(s1map, s2map)\n  \n};\n\nfunction matches(s1map, s2map) {\n  for(let i = 0; i < 26; i++) {\n    if(s1map[i] !== s2map[i]) return false\n  }\n  return true\n}\n\n\n// another\n\n/**\n * @param {string} s1\n * @param {string} s2\n * @return {boolean}\n */\nconst checkInclusion = function(s1, s2) {\n  const arr = Array(26).fill(0)\n  const a = 'a'.charCodeAt(0)\n  const s1l = s1.length\n  for(let c of s1) arr[c.charCodeAt(0) - a] += 1\n  for(let i = 0, len = s2.length; i < len; i++) {\n    const tmp = s2[i]\n    arr[tmp.charCodeAt(0) - a]--\n    if(i >= s1l - 1) {\n      if(allZeros(arr)) return true\n      arr[s2.charCodeAt(i - s1l + 1) - a]++\n    }\n    \n  }\n  \n  return false\n};\n\nfunction allZeros(arr) {\n  for(let e of arr) {\n    if(e !== 0) return false\n  }\n  return true\n}\n"
    }
  },
  {
    "name": "568-maximum-vacation-days",
    "code": {
      "JS": "/**\n * @param {number[][]} flights\n * @param {number[][]} days\n * @return {number}\n */\nconst maxVacationDays = function (flights, days) {\n  const N = flights.length\n  let dp = new Array(N).fill(0)\n  for (let k = days[0].length - 1; k >= 0; k--) {\n    const tmp = new Array(N)\n    for (let i = 0; i < N; i++) {\n      tmp[i] = days[i][k] + dp[i]\n      for (let j = 0; j < N; j++) {\n        if (flights[i][j] === 0) continue\n        tmp[i] = Math.max(tmp[i], days[j][k] + dp[j])\n      }\n    }\n    dp = tmp\n  }\n  return dp[0]\n}\n"
    }
  },
  {
    "name": "57-insert-interval",
    "code": {
      "JS": "/**\n * @param {number[][]} intervals\n * @param {number[]} newInterval\n * @return {number[][]}\n */\nconst insert = function(intervals, newInterval) {\n  let i = 0\n  while (i < intervals.length && intervals[i][1] < newInterval[0]) i++\n  while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\n    newInterval[0] = Math.min(newInterval[0], intervals[i][0])\n    newInterval[1] = Math.max(newInterval[1], intervals[i][1])\n    intervals.splice(i, 1)\n  }\n  intervals.splice(i, 0, newInterval)\n  return intervals\n}\n"
    }
  },
  {
    "name": "572-subtree-of-another-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} s\n * @param {TreeNode} t\n * @return {boolean}\n */\nconst isSubtree = function(s, t) {\n    if (s == null) return false \n    if (isSame(s, t)) return true\n    return isSubtree(s.left, t) || isSubtree(s.right, t)      \n};\n\nfunction isSame(s, t) {\n    if (s == null && t == null) return true\n    if (s == null || t == null) return false\n    if (s.val !== t.val) return false\n    return isSame(s.left, t.left) && isSame(s.right, t.right)\n}\n"
    }
  },
  {
    "name": "573-squirrel-simulation",
    "code": {
      "JS": "/**\n * @param {number} height\n * @param {number} width\n * @param {number[]} tree\n * @param {number[]} squirrel\n * @param {number[][]} nuts\n * @return {number}\n */\nconst minDistance = function(height, width, tree, squirrel, nuts) {\n  const arr = nuts.map(el => 2 * distance(el, tree))\n  const sum = arr.reduce((ac, el) => ac + el, 0)\n  let res = Number.MAX_VALUE\n  for(let i = 0, len = arr.length; i < len; i++) {\n    let tmp = sum - arr[i] + distance(squirrel, nuts[i]) + distance(nuts[i], tree)\n    res = Math.min(res, tmp)\n  }\n  return res\n};\n\nfunction distance(p1, p2) {\n  return Math.abs(p1[0] - p2[0]) + Math.abs(p1[1] - p2[1])\n}\n\n// another\n\n/**\n * @param {number} height\n * @param {number} width\n * @param {number[]} tree\n * @param {number[]} squirrel\n * @param {number[][]} nuts\n * @return {number}\n */\nconst minDistance = function (height, width, tree, squirrel, nuts) {\n  let sum = 0,\n    maxDiff = -Number.MAX_VALUE\n  for (let nut of nuts) {\n    const dist = Math.abs(tree[0] - nut[0]) + Math.abs(tree[1] - nut[1])\n    sum += 2 * dist\n    maxDiff = Math.max(\n      maxDiff,\n      dist - Math.abs(squirrel[0] - nut[0]) - Math.abs(squirrel[1] - nut[1])\n    )\n  }\n  return sum - maxDiff\n}\n"
    }
  },
  {
    "name": "5745-last-day-where-you-can-still-cross",
    "code": {
      "JS": "/**\n * @param {number} row\n * @param {number} col\n * @param {number[][]} cells\n * @return {number}\n */\nconst latestDayToCross = function (row, col, cells) {\n  const d = [\n    [-1, 0],\n    [1, 0],\n    [0, 1],\n    [0, -1],\n  ]\n\n  let a = Array.from({ length: row }, () => Array(col).fill(0))\n  let visited = Array.from({ length: row }, () => Array(col).fill(false))\n\n  for (let i = 0; i < cells.length; i++) {\n    a[cells[i][0] - 1][cells[i][1] - 1] = i\n  }\n\n  let l = 0\n  let r = row * col\n  while (l + 1 < r) {\n    let w = ~~((l + r) / 2)\n    if (canCross(w)) {\n      l = w\n    } else {\n      r = w\n    }\n  }\n\n  return l\n\n  function canReachBottom(i, j, day) {\n    if (i == row - 1) {\n      return true\n    }\n    visited[i][j] = true\n\n    for (let diff of d) {\n      let newI = i + diff[0]\n      let newJ = j + diff[1]\n\n      if (newI < 0 || newI >= row || newJ < 0 || newJ >= col) {\n        continue\n      }\n\n      if (visited[newI][newJ] || a[newI][newJ] < day) {\n        continue\n      }\n\n      if (canReachBottom(newI, newJ, day)) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  function canCross(day) {\n    for (let layer of visited) {\n      layer.forEach((e, idx) => (layer[idx] = false))\n    }\n\n    for (let j = 0; j < col; j++) {\n      if (a[0][j] >= day && canReachBottom(0, j, day)) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\n\n"
    }
  },
  {
    "name": "575-distribute-candies",
    "code": {
      "JS": "/**\r\n * @param {number[]} candies\r\n * @return {number}\r\n */\r\nconst distributeCandies = function(candies) {\r\n  const uniqNum = candies.filter((el, idx, arr) => arr.indexOf(el) === idx)\r\n    .length;\r\n  const halfNum = candies.length / 2;\r\n  return halfNum > uniqNum ? uniqNum : halfNum;\r\n};\r\n\r\nconsole.log(distributeCandies([1, 1, 2, 2, 3, 3]));\r\nconsole.log(distributeCandies([1, 1, 2, 3]));\r\n"
    }
  },
  {
    "name": "576-out-of-boundary-paths",
    "code": {
      "JS": "/**\n * @param {number} m\n * @param {number} n\n * @param {number} N\n * @param {number} i\n * @param {number} j\n * @return {number}\n */\nconst findPaths = function (m, n, N, i, j) {\n  const dp = [...Array(2)].map((_) =>\n    [...Array(50)].map((_) => Array(50).fill(0))\n  )\n  while (N-- > 0) {\n    for (let i = 0; i < m; i++) {\n      for (let j = 0, nc = (N + 1) % 2, np = N % 2; j < n; j++) {\n        dp[nc][i][j] =\n          ((i === 0 ? 1 : dp[np][i - 1][j]) +\n            (i === m - 1 ? 1 : dp[np][i + 1][j]) +\n            (j === 0 ? 1 : dp[np][i][j - 1]) +\n            (j === n - 1 ? 1 : dp[np][i][j + 1])) %\n          1000000007\n      }\n    }\n  }\n  return dp[1][i][j]\n}\n\n// another\n\n/**\n * @param {number} m\n * @param {number} n\n * @param {number} N\n * @param {number} i\n * @param {number} j\n * @return {number}\n */\nconst findPaths = function (m, n, N, i, j) {\n  if (N <= 0) return 0;\n  const MOD = 1000000007;\n  let count = Array.from({ length: m }, () => new Array(n).fill(0));\n  count[i][j] = 1;\n  let result = 0;\n  const dirs = [\n    [-1, 0],\n    [1, 0],\n    [0, -1],\n    [0, 1],\n  ];\n  for (let step = 0; step < N; step++) {\n    const temp = Array.from({ length: m }, () => new Array(n).fill(0));\n    for (let r = 0; r < m; r++) {\n      for (let c = 0; c < n; c++) {\n        for (let d of dirs) {\n          const nr = r + d[0];\n          const nc = c + d[1];\n          if (nr < 0 || nr >= m || nc < 0 || nc >= n) {\n            result = (result + count[r][c]) % MOD;\n          } else {\n            temp[nr][nc] = (temp[nr][nc] + count[r][c]) % MOD;\n          }\n        }\n      }\n    }\n    count = temp;\n  }\n  return result;\n};\n\n// another\n\n/**\n * @param {number} m\n * @param {number} n\n * @param {number} N\n * @param {number} i\n * @param {number} j\n * @return {number}\n */\nconst findPaths = function (m, n, N, i, j, memo = new Map()) {\n    const key = N + ',' + i + ',' + j;\n    if (memo.has(key)) return memo.get(key);\n    const isOutside = i === -1 || i === m || j === -1 || j === n;\n    if (N === 0 || isOutside) return +isOutside;\n    memo.set(key, (\n          findPaths(m, n, N - 1, i - 1, j, memo)\n        + findPaths(m, n, N - 1, i + 1, j, memo)\n        + findPaths(m, n, N - 1, i, j + 1, memo)\n        + findPaths(m, n, N - 1, i, j - 1, memo)\n    ) % 1000000007);\n    return memo.get(key);\n}\n\n\n\n"
    }
  },
  {
    "name": "58-length-of-last-word",
    "code": {
      "JS": "/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nconst lengthOfLastWord = function(s) {\r\n  const arr = s.split(\" \");\r\n  for (let i = arr.length - 1; i >= 0; i--) {\r\n    if (arr[i].length > 0) return arr[i].length;\r\n  }\r\n  return 0;\r\n};\r\n"
    }
  },
  {
    "name": "581-shortest-unsorted-continuous-subarray",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst findUnsortedSubarray = function(nums) {\n  let stack = []\n  let left = nums.length\n  let right = 0\n  for(let i = 0; i < nums.length; i++) {\n    while(stack.length > 0 && nums[stack[stack.length - 1]] > nums[i]) {\n      left = Math.min(left, stack.pop())\n    }\n    stack.push(i)\n  }\n  stack = []\n  for(let i = nums.length - 1; i >= 0; i--) {\n    while(stack.length > 0 && nums[stack[stack.length - 1]] < nums[i] ) {\n      right = Math.max(right, stack.pop())\n    }\n    stack.push(i)\n  }\n  \n  \n  return right > left ? right - left + 1: 0\n};\n"
    }
  },
  {
    "name": "582-kill-process",
    "code": {
      "JS": "/**\n * @param {number[]} pid\n * @param {number[]} ppid\n * @param {number} kill\n * @return {number[]}\n */\nconst killProcess = function(pid, ppid, kill) {\n  const pm = new Map()\n  for(let i = 0, len = pid.length; i < len; i++) {\n    const c = pid[i]\n    const p = ppid[i]\n    let tmp = pm.get(p)\n    if(!tmp) tmp = new Set()\n    tmp.add(c)\n    pm.set(p, tmp)\n  }\n  const res = []\n  const q = [kill]\n  while(q.length) {\n    const size = q.length\n    for(let i = 0; i < size; i++) {\n      const el = q.shift()\n      res.push(el)\n      if(pm.get(el)) {\n        q.push(...Array.from(pm.get(el)))\n      }\n    }\n  }\n  return res\n};\n\n// another\n\n/**\n * @param {number[]} pid\n * @param {number[]} ppid\n * @param {number} kill\n * @return {number[]}\n */\nconst killProcess = function(pid, ppid, kill) {\n  const pm = new Map()\n  for(let i = 0, len = pid.length; i < len; i++) {\n    const p = ppid[i]\n    let tmp = pm.get(p)\n    if(!tmp) tmp = new Set()\n    tmp.add(pid[i])\n    pm.set(p, tmp)\n  }\n  const res = []\n  function dfs(k) {\n    res.push(k)\n    if(pm.get(k)) {\n      for(let e of pm.get(k)) {\n        dfs(e)\n      }      \n    }\n  }\n  dfs(kill)\n  return res\n};\n"
    }
  },
  {
    "name": "583-delete-operation-for-two-strings",
    "code": {
      "JS": "/**\n * @param {string} word1\n * @param {string} word2\n * @return {number}\n */\nconst minDistance = function (word1, word2, memo = new Map()) {\n  if (word1 === word2) return 0\n  if (word1 === '' || word2 === '') return Math.max(word1.length, word2.length)\n  const len1 = word1.length\n  const len2 = word2.length\n  if (memo.has(`${word1}-${word2}`)) return memo.get(`${word1}-${word2}`)\n  let res\n  if (word1[len1 - 1] === word2[len2 - 1]) {\n    res = minDistance(word1.slice(0, len1 - 1), word2.slice(0, len2 - 1), memo)\n  } else {\n    res =\n      1 +\n      Math.min(\n        minDistance(word1.slice(0, len1 - 1), word2, memo),\n        minDistance(word1, word2.slice(0, len2 - 1), memo)\n      )\n  }\n  memo.set(`${word1}-${word2}`, res)\n  return res\n}\n\n// another\n\n/**\n * @param {string} word1\n * @param {string} word2\n * @return {number}\n */\nconst minDistance = function (word1, word2) {\n  const len1 = word1.length\n  const len2 = word2.length\n  const dp = Array.from({ length: len1 + 1 }, () => new Array(len2 + 1).fill(0))\n  for(let i = 1; i <= len1; i++) {\n    for(let j = 1; j<= len2; j++) {\n      if(word1[i - 1] === word2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1\n      else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])\n    }\n  }\n  return len1 + len2 - dp[len1][len2] * 2\n}\n\n// another\n\n/**\n * @param {string} word1\n * @param {string} word2\n * @return {number}\n */\nconst minDistance = function (word1, word2) {\n  const len1 = word1.length\n  const len2 = word2.length\n  const dp = Array.from({ length: len1 + 1 }, () => new Array(len2 + 1).fill(0))\n  for(let i = 1; i <= len2; i++) {\n    dp[0][i] = i\n  }\n  for(let j = 1; j <= len1; j++) {\n    dp[j][0] = j\n  }\n  for(let i = 1; i <= len1; i++) {\n    for(let j = 1; j<= len2; j++) {\n      if(word1[i - 1] === word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]\n      else dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + 1\n    }\n  }\n  return dp[len1][len2]\n}\n"
    }
  },
  {
    "name": "5832-array-with-elements-not-equal-to-average-of-neighbors",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nconst rearrangeArray = function(nums) {\n  nums.sort((a, b) => a - b)\n  const res = []\n  let idx = 0, i = 0\n  const n = ~~((nums.length + 1) / 2)\n  while(i < nums.length) {\n    if(idx >= nums.length) idx = 1\n    // console.log(idx,i)\n    res[idx] = nums[i]\n    \n    idx += 2\n    i++\n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "5843-number-of-strings-that-appear-as-substrings-in-word",
    "code": {
      "JS": "/**\n * @param {string[]} patterns\n * @param {string} word\n * @return {number}\n */\nconst numOfStrings = function(patterns, word) {\n  let res = 0\n  for(let e of patterns) {\n    if(word.indexOf(e) !== -1) res++\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "5844-minimum-non-zero-product-of-the-array-elements",
    "code": {
      "JS": "/**\n * @param {number} p\n * @return {number}\n */\nconst minNonZeroProduct = function(p) {\n  const b = BigInt(p)\n  const mod = BigInt(10 ** 9 + 7)\n\n  return (BigInt(1n << b) - 1n) % mod * pow(BigInt(1n << b) - 2n, BigInt(1n << (b - 1n)) - 1n) % mod;\n\n  function pow(a,  n) {\n    let r = 1n;\n    a %= mod;\n    while (n > 0n) {\n        r = r * a % mod;\n        a = a * a % mod;\n        n /= 2n;\n    }\n    return r;\n  }\n};\n"
    }
  },
  {
    "name": "587-erect-the-fence",
    "code": {
      "JS": "/**\n * @param {number[][]} points\n * @return {number[][]}\n */\nconst outerTrees = function (points) {\n  const orientation = (p1, p2, p3) => {\n    return (p2[1] - p1[1]) * (p3[0] - p2[0]) - (p2[0] - p1[0]) * (p3[1] - p2[1])\n  }\n  points.sort((a, b) => {\n    return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]\n  })\n  const stack = []\n  for (let i = 0; i < points.length; i++) {\n    while (\n      stack.length >= 2 &&\n      orientation(stack[stack.length - 2], stack[stack.length - 1], points[i]) >\n        0\n    )\n      stack.pop()\n    stack.push(points[i])\n  }\n  stack.pop()\n  for (let i = points.length - 1; i >= 0; i--) {\n    while (\n      stack.length >= 2 &&\n      orientation(stack[stack.length - 2], stack[stack.length - 1], points[i]) >\n        0\n    )\n      stack.pop()\n    stack.push(points[i])\n  }\n  return [...new Set(stack)]\n}\n"
    }
  },
  {
    "name": "588-design-in-memory-file-system",
    "code": {
      "JS": "const FileSystem = function () {\n  this.items = new Map()\n}\n\n/**\n * @param {string} path\n * @return {string[]}\n */\nFileSystem.prototype.ls = function (path) {\n  const paths = path.split('/').filter((p) => !!p.length)\n  let curr = this.items\n  let last = ''\n\n  for (const p of paths) {\n    curr = curr.get(p)\n    last = p\n  }\n  const list = Array.from(curr.keys()).filter((e) => e !== 'content')\n  if (curr.has('content')) list.push(last)\n  return list.sort()\n}\n\n/**\n * @param {string} path\n * @return {void}\n */\nFileSystem.prototype.mkdir = function (path) {\n  const paths = path.split('/').filter((p) => !!p.length)\n  let curr = this.items\n  for (const p of paths) {\n    if (!curr.has(p)) {\n      curr.set(p, new Map())\n    }\n    curr = curr.get(p)\n  }\n}\n\n/**\n * @param {string} filePath\n * @param {string} content\n * @return {void}\n */\nFileSystem.prototype.addContentToFile = function (filePath, content) {\n  const paths = filePath.split('/').filter((p) => !!p.length)\n  let curr = this.items\n  for (const p of paths) {\n    if (!curr.has(p)) {\n      curr.set(p, new Map())\n    }\n    curr = curr.get(p)\n  }\n  curr.set('content', (curr.get('content') || '') + content)\n}\n\n/**\n * @param {string} filePath\n * @return {string}\n */\nFileSystem.prototype.readContentFromFile = function (filePath) {\n  const paths = filePath.split('/').filter((p) => !!p.length)\n  let curr = this.items\n  for (const p of paths) {\n    curr = curr.get(p)\n  }\n  return curr.get('content')\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * var obj = new FileSystem()\n * var param_1 = obj.ls(path)\n * obj.mkdir(path)\n * obj.addContentToFile(filePath,content)\n * var param_4 = obj.readContentFromFile(filePath)\n */\n\n// another\n\nconst FileSystem = function () {\n  this.root = new Node()\n}\n\n/**\n * @param {string} path\n * @return {string[]}\n */\nFileSystem.prototype.ls = function (path) {\n  const cur = this.find(path)\n  if(cur.content) {\n    const arr = path.split('/')\n    return [arr[arr.length - 1]]\n  }\n  return Object.keys(cur.children).sort()\n}\n\n/**\n * @param {string} path\n * @return {void}\n */\nFileSystem.prototype.mkdir = function (path) {\n  this.find(path)\n}\n\n/**\n * @param {string} filePath\n * @param {string} content\n * @return {void}\n */\nFileSystem.prototype.addContentToFile = function (filePath, content) {\n  const cur = this.find(filePath)\n  cur.content += content\n}\n\n/**\n * @param {string} filePath\n * @return {string}\n */\nFileSystem.prototype.readContentFromFile = function (filePath) {\n  const cur = this.find(filePath)\n  return cur.content\n}\n\nFileSystem.prototype.find = function (filePath) {\n  if(filePath.length === 1) return this.root\n  const arr = filePath.split('/').slice(1)\n  let cur = this.root\n  for(let e of arr) {\n    if (cur.children[e] == null) cur.children[e] = new Node()\n    cur = cur.children[e]\n  }\n  return cur\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * var obj = new FileSystem()\n * var param_1 = obj.ls(path)\n * obj.mkdir(path)\n * obj.addContentToFile(filePath,content)\n * var param_4 = obj.readContentFromFile(filePath)\n */\n\nclass Node {\n  constructor() {\n    this.children = {}\n    this.content = ''\n  }\n}\n\n"
    }
  },
  {
    "name": "589-n-ary-tree-preorder-traversal",
    "code": {
      "JS": "/**\n * // Definition for a Node.\n * function Node(val,children) {\n *    this.val = val;\n *    this.children = children;\n * };\n */\n/**\n * @param {Node} root\n * @return {number[]}\n */\nconst preorder = function(root) {\n  const arr = []\n  traverse(root, arr)\n  return arr\n};\n\nfunction traverse(node, arr) {\n  if(node === null) return\n  arr.push(node.val)\n  for(let i = 0; i < node.children.length; i++) {\n    traverse(node.children[i], arr)\n  }\n}\n"
    }
  },
  {
    "name": "59-spiral-matrix-II",
    "code": {
      "JS": "/**\r\n * @param {number} n\r\n * @return {number[][]}\r\n */\r\nconst generateMatrix = function(n) {\r\n  const res = [];\r\n  for (let i = 0; i < n; i++) {\r\n    res[i] = [];\r\n  }\r\n  let i = 0,\r\n    j = 0,\r\n    cur = 1;\r\n  while (n > 0) {\r\n    res[i][j] = cur++;\r\n    n--;\r\n    let step = n;\r\n    while (step > 0) {\r\n      res[i][++j] = cur++;\r\n      step--;\r\n    }\r\n    step = n;\r\n    while (step > 0) {\r\n      res[++i][j] = cur++;\r\n      step--;\r\n    }\r\n    step = n--;\r\n    while (step > 0) {\r\n      res[i][--j] = cur++;\r\n      step--;\r\n    }\r\n    step = n;\r\n    while (step > 0) {\r\n      res[--i][j] = cur++;\r\n      step--;\r\n    }\r\n    j++;\r\n  }\r\n  return res;\r\n};\r\n"
    }
  },
  {
    "name": "590-n-ary-tree-postorder-traversal",
    "code": {
      "JS": "/**\n * // Definition for a Node.\n * function Node(val,children) {\n *    this.val = val;\n *    this.children = children;\n * };\n */\n/**\n * @param {Node} root\n * @return {number[]}\n */\nconst postorder = function(root) {\n    const res = []\n    traverse(root, res)\n    return res\n};\n\nfunction traverse(node, res) {\n  if(node == null) return\n  for(let i = 0; i < node.children.length; i++) {\n    traverse(node.children[i], res)\n  }\n  res.push(node.val)\n}\n"
    }
  },
  {
    "name": "591-tag-validator",
    "code": {
      "JS": "/**\n * @param {string} code\n * @return {boolean}\n */\nconst isValid = function (code) {\n  const stack = []\n  const [A, Z] = ['A', 'Z'].map((e) => e.charCodeAt(0))\n  for (let i = 0; i < code.length; ) {\n    if (i > 0 && stack.length === 0) return false\n    if (code.startsWith('<![CDATA[', i)) {\n      let j = i + 9\n      i = code.indexOf(']]>', j)\n      if (i < 0) return false\n      i += 3\n    } else if (code.startsWith('</', i)) {\n      let j = i + 2\n      i = code.indexOf('>', j)\n      if (i < 0 || i === j || i - j > 9) return false\n      for (let k = j; k < i; k++) {\n        if (\n          code.charAt(k) !== code[k].toUpperCase() ||\n          !(code.charCodeAt(k) >= A && code.charCodeAt(k) <= Z)\n        )\n          return false\n      }\n      let s = code.slice(j, i++)\n      if (stack.length === 0 || stack.pop() !== s) return false\n    } else if (code.startsWith('<', i)) {\n      let j = i + 1\n      i = code.indexOf('>', j)\n      if (i < 0 || i === j || i - j > 9) return false\n      for (let k = j; k < i; k++) {\n        if (\n          code.charAt(k) !== code[k].toUpperCase() ||\n          !(code.charCodeAt(k) >= A && code.charCodeAt(k) <= Z)\n        )\n          return false\n      }\n      let s = code.slice(j, i++)\n      stack.push(s)\n    } else {\n      i++\n    }\n  }\n  return stack.length === 0\n}\n\n// another\n\n/**\n * @param {string} code\n * @return {boolean}\n */\nconst isValid = function (code) {\n  code = code.replace(/<!\\[CDATA\\[.*?\\]\\]>|t/g, '-')\n  let prev\n  while (code !== prev) {\n    prev = code\n    code = code.replace(/<([A-Z]{1,9})>[^<]*<\\/\\1>/g, 't')\n  }\n  return code === 't'\n}\n\n\n// another\n\n/**\n * @param {string} code\n * @return {boolean}\n */\nconst isValid = function (code) {\n  const STATES = {\n    lt: 1, // <\n    tagOrData: 2, // uppercase=tag, '!'=data\n    tagName: 3, // uppercase, '>'=end\n    dataContent: 4, // any, ']'=wait-for-end\n    dataEnd: 5, // any, ']'=end\n    tagContent: 6, // any, '<'=tag-or-data\n  }\n  class Validator {\n    constructor(str) {\n      this.state = STATES.lt\n      this.str = str\n      this.stack = []\n      this.i = 0\n      // this ensure it doesnt start with cdata\n      this.isValid = this.isUpperCase(this.str[1])\n      // check through code\n      while (this.isValid && this.i < this.str.length) {\n        this.isValid = this.validate()\n      }\n      // check if there is unclosed tags\n      this.isValid = this.isValid && !this.stack.length\n    }\n\n    /**\n     * check and move on\n     */\n    validate() {\n      let char = this.str[this.i]\n      switch (this.state) {\n        // expect '<', only used at start\n        case STATES.lt:\n          this.i++\n          if (char == '<') {\n            this.state = STATES.tagOrData\n            return true\n          }\n          return false\n        // expect (end-)tag-name or cdata\n        case STATES.tagOrData:\n          // data\n          if (char == '!') {\n            this.i = this.findStrEnd(this.i + 1, '[CDATA[')\n            if (this.i == -1) {\n              return false\n            }\n            this.state = STATES.dataContent\n            return true\n          }\n          // end tag\n          if (char == '/') {\n            let name = this.stack.pop()\n            if (!name) {\n              return false\n            }\n            this.i = this.findStrEnd(this.i + 1, name + '>')\n            if (this.i == -1) {\n              return false\n            }\n            if (!this.stack.length & (this.i < this.str.length)) {\n              // more than one top level tags\n              return false\n            }\n            this.state = STATES.tagContent\n            return true\n          }\n          // tag name\n          {\n            let name = this.findTagName(this.i)\n            if (!name) {\n              return false\n            }\n            if (name.length > 9) {\n              return false\n            }\n            this.i += name.length + 1\n            this.stack.push(name)\n            this.state = STATES.tagContent\n            return true\n          }\n        case STATES.dataContent: // you can try replace these code with indexOf\n        {\n          let end = this.findStrEnd(this.i, ']]>')\n          if (end != -1) {\n            // found end\n            this.i = end\n            this.state = STATES.tagContent\n            return true\n          }\n          // not yet\n          this.i++\n          return true\n        }\n        case STATES.tagContent:\n          if (char == '<') {\n            this.state = STATES.tagOrData\n            this.i++\n            return true\n          }\n          this.i++\n          return true\n      }\n    }\n\n    isUpperCase(char) {\n      return /[A-Z]/.test(char)\n    }\n\n    findStrEnd(from, toFind = '') {\n      let end = from + toFind.length\n      for (let i = 0; i < toFind.length; i++) {\n        if (toFind[i] != this.str[i + from]) return -1\n      }\n      return end\n    }\n\n    findTagName(from) {\n      let tagName = ''\n      for (let i = from; i < this.str.length; i++) {\n        if (this.isUpperCase(this.str[i])) {\n          tagName += this.str[i]\n          continue\n        }\n        if (this.str[i] == '>') {\n          return tagName\n        }\n        return ''\n      }\n      return ''\n    }\n  }\n  let v = new Validator(code)\n  return v.isValid\n}\n"
    }
  },
  {
    "name": "592-fraction-addition-and-subtraction",
    "code": {
      "JS": "/**\n * @param {string} expression\n * @return {string}\n */\nconst fractionAddition = function (expression) {\n  if (expression[0] === '-') expression = '0/1' + expression\n  const terms = expression.split(/[+-]/g)\n  const ops = '+' + expression.replace(/[^+-]/g, '')\n  const nums = [],\n    dens = []\n  for (let term of terms) {\n    let t = term.split('/')\n    nums.push(parseInt(t[0]))\n    dens.push(parseInt(t[1]))\n  }\n  const lcm = LCM(dens)\n  const numSum = nums.reduce(\n    (sum, num, i) => sum + ((+(ops[i] === '+') || -1) * num * lcm) / dens[i],\n    0\n  )\n  const gcd = Math.abs(GCD(numSum, lcm))\n  return numSum / gcd + '/' + lcm / gcd\n}\n\nfunction LCM(arr) {\n  let res = arr[0]\n  for (let i = 1; i < arr.length; i++) {\n    res = (arr[i] * res) / GCD(arr[i], res)\n  }\n  return res\n}\n\nfunction GCD(a, b) {\n  if (b === 0) return a\n  return GCD(b, a % b)\n}\n"
    }
  },
  {
    "name": "593-valid-square",
    "code": {
      "JS": "/**\n * @param {number[]} p1\n * @param {number[]} p2\n * @param {number[]} p3\n * @param {number[]} p4\n * @return {boolean}\n */\nconst validSquare = function(p1, p2, p3, p4) {\n  const lenArr = [\n    distance(p1, p2),\n    distance(p1, p3),\n    distance(p1, p4),\n    distance(p2, p3),\n    distance(p2, p4),\n    distance(p3, p4)\n  ]\n  const obj = {}\n  for (let el of lenArr) {\n    if (obj[el] != null) obj[el] += 1\n    else obj[el] = 1\n  }\n  const keys = Object.keys(obj)\n\n  return keys.length === 2 && (obj[keys[0]] === 2 || obj[keys[1]] === 2)\n}\n\nfunction distance(p1, p2) {\n  return Math.sqrt(Math.pow(p1[1] - p2[1], 2) + Math.pow(p1[0] - p2[0], 2))\n}\n"
    }
  },
  {
    "name": "594-longest-harmonious-subsequence",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst findLHS = function(nums) {\n    if(nums == null) return 0\n    if(Object.prototype.toString.call(nums) === '[object Array]' && nums.length === 0) return 0\n    let res = 0\n    const map = {}\n    for (let el of nums) {\n        if(map.hasOwnProperty(el)) {\n           map[el] +=  1\n        } else {\n           map[el] = 1\n        }\n    }\n    Object.keys(map).forEach(el => {\n        if(map.hasOwnProperty(+el + 1)) {\n            res = Math.max(res, map[el] + map[+el + 1])\n        }\n    })\n    console.log(res)\n    return res\n};\n"
    }
  },
  {
    "name": "5956-find-first-palindromic-string-in-the-array",
    "code": {
      "JS": "/**\n * @param {string[]} words\n * @return {string}\n */\nconst firstPalindrome = function(words) {\n  for(let str of words) {\n    if(isPa(str)) return str\n  }\n  \n  return ''\n};\n\nfunction isPa(str) {\n  let l = 0, r = str.length - 1\n  while(l < r) {\n    if(str[l] !== str[r]) return false\n    l++\n    r--\n  }\n  \n  \n  return true\n}\n"
    }
  },
  {
    "name": "5957-adding-spaces-to-a-string",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {number[]} spaces\n * @return {string}\n */\nvar addSpaces = function(s, spaces) {\n  let res = '', j = 0, idx = spaces[j]\n  for(let i = 0, n = s.length; i < n; i++) {\n    if(i === idx) {\n      res += ' '\n      j++\n      idx = spaces[j]\n    }\n    res += s[i]\n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "5958-number-of-smooth-descent-periods-of-a-stock",
    "code": {
      "JS": "/**\n * @param {number[]} prices\n * @return {number}\n */\nconst getDescentPeriods = function(prices) {\n  if(prices.length === 1) return 1\n  let res = 0, idx = 0\n  \n  for (let i = 1, n = prices.length; i < n ; i++) {\n    if(prices[i - 1] - prices[i] === 1) {\n     if (i === n - 1) {\n      const len = i - idx + 1\n      res += (len + 1) * len / 2\n     }\n    } else {\n      const len = i - 1 - idx + 1\n      res += (len + 1) * len / 2\n      idx = i\n      if(i === n - 1) {\n        res += 1\n      }\n    }\n\n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "5976-check-if-every-row-and-column-contains-all-numbers",
    "code": {
      "JS": "/**\n * @param {number[][]} matrix\n * @return {boolean}\n */\nvar checkValid = function(matrix) {\n  const n = matrix.length\n  let res = true\n  for(let i = 0; i < n; i++) {\n    if(!chkRow(i) || !chkCol(i)) {\n      res = false\n      break\n    }\n  }\n  \n  \n  return res\n  \n  function chkRow(i) {\n    const row = matrix[i], set = new Set()\n    for(let i = 0; i < n; i++) {\n      set.add(row[i])\n    }\n    return set.size === n\n  }\n  \n  function chkCol(j) {\n    const set = new Set()\n    for(let i = 0; i < n; i++) {\n      set.add(matrix[i][j])\n    }\n    \n    return set.size === n\n  }\n};\n"
    }
  },
  {
    "name": "5977-minimum-swaps-to-group-all-1s-together-ii",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar minSwaps = function(nums) {\n    let one = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] == 1)\n            one++;\n    }\n    let maxOne = 0;\n    for (let i = 0; i < one; i++) {\n        if (nums[i] == 1)\n            maxOne++;\n    }\n    let max = maxOne;\n    for (let i = 1; i < nums.length; i++) {\n        if (nums[i - 1] == 1)\n            maxOne--;\n        if (nums[(i + one - 1) % nums.length] == 1)\n            maxOne++;\n        if (maxOne > max)\n            max = maxOne;\n    }\n    return one - max;\n      \n};\n"
    }
  },
  {
    "name": "5978-count-words-obtained-after-adding-a-letter",
    "code": {
      "JS": "/**\n * @param {string[]} startWords\n * @param {string[]} targetWords\n * @return {number}\n */\nvar wordCount = function(startWords, targetWords) {\n        const set = new Set();\n    for (let startWord of startWords) {\n        const chars = startWord.split('');\n        chars.sort();\n        set.add(chars.join(''));\n    }\n    let res = 0;\n    for (let targetWord of targetWords) {\n        let chars = targetWord.split('');\n        chars.sort()  \n\n        let word = chars.join('');\n        for (let i = 0; i < chars.length; i++) {\n            let subWord = word.substring(0, i) + word.substring(i + 1, chars.length);\n            if (set.has(subWord)) {\n                res++;\n                break;\n            }\n        }\n    }\n    return res;\n};\n"
    }
  },
  {
    "name": "598-range-addition-ii",
    "code": {
      "JS": "/**\n * @param {number} m\n * @param {number} n\n * @param {number[][]} ops\n * @return {number}\n */\nconst maxCount = function (m, n, ops) {\n  for (let i = 0, len = ops.length; i < len; i++) {\n    if (ops[i][0] < m) m = ops[i][0]\n    if (ops[i][1] < n) n = ops[i][1]\n  }\n  return m * n\n}\n"
    }
  },
  {
    "name": "599-minimum-index-sum-of-two-lists",
    "code": {
      "JS": "/**\r\n * @param {string[]} list1\r\n * @param {string[]} list2\r\n * @return {string[]}\r\n */\r\nconst findRestaurant = function(list1, list2) {\r\n  const hash = {};\r\n  for (let i = 0; i < list1.length; i++) {\r\n    if (!hash.hasOwnProperty(list1[i])) {\r\n      hash[list1[i]] = i;\r\n    }\r\n  }\r\n  const resArr = [];\r\n  for (let j = 0; j < list2.length; j++) {\r\n    if (hash.hasOwnProperty(list2[j])) {\r\n      resArr.push([list2[j], hash[list2[j]] + j]);\r\n    }\r\n  }\r\n  const resHash = {};\r\n  resArr.forEach(el => {\r\n    if (resHash.hasOwnProperty(el[1])) {\r\n      resHash[el[1]].push(el[0]);\r\n    } else {\r\n      resHash[el[1]] = [el[0]];\r\n    }\r\n  });\r\n  resArr.sort((a, b) => a[1] - b[1]);\r\n  return resHash[resArr[0][1]];\r\n};\r\n\r\nconsole.log(\r\n  findRestaurant(\r\n    [\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"],\r\n    [\"KFC\", \"Burger King\", \"Tapioca Express\", \"Shogun\"]\r\n  )\r\n);\r\n"
    }
  },
  {
    "name": "6-zigzag-conversion",
    "code": {
      "JS": "/**\r\n * @param {string} s\r\n * @param {number} numRows\r\n * @return {string}\r\n */\r\nconst convert = function(s, numRows) {\r\n  if (numRows === 1) {\r\n    return s;\r\n  }\r\n  let output = \"\";\r\n  for (let i = 1; i <= numRows; i++) {\r\n    let j = i - 1;\r\n    let maxIncrement = 2 * numRows - 2;\r\n    let increment = 2 * numRows - 2 - 2 * j;\r\n    if (increment === 0) {\r\n      increment = maxIncrement;\r\n    } else {\r\n      increment = maxIncrement - increment;\r\n    }\r\n    for (j; j < s.length; j += increment) {\r\n      output += s[j];\r\n      if (maxIncrement !== increment) {\r\n        increment = maxIncrement - increment;\r\n      }\r\n    }\r\n  }\r\n  return output;\r\n};\r\n"
    }
  },
  {
    "name": "60-permutation-sequence",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number} k\n * @return {string}\n */\nconst getPermutation = function (n, k) {\n  let sb = ''\n  const num = []\n  let fact = 1\n  for (let i = 1; i <= n; i++) {\n    fact *= i\n    num.push(i)\n  }\n  for (let i = 0, l = k - 1; i < n; i++) {\n    fact = Math.floor(fact / (n - i))\n    const index = Math.floor(l / fact)\n    sb += num.splice(index, 1)[0]\n    l -= index * fact\n  }\n  return sb\n}\n\n// another\n\n/**\n * @param {number} n\n * @param {number} k\n * @return {string}\n */\nconst getPermutation = function(n, k) {\n  const factorial = []\n  const nums = []\n  let res = ''\n  factorial[0] = 1\n  for(let i = 1, sum = 1; i <= n; i++) {\n    sum *= i\n    factorial[i] = sum\n  }\n  for(let i = 1; i <= n; i++) {\n    nums.push(i)\n  }\n  k--\n  for(let i = 0; i <= n; i++) {\n    const idx = ~~(k / factorial[n - i])\n    res += nums[idx]\n    nums.splice(idx, 1)\n    k -= idx * factorial[n - i]\n  }\n\n  return res\n};\n"
    }
  },
  {
    "name": "600-non-negative-integers-without-consecutive-ones",
    "code": {
      "JS": "/**\n * @param {number} num\n * @return {number}\n */\nconst findIntegers = function (num) {\n  const binary = num.toString(2)\n  const fibonacci = [1, 2]\n  for (let i = 2; i < binary.length; ++i) {\n    fibonacci.push(fibonacci[i - 2] + fibonacci[i - 1])\n  }\n  let answer = binary.indexOf('11') === -1 ? 1 : 0\n  for (let i = 0; i < binary.length; ++i) {\n    if (binary[i] === '1') {\n      answer += fibonacci[binary.length - 1 - i]\n      if (binary[i - 1] === '1') {\n        break\n      }\n    }\n  }\n  return answer\n}\n"
    }
  },
  {
    "name": "604-design-compressed-string-iterator",
    "code": {
      "JS": "/**\n * @param {string} compressedString\n */\nconst StringIterator = function(compressedString) {\n  const s = compressedString.replace(/[a-zA-Z]/g,'-')\n  const ss = compressedString.replace(/[0-9]+/g, '-')\n  const sa = s.split('-').filter(e => !!e).map(e => +e)\n  const ssa = ss.split('-').filter(e => !!e)\n  this.idx = 0\n  this.charArr = ssa\n  this.numArr = sa\n};\n\n/**\n * @return {character}\n */\nStringIterator.prototype.next = function() {\n  let res = ' '\n  if(this.idx >= this.numArr.length) return res\n  if(this.numArr[this.idx]) res = this.charArr[this.idx]\n  this.numArr[this.idx]--\n  if(this.numArr[this.idx] === 0) this.idx++\n  return res\n};\n\n/**\n * @return {boolean}\n */\nStringIterator.prototype.hasNext = function() {\n  return this.numArr[this.idx] > 0\n};\n\n/** \n * Your StringIterator object will be instantiated and called as such:\n * var obj = new StringIterator(compressedString)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */\n"
    }
  },
  {
    "name": "605-can-place-flowers",
    "code": {
      "JS": "/**\n * @param {number[]} flowerbed\n * @param {number} n\n * @return {boolean}\n */\nconst canPlaceFlowers = function(flowerbed, n) {\n    let count = 0\n    const clone = flowerbed\n    for(let i = 0; i < clone.length; i++) {\n      if(clone[i] === 0) {\n        if(i === 0 && (clone[i + 1] === 0 || clone[i+1] == null)){\n          count++\n          clone[i] = 1\n        }\n        if(i > 0 && i < clone.length - 1 && clone[i - 1] === 0 && clone[i + 1] === 0) {\n          count++\n          clone[i] = 1\n        }\n        if(i === clone.length - 1 && clone[i - 1] === 0 && clone[i] === 0) {\n           count++\n          clone[i] = 1\n        }\n      }\n    }\n    \n    return count >= n ? true : false\n};\n"
    }
  },
  {
    "name": "606-construct-string-from-binary-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} t\n * @return {string}\n */\nconst tree2str = function(t) {\n  if (!t) return ''\n  const left = tree2str(t.left)\n  const right = tree2str(t.right)\n  if (right) return `${t.val}(${left})(${right})`\n  else if (left) return `${t.val}(${left})`\n  else return `${t.val}`\n};\n"
    }
  },
  {
    "name": "609-find-duplicate-file-in-system",
    "code": {
      "JS": "/**\n * @param {string[]} paths\n * @return {string[][]}\n */\nconst findDuplicate = function (paths) {\n  const map = {}\n  for (let text of paths) {\n    for (let i = 1, files = text.split(' '); i < files.length; i++) {\n      const paren = files[i].indexOf('(')\n      const content = files[i].substring(paren + 1, files[i].length - 1)\n      map[content] = map[content] || []\n      map[content].push(files[0] + '/' + files[i].substr(0, paren))\n    }\n  }\n  return Object.values(map).filter((dups) => dups.length > 1)\n}\n"
    }
  },
  {
    "name": "61-rotate-list",
    "code": {
      "JS": "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nconst rotateRight = function(head, k) {\n    if (head === null || head.next === null) return head;\n    const dummy = new ListNode(0);\n    dummy.next = head;\n    let fast = dummy,slow = dummy;\n\n    let i;\n    for (i = 0; fast.next != null; i++)//Get the total length \n    \tfast = fast.next;\n    \n    for (let j = i - k % i; j > 0; j--) //Get the i-n%i th node\n    \tslow = slow.next;\n    \n    fast.next = dummy.next; //Do the rotation\n    dummy.next = slow.next;\n    slow.next = null;\n    \n    return dummy.next;\n};\n\n// another\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nconst rotateRight = function(head, k) {\n  if(head == null) return null\n  let len = 1\n  let tmp = head\n  while(tmp.next) {\n    len++\n    tmp = tmp.next\n  }\n  k = k % len\n  if(k === 0) return head\n  let tail = head\n  for(let i = 1; i < len - k; i++) {\n    tail = tail.next\n  }\n  const newHead = tail.next\n  tmp.next = head\n  tail.next = null\n  return newHead\n};\n"
    }
  },
  {
    "name": "611-valid-triangle-number",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nconst triangleNumber = function(nums) {\r\n  nums.sort((a, b) => a - b);\r\n  let count = 0;\r\n  let n = nums.length;\r\n  for (let i = n - 1; i >= 2; i--) {\r\n    let lo = 0;\r\n    let mid = i - 1;\r\n    while (lo < mid) {\r\n      if (nums[lo] + nums[mid] > nums[i]) {\r\n        count += mid - lo;\r\n        mid -= 1;\r\n      } else {\r\n        lo += 1;\r\n      }\r\n    }\r\n  }\r\n  return count;\r\n};\r\n\r\nconsole.log(triangleNumber([2, 2, 3, 4]));\r\n"
    }
  },
  {
    "name": "616-add-bold-tag-in-string",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {string[]} dict\n * @return {string}\n */\nconst addBoldTag = function (s, dict) {\n  const bold = new Array(s.length)\n  for (let sub of dict) {\n    let found = -1\n    let prevBold = 0\n    while ((found = s.indexOf(sub, found + 1)) !== -1) {\n      for (let i = Math.max(prevBold, found); i < found + sub.length; i++) {\n        bold[i] = 1\n      }\n      prevBold = found + sub.length\n    }\n  }\n  let res = ''\n  let open = false\n  for (let i = 0; i < s.length; i++) {\n    if (bold[i] && !open) {\n      open = true\n      res += '<b>'\n    } else if (!bold[i] && open) {\n      open = false\n      res += '</b>'\n    }\n    res += s[i]\n  }\n  return open ? res + '</b>' : res\n}\n"
    }
  },
  {
    "name": "62-unique-paths",
    "code": {
      "JS": "/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nconst uniquePaths = function(m, n) {\n    if(m === 0 || n === 0) return 0\n    const dp = Array.from({length: m+1}, () => new Array(n+1).fill(1))\n    dp[0][1] = dp[1][0] = 1\n    for(let i = 1; i <= m; i++) {\n      for(let j = 1; j <= n; j++) {\n        dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n      }\n    }\n    return dp[m - 1][n - 1]\n};\n\n// another\n\n/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nconst uniquePaths = function(m, n) {\n  const dp = Array(m).fill(0)\n  for(let i = 0; i < n; i++) {\n    dp[0] = 1\n    for(let j = 1; j < m; j++) {\n      dp[j] += dp[j - 1]\n    }\n  }\n  return dp[m - 1]\n};\n\n// another\n\n/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nconst uniquePaths = function(m, n) {\n    return factorial(m+n-2)/(factorial(m - 1) * factorial(n - 1))\n};\n\nfunction factorial(n) {\n  let res = 1\n  while(n > 0) {\n    res *= n\n    n--\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "621-task-scheduler",
    "code": {
      "JS": "/**\r\n * @param {character[]} tasks\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nconst leastInterval = function(tasks, n) {\r\n  const map = Array(26).fill(0);\r\n  const ca = \"A\".charCodeAt(0);\r\n  for (let c of tasks) map[c.charCodeAt(0) - ca]++;\r\n  map.sort((a, b) => a - b);\r\n  let max_val = map[25] - 1,\r\n    idle_slots = max_val * n;\r\n  for (let i = 24; i >= 0 && map[i] > 0; i--) {\r\n    idle_slots -= Math.min(map[i], max_val);\r\n  }\r\n  return idle_slots > 0 ? idle_slots + tasks.length : tasks.length;\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * @param {character[]} tasks\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nconst leastInterval = function(tasks, n) {\r\n  const hash = {};\r\n  for(let task of tasks) {\r\n    hash[task] = hash[task] + 1 || 1\r\n  }\r\n  let max = 0, count = 0;\r\n  for(let el in hash) {\r\n    if(hash[el] > max) {\r\n      max = hash[el];\r\n      count = 1\r\n    } else if(hash[el] === max) {\r\n      count++;\r\n    }\r\n  }\r\n  return Math.max((max - 1) *  (n + 1)  +  count, tasks.length)\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * @param {character[]} tasks\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nconst leastInterval = function(tasks, n) {\r\n  let max = 0, maxCnt = 0\r\n  const len = tasks.length, cnt = Array(26).fill(0), A = 'A'.charCodeAt(0)\r\n  \r\n  for(let ch of tasks) {\r\n    const idx = ch.charCodeAt(0) - A\r\n    cnt[idx]++\r\n    if(max === cnt[idx]) maxCnt++\r\n    else if(max < cnt[idx]) {\r\n      max = cnt[idx]\r\n      maxCnt = 1\r\n    }\r\n  }\r\n  \r\n  const maxSlots = max * maxCnt\r\n  const avaiSlots = (max - 1) * (n - (maxCnt - 1))\r\n  const rem = len - maxSlots\r\n  const emptySlots = Math.max(0, avaiSlots - rem)\r\n  \r\n  return len + emptySlots\r\n};\r\n"
    }
  },
  {
    "name": "622-design-circular-queue",
    "code": {
      "JS": "/**\n * Initialize your data structure here. Set the size of the queue to be k.\n * @param {number} k\n */\nconst MyCircularQueue = function (k) {\n  this.a = new Array(k).fill(0)\n  this.front = 0\n  this.rear = -1\n  this.len = 0\n}\n\n/**\n * Insert an element into the circular queue. Return true if the operation is successful.\n * @param {number} value\n * @return {boolean}\n */\nMyCircularQueue.prototype.enQueue = function (value) {\n  if (!this.isFull()) {\n    this.rear = (this.rear + 1) % this.a.length\n    this.a[this.rear] = value\n    this.len++\n    return true\n  } else return false\n}\n\n/**\n * Delete an element from the circular queue. Return true if the operation is successful.\n * @return {boolean}\n */\nMyCircularQueue.prototype.deQueue = function () {\n  if (!this.isEmpty()) {\n    this.front = (this.front + 1) % this.a.length\n    this.len--\n    return true\n  } else return false\n}\n\n/**\n * Get the front item from the queue.\n * @return {number}\n */\nMyCircularQueue.prototype.Front = function () {\n  return this.isEmpty() ? -1 : this.a[this.front]\n}\n\n/**\n * Get the last item from the queue.\n * @return {number}\n */\nMyCircularQueue.prototype.Rear = function () {\n  return this.isEmpty() ? -1 : this.a[this.rear]\n}\n\n/**\n * Checks whether the circular queue is empty or not.\n * @return {boolean}\n */\nMyCircularQueue.prototype.isEmpty = function () {\n  return this.len === 0\n}\n\n/**\n * Checks whether the circular queue is full or not.\n * @return {boolean}\n */\nMyCircularQueue.prototype.isFull = function () {\n  return this.len == this.a.length\n}\n\n/**\n * Your MyCircularQueue object will be instantiated and called as such:\n * var obj = new MyCircularQueue(k)\n * var param_1 = obj.enQueue(value)\n * var param_2 = obj.deQueue()\n * var param_3 = obj.Front()\n * var param_4 = obj.Rear()\n * var param_5 = obj.isEmpty()\n * var param_6 = obj.isFull()\n */\n"
    }
  },
  {
    "name": "623-add-one-row-to-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} v\n * @param {number} d\n * @return {TreeNode}\n */\nconst addOneRow = function (root, v, d, level = 1) {\n  if (d === 1) {\n    const node = new TreeNode(v)\n    node.left = root\n    return node\n  }\n  const queue = []\n  queue.push(root)\n  let depth = 1\n  while (queue.length) {\n    const size = queue.length\n    for (let i = 0; i < size; i++) {\n      const cur = queue.shift()\n      if (depth === d - 1) {\n        let left = new TreeNode(v)\n        let right = new TreeNode(v)\n        left.left = cur.left\n        right.right = cur.right\n        cur.left = left\n        cur.right = right\n      } else {\n        if (cur.left !== null) {\n          queue.push(cur.left)\n        }\n        if (cur.right !== null) {\n          queue.push(cur.right)\n        }\n      }\n    }\n    depth++\n  }\n  return root\n}\n\n// another\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} v\n * @param {number} d\n * @return {TreeNode}\n */\nconst addOneRow = function (root, v, d, level = 1) {\n  if (!root) return\n  if (d === 1) {\n    const newRoot = new TreeNode(v)\n    newRoot.left = root\n    return newRoot\n  } else if (d === level + 1) {\n    const oldLeft = root.left\n    const oldRight = root.right\n    root.left = new TreeNode(v)\n    root.right = new TreeNode(v)\n    root.left.left = oldLeft\n    root.right.right = oldRight\n  } else {\n    addOneRow(root.left, v, d, level + 1)\n    addOneRow(root.right, v, d, level + 1)\n  }\n  return root\n}\n"
    }
  },
  {
    "name": "624-maximum-distance-in-arrays",
    "code": {
      "JS": "/**\n\nGiven m arrays, and each array is sorted in ascending order.\nNow you can pick up two integers from two different arrays (each array picks one)\nand calculate the distance.\nWe define the distance between two integers a and b to be their absolute difference |a-b|.\nYour task is to find the maximum distance.\n\nExample 1:\n\nInput: \n[[1,2,3],\n [4,5],\n [1,2,3]]\n\nOutput: 4\n\nExplanation: \nOne way to reach the maximum distance 4 is to pick 1 in the first or third array and pick 5 in the second array.\n\nNote:\nEach given array will have at least 1 number. There will be at least two non-empty arrays.\nThe total number of the integers in all the m arrays will be in the range of [2, 10000].\nThe integers in the m arrays will be in the range of [-10000, 10000].\n\n*/\n\n/**\n * @param {number[][]} arrays\n * @return {number}\n */\nconst maxDistance = function(arrays) {\n  if (arrays == null) return 0\n  let result = 0\n  let min = arrays[0][0]\n  let max = arrays[0][arrays[0].length - 1]\n  for (let i = 1; i < arrays.length; i++) {\n    result = Math.max(\n      result,\n      Math.abs(arrays[i][arrays[i].length - 1] - min),\n      Math.abs(arrays[i][0] - max)\n    )\n    max = Math.max(max, arrays[i][arrays[i].length - 1])\n    min = Math.min(min, arrays[i][0])\n  }\n  return result\n}\n"
    }
  },
  {
    "name": "625-minimum-factorization",
    "code": {
      "JS": "/**\n * @param {number} a\n * @return {number}\n */\nconst smallestFactorization = function (a) {\n  if (a < 2) return a\n  let MAX_INT = 2 ** 31 - 1,\n    res = 0,\n    mul = 1\n  for (let i = 9; i >= 2; i--) {\n    while (a % i === 0) {\n      a /= i\n      res = mul * i + res\n      mul *= 10\n    }\n  }\n  return a < 2 && res <= MAX_INT ? res : 0\n}\n"
    }
  },
  {
    "name": "628-maximum-product-of-three-numbers",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst maximumProduct = function (nums) {\n  nums.sort((a, b) => a - b)\n  return Math.max(\n    nums[0] * nums[1] * nums[nums.length - 1],\n    nums[nums.length - 1] * nums[nums.length - 2] * nums[nums.length - 3]\n  )\n}\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst maximumProduct = function (nums) {\n  let max1 = -Infinity\n  let max2 = -Infinity\n  let max3 = -Infinity\n  let min1 = Infinity\n  let min2 = Infinity\n  for (let num of nums) {\n    if (num > max1) {\n      max3 = max2\n      max2 = max1\n      max1 = num\n    } else if (num > max2) {\n      max3 = max2\n      max2 = num\n    } else if (num > max3) {\n      max3 = num\n    }\n\n    if (num < min1) {\n      min2 = min1\n      min1 = num\n    } else if (num < min2) {\n      min2 = num\n    }\n  }\n  return Math.max(max1 * max2 * max3, max1 * min1 * min2)\n}\n"
    }
  },
  {
    "name": "629-k-inverse-pairs-array",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number} k\n * @return {number}\n */\nconst kInversePairs = function(n, k) {\n  const dp = Array.from({ length: n + 1 }, () => new Array(k + 1).fill(0))\n  for (let i = 1; i < n + 1; i++) {\n    dp[i][0] = 1\n  }\n  const MOD = 1e9 + 7\n  for (let i = 1; i < n + 1; i++) {\n    for (let j = 1; j < k + 1; j++) {\n      let val = (dp[i - 1][j] - (j >= i ? dp[i - 1][j - i] : 0) + MOD) % MOD\n      dp[i][j] = (dp[i][j - 1] + val) % MOD\n    }\n  }\n  return (dp[n][k] - (dp[n][k - 1] || 0) + MOD) % MOD\n}\n"
    }
  },
  {
    "name": "63-unique-paths-ii",
    "code": {
      "JS": "/**\n * @param {number[][]} obstacleGrid\n * @return {number}\n */\nconst uniquePathsWithObstacles = function(obstacleGrid) {\n  const rows = obstacleGrid.length\n  const cols = obstacleGrid[0].length\n  const dp = Array.from({ length: rows }, () => new Array(cols).fill(0))\n  if (obstacleGrid[0][0] === 1) return 0\n  else dp[0][0] = 1\n  let firstRowOneIdx\n  let firstColOneIdx\n  for (let i = 0; i < cols; i++) {\n    if (obstacleGrid[0][i] === 1) {\n      firstRowOneIdx = i\n      break\n    } else {\n      dp[0][i] = 1\n    }\n  }\n  for (let i = 0; i < rows; i++) {\n    if (obstacleGrid[i][0] === 1) {\n      firstColOneIdx = i\n      break\n    } else {\n      dp[i][0] = 1\n    }\n  }\n\n  for (let i = 1; i < rows; i++) {\n    for (let j = 1; j < cols; j++) {\n      if (obstacleGrid[i][j] !== 1) {\n        dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n      }\n    }\n  }\n  return dp[rows - 1][cols - 1]\n}\n"
    }
  },
  {
    "name": "630-course-schedule-iii",
    "code": {
      "JS": "/**\n * @param {number[][]} courses\n * @return {number}\n */\nconst scheduleCourse = function (courses) {\n  const queue = new MaxPriorityQueue({\n    priority: e => e[0]\n  })\n  courses.sort((a, b) => a[1] - b[1])\n  let time = 0\n  for(let e of courses) {\n    time += e[0]\n    queue.enqueue(e)\n    if(time > e[1]) {\n      const tmp = queue.dequeue().element\n      time -= tmp[0]\n    }\n  }\n  return queue.size()\n}\n\n// another\n\n/**\n * @param {number[][]} courses\n * @return {number}\n */\nconst scheduleCourse = function (courses) {\n  courses.sort((c1, c2) => c1[1] - c2[1])\n  let count = 0\n  let time = 0\n  const queue = []\n  const inQueue = (val) => {\n    let i = 0\n    while (i < queue.length && queue[i] > val) i += 1\n    queue.splice(i, 0, val)\n  }\n  for (let i = 0; i < courses.length; i += 1) {\n    const [dur, end] = courses[i]\n    if (time <= end - dur) {\n      count += 1\n      time += dur\n      inQueue(dur)\n    } else if (queue.length && queue[0] > dur) {\n      time = time - queue.shift() + dur\n      inQueue(dur)\n    }\n  }\n  return count\n}\n\n// another\n\n/**\n * @param {number[][]} courses\n * @return {number}\n */\nconst scheduleCourse = function (courses) {\n  courses.sort((a, b) => +a[1] - +b[1])\n  let queue = new Heap()\n  let time = 0\n  for (let c of courses) {\n    if (c[0] + time <= c[1]) {\n      time += c[0]\n      queue.push(c[0])\n    } else if (queue.size() > 0) {\n      let top = queue.peek()\n      if (top > c[0]) {\n        queue.pop()\n        queue.push(c[0])\n        time += c[0] - top\n      }\n    }\n  }\n  return queue.size()\n}\n\nconst parent = (i) => Math.floor((i - 1) / 2)\nconst left = (i) => 2 * i + 1\nconst right = (i) => 2 * i + 2\nclass Heap {\n  constructor() {\n    this.compare = (a, b) => +b - +a\n    this._heap = []\n  }\n  size() {\n    return this._heap.length\n  }\n  _upper(i, j) {\n    return this.compare(this._heap[i], this._heap[j]) < 0\n  }\n  _swap(i, j) {\n    let tmp = this._heap[i]\n    this._heap[i] = this._heap[j]\n    this._heap[j] = tmp\n  }\n  push(item) {\n    this._heap.push(item)\n    this._siftUp()\n    return this.size()\n  }\n  _siftUp() {\n    let node = this._heap.length - 1\n    while (node > 0 && this._upper(node, parent(node))) {\n      this._swap(node, parent(node))\n      node = parent(node)\n    }\n  }\n  peek() {\n    return this._heap[0]\n  }\n  pop() {\n    let ret = this._heap[0]\n    if (this.size() > 1) {\n      this._swap(0, this._heap.length - 1)\n    }\n    this._heap.pop()\n    this._siftDown()\n    return ret\n  }\n  _siftDown() {\n    let node = 0\n    while (\n      (right(node) < this.size() && this._upper(right(node), node)) ||\n      (left(node) < this.size() && this._upper(left(node), node))\n    ) {\n      let upperChild =\n        right(node) < this.size() && this._upper(right(node), left(node))\n          ? right(node)\n          : left(node)\n      this._swap(upperChild, node)\n      node = upperChild\n    }\n  }\n}\n\n"
    }
  },
  {
    "name": "631-design-excel-sum-formula",
    "code": {
      "JS": "/**\n * @param {number} H\n * @param {character} W\n */\nconst Excel = function (H, W) {\n  this.W = W.charCodeAt(0) - 'A'.charCodeAt(0) + 1\n  this.H = H\n  this.map = {}\n  this.mat = []\n  for (let i = 0; i < this.H; i++) {\n    this.mat[i] = new Array(this.W).fill(0)\n  }\n  return\n}\n\n/**\n * @param {number} r\n * @param {character} c\n * @param {number} v\n * @return {void}\n */\nExcel.prototype.set = function (r, c, v) {\n  let row = r - 1\n  let col = c.charCodeAt(0) - 'A'.charCodeAt(0)\n  if (this.map[r + ':' + c]) delete this.map[r + ':' + c]\n  this.mat[row][col] = v\n}\n/**\n * @param {number} r\n * @param {character} c\n * @return {number}\n */\nExcel.prototype.get = function (r, c) {\n  let row = r - 1\n  let col = c.charCodeAt(0) - 'A'.charCodeAt(0)\n  if (this.map[r + ':' + c] !== undefined)\n    return this.sum(r, c, this.map[r + ':' + c])\n  return this.mat[row][col]\n}\n\n/**\n * @param {number} r\n * @param {character} c\n * @param {string[]} strs\n * @return {number}\n */\nExcel.prototype.sum = function (r, c, strs) {\n  let sum = 0\n  for (let str of strs) {\n    if (str.indexOf(':') < 0) {\n      sum += this.get(+str.substring(1), str[0])\n    } else {\n      let [r1, c1, r2, c2] = this.getRange(str.split(':'))\n      for (let i = r1; i <= r2; i++) {\n        for (let j = c1; j <= c2; j++) {\n          sum += this.get(i + 1, String.fromCharCode(j + 'A'.charCodeAt(0)))\n        }\n      }\n    }\n  }\n  this.map[r + ':' + c] = strs\n  return sum\n}\n\nExcel.prototype.getRange = function (arr) {\n  let p1 = arr[0],\n    p2 = arr[1]\n  let c1 = p1[0].charCodeAt(0) - 'A'.charCodeAt(0)\n  let r1 = +p1.substring(1) - 1\n  let c2 = p2[0].charCodeAt(0) - 'A'.charCodeAt(0)\n  let r2 = +p2.substring(1) - 1\n  return [r1, c1, r2, c2]\n}\n\n/**\n * Your Excel object will be instantiated and called as such:\n * var obj = Object.create(Excel).createNew(H, W)\n * obj.set(r,c,v)\n * var param_2 = obj.get(r,c)\n * var param_3 = obj.sum(r,c,strs)\n */\n\n\n// another\n\n/**\n * @param {number} H\n * @param {character} W\n */\nconst Excel = function (H, W) {\n  this.data = []\n  for (let i = 1; i <= H; i++) {\n    this.data[i] = []\n    for (let j = 1; j <= this.col(W); j++) {\n      this.data[i][j] = 0\n    }\n  }\n}\n\nExcel.prototype.col = function (c) {\n  return c.charCodeAt() - 'A'.charCodeAt() + 1\n}\n\nExcel.prototype.parse = function (str) {\n  let idx = str.indexOf(':')\n  if (idx === -1) return { r: Number(str.slice(1)), c: str[0] }\n  let topLeft = str.slice(0, idx),\n    bottomRight = str.slice(idx + 1)\n  return [\n    { r: Number(topLeft.slice(1)), c: topLeft[0] },\n    { r: Number(bottomRight.slice(1)), c: bottomRight[0] },\n  ]\n}\n\n/**\n * @param {number} r\n * @param {character} c\n * @param {number} v\n * @return {void}\n */\nExcel.prototype.set = function (r, c, v) {\n  this.data[r][this.col(c)] = v\n}\n\n/**\n * @param {number} r\n * @param {character} c\n * @return {number}\n */\nExcel.prototype.get = function (r, c) {\n  if (Array.isArray(this.data[r][this.col(c)])) {\n    let sum = 0\n    for (let str of this.data[r][this.col(c)]) {\n      let parsed = this.parse(str)\n      if (Array.isArray(parsed)) {\n        for (let i = parsed[0].r; i <= parsed[1].r; i++) {\n          for (\n            let jc = parsed[0].c;\n            jc <= parsed[1].c;\n            jc = String.fromCharCode(jc.charCodeAt() + 1)\n          ) {\n            sum += this.get(i, jc)\n          }\n        }\n      } else sum += this.get(parsed.r, parsed.c)\n    }\n    return sum\n  }\n  return this.data[r][this.col(c)]\n}\n\n/**\n * @param {number} r\n * @param {character} c\n * @param {string[]} strs\n * @return {number}\n */\nExcel.prototype.sum = function (r, c, strs) {\n  this.set(r, c, strs)\n  return this.get(r, c)\n}\n\n/**\n * Your Excel object will be instantiated and called as such:\n * var obj = new Excel(H, W)\n * obj.set(r,c,v)\n * var param_2 = obj.get(r,c)\n * var param_3 = obj.sum(r,c,strs)\n */\n"
    }
  },
  {
    "name": "632-smallest-range",
    "code": {
      "JS": "/**\n * @param {number[][]} nums\n * @return {number[]}\n */\nconst smallestRange = function(nums) {\n  if (nums.length === 1) return [nums[0], nums[0]]\n  const pq = new PQ((a, b) => a.v < b.v)\n  let min = Number.MAX_SAFE_INTEGER\n  let max = Number.MIN_SAFE_INTEGER\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i].length > 0) {\n      const top = nums[i].shift()\n      pq.push({ v: top, i })\n      min = Math.min(min, top)\n      max = Math.max(max, top)\n    }\n  }\n  let bestRange = [min, max]\n  while (pq.size() > 0) {\n    const { v, i } = pq.pop()\n    if (nums[i].length === 0) return bestRange\n    const newVal = nums[i].shift()\n    pq.push({ v: newVal, i })\n    min = pq.peek().v\n    max = Math.max(max, newVal)\n    if (max - min < bestRange[1] - bestRange[0]) {\n      bestRange = [min, max]\n    }\n  }\n  return bestRange\n}\n\nfunction PQ(f) {\n  this.q = []\n  this.f = f\n}\n\nPQ.prototype.size = function() {\n  return this.q.length\n}\n\nPQ.prototype.peek = function() {\n  return this.q[0]\n}\n\nPQ.prototype.push = function(v) {\n  const q = this.q\n  let i = q.length\n  q.push(v)\n  let parent = Math.floor((i - 1) / 2)\n  while (parent >= 0 && this.f(q[i], q[parent])) {\n    this.swap(i, parent)\n    i = parent\n    parent = Math.floor((i - 1) / 2)\n  }\n}\n\nPQ.prototype.pop = function() {\n  const q = this.q\n  if (q.length === 0) return null\n  this.swap(0, q.length - 1)\n  let i = 0\n  let lc = 1\n  let rc = 2\n  while (lc < q.length - 1) {\n    let r = i\n    if (this.f(q[lc], q[r])) {\n      r = lc\n    }\n    if (rc < q.length - 1 && this.f(q[rc], q[r])) {\n      r = rc\n    }\n    if (r === i) break\n    this.swap(i, r)\n    i = r\n    lc = i * 2 + 1\n    rc = i * 2 + 2\n  }\n  return q.pop()\n}\n\nPQ.prototype.swap = function(i, j) {\n  const q = this.q\n  const t = q[i]\n  q[i] = q[j]\n  q[j] = t\n}\n\n// another\n\nfunction Queue() {\n  this.data = []\n}\n\nQueue.prototype.pop = function() {\n  return this.data.shift()\n}\n\nQueue.prototype.getMax = function() {\n  let n = this.data.length - 1\n  let max = this.data[n]\n  if (max === undefined) {\n    return 100000000\n  }\n  return max.val\n}\n\nQueue.prototype.getMin = function() {\n  let min = this.data[0]\n  if (min === undefined) {\n    return -100000000\n  }\n  return min.val\n}\n\nQueue.prototype.add = function(node) {\n  if (!this.data.length) {\n    this.data.push(node)\n    return\n  }\n\n  let index = findIndex(this.data, node)\n  this.data.splice(index, 0, node)\n  return true\n\n  function findIndex(arr, node) {\n    let left = 0\n    let right = arr.length - 1\n    while (left <= right) {\n      let mid = Math.floor((left + right) / 2)\n      if (arr[mid].val === node.val) {\n        return mid\n      }\n\n      if (arr[mid].val > node.val) {\n        right = mid - 1\n      } else {\n        left = mid + 1\n      }\n    }\n    return left\n  }\n}\n\nfunction Node(list, val, index) {\n  this.list = list\n  this.val = val\n  this.index = index\n}\n/**\n * @param {number[][]} nums\n * @return {number[]}\n */\nvar smallestRange = function(nums) {\n  let queue = new Queue()\n  for (let i = 0; i < nums.length; i++) {\n    let node = new Node(i, nums[i][0], 0)\n    queue.add(node)\n  }\n\n  let a = Math.min(queue.getMin(), queue.getMax())\n  let b = Math.max(queue.getMin(), queue.getMax())\n  let ans = [a, b]\n  let min = ans[1] - ans[0]\n  for (;;) {\n    let a = Math.min(queue.getMin(), queue.getMax())\n    let b = Math.max(queue.getMin(), queue.getMax())\n    if (b - a < min) {\n      min = b - a\n      ans = [a, b]\n    }\n\n    let m = queue.pop()\n    let list = nums[m.list]\n    let index = m.index\n    if (index + 1 < list.length) {\n      m.index++\n      m.val = list[m.index]\n      queue.add(m)\n    } else {\n      break\n    }\n  }\n\n  return ans\n}\n\n\n// another\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n/**\n * @param {number[][]} nums\n * @return {number[]}\n */\nconst smallestRange = function (nums) {\n  const pq = new PriorityQueue((a, b) => a[0] < b[0])\n  const limit = 10 ** 5,\n    n = nums.length,\n    { max } = Math\n  let right = -1e5,\n    res = [-limit, limit]\n  for (let i = 0; i < n; i++) {\n    pq.push([nums[i][0], i, 0])\n    right = max(right, nums[i][0])\n  }\n  while (pq.size()) {\n    const cur = pq.pop()\n    const [left, list, indice] = cur\n    if (right - left < res[1] - res[0]) res = [left, right]\n    if (indice + 1 === nums[list].length) return res\n    right = max(right, nums[list][indice + 1])\n    pq.push([nums[list][indice + 1], list, indice + 1])\n  }\n  return []\n}\n"
    }
  },
  {
    "name": "633-sum-of-square-numbers",
    "code": {
      "JS": "/**\n * @param {number} c\n * @return {boolean}\n */\nconst judgeSquareSum = function(c) {\n  if (c < 0) return false;\n  const max = Math.floor(Math.sqrt(c));\n  for (let i = 0; i < max + 1; i++) {\n    if (Number.isInteger(Math.sqrt(c - i * i))) {\n      return true;\n    }\n  }\n  return false;\n};\n"
    }
  },
  {
    "name": "634-find-the-derangement-of-an-array",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst findDerangement = function (n) {\n  if ([0, 1].includes(n)) return 0\n  if (n === 2) return 1\n  let prev = 1\n  const MOD = 10 ** 9 + 7\n  let result = 0\n  for (let i = 3; i <= n; i++) {\n    result = (prev * i + (i % 2 === 1 ? -1 : 1)) % MOD\n    prev = result\n  }\n  return result\n}\n\n// another\n\n/**\n * @param {number} n\n * @return {number}\n */\nconst findDerangement = function (n) {\n  if (n === 0) return 0\n  const MOD = 10 ** 9 + 7\n  const dp = [1, 0]\n  for (let i = 2; i <= n; i++) {\n    dp[i] = ((i - 1) * (dp[i - 2] + dp[i - 1])) % MOD\n  }\n  return dp[n]\n}\n\n"
    }
  },
  {
    "name": "635-design-log-storage-system",
    "code": {
      "JS": "/**\n\nYou are given several logs that each log contains a unique id and timestamp.\nTimestamp is a string that has the following format: Year:Month:Day:Hour:Minute:Second,\nfor example, 2017:01:01:23:59:59. All domains are zero-padded decimal numbers.\n\nDesign a log storage system to implement the following functions:\n\nvoid Put(int id, string timestamp): Given a log's unique id and timestamp,\nstore the log in your storage system.\n\nint[] Retrieve(String start, String end, String granularity): Return the id of logs whose\ntimestamps are within the range from start to end. Start and end all have the same format as timestamp.\nHowever, granularity means the time level for consideration. For example, start = \"2017:01:01:23:59:59\",\nend = \"2017:01:02:23:59:59\", granularity = \"Day\", it means that we need to find the logs within the range\nfrom Jan. 1st 2017 to Jan. 2nd 2017.\n\nExample 1:\nput(1, \"2017:01:01:23:59:59\");\nput(2, \"2017:01:01:22:59:59\");\nput(3, \"2016:01:01:00:00:00\");\nretrieve(\"2016:01:01:01:01:01\",\"2017:01:01:23:00:00\",\"Year\"); // return [1,2,3], because you need to return all logs within 2016 and 2017.\nretrieve(\"2016:01:01:01:01:01\",\"2017:01:01:23:00:00\",\"Hour\"); // return [1,2], because you need to return all logs start from 2016:01:01:01 to 2017:01:01:23, where log 3 is left outside the range.\n\nNote:\nThere will be at most 300 operations of Put or Retrieve.\nYear ranges from [2000,2017]. Hour ranges from [00,23].\nOutput for Retrieve has no order required.\n\n*/\n\nconst Log = function(id, timeArgs) {\n  this.id = id;\n  this.timeArgs = timeArgs;\n};\nconst LogSystem = function() {\n  this.logs = [];\n};\n\n/**\n * @param {number} id\n * @param {string} timestamp\n * @return {void}\n */\nLogSystem.prototype.put = function(id, timestamp) {\n  const args = timestamp.split(\":\");\n  this.logs.push(new Log(id, args));\n};\n\n/**\n * @param {string} s\n * @param {string} e\n * @param {string} gra\n * @return {number[]}\n */\nLogSystem.prototype.retrieve = function(s, e, gra) {\n  const gransarr = [\"Year\", \"Month\", \"Day\", \"Hour\", \"Minute\", \"Second\"];\n  const idx = gransarr.indexOf(gra);\n  const sargs = s.split(\":\").slice(0, idx + 1);\n  const eargs = e.split(\":\").slice(0, idx + 1);\n  const sdate = new Date(...sargs).getTime();\n  const edate = new Date(...eargs).getTime();\n  const set = [];\n  this.logs.forEach(function(item) {\n    const itemArgs = item.timeArgs.slice(0, idx + 1);\n    const itemTime = new Date(...itemArgs).getTime();\n    if (itemTime >= sdate && itemTime <= edate) {\n      set.push(item.id);\n    }\n  });\n  return set;\n};\n\n/**\n * Your LogSystem object will be instantiated and called as such:\n * var obj = new LogSystem()\n * obj.put(id,timestamp)\n * var param_2 = obj.retrieve(s,e,gra)\n */\n"
    }
  },
  {
    "name": "636-exclusive-time-of-functions",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {string[]} logs\n * @return {number[]}\n */\nconst exclusiveTime = function (n, logs) {\n  const res = [...Array(n)].fill(0)\n  const stack = []\n  let pre = 0\n  for (let i = 0; i < logs.length; i++) {\n    const log = logs[i].split(':')\n    if (log[1] === 'start') {\n      if(stack.length !== 0) res[stack[stack.length - 1]] += +log[2] - pre\n      stack.push(log[0])\n      pre = log[2]\n    } else {\n      res[stack.pop()] += +log[2] - pre + 1\n      pre = +log[2] + 1\n    }\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "637-average-of-levels-in-binary-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nconst averageOfLevels = function(root) {\n  const res = [];\n  layer(res, [root]);\n  return res.map(el => el.val / el.num);\n};\n\nfunction layer(arr, args) {\n  const item = {\n    val: args.reduce((ac, el) => ac + el.val, 0),\n    num: args.length\n  };\n  arr.push(item);\n  const children = [];\n  args.forEach(el => {\n    el.left === null ? null : children.push(el.left);\n    el.right === null ? null : children.push(el.right);\n  });\n  if (children.length) {\n    layer(arr, children);\n  }\n}\n"
    }
  },
  {
    "name": "638-shopping-offers",
    "code": {
      "JS": "/**\n * @param {number[]} price\n * @param {number[][]} special\n * @param {number[]} needs\n * @return {number}\n */\nconst shoppingOffers = function (price, special, needs) {\n  const directBuy = function (price, needs) {\n    let res = 0\n    for (let i = 0; i < price.length; i++) {\n      res += price[i] * needs[i]\n    }\n    return res\n  }\n  const isValid = function (offer, needs) {\n    for (let i = 0; i < offer.length; i++) {\n      if (offer[i] > needs[i]) return false\n    }\n    return true\n  }\n  const help = (price, special, needs) => {\n    let curMin = directBuy(price, needs)\n    for (let i = 0; i < special.length; i++) {\n      let curOf = special[i]\n      if (isValid(curOf, needs)) {\n        let tem = []\n        for (let j = 0; j < needs.length; j++) {\n          tem.push(needs[j] - curOf[j])\n        }\n        if (tem.length > 0) {\n          curMin = Math.min(\n            curMin,\n            curOf[curOf.length - 1] + help(price, special, tem)\n          )\n        }\n      }\n    }\n    return curMin\n  }\n  return help(price, special, needs)\n}\n"
    }
  },
  {
    "name": "639-decode-ways-ii",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst numDecodings = function(s) {\n  const mod = Math.pow(10, 9) + 7\n  const dp = [1, s.charAt(0) === '*' ? 9 : s.charAt(0) === '0' ? 0 : 1]\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) === '*') {\n      if (s.charAt(i - 1) === '*') {\n        dp[i + 1] = 9 * dp[i] + 15 * dp[i - 1]\n      } else if (s.charAt(i - 1) === '1') {\n        dp[i + 1] = 9 * dp[i] + 9 * dp[i - 1]\n      } else if (s.charAt(i - 1) === '2') {\n        dp[i + 1] = 9 * dp[i] + 6 * dp[i - 1]\n      } else {\n        dp[i + 1] = dp[i] * 9\n      }\n    } else {\n      let mul = s.charAt(i) === '0' ? 0 : 1\n      if (s.charAt(i - 1) === '*') {\n        dp[i + 1] = mul * dp[i] + (s.charAt(i) <= '6' ? 2 : 1) * dp[i - 1]\n      } else if (\n        s.charAt(i - 1) === '1' ||\n        (s.charAt(i - 1) === '2' && s.charAt(i) <= '6')\n      ) {\n        dp[i + 1] = mul * dp[i] + dp[i - 1]\n      } else {\n        dp[i + 1] = mul * dp[i]\n      }\n    }\n    dp[i + 1] = dp[i + 1] % mod\n  }\n  return dp[dp.length - 1]\n}\n"
    }
  },
  {
    "name": "64-minimum-path-sum",
    "code": {
      "JS": "/**\r\n * @param {number[][]} grid\r\n * @return {number}\r\n */\r\nconst minPathSum = function(grid) {\r\n  const m = grid.length;\r\n  const n = grid[0].length;\r\n  for (let i = 1; i < n; i++) {\r\n    grid[0][i] += grid[0][i - 1];\r\n  }\r\n  for (let i = 1; i < m; i++) {\r\n    grid[i][0] += grid[i - 1][0];\r\n  }\r\n  for (let i = 1; i < m; i++) {\r\n    for (let j = 1; j < n; j++) {\r\n      grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\r\n    }\r\n  }\r\n  return grid[m - 1][n - 1];\r\n};\r\n"
    }
  },
  {
    "name": "640-solve-the-equation",
    "code": {
      "JS": "/**\n * @param {string} equation\n * @return {string}\n */\nfunction solveEquation (equation) {\n  const strArr = equation.split('=')\n  const leftHash = build(strArr[0])\n  const rightHash = build(strArr[1])\n  const xnum = leftHash.x - rightHash.x\n  const num = rightHash.num - leftHash.num\n  if(xnum === 0 && num !== 0) {\n     return \"No solution\"\n  } else if(xnum === 0) {\n     return \"Infinite solutions\"\n  } else {\n     return `x=${num / xnum}`\n  }\n};\n\nfunction build(str) {\n  let cur = ''\n  const map = {\n    num:0,\n    x:0\n  }\n  for(let i = 0; i < str.length; i++) {\n    if(str[i] === '-' || str[i] === '+') {\n      chkCur(cur, map)\n      cur = str[i]\n    } else {\n      cur += str[i]\n    }\n  }\n  if(cur !== '') {\n    chkCur(cur, map)\n  }\n  return map\n}\nfunction chkCur(cur, map) {\n  let xIdx = cur.indexOf('x')\n  if(xIdx === -1) {\n    map.num += +cur\n  } else {\n    map.x += chkX(cur, xIdx)\n  }\n}\nfunction chkX(str, xIdx) {\n  let tmp = str.slice(0,xIdx)\n  let num = 0\n  if(tmp === '-') {\n    num = -1\n  } else if(tmp === '' || tmp === '+') {\n    num = 1\n  } else {\n    num = +tmp\n  }\n  return num\n}\n"
    }
  },
  {
    "name": "641-design-circular-deque",
    "code": {
      "JS": "/**\n * Initialize your data structure here. Set the size of the deque to be k.\n * @param {number} k\n */\nconst MyCircularDeque = function(k) {\n  this.q = []\n  this.k = k\n};\n\n/**\n * Adds an item at the front of Deque. Return true if the operation is successful. \n * @param {number} value\n * @return {boolean}\n */\nMyCircularDeque.prototype.insertFront = function(value) {\n  if(this.q.length < this.k) {\n    this.q.unshift(value)\n    return true\n  }\n  return false\n};\n\n/**\n * Adds an item at the rear of Deque. Return true if the operation is successful. \n * @param {number} value\n * @return {boolean}\n */\nMyCircularDeque.prototype.insertLast = function(value) {\n  if(this.q.length < this.k) {\n    this.q.push(value)\n    return true\n  }\n  return false\n};\n\n/**\n * Deletes an item from the front of Deque. Return true if the operation is successful.\n * @return {boolean}\n */\nMyCircularDeque.prototype.deleteFront = function() {\n  if(this.q.length) {\n    this.q.shift()\n    return true\n  }\n  return false\n};\n\n/**\n * Deletes an item from the rear of Deque. Return true if the operation is successful.\n * @return {boolean}\n */\nMyCircularDeque.prototype.deleteLast = function() {\n  if(this.q.length) {\n    this.q.pop()\n    return true\n  }\n  return false \n};\n\n/**\n * Get the front item from the deque.\n * @return {number}\n */\nMyCircularDeque.prototype.getFront = function() {\n  return this.q[0] === undefined ? -1 : this.q[0]\n};\n\n/**\n * Get the last item from the deque.\n * @return {number}\n */\nMyCircularDeque.prototype.getRear = function() {\n  return this.q[this.q.length - 1] === undefined ? -1 : this.q[this.q.length - 1]\n};\n\n/**\n * Checks whether the circular deque is empty or not.\n * @return {boolean}\n */\nMyCircularDeque.prototype.isEmpty = function() {\n  return this.q.length === 0\n};\n\n/**\n * Checks whether the circular deque is full or not.\n * @return {boolean}\n */\nMyCircularDeque.prototype.isFull = function() {\n  return this.q.length === this.k\n};\n\n/** \n * Your MyCircularDeque object will be instantiated and called as such:\n * var obj = new MyCircularDeque(k)\n * var param_1 = obj.insertFront(value)\n * var param_2 = obj.insertLast(value)\n * var param_3 = obj.deleteFront()\n * var param_4 = obj.deleteLast()\n * var param_5 = obj.getFront()\n * var param_6 = obj.getRear()\n * var param_7 = obj.isEmpty()\n * var param_8 = obj.isFull()\n */\n"
    }
  },
  {
    "name": "642-design-search-autocomplete-system",
    "code": {
      "JS": "/**\n * @param {string[]} sentences\n * @param {number[]} times\n */\nconst AutocompleteSystem = function (sentences, times) {\n  this.trie = new Trie()\n  this.inputString = ''\n  this.MAX_RESULTS = 3\n  for (let i = 0, len = times.length; i < len; i++) {\n    this.trie.insert(sentences[i], times[i])\n  }\n}\n\n/**\n * @param {character} c\n * @return {string[]}\n */\nAutocompleteSystem.prototype.input = function (c) {\n  if (c === '#') {\n    this.trie.insert(this.inputString)\n    this.inputString = ''\n    return []\n  }\n  this.inputString += c\n  const strings = this.trie.stringsStartingWith(this.inputString)\n  const results = Object.keys(strings)\n  results.sort((a, b) => {\n    const aFreq = strings[a]\n    const bFreq = strings[b]\n    return aFreq !== bFreq ? bFreq - aFreq : a > b ? 1 : -1\n  })\n  return results.slice(0, this.MAX_RESULTS)\n}\n\n/**\n * Your AutocompleteSystem object will be instantiated and called as such:\n * var obj = new AutocompleteSystem(sentences, times)\n * var param_1 = obj.input(c)\n */\n\n// Using a Trie (Prefix tree).\n/**\n * Initialize your data structure here.\n */\nconst Trie = function () {\n  this._trie = {}\n}\n\n/**\n * Inserts a string into the trie a number of times.\n * @param {string} word\n * @param {number} [count=1]\n * @return {void}\n */\nTrie.prototype.insert = function (word, count = 1) {\n  if (!word.length || count < 1) {\n    return\n  }\n  let curr = this._trie\n  for (let i = 0; i < word.length; i++) {\n    const char = word[i]\n    if (!curr.hasOwnProperty(char)) {\n      curr[char] = {}\n    }\n    curr = curr[char]\n  }\n  if (!curr.hasOwnProperty('#')) {\n    curr['#'] = 0\n  }\n  curr['#'] += count\n}\n\n/**\n * Returns if there is any string in the trie that starts with the given prefix.\n * @param {string} prefix\n * @return {Object}\n */\n// Time: O(n), where n is the number of different strings in the Trie.\n// Space: O(1)\nTrie.prototype.stringsStartingWith = function (prefix) {\n  if (!prefix.length) {\n    return false\n  }\n  let curr = this._trie\n  for (let i = 0; i < prefix.length; i++) {\n    const char = prefix[i]\n    if (!curr.hasOwnProperty(char)) {\n      return false\n    }\n    curr = curr[char]\n  }\n  const results = {}\n  function traverse(node, chars) {\n    if (!node) {\n      return\n    }\n    Object.keys(node).forEach((char) => {\n      if (char === '#') {\n        results[chars] = node[char]\n        return\n      }\n      traverse(node[char], chars + char)\n    })\n  }\n  traverse(curr, prefix)\n  return results\n}\n"
    }
  },
  {
    "name": "643-maximum-average-subarray-i",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nconst findMaxAverage = function(nums, k) {\n    let max = 0;\n    let temp = 0;\n    for(let i = 0; i < k; i++) {\n      max += nums[i];\n    }\n    temp = max;\n    for(let i = k; i < nums.length ; i++) {\n      temp = temp - nums[i - k] + nums[i];\n      max = Math.max(max, temp);\n    }\n    \n    return max/k;\n  };\n"
    }
  },
  {
    "name": "644-maximum-average-subarray-ii",
    "code": {
      "JS": "/**\n\nGiven an array consisting of n integers,\nfind the contiguous subarray whose length is greater than or\nequal to k that has the maximum average value.\nAnd you need to output the maximum average value.\n\nExample 1:\nInput: [1,12,-5,-6,50,3], k = 4\nOutput: 12.75\nExplanation:\nwhen length is 5, maximum average value is 10.8,\nwhen length is 6, maximum average value is 9.16667.\nThus return 12.75.\nNote:\n1 <= k <= n <= 10,000.\nElements of the given array will be in range [-10,000, 10,000].\nThe answer with the calculation error less than 10-5 will be accepted.\n\n*/\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nconst findMaxAverage = function(nums, k) {\n  let left = nums[0]\n  let right = nums[0]\n  nums.forEach(num => {\n    left = Math.min(left, num)\n    right = Math.max(right, num)\n  })\n  const check = average => {\n    let rightSum = 0\n    let leftSum = 0\n    let minLeftSum = 0\n    for (let i = 0; i < k; i++) {\n      rightSum += nums[i] - average\n    }\n    for (let i = k; i <= nums.length; i++) {\n      if (rightSum - minLeftSum >= 0) {\n        return true\n      }\n      if (i < nums.length) {\n        rightSum += nums[i] - average\n        leftSum += nums[i - k] - average\n        minLeftSum = Math.min(leftSum, minLeftSum)\n      }\n    }\n    return false\n  }\n  while (left + 1e-5 < right) {\n    let mid = (left + right) / 2\n    if (check(mid)) {\n      left = mid\n    } else {\n      right = mid\n    }\n  }\n  return left\n}\n"
    }
  },
  {
    "name": "645-set-mismatch",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nconst findErrorNums = function(nums) {\n  if(nums == null || nums.length === 0) return null\n  const res = []\n  const hash = {}\n  for(let el of nums) {\n    if(hash.hasOwnProperty(el)){\n      res[0] = el\n    } else hash[el] = 0\n    hash[el]++\n  }\n  for(let i = 1, len = nums.length; i <= len; i++) {\n    if(!hash.hasOwnProperty(i)) {\n      res[1] = i\n      break\n    }\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "646-maximum-length-of-pair-chain",
    "code": {
      "JS": "/**\r\n * @param {number[][]} pairs\r\n * @return {number}\r\n */\r\nconst findLongestChain = function(pairs) {\r\n  pairs.sort((a, b) => a[1] - b[1])\r\n  let end = pairs[0][1], res = 1\r\n  for(let i = 1, len = pairs.length; i < len; i++) {\r\n    if(pairs[i][0] > end) {\r\n      res++\r\n      end = pairs[i][1]\r\n    }    \r\n  }\r\n  return res\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * @param {number[][]} pairs\r\n * @return {number}\r\n */\r\nconst findLongestChain = function(pairs) {\r\n  pairs.sort((a, b) => a[1] - b[1]);\r\n  let cur = Number.MIN_SAFE_INTEGER;\r\n  let res = 0;\r\n  for (let i = 0; i < pairs.length; i++) {\r\n    if (cur < pairs[i][0]) {\r\n      cur = pairs[i][1];\r\n      res += 1;\r\n    }\r\n  }\r\n  return res;\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * @param {number[][]} pairs\r\n * @return {number}\r\n */\r\nconst findLongestChain = function (pairs) {\r\n  pairs.sort((a, b) => a[0] - b[0])\r\n  let out = 0\r\n  let prevEnd = Number.MIN_SAFE_INTEGER\r\n  for (let i = 0; i < pairs.length; i++) {\r\n    const cur = pairs[i]\r\n    if (prevEnd < cur[0]) {\r\n      prevEnd = cur[1]\r\n      out += 1\r\n    } else {\r\n      prevEnd = Math.min(cur[1], prevEnd)\r\n    }\r\n  }\r\n  return out\r\n}\r\n"
    }
  },
  {
    "name": "647-palindromic-substrings",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst countSubstrings = function(s) {\n  let count = 0;\n\n  if (s == null || s.length === 0) {\n    return 0;\n  }\n\n  for (let i = 0; i < s.length; i++) {\n    extendPalindrome(s, i, i);\n    extendPalindrome(s, i, i + 1);\n  }\n\n  function extendPalindrome(str, left, right) {\n    while (\n      left >= 0 &&\n      right < s.length &&\n      s.charAt(left) === s.charAt(right)\n    ) {\n      count++;\n      left--;\n      right++;\n    }\n  }\n  return count;\n};\n\nconsole.log(countSubstrings(\"abc\"));\nconsole.log(countSubstrings(\"aaa\"));\n\n// another\n\n/**\n * @param {string} s\n * @return {number}\n */\nconst countSubstrings = function(s) {\n  const arr = manachers(s)\n  return arr.map(e => ~~((e + 1) / 2)).reduce((ac, e) => ac + e, 0)\n};\n\nfunction manachers(s) {\n  const str = `@#${s.split('').join('#')}#$`\n  const arr = Array(str.length).fill(0)\n  \n  let center = right = 0\n  for(let i = 1, n = str.length; i < n - 1; i++) {\n    if(i < right) {\n      arr[i] = Math.min(right - i, arr[2 * center - i])\n    }\n    while(str[i + arr[i] + 1] === str[i - arr[i] - 1]) {\n      arr[i] += 1\n    }\n    if(i + arr[i] > right) {\n      center = i\n      right = i + arr[i]\n    }\n  }\n  \n  return arr\n}\n"
    }
  },
  {
    "name": "648-replace-words",
    "code": {
      "JS": "/**\r\n * @param {string[]} dict\r\n * @param {string} sentence\r\n * @return {string}\r\n */\r\nconst replaceWords = function(dict, sentence) {\r\n  dict.sort();\r\n  const unsortedParts = sentence.split(\" \");\r\n  const parts = unsortedParts.slice();\r\n  parts.sort();\r\n\r\n  let i = (j = 0);\r\n  const rootMap = {};\r\n  while (i < dict.length && j < parts.length) {\r\n    let part = parts[j];\r\n    let root = dict[i];\r\n    // dict is ahead, increase part\r\n    if (root > part) {\r\n      j++;\r\n    } else {\r\n      if (part.startsWith(root)) {\r\n        rootMap[part] = root;\r\n        j++;\r\n      } else {\r\n        i++;\r\n      }\r\n    }\r\n  }\r\n  for (i = 0; i < unsortedParts.length; i++) {\r\n    if (rootMap[unsortedParts[i]]) {\r\n      unsortedParts[i] = rootMap[unsortedParts[i]];\r\n    }\r\n  }\r\n  return unsortedParts.join(\" \");\r\n};\r\n\r\nconsole.log(\r\n  replaceWords([\"cat\", \"bat\", \"rat\"], \"the cattle was rattled by the battery\")\r\n);\r\n"
    }
  },
  {
    "name": "649-dota2-senate",
    "code": {
      "JS": "/**\n * @param {string} senate\n * @return {string}\n */\nconst predictPartyVictory = function (senate) {\n  const m = senate.length,\n    radiant = [],\n    dire = []\n  for (let i = 0; i < m; i++) {\n    if (senate[i] === 'R') {\n      radiant.push(i)\n    } else {\n      dire.push(i)\n    }\n  }\n\n  while (radiant.length && dire.length) {\n    let r = radiant.shift(),\n      d = dire.shift()\n    if (r < d) {\n      radiant.push(r + m)\n    } else {\n      dire.push(d + m)\n    }\n  }\n  return radiant.length > dire.length ? 'Radiant' : 'Dire'\n}\n"
    }
  },
  {
    "name": "65-valid-number",
    "code": {
      "JS": "/**\r\n * @param {string} str\r\n * @returns {boolean}\r\n */\r\nconst isNumber = function(str) {\r\n  let i = 0;\r\n  let s = str;\r\n  // 跳过前导空格\r\n  for (; i < s.length && \" \" == s[i]; ++i);\r\n  // 处理正负号\r\n  if (\"+\" == s[i] || \"-\" == s[i]) ++i;\r\n  // 处理后面数字部分\r\n  let digit = false,\r\n    dot = false,\r\n    exp = false;\r\n  for (; i < s.length; ++i) {\r\n    if (\".\" == s[i] && !dot)\r\n      // '.'不能出现2次，'.'前面可以没有数字\r\n      dot = true;\r\n    else if (\"e\" == s[i] && !exp && digit) {\r\n      // 'e'不能出现2次，'e'前面必须有数字\r\n      // 'e'后面不能出现'.'，'e'后面必须是整数（可以是正的或负的）\r\n      dot = exp = true;\r\n      if (i + 1 < s.length && (\"+\" == s[i + 1] || \"-\" == s[i + 1])) ++i;\r\n      if (i + 1 >= s.length || !(s[i + 1] >= \"0\" && s[i + 1] <= \"9\"))\r\n        return false;\r\n    } else if (s[i] >= \"0\" && s[i] <= \"9\") digit = true;\r\n    else break;\r\n  }\r\n\r\n  // 跳过后面空格\r\n  for (; i < s.length && \" \" == s[i]; ++i);\r\n\r\n  return digit && i == s.length;\r\n};\r\n"
    }
  },
  {
    "name": "650-2-keys-keyboard",
    "code": {
      "JS": "/**\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nconst minSteps = function(n) {\r\n  let res = 0\r\n  for (let i = 2; i <= n; i++) {\r\n    while (n % i === 0) {\r\n      res += i\r\n      n /= i\r\n    }\r\n  }\r\n  return res\r\n}\r\n"
    }
  },
  {
    "name": "651-4-keys-keyboard",
    "code": {
      "JS": "/**\n * @param {number} N\n * @return {number}\n */\nconst maxA = function (N) {\n  const dp = [0, 1, 2, 3, 4, 5, 6]\n  const recurse = function (n) {\n    if (dp[n]) return dp[n]\n    const max = Math.max(\n      recurse(n - 3) * 2,\n      recurse(n - 4) * 3,\n      recurse(n - 5) * 4\n    )\n    return (dp[n] = max)\n  }\n  return recurse(N)\n}\n\n// another\n\n/**\n * @param {number} N\n * @return {number}\n */\nconst maxA = function (N) {\n  const dp = [...new Array(N + 1)].map((_, i) => i)\n  for (let i = 4; i <= N; i++) {\n    for (let j = 1; j <= i - 3; j++) {\n      dp[i] = Math.max(dp[i], dp[j] * (i - j - 1))\n    }\n  }\n  return dp[N]\n}\n\n// another\n\n/**\n * @param {number} N\n * @return {number}\n */\nconst maxA = function (N) {\n  const dp = new Array(7).fill(0)\n  for (let i = 1; i <= N; i++) {\n    dp[0] = i\n    for (let k = 6; k > 2; k--) {\n      dp[0] = Math.max(dp[0], dp[k] * (k - 1))\n    }\n    for (let k = 6; k > 0; k--) {\n      dp[k] = dp[k - 1]\n    }\n  }\n  return dp[0]\n}\n\n"
    }
  },
  {
    "name": "652-find-duplicate-subtrees",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode[]}\n */\nconst findDuplicateSubtrees = function(root) {\n  const hash = {}, res = []\n  pre(root, hash, res)\n  return res\n};\n\nfunction pre(node, hash, res) {\n  if(node == null) return '#'\n  const str = `${node.val},${pre(node.left, hash, res)},${pre(node.right, hash, res)}`\n  if(hash[str] == null) hash[str] = 0\n  hash[str]++\n  if(hash[str] === 2) res.push(node)\n  return str\n}\n\n// another\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode[]}\n */\nconst findDuplicateSubtrees = function(root) {\n  const serId = {}, cntId = {}, res = []\n  let id = 1\n  post(root)\n  return res\n  \n  function post(node) {\n    if(node == null) return 0\n    const curId = `${post(node.left)},${node.val},${post(node.right)}`\n    serId[curId] = serId[curId] || id\n    if(serId[curId] === id) id++\n    cntId[curId] = (cntId[curId] || 0) + 1\n    if(cntId[curId] === 2) res.push(node)\n    return serId[curId]\n  }\n};\n\n"
    }
  },
  {
    "name": "653-two-sum-iv-input-is-a-bst",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} k\n * @return {boolean}\n */\nconst findTarget = function(root, k) {\n  const m = new Map()\n  return traverse(root, k, m)\n};\n\nfunction traverse(node, k, m) {\n  if(node == null) return false\n  if(m.has(k - node.val)) return true\n  m.set(node.val, node)\n  return traverse(node.left,k,m) || traverse(node.right,k,m)\n}\n"
    }
  },
  {
    "name": "655-print-binary-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {string[][]}\n */\nconst printTree = function (root) {\n  const h = getH(root)\n  const w = Math.pow(2, h) - 1\n  const matrix = new Array(h).fill(0).map((_) => new Array(w).fill(''))\n  fill(root, 0, 0, w - 1)\n  return matrix\n  function getH(root) {\n    if (!root) return 0\n    return Math.max(getH(root.left), getH(root.right)) + 1\n  }\n  function fill(root, level, start, end) {\n    if (!root) return\n    let mid = (start + end) / 2\n    matrix[level][mid] = root.val + ''\n    fill(root.left, level + 1, start, mid - 1)\n    fill(root.right, level + 1, mid + 1, end)\n  }\n}\n"
    }
  },
  {
    "name": "656-coin-path",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @param {number} B\n * @return {number[]}\n */\nconst cheapestJump = function (A, B) {\n  if (A[A.length - 1] < 0) return []\n  let dp = []\n  let nextTo = []\n  dp[A.length - 1] = A[A.length - 1]\n  nextTo[A.length - 1] = -1\n  for (let i = A.length - 2; i >= 0; i--) {\n    dp[i] = -1\n    if (A[i] === -1) continue\n    let cost = Infinity\n    for (let j = i + 1; j <= Math.min(i + B, A.length - 1); j++) {\n      if (dp[j] !== -1 && dp[j] < cost) {\n        cost = dp[j]\n        nextTo[i] = j\n      }\n    }\n    if (cost < Infinity) dp[i] = cost + A[i]\n  }\n  let ans = []\n  if (dp[0] >= 0) {\n    let p = 0\n    while (p >= 0) {\n      ans.push(p + 1)\n      p = nextTo[p]\n    }\n  }\n  return ans\n}\n"
    }
  },
  {
    "name": "658-find-k-closest-elements",
    "code": {
      "JS": "/**\n * @param {number[]} arr\n * @param {number} k\n * @param {number} x\n * @return {number[]}\n */\nconst findClosestElements = function(arr, k, x) {\n      let lo = 0, hi = arr.length - k - 1;\n      while (lo <= hi) {\n          let mid = Math.floor(lo + (hi - lo) / 2);\n          if (Math.abs(x - arr[mid]) > Math.abs(x - arr[mid+k])) {\n              lo = mid + 1; \n          } else {\n              hi = mid - 1; \n          }                \n      }     \n      return arr.slice(lo, lo+k);\n};\n\n// another\n\n/**\n * @param {number[]} arr\n * @param {number} k\n * @param {number} x\n * @return {number[]}\n */\nconst findClosestElements = function(arr, k, x) {\n    let lo=0,hi=arr.length-1\n    while(hi-lo>=k){\n        let left=Math.abs(x-arr[lo])\n        let right=Math.abs(x-arr[hi])\n        if(left<right){\n            hi--\n        }else if(left>right){\n            lo++\n        }else{\n            hi--\n        }\n    }\n    return arr.slice(lo,hi+1)\n};\n"
    }
  },
  {
    "name": "659-split-array-into-consecutive-subsequences",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nconst isPossible = function(nums) {\n  const freq = new Map()\n  const build = new Map()\n  for (let el of nums) {\n    freq.has(el) ? freq.set(el, freq.get(el) + 1) : freq.set(el, 1)\n  }\n  for (let item of nums) {\n    if (freq.get(item) === 0) continue\n    else if (getOrDefault(build, item) > 0) {\n      build.set(item, build.get(item) - 1)\n      build.set(item + 1, getOrDefault(build, item + 1) + 1)\n    } else if (getOrDefault(freq, item + 1) > 0 && getOrDefault(freq, item + 2) > 0) {\n      freq.set(item + 1, freq.get(item + 1) - 1)\n      freq.set(item + 2, freq.get(item + 2) - 1)\n      build.set(item + 3, getOrDefault(build, item + 3) + 1)\n    } else return false\n    freq.set(item, freq.get(item) - 1)\n  }\n  return true\n}\n\nfunction getOrDefault(map, key) {\n  return map.get(key) || 0\n}\n\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\nconst isPossible = function(nums) {\n  let prev = -Infinity, p1 = 0, p2 = 0, p3 = 0\n  let i = 0\n  const n = nums.length\n  while (i < n) {\n    let curr = nums[i], c1 = 0, c2 = 0, c3 = 0\n    let cnt = 0\n    while (i < n && nums[i] === curr) { cnt++; i++ }\n    if (curr !== prev+1) {\n      if (p1 > 0 || p2 > 0) { return false }\n      c1 = cnt; c2 = 0; c3 = 0\n    } else {\n      if (cnt < p1 + p2) { return false }\n      c2 = p1\n      c3 = p2 + Math.min(p3, cnt - p1 - p2)\n      c1 = Math.max(0, cnt - p1 - p2 - p3)\n    }\n    prev = curr; p1 = c1; p2 = c2; p3 = c3;\n  }\n  return p1 === 0 && p2 === 0\n};\n"
    }
  },
  {
    "name": "66-plus-one",
    "code": {
      "JS": "/**\n * @param {number[]} digits\n * @return {number[]}\n */\nconst plusOne = function (digits) {\n  for (let i = digits.length - 1; i >= 0; i--) {\n    if (digits[i] !== 9) {\n      digits[i]++\n      return digits\n    } else {\n      digits[i] = 0\n    }\n  }\n  digits.unshift(1)\n  return digits\n}\n"
    }
  },
  {
    "name": "660-remove-9",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst newInteger = function (n) {\n  let res = ''\n  while (n > 0) {\n    res = (n % 9) + res\n    n = Math.floor(n / 9)\n  }\n  return parseInt(res, 10)\n}\n\n// another\n\n/**\n * @param {number} n\n * @return {number}\n */\nconst newInteger = function (n) {\n  return +(n).toString(9)\n}\n"
    }
  },
  {
    "name": "661-image-smoother",
    "code": {
      "JS": "/**\n * @param {number[][]} M\n * @return {number[][]}\n */\nconst imageSmoother = function (M) {\n  const r = M.length\n  if (r === 0) return 0\n  const c = M[0].length\n  if (c === 0) return 0\n  const res = Array.from({ length: r }, () => Array(c).fill(0))\n  for (let i = 0; i < r; i++) {\n    for (let j = 0; j < c; j++) {\n      res[i][j] = helper(M, i, j, res)\n    }\n  }\n  return res\n}\n\nfunction helper(M, i, j, res) {\n  let val = M[i][j]\n  let num = 1\n  const dirs = [\n    [-1, -1],\n    [-1, 0],\n    [-1, 1],\n    [0, -1],\n    [0, 1],\n    [1, -1],\n    [1, 0],\n    [1, 1],\n  ]\n  for (let [dr, dc] of dirs) {\n    const ii = i + dr\n    const jj = j + dc\n    if (M[ii] != null && M[ii][jj] != null) {\n      val += M[ii][jj]\n      num++\n    }\n  }\n  return (val / num) >> 0\n}\n"
    }
  },
  {
    "name": "662-maximum-width-of-binary-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nconst widthOfBinaryTree = function(root) {\n    const mins = [0]\n    let max = 0\n  \n    dfs(root, 0, 0)\n    return max\n  \n    // depth first search\n    function dfs(currentNode, depth, position) {\n      if (!currentNode) return\n      if (depth === mins.length) {\n        mins[depth] = position\n      }\n  \n      const delta = position - mins[depth]\n      max = Math.max(max, delta + 1)\n      dfs(currentNode.left, depth + 1, delta * 2)\n      dfs(currentNode.right, depth + 1, delta * 2 + 1)\n    }\n  }\n"
    }
  },
  {
    "name": "663-equal-tree-partition",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nconst checkEqualTree = function (root) {\n  const s = new Set()\n  const visit = (node, k = 1) => {\n    if (!node) return 0\n    const l = visit(node.left)\n    const r = visit(node.right)\n    const ret = l + r + node.val\n    if (k) s.add(ret)\n    return ret\n  }\n  const sum = visit(root, 0)\n  if (sum % 2) return false\n  return s.has(sum / 2)\n}\n"
    }
  },
  {
    "name": "664-strange-printer",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst strangePrinter = function(s) {\n  // optimize\n  const arr = s.split('')\n  for(let i = 1; i < arr.length; i++) {\n    if(arr[i] === arr[i - 1]) arr[i - 1] = ''\n  }\n  s = arr.join('')\n  let n = s.length\n  let dp = new Array(n).fill(0).map(() => new Array(n).fill(0))\n\n  const help = (s, i, j) => {\n    if (i > j) return 0\n    if (dp[i][j] > 0) {\n      return dp[i][j]\n    }\n    let res = help(s, i, j - 1) + 1\n    for (let k = i; k < j; k++) {\n      if (s[k] === s[j]) {\n        res = Math.min(help(s, i, k) + help(s, k + 1, j - 1), res)\n      }\n    }\n    dp[i][j] = res\n    return res\n  }\n\n  return help(s, 0, n - 1)\n}\n\n// another\n\n/**\n * @param {string} s\n * @return {number}\n */\nconst strangePrinter = function(s) {\n  const n = s.length\n  const dp = Array.from({ length: n }, () => Array(n).fill(n))\n  for(let i = 0; i < n; i++) dp[i][i] = 1\n  for(let len = 2; len <= n; len++) {\n    for(let i = 0; i < n - len + 1; i++) {\n      let j = i + len - 1\n      dp[i][j] = 1 + dp[i + 1][j]\n      for(let k = i + 1; k < j; k++) {\n        if(s[i] === s[k]) dp[i][j] = Math.min(dp[i][j], dp[i][k - 1] + dp[k + 1][j])\n      }\n      if(s[i] === s[j]) dp[i][j] = Math.min(dp[i][j - 1], dp[i][j])\n    }\n  }\n  return dp[0][n - 1]\n};\n"
    }
  },
  {
    "name": "665-non-decreasing-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nconst checkPossibility = function(nums) {\n  let count = 0;\n  let idx;\n  if (nums.length === 1) return true;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i - 1] > nums[i]) {\n      count++;\n      idx = i;\n    }\n  }\n  if (count > 1) return false;\n  if (idx === nums.length - 1 || idx === 1) return true;\n  return (\n    Math.max(...nums.slice(0, idx - 1)) <= Math.min(...nums.slice(idx)) ||\n    Math.max(...nums.slice(0, idx)) <= Math.min(...nums.slice(idx + 1))\n  );\n};\n"
    }
  },
  {
    "name": "666-path-sum-iv",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst pathSum = function (nums) {\n  if (nums == null || nums.length === 0) return 0\n  const tree = Array(2 ** 5).fill(null)\n  for (let num of nums) {\n    const r = ((num / 100) >> 0) - 1\n    const pos = (((num % 100) / 10) >> 0) - 1\n    const v = num % 10\n    tree[Math.pow(2, r) + pos] = v\n  }\n  let res = 0\n  const q = [1]\n  while (q.length) {\n    const cur = q.shift()\n    const left = cur * 2\n    const right = cur * 2 + 1\n    if (left >= tree.length || (tree[left] == null && tree[right] == null))\n      res += tree[cur]\n    else {\n      if (tree[left] != null) {\n        q.push(left)\n        tree[left] += tree[cur]\n      }\n      if (tree[right] != null) {\n        q.push(right)\n        tree[right] += tree[cur]\n      }\n    }\n  }\n  return res\n}\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst pathSum = function (nums) {\n  if (nums == null || nums.length === 0) return 0\n  const tree = new Map()\n  for (let num of nums) {\n    tree.set((num / 10) >> 0, num % 10)\n  }\n  return traverse((nums[0] / 10) >> 0, 0)\n\n  function traverse(node, prev) {\n    if (!tree.has(node)) return 0\n    const level = (node / 10) >> 0\n    const pos = node % 10\n    const val = tree.get(node)\n    const left = (level + 1) * 10 + pos * 2 - 1\n    const right = (level + 1) * 10 + pos * 2\n    const cur = prev + val\n    if (!tree.has(left) && !tree.has(right)) return cur\n    return traverse(left, cur) + traverse(right, cur)\n  }\n}\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nconst pathSum = function (nums) {\n  const arr = Array(1 << 5).fill(-1)\n  for (let num of nums) {\n    let [lvl, pos, val] = [\n      parseInt(num / 100),\n      parseInt((num % 100) / 10),\n      num % 10,\n    ]\n    arr[(1 << (lvl - 1)) - 1 + pos - 1] = val\n  }\n  let sum = 0\n  for (let i = 0; i < 1 << 4; i++) {\n    if (arr[i] !== -1) {\n      arr[i] += i > 0 ? arr[parseInt((i - 1) >> 1)] : 0\n      if (arr[i * 2 + 1] === -1 && arr[i * 2 + 2] === -1) {\n        sum += arr[i]\n      }\n    }\n  }\n  return sum\n}\n"
    }
  },
  {
    "name": "667-beautiful-arrangement-ii",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number} k\n * @return {number[]}\n */\nconst constructArray = function (n, k) {\n  const res = [1]\n  while (k) {\n    const index = res.length\n    if (index % 2 === 1) {\n      res.push(res[index - 1] + k)\n    } else {\n      res.push(res[index - 1] - k)\n    }\n    k -= 1\n  }\n  if (res.length < n) {\n    for (let i = res.length + 1; i <= n; i += 1) {\n      res.push(i)\n    }\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "668-kth-smallest-number-in-multiplication-table",
    "code": {
      "JS": "/**\n * @param {number} m\n * @param {number} n\n * @param {number} k\n * @return {number}\n */\nconst findKthNumber = function(m, n, k) {\n  let left = 1;\n  let right = m * n;\n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n    const nSmaller = count(m, n, mid);\n    if (nSmaller >= k) {\n      right = mid;\n    } else {\n      left = mid + 1;\n    }\n  }\n  return left;\n};\n\nfunction count(m, n, target) {\n  let nSmaller = 0;\n  let j = n;\n  for (let i = 1; i <= m; i++) {\n    while (i * j > target) {\n      j -= 1;\n    }\n    nSmaller += j;\n  }\n  return nSmaller;\n}\n\n// another\n\n/**\n * @param {number} m\n * @param {number} n\n * @param {number} k\n * @return {number}\n */\nconst findKthNumber = function(m, n, k) {\n  let left = 1;\n  let right = m * n;\n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n    const num = count(m, n, mid);\n    if (num < k) left = mid + 1;\n    else right = mid;\n  }\n  return left;\n};\n\nfunction count(m, n, target) {\n  let res = 0;\n  let j = n;\n  for (let i = 1; i <= m; i++) {\n    while (i * j > target) j--\n    res += j;\n  }\n  return res;\n}\n"
    }
  },
  {
    "name": "669-trim-a-binary-search-tree",
    "code": {
      "JS": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @param {number} L\r\n * @param {number} R\r\n * @return {TreeNode}\r\n */\r\nconst trimBST = function(root, L, R) {\r\n  return single(root, L, R);\r\n};\r\n\r\nfunction single(node, L, R) {\r\n  if (node === null) {\r\n    return null;\r\n  }\r\n  if (node.val > R) {\r\n    return single(node.left, L, R);\r\n  }\r\n  if (node.val < L) {\r\n    return single(node.right, L, R);\r\n  }\r\n  if (node.left !== null) {\r\n    node.left = single(node.left, L, R);\r\n  }\r\n  if (node.right !== null) {\r\n    node.right = single(node.right, L, R);\r\n  }\r\n  return node;\r\n}\r\n"
    }
  },
  {
    "name": "67-add-binary",
    "code": {
      "JS": "/**\n * @param {string} a\n * @param {string} b\n * @return {string}\n */\nconst addBinary = function(a, b) {\n    let s = ''\n    let c = 0\n    let i = a.length - 1\n    let j = b.length - 1\n    while(i >= 0 || j >= 0 || c === 1) {\n        c += i >= 0 ? +a[i--] : 0\n        c += j >= 0 ? +b[j--] : 0\n        s = (c % 2 === 1 ? '1' : '0') + s\n        c = Math.floor(c / 2)\n    }\n    return s\n};\n\n// another\n\n/**\n * @param {string} a\n * @param {string} b\n * @return {string}\n */\nconst addBinary = function(a, b) {\n  let next = false\n  let res = []\n  let ai = a.length - 1\n  let bi = b.length - 1\n  while((ai >= 0 && bi >=0) || next) {\n    const tmp = (ai >= 0 ? +a[ai--] : 0) + (bi >= 0 ? +b[bi--] : 0) + (next ? 1 : 0)\n    if(tmp > 1) next = true\n    else next = false\n    res.unshift('' + (tmp % 2))\n  }\n\n  while(ai >= 0) res.unshift(a[ai--])\n  while(bi >= 0) res.unshift(b[bi--])\n  \n  return res.join('')\n};\n"
    }
  },
  {
    "name": "670-maximum-swap",
    "code": {
      "JS": "/**\n * @param {number} num\n * @return {number}\n */\nconst maximumSwap = function(num) {\n    const arr = ('' + num).split('')\n    for(let i = 0; i < arr.length - 1; i++) {\n        let cur = +arr[i]\n        let nextMax = Math.max(...arr.slice(i+1).map(el => +el))\n        if (nextMax > cur) {\n            let idx = arr.lastIndexOf(''+nextMax)\n            arr[i] = nextMax\n            arr[idx] = cur\n            break\n        }\n    }\n    return +(arr.join(''))\n};\n"
    }
  },
  {
    "name": "671-second-minimum-node-in-a-binary-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nconst findSecondMinimumValue = function(root) {\n  if(root == null) return -1\n  const q = [root]\n  let min = Number.MAX_VALUE\n  let min2nd = Number.MAX_VALUE\n  while(q.length) {\n    const len = q.length\n    for(let i = 0; i < len; i++) {\n      const cur = q.shift()\n      if(cur.val <= min) {\n        min = cur.val\n      } else if(cur.val > min && cur.val < min2nd) {\n        min2nd = cur.val\n      }\n      if(cur.left) q.push(cur.left)\n      if(cur.right) q.push(cur.right)\n    }\n  }\n  return min2nd === Number.MAX_VALUE ? -1 : min2nd\n};\n\n// another\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nconst findSecondMinimumValue = function (root) {\n  if (root === null) return -1;\n  if (root.left === null && root.right === null) return -1;\n  let left = root.left.val;\n  let right = root.right.val;\n  if (left === root.val) {\n    left = findSecondMinimumValue(root.left);\n  }\n  if (right === root.val) {\n    right = findSecondMinimumValue(root.right);\n  }\n  if (right !== -1 && left !== -1) {\n    return Math.min(left, right);\n  }\n  if (right === -1) {\n    return left;\n  }\n  if (left === -1) {\n    return right;\n  }\n};\n"
    }
  },
  {
    "name": "672-bulb-switcher-ii",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number} m\n * @return {number}\n */\nconst flipLights = function (n, m) {\n  n = Math.min(n, 3)\n  if (m === 0) return 1\n  if (m === 1) return n === 1 ? 2 : n === 2 ? 3 : 4\n  if (m === 2) return n === 1 ? 2 : n === 2 ? 4 : 7\n  return n === 1 ? 2 : n === 2 ? 4 : 8\n}\n"
    }
  },
  {
    "name": "673-number-of-longest-increasing-subsequence",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst findNumberOfLIS = function(nums) {\n    if (nums.length === 0) return 0;\n    const len = new Array(nums.length);\n    const cnt = new Array(nums.length);\n    let max = 1;\n    let res=1;\n    len[0] = 1;\n    cnt[0] = 1;\n    for (let i = 1; i < nums.length; i++) {\n        len[i] = 1;\n        cnt[i] = 1;\n        for (let j = 0; j < i; j++) {\n            if (nums[j] < nums[i]) {\n                if (len[j] + 1 > len[i]) {\n                    cnt[i] = cnt[j];\n                    len[i] = len[j] + 1;\n                } else if (len[j] + 1 === len[i]) {\n                    cnt[i] += cnt[j];\n                }\n            }\n        }\n        if (len[i] > max) {\n            max = len[i];\n            res = cnt[i];\n        } else if (len[i] === max) {\n            res += cnt[i];\n        }\n    }\n    return res;\n};\n"
    }
  },
  {
    "name": "674-longest-continuous-increasing-subsequence",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nconst findLengthOfLCIS = function(nums) {\r\n  if (nums.length == 1) {\r\n    return 1;\r\n  }\r\n  let ans = 0,\r\n    anchor = 0;\r\n  for (let i = 1; i < nums.length; i++) {\r\n    if (nums[i - 1] >= nums[i]) {\r\n      anchor = i;\r\n    }\r\n    ans = Math.max(ans, i - anchor + 1);\r\n  }\r\n  return ans;\r\n};\r\n"
    }
  },
  {
    "name": "675-cut-off-trees-for-golf-event",
    "code": {
      "JS": "/**\n * @param {number[][]} forest\n * @return {number}\n */\nconst cutOffTree = function (forest) {\n  const n = forest.length\n  if (n === 0) return 0\n  const m = forest[0].length\n  if (m === 0) return 0\n  const entries = []\n  for (let i = 0; i < n; i += 1) {\n    for (let j = 0; j < m; j += 1) {\n      if (forest[i][j] > 0) {\n        entries.push([forest[i][j], i, j])\n      }\n    }\n  }\n  entries.sort((e1, e2) => e1[0] - e2[0])\n  const direct = [\n    [1, 0],\n    [-1, 0],\n    [0, 1],\n    [0, -1],\n  ]\n  const visited = Array(n)\n    .fill(null)\n    .map(() => Array(m).fill(0))\n  const bfs = function (start, end) {\n    for (let i = 0; i < n; i += 1)\n      for (let j = 0; j < m; j += 1) visited[i][j] = 0\n    let cur = [start],\n      next = [],\n      step = 0\n    visited[start[0]][start[1]] = 1\n    while (cur.length > 0) {\n      next = []\n      for (const [x, y] of cur) {\n        if (x === end[0] && y === end[1]) return step\n        for (const [dx, dy] of direct) {\n          const p = x + dx,\n            q = y + dy\n          if (\n            p < 0 ||\n            q < 0 ||\n            p >= n ||\n            q >= m ||\n            visited[p][q] === 1 ||\n            forest[p][q] === 0\n          )\n            continue\n          visited[p][q] = 1\n          next.push([p, q])\n        }\n      }\n      step += 1\n      cur = next\n    }\n    return -1\n  }\n  let pre = [0, 0],\n    totalCnt = 0\n  for (const entry of entries) {\n    const step = bfs(pre, entry.slice(1))\n    if (step === -1) return -1\n    totalCnt += step\n    pre = entry.slice(1)\n  }\n  return totalCnt\n}\n"
    }
  },
  {
    "name": "676-implement-magic-dictionary",
    "code": {
      "JS": "/**\r\n * Initialize your data structure here.\r\n */\r\nconst MagicDictionary = function(dict) {\r\n  this.dict = [];\r\n};\r\n\r\n/**\r\n * Build a dictionary through a list of words\r\n * @param {string[]} dict\r\n * @return {void}\r\n */\r\nMagicDictionary.prototype.buildDict = function(dict) {\r\n  this.dict = dict;\r\n};\r\n\r\n/**\r\n * Returns if there is any word in the trie that equals to the given word after modifying exactly one character\r\n * @param {string} word\r\n * @return {boolean}\r\n */\r\nMagicDictionary.prototype.search = function(word) {\r\n  return check(word, this.dict);\r\n};\r\n\r\n/**\r\n * Your MagicDictionary object will be instantiated and called as such:\r\n * var obj = Object.create(MagicDictionary).createNew()\r\n * obj.buildDict(dict)\r\n * var param_2 = obj.search(word)\r\n */\r\n\r\nfunction check(str, arr) {\r\n  let el;\r\n  for (let i = 0; i < arr.length; i++) {\r\n    el = arr[i];\r\n    if (el.length === str.length && oneCharDiff(el, str)) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction oneCharDiff(str1, str2) {\r\n  let diff = 0;\r\n  for (let i = 0; i < str1.length; i++) {\r\n    if (str1[i] !== str2[i]) {\r\n      diff += 1;\r\n    }\r\n  }\r\n  return diff === 1 ? true : false;\r\n}\r\n"
    }
  },
  {
    "name": "677-map-sum-pairs",
    "code": {
      "JS": "/**\r\n * Initialize your data structure here.\r\n */\r\nconst MapSum = function() {\r\n  this.hash = {};\r\n};\r\n\r\n/**\r\n * @param {string} key\r\n * @param {number} val\r\n * @return {void}\r\n */\r\nMapSum.prototype.insert = function(key, val) {\r\n  this.hash[key] = val;\r\n};\r\n\r\n/**\r\n * @param {string} prefix\r\n * @return {number}\r\n */\r\nMapSum.prototype.sum = function(prefix) {\r\n  let res = 0;\r\n  Object.keys(this.hash).forEach(el => {\r\n    if (el.indexOf(prefix) === 0) {\r\n      res += this.hash[el];\r\n    }\r\n  });\r\n  return res;\r\n};\r\n\r\n/**\r\n * Your MapSum object will be instantiated and called as such:\r\n * var obj = Object.create(MapSum).createNew()\r\n * obj.insert(key,val)\r\n * var param_2 = obj.sum(prefix)\r\n */\r\n"
    }
  },
  {
    "name": "678-valid-parenthesis-string",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {boolean}\n */\nconst checkValidString = function(s) {\n    let lo = 0, hi = 0;\n    for (let i = 0; i < s.length; i++) {\n        lo += s[i] == '(' ? 1 : -1;\n        hi += s[i] != ')' ? 1 : -1;\n        if (hi < 0) break;\n        lo = Math.max(lo, 0);\n    }\n    return lo === 0;\n};\n\n// another\n\n/**\n * @param {string} s\n * @return {boolean}\n */\n const checkValidString = function (s) {\n  let lo = 0, hi = 0 // 可能多余的‘(’\n  for(let ch of s) {\n    if(ch === '(') lo++, hi++\n    if(ch === ')') {\n      if(lo > 0) lo--\n      hi--\n    }\n    if(ch === '*') {\n      if(lo > 0) lo--\n      hi++\n    }\n    if(hi < 0) return false\n  }\n  return lo === 0\n}\n"
    }
  },
  {
    "name": "679-24-game",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nconst judgePoint24 = function(nums) {\n  return dfs(nums)\n}\n\nfunction dfs(list) {\n  let eps = 0.0001\n  if (list.length === 1) {\n    if (Math.abs(list[0] - 24) < eps) {\n      return true\n    }\n    return false\n  }\n  let n = list.length\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      const next = new Array(n - 1)\n      for (let k = 0, index = 0; k < n; k++) {\n        if (k !== i && k !== j) next[index++] = list[k]\n      }\n      let d1 = list[i],\n        d2 = list[j]\n      const dirs = [d1 + d2, d1 - d2, d2 - d1, d2 * d1]\n      if (d1 > eps) dirs.push(d2 / d1)\n      if (d2 > eps) dirs.push(d1 / d2)\n      for (let dir of dirs) {\n        next[n - 2] = dir\n        if (dfs(next)) return true\n      }\n    }\n  }\n  return false\n}\n\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\nconst judgePoint24 = function(nums) {\n  return dfs(nums);\n};\n\nfunction dfs(list) {\n  if (list.length === 1) {\n    if (Math.abs(list[0] - 24) < 0.001) {\n      return true;\n    }\n    return false;\n  }\n  for (let i = 0; i < list.length; i++) {\n    for (let j = i + 1; j < list.length; j++) {\n      for (let c of compute(list[i], list[j])) {\n        let nextRound = [];\n        nextRound.push(c);\n        for (let k = 0; k < list.length; k++) {\n          if (k === j || k === i) continue;\n          nextRound.push(list[k]);\n        }\n        if (dfs(nextRound)) return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction compute(a, b) {\n  return [a + b, a - b, b - a, a * b, a / b, b / a];\n}\n"
    }
  },
  {
    "name": "68-text-justification",
    "code": {
      "JS": "/**\r\n * @param {string[]} words\r\n * @param {number} maxWidth\r\n * @return {string[]}\r\n */\r\nconst fullJustify = function(words, maxWidth) {\r\n  const res = []\r\n  let curRow = []\r\n  let numOfChars = 0\r\n  \r\n  for (let w of words) {\r\n    if (numOfChars + w.length + curRow.length > maxWidth) {\r\n      for(let i = 0; i < maxWidth - numOfChars; i++) {\r\n        if(curRow.length === 1) {\r\n          curRow[0] += ' '\r\n        } else {\r\n          curRow[i % (curRow.length - 1)] += ' '\r\n        }\r\n      }\r\n      res.push(curRow.join(''))\r\n      curRow = []\r\n      numOfChars = 0\r\n    }\r\n    curRow.push(w)\r\n    numOfChars += w.length\r\n  }\r\n\r\n  const numOfSpace = maxWidth - numOfChars - (curRow.length - 1)\r\n  let tail = ''\r\n  for(let i = 0; i < numOfSpace; i++) tail += ' '\r\n  res.push(curRow.join(' ') + tail)\r\n\r\n  return res\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * @param {string[]} words\r\n * @param {number} L\r\n * @returns {string[]}\r\n */\r\nconst fullJustify = function(words, L) {\r\n  const res = [\"\"];\r\n  if (words.length === 0 || L === 0) {\r\n    return res;\r\n  } else {\r\n    res.shift();\r\n    for (let i = 0, k, l; i < words.length; i += k) {\r\n      for (\r\n        k = l = 0;\r\n        i + k < words.length && l + words[i + k].length <= L - k;\r\n        k++\r\n      ) {\r\n        l += words[i + k].length;\r\n      }\r\n      let tmp = words[i];\r\n      for (j = 0; j < k - 1; j++) {\r\n        if (i + k >= words.length) {\r\n          tmp += \" \";\r\n        } else {\r\n          // for (i = 0; i < ((L - l) / (k - 1) + (j < (L - l) % (k - 1))) - 1; i++) {\r\n          //     tmp += ' ';\r\n          // }\r\n          tmp += Array(\r\n            parseInt((L - l) / (k - 1) + (j < (L - l) % (k - 1))) + 1\r\n          ).join(\" \");\r\n        }\r\n        // tmp += (L - l) / (k - 1) + (j < (L - l) % (k - 1)) + ' ';\r\n        tmp += words[i + j + 1];\r\n      }\r\n      // for (i = 0; i < (L - tmp.length); i++) {\r\n      //     tmp += ' '\r\n      // }\r\n      tmp += Array(parseInt(L - tmp.length) + 1).join(\" \");\r\n      // tmp += L - tmp.length + ' ';\r\n      res.push(tmp);\r\n    }\r\n    return res;\r\n  }\r\n};\r\n"
    }
  },
  {
    "name": "680-valid-palindrome-ii",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {boolean}\n */\n\nconst validPalindrome = function(s) {\n  let start = 0;\n  let end = s.length - 1;\n\n  const isPalindrome = function(start, end, removed) {\n    while (start <= end) {\n      if (s[start] !== s[end]) {\n        if (removed) {\n          return false;\n        }\n\n        return (\n          isPalindrome(start + 1, end, true) ||\n          isPalindrome(start, end - 1, true)\n        );\n      }\n      start++;\n      end--;\n    }\n    return true;\n  };\n\n  return isPalindrome(start, end, false);\n};\n"
    }
  },
  {
    "name": "681-next-closest-time",
    "code": {
      "JS": "/**\n * @param {string} time\n * @return {string}\n */\nconst nextClosestTime = function (time) {\n  const digits = time.split('')\n  const orderedDigits = [...digits].sort()\n  for (let i = digits.length - 1; i >= 0; i--) {\n    const current = digits[i]\n    switch (i) {\n      case 4:\n        digits[i] = findSmallest(digits[i], '9', orderedDigits)\n        if (digits[i] > current) return digits.join('')\n        break\n      case 3:\n        digits[i] = findSmallest(digits[i], '5', orderedDigits)\n        if (digits[i] > current) return digits.join('')\n        break\n      case 1:\n        digits[i] = findSmallest(\n          digits[i],\n          digits[i - 1] == '2' ? '4' : '9',\n          orderedDigits\n        )\n        if (digits[i] > current) return digits.join('')\n        break\n      case 0:\n        digits[i] = findSmallest(digits[i], '2', orderedDigits)\n        if (digits[i] > current) return digits.join('')\n        break\n    }\n  }\n  return digits.join('')\n}\n\nconst findSmallest = (low, high, order) => {\n  for (let d = 0; d < order.length; d++) {\n    if (order[d] != ':' && order[d] > low && order[d] <= high) {\n      return order[d]\n    }\n  }\n  return order[0]\n}\n"
    }
  },
  {
    "name": "682-baseball-game",
    "code": {
      "JS": "/**\r\n * @param {string[]} ops\r\n * @return {number}\r\n */\r\nconst calPoints = function(ops) {\r\n  const opArr = [\"C\", \"D\", \"+\"];\r\n  const arr = [];\r\n  ops.forEach((el, idx) => {\r\n    const item = {\r\n      value: 0,\r\n      valid: true\r\n    };\r\n    switch (el) {\r\n      case \"C\":\r\n        findValid(arr, idx, 1).forEach(el => {\r\n          el.value = 0;\r\n          el.valid = false;\r\n        });\r\n        item.valid = false;\r\n        break;\r\n      case \"D\":\r\n        item.value = findValid(arr, idx, 1)[0].value * 2;\r\n        break;\r\n      case \"+\":\r\n        item.value = findValid(arr, idx, 2).reduce(\r\n          (ac, ele) => ac + ele.value,\r\n          0\r\n        );\r\n        break;\r\n      default:\r\n        item.value = +el;\r\n        break;\r\n    }\r\n    arr.push(item);\r\n  });\r\n  return arr.reduce((ac, el) => ac + el.value, 0);\r\n};\r\n\r\nfunction findValid(arr, idx, backStep) {\r\n  const res = [];\r\n  while (backStep > 0 && idx - 1 >= 0) {\r\n    if (arr[idx - 1].valid === true) {\r\n      backStep -= 1;\r\n      res.push(arr[idx - 1]);\r\n    }\r\n    idx -= 1;\r\n  }\r\n  return res;\r\n}\r\n\r\nconsole.log(calPoints([\"5\", \"2\", \"C\", \"D\", \"+\"]));\r\nconsole.log(calPoints([\"5\", \"-2\", \"4\", \"C\", \"D\", \"9\", \"+\", \"+\"]));\r\n"
    }
  },
  {
    "name": "683-k-empty-slots",
    "code": {
      "JS": "/**\n * @param {number[]} bulbs\n * @param {number} K\n * @return {number}\n */\nconst kEmptySlots = function (bulbs, K) {\n  const days = new Array(bulbs.length)\n  for (let i = 0; i < bulbs.length; i++) days[bulbs[i] - 1] = i + 1\n  let left = 0,\n    right = K + 1,\n    res = Number.MAX_VALUE\n  for (let i = 0; right < days.length; i++) {\n    if (days[i] < days[left] || days[i] <= days[right]) {\n      if (i === right) res = Math.min(res, Math.max(days[left], days[right]))\n      left = i\n      right = K + 1 + i\n    }\n  }\n  return res === Number.MAX_VALUE ? -1 : res\n}\n"
    }
  },
  {
    "name": "684-redundant-connection",
    "code": {
      "JS": "/**\n * @param {number[][]} edges\n * @return {number[]}\n */\nconst findRedundantConnection = function (edges) {\n  const uf = {}\n  for (let edge of edges) {\n    let u = edge[0]\n    let v = edge[1]\n    if (find(u) === find(v)) {\n      return edge\n    } else {\n      union(u, v)\n    }\n  }\n  function union(a, b) {\n    uf[find(a)] = uf[find(b)]\n  }\n  function find(x) {\n    if (!uf[x]) uf[x] = x\n    if (uf[x] === x) return x\n    return find(uf[x])\n  }\n}\n"
    }
  },
  {
    "name": "685-redundant-connection-ii",
    "code": {
      "JS": "/**\n * @param {number[][]} edges\n * @return {number[]}\n */\nconst findRedundantDirectedConnection = function (edges) {\n  const parent = []\n  //detect circle\n  for (let i = 1; i <= edges.length; i++) {\n    parent[i] = i\n  }\n  let circleEdge, removedEdge, candidateEdge\n  for (let i = 0; i < edges.length; i++) {\n    const [u, v] = edges[i]\n    const pu = findParent(parent, u)\n    const pv = findParent(parent, v)\n    if (pv !== v) {\n      removedEdge = [u, v] // node with 2 parents\n    } else {\n      if (pv === pu) {\n        circleEdge = [u, v] // circle edge\n      }\n      parent[v] = pu\n    }\n  }\n  if (!removedEdge) {\n    return circleEdge\n  }\n  if (circleEdge) {\n    return edges.find((d) => d[1] === removedEdge[1] && d[0] !== removedEdge[0])\n  } else {\n    return removedEdge\n  }\n}\nconst findParent = function (parent, i) {\n  if (parent[i] !== i) {\n    parent[i] = findParent(parent, parent[i])\n  }\n  return parent[i]\n}\n"
    }
  },
  {
    "name": "686-repeated-string-match",
    "code": {
      "JS": "/**\n * @param {string} A\n * @param {string} B\n * @return {number}\n */\nconst repeatedStringMatch = function(A, B) {\n    let count = Math.ceil(B.length / A.length);\n    let testString = A.repeat(count)\n    \n    return testString.includes(B) ? count : (testString + A).includes(B) ? count + 1 : -1\n};\n// Form a string of length N from each index in A. \n// If any of these string equals B, then B is a substring of A.\n// const repeatedStringMatch = function(A, B) {\n//     for (let i = 0; i < A.length; i++) {\n//         if (A.charAt(i) === B.charAt(0)) {\n//             let count = 1;\n//             let j = 0;\n//             let startIx = i;\n//             while (j < B.length && A.charAt(startIx) === B.charAt(j)) {\n//                 j++;\n//                 startIx++;\n//                 if (startIx >= A.length && j < B.length) {\n//                     startIx = startIx % A.length;\n//                     count++;\n//                 }\n//             }\n//             if (j == B.length) return count;\n//         }\n//     }\n//     return -1;\n// };\n"
    }
  },
  {
    "name": "687-longest-univalue-path",
    "code": {
      "JS": "\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nconst longestUnivaluePath = function(root) {\n  let res = 0\n  dfs(root)\n  return res\n\n  function dfs(node) {\n    if(node == null) return 0\n    let left = dfs(node.left), right = dfs(node.right)\n    if(node.left && node.left.val === node.val) left++\n    else left = 0\n\n    if(node.right && node.right.val === node.val) right++\n    else right = 0\n\n    res = Math.max(res, left + right)\n    return Math.max(left, right)\n  }\n};\n\n// another\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nconst getCount = function(root, longest) {\n  if (!root) {\n    return 0;\n  }\n  let leftCount = getCount(root.left, longest);\n  let rightCount = getCount(root.right, longest);\n  if (root.left && root.left.val === root.val) {\n    leftCount++;\n  } else {\n    leftCount = 0;\n  }\n  if (root.right && root.right.val === root.val) {\n    rightCount++;\n  } else {\n    rightCount = 0;\n  }\n  longest.max = Math.max(longest.max, leftCount + rightCount);\n  return Math.max(leftCount, rightCount);\n};\n\nconst longestUnivaluePath = function(root) {\n  let longest = { max: 0 };\n  getCount(root, longest);\n  return longest.max;\n};\n"
    }
  },
  {
    "name": "688-knight-probability-in-chessboard",
    "code": {
      "JS": "/**\n * @param {number} N\n * @param {number} K\n * @param {number} r\n * @param {number} c\n * @return {number}\n */\nconst knightProbability = function (N, K, r, c) {\n  const moves = [\n    [1, 2],\n    [1, -2],\n    [2, 1],\n    [2, -1],\n    [-1, 2],\n    [-1, -2],\n    [-2, 1],\n    [-2, -1],\n  ]\n  const dp = [...Array(K + 1)].map(() =>\n    [...Array(N)].map(() => Array(N).fill(0))\n  )\n  dp[0][r][c] = 1\n  for (let step = 1; step <= K; step++) {\n    for (let i = 0; i < N; i++) {\n      for (let j = 0; j < N; j++) {\n        for (let move of moves) {\n          let row = i + move[0],\n            col = j + move[1]\n          if (row >= 0 && row < N && col >= 0 && col < N)\n            dp[step][i][j] += dp[step - 1][row][col] / 8\n        }\n      }\n    }\n  }\n  let res = 0\n  for (let i = 0; i < N; i++) {\n    for (let j = 0; j < N; j++) {\n      res += dp[K][i][j]\n    }\n  }\n  return res\n}\n\n"
    }
  },
  {
    "name": "689-maximum-sum-of-3-non-overlapping-subarrays",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nconst maxSumOfThreeSubarrays = (nums, k) => {\n  let n = nums.length,\n    maxsum = 0\n  let sum = new Array(n + 1).fill(0),\n    posLeft = new Array(n).fill(0),\n    posRight = new Array(n).fill(0),\n    ans = new Array(3).fill(0)\n  for (let i = 0; i < n; i++) sum[i + 1] = sum[i] + nums[i]\n  for (let i = k, tot = sum[k] - sum[0]; i < n; i++) {\n    if (sum[i + 1] - sum[i + 1 - k] > tot) {\n      posLeft[i] = i + 1 - k\n      tot = sum[i + 1] - sum[i + 1 - k]\n    } else posLeft[i] = posLeft[i - 1]\n  }\n  posRight[n - k] = n - k\n  for (let i = n - k - 1, tot = sum[n] - sum[n - k]; i >= 0; i--) {\n    if (sum[i + k] - sum[i] >= tot) {\n      posRight[i] = i\n      tot = sum[i + k] - sum[i]\n    } else posRight[i] = posRight[i + 1]\n  }\n  for (let i = k; i <= n - 2 * k; i++) {\n    let l = posLeft[i - 1],\n      r = posRight[i + k]\n    let tot = sum[i + k] - sum[i] + (sum[l + k] - sum[l]) + (sum[r + k] - sum[r])\n    if (tot > maxsum) {\n      maxsum = tot\n      ans[0] = l\n      ans[1] = i\n      ans[2] = r\n    }\n  }\n  return ans\n}\n"
    }
  },
  {
    "name": "69-sqrt(x)",
    "code": {
      "JS": "/**\r\n * @param {number} x\r\n * @return {number}\r\n */\r\nconst mySqrt = function(x) {\r\n  let left = 0, right = x;\r\n  while (left < right) {\r\n    let mid = right - ((right - left) >> 1);\r\n    if (mid * mid > x) {\r\n      right = mid - 1;\r\n    } else {\r\n      left = mid;\r\n    }\r\n  }\r\n  return left;\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * @param {number} x\r\n * @return {number}\r\n */\r\nconst mySqrt = function(x) {\r\n  r = x;\r\n  while (r * r > x) r = ((r + x / r) / 2) | 0;\r\n  return r;\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * @param {number} x\r\n * @return {number}\r\n */\r\nconst mySqrt = function(x) {\r\n  let l = 1, r = x\r\n  if(x === 0) return 0\r\n  while(true) {\r\n    let mid = l + ((r - l) >> 1)\r\n    if(mid * mid > x) r = mid - 1\r\n    else {\r\n      if((mid + 1) * (mid + 1) > x) return mid\r\n      l = mid + 1\r\n    }\r\n  }\r\n};\r\n"
    }
  },
  {
    "name": "690-employee-importance",
    "code": {
      "JS": "/**\n * Definition for Employee.\n * function Employee(id, importance, subordinates) {\n *     // It's the unique id of each node\n *     // unique id of this employee\n *     this.id = id;\n *     // the importance value of this employee\n *     this.importance = importance;\n *     // the id of direct subordinates\n *     this.subordinates = subordinates;\n * }\n */\n\n/**\n * @param {Employee[]} employees\n * @param {number} id\n * @return {number}\n */\nconst GetImportance = function (employees, id) {\n  const map = {}\n  employees.forEach((employee) => {\n    map[employee.id] = employee\n  })\n  const s = [id]\n  let importance = 0\n  while (s.length) {\n    let current = map[s.pop()]\n    importance += current.importance\n    if (current.subordinates.length) {\n      s.push(...current.subordinates.reverse())\n    }\n  }\n  return importance\n}\n"
    }
  },
  {
    "name": "691-stickers-to-spell-word",
    "code": {
      "JS": "/**\n * @param {string[]} stickers\n * @param {string} target\n * @return {number}\n */\nconst minStickers = function(stickers, target) {\n  const isEqual = (arr1, arr2) => {\n    for (let i = 0; i < arr1.length; ++i) if (arr1[i] !== arr2[i]) return false\n    return true\n  }\n\n  const minus = (arr1, arr2) => {\n    let res = []\n    for (let i = 0; i < arr1.length; ++i)\n      res[i] = arr1[i] <= 0 ? arr1[i] : arr1[i] - arr2[i]\n    return res\n  }\n\n  const isAllNonpositive = arr => {\n    return arr.every(item => item <= 0)\n  }\n\n  const getString = arr => {\n    return arr.reduce((acc, cur, idx) => {\n      if (cur > 0) return acc + String.fromCharCode(idx + 97).repeat(cur)\n      else return acc\n    }, '')\n  }\n\n  let ss = stickers.map(word => {\n    let tmp = new Array(26).fill(0)\n    for (let i = 0; i < word.length; ++i) tmp[word.charCodeAt(i) - 97]++\n    return tmp\n  })\n  let root = new Array(26).fill(0)\n  for (let i = 0; i < target.length; ++i) root[target.charCodeAt(i) - 97]++\n  let cache = new Set()\n  let queue = [root]\n  let size = 0,\n    level = 0,\n    front = null\n  while (queue.length !== 0) {\n    size = queue.length\n    while (size--) {\n      front = queue.shift()\n      for (let w of ss) {\n        let t = minus(front, w)\n        let str = getString(t)\n        if (isEqual(t, front) || cache.has(str)) continue\n        if (isAllNonpositive(t)) return level + 1\n        else {\n          queue.push(t)\n          cache.add(str)\n        }\n      }\n    }\n    level++\n  }\n  return -1\n}\n"
    }
  },
  {
    "name": "692-top-k-frequent-words",
    "code": {
      "JS": "/**\n * @param {string[]} words\n * @param {number} k\n * @return {string[]}\n */\nconst topKFrequent = function(words, k) {\n  const hash = {}\n  words.forEach(el => {\n    if(hash.hasOwnProperty(el)) {\n      hash[el]++\n    } else {\n      hash[el] = 1\n    }\n  })\n  const freqArr = new Array(words.length)\n  const keys = Object.keys(hash)\n  \n  for(let k of keys) {\n    let freq = hash[k]\n    if(freqArr[freq] == null) {\n       freqArr[freq] = []\n    }\n    freqArr[freq].push(k)\n  }\n  \n  const res = []\n  for(let i = freqArr.length; i >= 0 && res.length < k; i--) {\n    if(freqArr[i] != null) {\n      res.push(...(freqArr[i].sort()))\n    }\n  }\n  \n  return res.slice(0, k)\n};\n"
    }
  },
  {
    "name": "693-binary-number-with-alternating-bits",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {boolean}\n */\nconst hasAlternatingBits = function(n) {\n  const str = bin(n);\n  for (let i = 1, prev = str.charAt(0); i < str.length; i++) {\n    if (str.charAt(i) === prev) {\n      return false;\n    }\n    prev = str.charAt(i);\n  }\n  return true;\n};\n\nfunction bin(num) {\n  return (num >>> 0).toString(2);\n}\n"
    }
  },
  {
    "name": "694-number-of-distinct-islands",
    "code": {
      "JS": "/**\n\nGiven a non-empty 2D array grid of 0's and 1's,\nan island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.)\nYou may assume all four edges of the grid are surrounded by water.\n\nCount the number of distinct islands. An island is considered to\nbe the same as another if and only if one island can\nbe translated (and not rotated or reflected) to equal the other.\n\nExample 1:\n11000\n11000\n00011\n00011\n\nGiven the above grid map, return 1.\n\nExample 2:\n11011\n10000\n00001\n11011\n\nGiven the above grid map, return 3.\n\nNotice that:\n11\n1\nand\n 1\n11\nare considered different island shapes, because we do not consider reflection / rotation.\nNote: The length of each dimension in the given grid does not exceed 50.\n\n*/\n\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nconst numDistinctIslands = function(grid) {\n  const set = new Set()\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[0].length; j++) {\n      if (grid[i][j] === 1) {\n        const tempArr = []\n        helper(i, j, grid, tempArr)\n        const x = tempArr[0][0] - 0\n        const y = tempArr[0][1] - 0\n        let str = ''\n        for (let k = 0; k < tempArr.length; k++) {\n          str += '#' + (tempArr[k][0] - x) + '#' + (tempArr[k][1] - y)\n        }\n        set.add(str)\n      }\n    }\n  }\n  return set.size\n}\n\nfunction helper(i, j, arr, tempArr) {\n  tempArr.push([i, j])\n  arr[i][j] = 0\n\n  if (arr[i][j - 1] === 1) helper(i, j - 1, arr, tempArr)\n  if (arr[i][j + 1] === 1) helper(i, j + 1, arr, tempArr)\n  if (arr[i - 1]) {\n    if (arr[i - 1][j] === 1) helper(i - 1, j, arr, tempArr)\n  }\n  if (arr[i + 1]) {\n    if (arr[i + 1][j] === 1) helper(i + 1, j, arr, tempArr)\n  }\n}\n\n// another\n\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nconst numDistinctIslands = function(grid) {\n  if (!grid.length) return 0;\n  const pattern = new Set();\n  grid.forEach((rows, row) => {\n    rows.forEach((val, col) => {\n      if (val === 1) pattern.add(depthFirst(grid, row, col, \"o\"));\n    });\n  });\n  return pattern.size;\n};\n\nfunction depthFirst(graph, row, col, di) {\n  if (graph[row] && graph[row][col]) {\n    graph[row][col] = 0;\n    let p =\n      di +\n      depthFirst(graph, row + 1, col, \"d\") +\n      depthFirst(graph, row - 1, col, \"u\") +\n      depthFirst(graph, row, col + 1, \"r\") +\n      depthFirst(graph, row, col - 1, \"l\") +\n      \"b\";\n    return p;\n  } else return \"\";\n}\n"
    }
  },
  {
    "name": "695-max-area-of-island",
    "code": {
      "JS": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nconst maxAreaOfIsland = function(grid) {\n    let res = 0\n    const seen = []\n    for(let i = 0; i < grid.length; i++) {\n        seen[i] = []\n    }\n    for(let i = 0; i < grid.length; i++) {\n        for(let j = 0; j < grid[0].length; j++) {\n            res = Math.max(res, area(i, j, seen, grid))\n        }\n    }\n    return res\n};\n\nfunction area(r, c, seen, grid) {\n    console.log(grid)\n    if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length || seen[r][c] || grid[r][c] == 0) return 0;\n    seen[r][c] = true;\n    return (1 + area(r+1, c, seen, grid) + area(r-1, c, seen, grid) + area(r, c-1, seen, grid) + area(r, c+1, seen, grid));\n}\n\nconsole.log(maxAreaOfIsland([[1,1,0,0,0],[1,1,0,0,0],[0,0,0,1,1],[0,0,0,1,1]]))\nconsole.log(maxAreaOfIsland([[1,0],[1,1]]))\nconsole.log(maxAreaOfIsland([[1,1],[1,0]]))\n"
    }
  },
  {
    "name": "697-degree-of-an-array",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nconst findShortestSubArray = function(nums) {\r\n  const left = {};\r\n  const right = {};\r\n  const count = {};\r\n\r\n  for (let i = 0; i < nums.length; i++) {\r\n    if (!left.hasOwnProperty(nums[i])) {\r\n      left[nums[i]] = i;\r\n    }\r\n    right[nums[i]] = i;\r\n    count[nums[i]] = count[nums[i]] ? count[nums[i]] + 1 : 1;\r\n  }\r\n  const degree = Math.max(...Object.keys(count).map(el => count[el]));\r\n  let res = nums.length;\r\n  for (let el in count) {\r\n    if (count.hasOwnProperty(el) && count[el] === degree) {\r\n      res = Math.min(res, right[el] - left[el] + 1);\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n"
    }
  },
  {
    "name": "698-partition-to-k-equal-sum-subsets",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {boolean}\n */\nconst canPartitionKSubsets = function(nums, k) {\n    const sum = nums.reduce((ac, el) => ac + el, 0)\n    return k !== 0 && sum % k === 0 && canPartition(0, nums, [], k, 0, sum / k)\n    \n};\n\nfunction canPartition(start, nums, seen, k, sum, target) {\n    if(k === 1) return true\n    if (sum === target) {\n        return canPartition(0, nums, seen, k - 1, 0, target)\n    }\n    for(let i = start; i < nums.length; i++) {\n        if (!seen[i]) {\n            seen[i] = true\n            if(canPartition(i + 1, nums, seen, k, sum + nums[i], target)) {\n                return true\n            }\n            seen[i] = false\n        }\n    }\n    return false\n}\n"
    }
  },
  {
    "name": "699-falling-squares",
    "code": {
      "JS": "/**\n * @param {number[][]} positions\n * @return {number[]}\n */\nclass Interval {\n  constructor(start, end, height) {\n    this.start = start\n    this.end = end\n    this.height = height\n  }\n}\nfunction fallingSquares(positions) {\n  const intervals = []\n  const res = []\n  let h = 0\n  for (let pos of positions) {\n    let cur = new Interval(pos[0], pos[0] + pos[1], pos[1])\n    h = Math.max(h, getHeight(intervals, cur))\n    res.push(h)\n  }\n  console.log(intervals)\n  return res\n}\nfunction getHeight(intervals, cur) {\n  let preMaxHeight = 0\n  for (let i of intervals) {\n    if (i.end <= cur.start) continue\n    if (i.start >= cur.end) continue\n    preMaxHeight = Math.max(preMaxHeight, i.height)\n  }\n  cur.height += preMaxHeight\n  intervals.push(cur)\n  return cur.height\n}\n\n// another\n\n/**\n * @param {number[][]} positions\n * @return {number[]}\n */\nvar fallingSquares = function (positions) {\n  let ranges = [{ left: 0, height: 0, right: 1e8 + 1e6 }], rtn = [], max = 0\n\n  outer:\n  for (let [left, length] of positions) {\n    let curHeight = 0, startI = -1, right = left + length, newRanges = []\n    for (let i = 0; i < ranges.length; i++) {\n      let range = ranges[i]\n      if (left < range.right && startI == -1) {\n        startI = i\n        // left part\n        if (left != range.left) {\n          newRanges.push({\n            left: range.left,\n            height: range.height,\n            right: left\n          })\n        }\n      }\n      if (startI != -1) {\n        curHeight = Math.max(curHeight, range.height)\n      }\n      if (right <= range.right) {\n        // added part\n        let newHeight = length + curHeight\n        newRanges.push({\n          left,\n          height: newHeight,\n          right,\n        })\n        // right part\n        if (right != range.right) {\n          newRanges.push({\n            left: right,\n            height: range.height,\n            right: range.right,\n          })\n        }\n        max = Math.max(newHeight, max)\n        rtn.push(max)\n        // replace\n        ranges.splice(startI, i - startI + 1, ...newRanges)\n        continue outer\n      }\n    }\n  }\n  return rtn\n};\n"
    }
  },
  {
    "name": "7-reverse-integer",
    "code": {
      "JS": "/**\r\n * @param {number} x\r\n * @return {number}\r\n */\r\nconst reverse = function (x) {\r\n  let res = 0, tail, newResult\r\n  const low = -Math.pow(2, 31), high = Math.pow(2, 31)\r\n  while(x !== 0) {\r\n    tail = x % 10\r\n    newResult = res * 10 + tail\r\n    // if((newResult - tail) / 10 !== res) return 0\r\n    if(newResult < low || newResult >= high) return 0\r\n    res = newResult\r\n    x = ~~(x / 10)\r\n  }\r\n  \r\n  return res\r\n};\r\n\r\n// another\r\n\r\n\r\n/**\r\n * @param {number} x\r\n * @return {number}\r\n */\r\nconst reverse = function(num) {\r\n  let negative = false;\r\n  let result = 0;\r\n  if (num < 0) {\r\n    negative = true;\r\n    num = Math.abs(num);\r\n  }\r\n  while (num > 0) {\r\n    mod = num % 10; // mod = 3 // mod = 2 // mod\r\n    num = Math.floor(num / 10); // num = 12 // num = 1\r\n    result = result * 10 + mod; // 0 = 0 * 10 + 3 = 0 + 3 = 3 // 3 = 3 * 10 + 2 = 30 + 2 = 32\r\n  }\r\n  if (result > 2147483647) return 0;\r\n  if (negative) return result * -1;\r\n  return result;\r\n};\r\n"
    }
  },
  {
    "name": "70-climbing-stairs",
    "code": {
      "JS": "/**\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nconst climbStairs = function(n) {\r\n  const hash = {};\r\n  return single(n, hash);\r\n};\r\n\r\nfunction single(i, hash) {\r\n  if (hash.hasOwnProperty(i)) {\r\n    return hash[i];\r\n  }\r\n  if (i === 1) {\r\n    hash[1] = 1;\r\n    return 1;\r\n  }\r\n  if (i === 2) {\r\n    hash[2] = 2;\r\n    return 2;\r\n  }\r\n  hash[i] = single(i - 1, hash) + single(i - 2, hash);\r\n  return hash[i];\r\n}\r\n\r\n// another\r\n\r\n/**\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nconst climbStairs = function (n) {\r\n  const dp = new Array(n + 1).fill(0)\r\n  if (n === 1) {\r\n    return 1\r\n  }\r\n  if (n === 2) {\r\n    return 2\r\n  }\r\n  dp[0] = 0\r\n  dp[1] = 1\r\n  dp[2] = 2\r\n  for (let i = 3; i <= n; i++) {\r\n    dp[i] = dp[i - 1] + dp[i - 2]\r\n  }\r\n  return dp[n]\r\n}\r\n"
    }
  },
  {
    "name": "700-search-in-a-binary-search-tree",
    "code": {
      "JS": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @param {number} val\r\n * @return {TreeNode}\r\n */\r\nconst searchBST = function (root, val) {\r\n  if (!root || root.val === val) {\r\n    return root\r\n  }\r\n  return root.val < val ? searchBST(root.right, val) : searchBST(root.left, val)\r\n}\r\n"
    }
  },
  {
    "name": "701-insert-into-a-binary-search-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} val\n * @return {TreeNode}\n */\nconst insertIntoBST = function(root, val) {\n    if(root == null) return new TreeNode(val);\n    let cur = root;\n    while(true) {\n      if(cur.val <= val) {\n        if(cur.right != null) cur = cur.right;\n        else {\n          cur.right = new TreeNode(val);\n          break;\n        }\n      } else {\n        if(cur.left != null) cur = cur.left;\n        else {\n          cur.left = new TreeNode(val);\n          break;\n        }\n      }\n    }\n    return root;\n}; \n\n// another\n\nconst insertIntoBST = function(root, val) {\n    if (root == null) {\n      return new TreeNode(val);\n    }\n    if (root.val > val) {\n      root.left = insertIntoBST(root.left, val);\n    } else {\n      root.right = insertIntoBST(root.right, val);\n    }\n    return root;\n}; \n\n// another\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} val\n * @return {TreeNode}\n */\nconst insertIntoBST = function(root, val) {\n  if(root == null) return new TreeNode(val)\n  if(val < root.val) root.left = insertIntoBST(root.left, val)\n  else if(val > root.val) root.right = insertIntoBST(root.right, val)\n  return root\n};\n"
    }
  },
  {
    "name": "702-search-in-a-sorted-array-of-unknown-size",
    "code": {
      "JS": "/**\n * // This is the ArrayReader's API interface.\n * // You should not implement it, or speculate about its implementation\n * function ArrayReader() {\n *\n *     @param {number} index\n *     @return {number}\n *     this.get = function(index) {\n *         ...\n *     };\n * };\n */\n\n/**\n * @param {ArrayReader} reader\n * @param {number} target\n * @return {number}\n */\nconst search = function (reader, target) {\n  let left = 0,\n    right = 1\n  while (reader.get(right) < target) {\n    left = right\n    right <<= 1\n  }\n  while (left <= right) {\n    const mid = left + Math.floor((right - left) / 2)\n    if (reader.get(mid) === target) return mid\n    if (reader.get(mid) > target) right = mid - 1\n    else left = mid + 1\n  }\n  return -1\n}\n"
    }
  },
  {
    "name": "703-kth-largest-element-in-a-stream",
    "code": {
      "JS": "/**\n * @param {number} k\n * @param {number[]} nums\n */\nconst KthLargest = function(k, nums) {\n  this.sorted = nums.sort((a, b) => a - b);\n  this.k = k;\n};\n\n/**\n * @param {number} val\n * @return {number}\n */\nKthLargest.prototype.add = function(val) {\n  let left = 0;\n  let right = this.sorted.length - 1;\n  let insertIndex = left;\n  while (left <= right) {\n    let mid = left + Math.floor((right - left) / 2);\n    if (val > this.sorted[mid]) {\n      left = mid + 1;\n      insertIndex = mid + 1;\n    } else if (val < this.sorted[mid]) {\n      right = mid - 1;\n      insertIndex = mid;\n    } else {\n      insertIndex = mid;\n      break;\n    }\n  }\n  this.sorted.splice(insertIndex, 0, val);\n  return this.sorted[this.sorted.length - this.k];\n};\n\n/** \n * Your KthLargest object will be instantiated and called as such:\n * var obj = new KthLargest(k, nums)\n * var param_1 = obj.add(val)\n */\n"
    }
  },
  {
    "name": "704-binary-search",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nconst search = function(nums, target) {\n    let start = 0;\n    let end = nums.length - 1;\n    \n    while(start <= end){\n        let mid = parseInt((start + end) / 2);\n        if(nums[mid] === target) return mid;\n        if(nums[mid] > target) end = mid -1;\n        if(nums[mid] < target) start = mid + 1;\n    }\n    return -1;\n};\n"
    }
  },
  {
    "name": "705-design-hashset",
    "code": {
      "JS": "/**\n * Initialize your data structure here.\n */\nconst MyHashSet = function() {\n    this.s = {}\n};\n\n/** \n * @param {number} key\n * @return {void}\n */\nMyHashSet.prototype.add = function(key) {\n    this.s[key] = true\n};\n\n/** \n * @param {number} key\n * @return {void}\n */\nMyHashSet.prototype.remove = function(key) {\n    delete this.s[key]\n};\n\n/**\n * Returns true if this set contains the specified element \n * @param {number} key\n * @return {boolean}\n */\nMyHashSet.prototype.contains = function(key) {\n    return Object.prototype.hasOwnProperty.call(this.s, key)\n};\n\n/** \n * Your MyHashSet object will be instantiated and called as such:\n * var obj = Object.create(MyHashSet).createNew()\n * obj.add(key)\n * obj.remove(key)\n * var param_3 = obj.contains(key)\n */\n"
    }
  },
  {
    "name": "706-design-hashmap",
    "code": {
      "JS": "/**\n * Initialize your data structure here.\n */\nconst MyHashMap = function() {\n    this.h = {}\n};\n\n/**\n * value will always be non-negative. \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nMyHashMap.prototype.put = function(key, value) {\n    this.h[key] = value\n};\n\n/**\n * Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key \n * @param {number} key\n * @return {number}\n */\nMyHashMap.prototype.get = function(key) {\n   return {}.hasOwnProperty.call(this.h, key) ? this.h[key] : -1\n};\n\n/**\n * Removes the mapping of the specified value key if this map contains a mapping for the key \n * @param {number} key\n * @return {void}\n */\nMyHashMap.prototype.remove = function(key) {\n    delete this.h[key]\n};\n\n/** \n * Your MyHashMap object will be instantiated and called as such:\n * var obj = Object.create(MyHashMap).createNew()\n * obj.put(key,value)\n * var param_2 = obj.get(key)\n * obj.remove(key)\n */\n"
    }
  },
  {
    "name": "707-design-linked-list",
    "code": {
      "JS": "/**\n * Initialize your data structure here.\n */\nvar MyLinkedList = function() {\n  this.arr = []\n}\n\n/**\n * Get the value of the index-th node in the linked list. If the index is invalid, return -1.\n * @param {number} index\n * @return {number}\n */\nMyLinkedList.prototype.get = function(index) {\n  if (this.arr[index] !== undefined) {\n    return this.arr[index]\n  } else {\n    return -1\n  }\n}\n\n/**\n * Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.\n * @param {number} val\n * @return {void}\n */\nMyLinkedList.prototype.addAtHead = function(val) {\n  this.arr.unshift(val)\n}\n\n/**\n * Append a node of value val to the last element of the linked list.\n * @param {number} val\n * @return {void}\n */\nMyLinkedList.prototype.addAtTail = function(val) {\n  this.arr.push(val)\n}\n\n/**\n * Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.\n * @param {number} index\n * @param {number} val\n * @return {void}\n */\nMyLinkedList.prototype.addAtIndex = function(index, val) {\n  if (this.arr.length >= index) {\n    this.arr.splice(index, 0, val)\n  }\n  if (index < 0) {\n    this.arr.unshift(val)\n  }\n}\n\n/**\n * Delete the index-th node in the linked list, if the index is valid.\n * @param {number} index\n * @return {void}\n */\nMyLinkedList.prototype.deleteAtIndex = function(index) {\n  if (index >= 0 && index < this.arr.length) {\n    this.arr.splice(index, 1)\n  }\n}\n\n/**\n * Your MyLinkedList object will be instantiated and called as such:\n * var obj = new MyLinkedList()\n * var param_1 = obj.get(index)\n * obj.addAtHead(val)\n * obj.addAtTail(val)\n * obj.addAtIndex(index,val)\n * obj.deleteAtIndex(index)\n */\n\n// another\n\n/**\n * Initialize your data structure here.\n */\nvar MyLinkedList = function(val) {\n  this.head = null\n  this.tail = null\n  this.size = 0\n}\n\n// Create Node class to store node data as an 'object'\nvar Node = function(val) {\n  this.val = val\n  this.next = null\n}\n\n/**\n * Get the value of the index-th node in the linked list. If the index is invalid, return -1.\n * @param {number} index\n * @return {number}\n */\nMyLinkedList.prototype.get = function(index) {\n  if (index < 0 || this.size === 0 || index > this.size - 1) return -1\n  let curr = this.head\n  let i = 0\n  while (i < index) {\n    curr = curr.next\n    i += 1\n  }\n  return curr.val\n}\n\n/**\n * Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.\n * @param {number} val\n * @return {void}\n */\nMyLinkedList.prototype.addAtHead = function(val) {\n  let newNode = new Node(val)\n  if (this.head === null) {\n    this.head = newNode\n    this.tail = newNode\n  } else {\n    newNode.next = this.head\n    this.head = newNode\n  }\n  this.size++\n  return this\n}\n\n/**\n * Append a node of value val to the last element of the linked list.\n * @param {number} val\n * @return {void}\n */\nMyLinkedList.prototype.addAtTail = function(val) {\n  const newNode = new Node(val)\n  if (this.head === null) {\n    this.head = newNode\n    this.tail = newNode\n  } else {\n    this.tail.next = newNode\n    this.tail = newNode\n  }\n  this.size++\n  return this\n}\n\n/**\n * Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.\n * @param {number} index\n * @param {number} val\n * @return {void}\n */\nMyLinkedList.prototype.addAtIndex = function(index, val) {\n  if (index > this.size) return\n  if (index <= 0) return this.addAtHead(val)\n  if (index === this.size) return this.addAtTail(val)\n  let newNode = new Node(val)\n  let i = 0\n  let curr = this.head\n  while (i < index - 1) {\n    curr = curr.next\n    i++\n  }\n  newNode.next = curr.next ? curr.next : null\n  curr.next = newNode\n  this.size++\n  return this\n}\n\n/**\n * Delete the index-th node in the linked list, if the index is valid.\n * @param {number} index\n * @return {void}\n */\nMyLinkedList.prototype.deleteAtIndex = function(index) {\n  if (index >= this.size || index < 0) return\n  if (index === 0) {\n    this.head = this.head.next\n    this.size--\n    return this\n  }\n  let curr = this.head\n  let i = 0\n  while (i < index - 1) {\n    i++\n    curr = curr.next\n  }\n  curr.next = curr.next.next ? curr.next.next : null\n  if (!curr.next) this.tail = curr\n  this.size--\n  return this\n}\n\n/**\n * Your MyLinkedList object will be instantiated and called as such:\n * var obj = new MyLinkedList()\n * var param_1 = obj.get(index)\n * obj.addAtHead(val)\n * obj.addAtTail(val)\n * obj.addAtIndex(index,val)\n * obj.deleteAtIndex(index)\n */\n\n"
    }
  },
  {
    "name": "708-insert-into-a-sorted-circular-linked-list",
    "code": {
      "JS": "/**\n * // Definition for a Node.\n * function Node(val, next) {\n *     this.val = val;\n *     this.next = next;\n * };\n */\n\n/**\n * @param {Node} head\n * @param {number} insertVal\n * @return {Node}\n */\nconst insert = function (head, insertVal) {\n  if (head === null) {\n    const node = new Node(insertVal)\n    node.next = node\n    return node\n  }\n  let prev = head,\n    cur = prev.next\n  while (cur != head) {\n    if (prev.val > cur.val) {\n      if (insertVal >= prev.val || insertVal <= cur.val) break\n    }\n    if (prev.val <= insertVal && insertVal <= cur.val) break\n    prev = cur\n    cur = cur.next\n  }\n  prev.next = new Node(insertVal, cur)\n  return head\n}\n"
    }
  },
  {
    "name": "71-simplify-path",
    "code": {
      "JS": "/**\n * @param {string} path\n * @return {string}\n */\nconst simplifyPath = function(path) {\n  path = path.split('/').filter(s => !!s && s !== '.')\n  while (path[0] === '..') path = path.slice(1)\n  let result = []\n  for (let val of path) {\n    if (val === '..') result.pop()\n    else result.push(val)\n  }\n  return '/' + result.join('/')\n}\n"
    }
  },
  {
    "name": "710-random-pick-with-blacklist",
    "code": {
      "JS": "/**\n * @param {number} N\n * @param {number[]} blacklist\n */\nconst Solution = function (N, blacklist) {\n  this.map = new Map()\n  for (let b of blacklist) this.map.set(b, -1)\n  this.M = N - this.map.size\n  for (let b of blacklist) {\n    if (b < this.M) {\n      while (this.map.has(N - 1)) N--\n      this.map.set(b, N - 1)\n      N--\n    }\n  }\n}\n\n/**\n * @return {number}\n */\nSolution.prototype.pick = function () {\n  const p = Math.floor(Math.random() * this.M)\n  if (this.map.has(p)) return this.map.get(p)\n  return p\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * var obj = new Solution(N, blacklist)\n * var param_1 = obj.pick()\n */\n"
    }
  },
  {
    "name": "711-number-of-distinct-islands-ii",
    "code": {
      "JS": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nconst numDistinctIslands2 = function (grid) {\n  const dirs = [\n    [0, 1],\n    [0, -1],\n    [-1, 0],\n    [1, 0],\n  ]\n  const rowSize = grid.length\n  const colSize = grid[0].length\n  const seen = Array.from({ length: rowSize }, () => Array(colSize).fill(false))\n  const islands = new Set()\n  for (let r = 0; r < rowSize; r++) {\n    for (let c = 0; c < colSize; c++) {\n      const shape = []\n      dfs(r, c, shape)\n      if (shape.length > 0) islands.add(canonical(shape))\n    }\n  }\n  return islands.size\n  function dfs(r, c, shape = []) {\n    if (!inBound(r, c) || grid[r][c] !== 1 || seen[r][c]) return\n    seen[r][c] = true\n    shape.push(r * colSize + c)\n    dirs.forEach(([dr, dc]) => dfs(r + dr, c + dc, shape))\n  }\n  function canonical(shape) {\n    let ans = ''\n    const lift = rowSize + colSize\n    const n = shape.length\n    const out = Array(n).fill(0)\n    const xs = Array(n).fill(0)\n    const ys = Array(n).fill(0)\n    for (let rotate = 0; rotate < 8; rotate++) {\n      for (let i = 0; i < n; i++) {\n        const x = ~~(shape[i] / colSize)\n        const y = shape[i] % colSize\n        xs[i] = rotate <= 1 ? x : rotate <= 3 ? -x : rotate <= 5 ? y : -y\n        ys[i] =\n          rotate <= 3 ? (rotate % 2 === 0 ? y : -y) : rotate % 2 === 0 ? x : -x\n      }\n      const mx = Math.min(...xs)\n      const my = Math.min(...ys)\n      for (let i = 0; i < n; i++) {\n        out[i] = (xs[i] - mx) * lift + (ys[i] - my)\n      }\n      const candidate = out.sort((a, b) => a - b).join(',')\n      if (ans < candidate) ans = candidate\n    }\n    return ans\n  }\n  function inBound(r, c) {\n    return r >= 0 && r < rowSize && c >= 0 && c < colSize\n  }\n}\n"
    }
  },
  {
    "name": "712-minimum-ASCII-delete-sum-for-two-strings",
    "code": {
      "JS": "/**\r\n * @param {string} s1\r\n * @param {string} s2\r\n * @return {number}\r\n */\r\nconst minimumDeleteSum = function(s1, s2) {\r\n  const l1 = s1.length;\r\n  const l2 = s2.length;\r\n  const dp = [];\r\n  for (let i = 0; i <= l1; i++) {\r\n    dp[i] = [];\r\n  }\r\n  let sum = 0;\r\n  for (let i = 0; i <= l1; i++) {\r\n    for (let j = 0; j <= l2; j++) {\r\n      if (i === 0 || j === 0) {\r\n        sum = 0;\r\n        for (let k = 0; k < Math.max(i, j); k++) {\r\n          sum += i > j ? s1.charCodeAt(k) : s2.charCodeAt(k);\r\n        }\r\n        dp[i][j] = sum;\r\n      } else {\r\n        if (s1[i - 1] === s2[j - 1]) {\r\n          dp[i][j] = dp[i - 1][j - 1];\r\n        } else {\r\n          dp[i][j] = Math.min(\r\n            s1.charCodeAt(i - 1) + dp[i - 1][j],\r\n            s2.charCodeAt(j - 1) + dp[i][j - 1],\r\n            s1.charCodeAt(i - 1) + s2.charCodeAt(j - 1) + dp[i - 1][j - 1]\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return dp[l1][l2];\r\n};\r\n"
    }
  },
  {
    "name": "713-subarray-product-less-than-k",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nconst numSubarrayProductLessThanK = function(nums, k) {\n  if (k == 0) return 0\n  let cnt = 0\n  let pro = 1\n  for (let i = 0, j = 0, len = nums.length; j < len; j++) {\n    pro *= nums[j]\n    while (i <= j && pro >= k) {\n      pro /= nums[i++]\n    }\n    cnt += j - i + 1\n  }\n  return cnt\n}\n"
    }
  },
  {
    "name": "714-best-time-to-buy-and-sell-stock-with-transaction-fee",
    "code": {
      "JS": "/**\r\n * @param {number[]} prices\r\n * @param {number} fee\r\n * @return {number}\r\n */\r\nconst maxProfit = function(prices, fee) {\r\n  let cash = 0,\r\n    hold = -prices[0];\r\n  for (let i = 1; i < prices.length; i++) {\r\n    cash = Math.max(cash, hold + prices[i] - fee);\r\n    hold = Math.max(hold, cash - prices[i]);\r\n  }\r\n  return cash;\r\n};\r\n\r\nconsole.log(maxProfit([1, 3, 2, 8, 4, 9], 2));\r\n"
    }
  },
  {
    "name": "715-range-module",
    "code": {
      "JS": "const RangeModule = function() {\n  this.range = []\n}\n\n/**\n * @param {number} left\n * @param {number} right\n * @return {void}\n */\nRangeModule.prototype.addRange = function(left, right) {\n  let index1 = this.range.length\n  let low = 0\n  let high = this.range.length - 1\n  while (low <= high) {\n    const mid = (low + high) >> 1\n    if (this.range[mid][1] >= left) {\n      index1 = Math.min(index1, mid)\n      high = mid - 1\n    } else {\n      low = mid + 1\n    }\n  }\n\n  let index2 = -1\n  low = 0\n  high = this.range.length - 1\n  while (low <= high) {\n    const mid = (low + high) >> 1\n    if (this.range[mid][0] <= right) {\n      index2 = Math.max(index2, mid)\n      low = mid + 1\n    } else {\n      high = mid - 1\n    }\n  }\n\n  if (index1 === this.range.length) {\n    this.range.push([left, right])\n    return\n  } else if (index2 === -1) {\n    this.range.unshift([left, right])\n    return\n  }\n  left = Math.min(left, this.range[index1][0])\n  right = Math.max(right, this.range[index2][1])\n  this.range.splice(index1, index2 - index1 + 1, [left, right])\n}\n\n/**\n * @param {number} left\n * @param {number} right\n * @return {boolean}\n */\nRangeModule.prototype.queryRange = function(left, right) {\n  let index = -1\n  let low = 0\n  let high = this.range.length - 1\n  while (low <= high) {\n    const mid = (low + high) >> 1\n    if (this.range[mid][0] <= left) {\n      index = Math.max(index, mid)\n      low = mid + 1\n    } else {\n      high = mid - 1\n    }\n  }\n  if (index === -1 || this.range[index][1] < right) {\n    return false\n  }\n  return true\n}\n\n/**\n * @param {number} left\n * @param {number} right\n * @return {void}\n */\nRangeModule.prototype.removeRange = function(left, right) {\n  let index1 = this.range.length\n  let low = 0\n  let high = this.range.length - 1\n  while (low <= high) {\n    const mid = (low + high) >> 1\n    if (this.range[mid][1] >= left) {\n      index1 = Math.min(index1, mid)\n      high = mid - 1\n    } else {\n      low = mid + 1\n    }\n  }\n\n  let index2 = -1\n  low = 0\n  high = this.range.length - 1\n  while (low <= high) {\n    const mid = (low + high) >> 1\n    if (this.range[mid][0] <= right) {\n      index2 = Math.max(index2, mid)\n      low = mid + 1\n    } else {\n      high = mid - 1\n    }\n  }\n\n  if (index1 === this.range.length || index2 === -1) {\n    return\n  }\n\n  const newRange = []\n  if (left > this.range[index1][0]) {\n    newRange.push([this.range[index1][0], left])\n  }\n  if (right < this.range[index2][1]) {\n    newRange.push([right, this.range[index2][1]])\n  }\n  this.range.splice(index1, index2 - index1 + 1, ...newRange)\n}\n\n/**\n * Your RangeModule object will be instantiated and called as such:\n * var obj = new RangeModule()\n * obj.addRange(left,right)\n * var param_2 = obj.queryRange(left,right)\n * obj.removeRange(left,right)\n */\n\n\n// another\n\nconst RangeModule = function () {\n  this.intervals = []\n}\n\n/**\n * @param {number} left\n * @param {number} right\n * @return {void}\n */\nRangeModule.prototype.addRange = function (left, right) {\n  const n = this.intervals.length\n  const tmp = []\n  for (let i = 0; i <= n; i++) {\n    const cur = this.intervals[i]\n\n    if (i == n || cur[0] > right) {\n      tmp.push([left, right])\n      while (i < n) tmp.push(this.intervals[i++])\n    } else if (cur[1] < left) tmp.push(cur)\n    else {\n      left = Math.min(left, cur[0])\n      right = Math.max(right, cur[1])\n    }\n  }\n  this.intervals = tmp\n}\n\n/**\n * @param {number} left\n * @param {number} right\n * @return {boolean}\n */\nRangeModule.prototype.queryRange = function (left, right) {\n  const n = this.intervals.length\n  let l = 0,\n    r = n - 1\n  while (l <= r) {\n    let m = ~~(l + (r - l) / 2)\n    if (this.intervals[m][0] >= right) r = m - 1\n    else if (this.intervals[m][1] <= left) l = m + 1\n    else return this.intervals[m][0] <= left && this.intervals[m][1] >= right\n  }\n  return false\n}\n\n/**\n * @param {number} left\n * @param {number} right\n * @return {void}\n */\nRangeModule.prototype.removeRange = function (left, right) {\n  const n = this.intervals.length\n  const tmp = []\n  for (let i = 0; i < n; i++) {\n    const cur = this.intervals[i]\n    if (cur[1] <= left || cur[0] >= right) tmp.push(cur)\n    else {\n      if (cur[0] < left) tmp.push([cur[0], left])\n      if (cur[1] > right) tmp.push([right, cur[1]])\n    }\n  }\n  this.intervals = tmp\n}\n\n/**\n * Your RangeModule object will be instantiated and called as such:\n * var obj = new RangeModule()\n * obj.addRange(left,right)\n * var param_2 = obj.queryRange(left,right)\n * obj.removeRange(left,right)\n */\n"
    }
  },
  {
    "name": "716-max-stack",
    "code": {
      "JS": "/**\n * initialize your data structure here.\n */\nconst MaxStack = function() {\n  this.stack = []\n}\n\n/**\n * @param {number} x\n * @return {void}\n */\nMaxStack.prototype.push = function(x) {\n  this.stack.push(x)\n}\n\n/**\n * @return {number}\n */\nMaxStack.prototype.pop = function() {\n  return this.stack.pop()\n}\n\n/**\n * @return {number}\n */\nMaxStack.prototype.top = function() {\n  return this.stack[this.stack.length - 1]\n}\n\n/**\n * @return {number}\n */\nMaxStack.prototype.peekMax = function() {\n  return Math.max(...this.stack)\n}\n\n/**\n * @return {number}\n */\nMaxStack.prototype.popMax = function() {\n  const elem = Math.max(...this.stack)\n  const index = this.stack.lastIndexOf(elem)\n  return this.stack.splice(index, 1)[0]\n}\n\n/**\n * Your MaxStack object will be instantiated and called as such:\n * var obj = new MaxStack()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.top()\n * var param_4 = obj.peekMax()\n * var param_5 = obj.popMax()\n */\n"
    }
  },
  {
    "name": "717-1-bit-and-2-bit-characters",
    "code": {
      "JS": "/**\r\n * @param {number[]} bits\r\n * @return {boolean}\r\n */\r\nconst isOneBitCharacter = function(bits) {\r\n  let ones = 0;\r\n  //Starting from one but last, as last one is always 0.\r\n  for (let i = bits.length - 2; i >= 0 && bits[i] != 0; i--) {\r\n    ones++;\r\n  }\r\n  return ones % 2 > 0 ? false : true;\r\n};\r\n"
    }
  },
  {
    "name": "718-maximum-length-of-repeated-subarray",
    "code": {
      "JS": "/**\r\n * @param {number[]} A\r\n * @param {number[]} B\r\n * @return {number}\r\n */\r\nconst findLength = function(A, B) {\r\n  let ans = 0;\r\n  let memo = [];\r\n  for (let i = 0; i < A.length + 1; i++) {\r\n    memo[i] = Array(B.length + 1).fill(0);\r\n  }\r\n  for (let i = A.length - 1; i >= 0; --i) {\r\n    for (let j = B.length - 1; j >= 0; --j) {\r\n      if (A[i] == B[j]) {\r\n        memo[i][j] = memo[i + 1][j + 1] + 1;\r\n        if (ans < memo[i][j]) ans = memo[i][j];\r\n      }\r\n    }\r\n  }\r\n  return ans;\r\n};\r\n"
    }
  },
  {
    "name": "719-find-k-th-smallest-pair-distance",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nfunction smallestDistancePair(nums, k) {\n  nums.sort((a, b) => a - b)\n  let l = 0, n = nums.length, r = nums[n - 1] - nums[0]\n  \n  let res = 0\n  while(l < r) {\n    let cnt = 0, mid = l + ((r - l) >> 1)\n    for(let i = 0, j = 0; i < n; i++) {\n      while(j < n && nums[j] <= nums[i] + mid) j++\n      cnt += j - 1 - i\n    }\n    if(cnt < k) l = mid + 1\n    else r = mid\n  }\n\n  return l\n}\n\n// another\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nconst smallestDistancePair = function(nums, k) {\n  nums.sort((a, b) => a - b)\n  let lo = 0\n  let hi = nums[nums.length - 1] - nums[0]\n  while (lo < hi) {\n    let mi = Math.floor((lo + hi) / 2)\n    let count = 0\n    let left = 0\n    for (let right = 0; right < nums.length; right++) {\n      while (nums[right] - nums[left] > mi) left++\n      count += right - left\n    }\n    //count = number of pairs with distance <= mi\n    if (count >= k) hi = mi\n    else lo = mi + 1\n  }\n  return lo\n}\n"
    }
  },
  {
    "name": "72-edit-distance",
    "code": {
      "JS": "/**\n * @param {string} word1\n * @param {string} word2\n * @return {number}\n */\nconst minDistance = function(word1, word2) {\n    let m = word1.length, n = word2.length;\n    const dp = Array.from({length: m + 1}, ()=> new Array(n+ 1).fill(0))\n    for (let i = 1; i <= m; i++) {\n      dp[i][0] = i;\n    }\n    for (let j = 1; j <= n; j++) {\n      dp[0][j] = j;\n    }\n    for (let i = 1; i <= m; i++) {\n      for (let j = 1; j <= n; j++) {\n        if (word1[i - 1] === word2[j - 1]) {\n          dp[i][j] = dp[i - 1][j - 1];\n        } else {\n          dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i][j - 1], dp[i - 1][j])) + 1;\n        }\n      }\n    }\n    return dp[m][n];\n};\n\n// another\n\n/**\n * @param {string} word1\n * @param {string} word2\n * @return {number}\n */\nconst minDistance = function(word1, word2) {\n  const m = word1.length, n = word2.length\n  const dp = Array(n + 1).fill(0)\n  for(let i = 1; i <= n; i++) dp[i] = i \n  let pre = 0\n  for(let i = 1; i <= m; i++) {\n    pre = dp[0]\n    dp[0] = i\n    for(let j = 1; j <= n; j++) {\n      let tmp = dp[j]\n      if(word1[i - 1] === word2[j - 1]) {\n        dp[j] = pre\n      } else {\n        dp[j] = Math.min(pre, dp[j],  dp[j - 1]) + 1\n      }\n      pre = tmp\n    }\n  }\n\n  return dp[n]\n};\n"
    }
  },
  {
    "name": "720-longest-word-in-dictionary",
    "code": {
      "JS": "/**\n * @param {string[]} words\n * @return {string}\n */\nconst longestWord = function(words) {\n  if(words == null || words.length === 0) return ''\n  words.sort()\n  const s = new Set()\n  let res = ''\n  for(let i = 0, len = words.length; i < len; i++) {\n    const w = words[i]\n    if(w.length === 1 || s.has(w.slice(0, w.length - 1))) {\n      res = w.length > res.length ? w : res\n      s.add(w)\n    }\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "721-accounts-merge",
    "code": {
      "JS": "/**\n * @param {string[][]} accounts\n * @return {string[][]}\n */\nconst accountsMerge = function (accounts) {\n  const roots = new Set()\n  const owner = {}\n  const parent = {}\n  const children = {}\n\n  for (let account of accounts) {\n    let [user, root, ...emails] = account\n    let r1 = find(root)\n    owner[root] = user\n    children[r1] = children[r1] || [root]\n    roots.add(r1)\n\n    for (let email of emails) {\n      let r2 = find(email)\n      if (r2 !== r1) {\n        parent[r2] = r1\n        children[r1].push(...(children[r2] ? children[r2] : [email]))\n        roots.delete(r2)\n        delete children[r2]\n      }\n    }\n  }\n\n  return [...roots].map((r) => [owner[r], ...children[r].sort()])\n\n  function find(a) {\n    parent[a] = parent[a] || a\n    return a === parent[a] ? a : find(parent[a])\n  }\n}\n"
    }
  },
  {
    "name": "722-remove-comments",
    "code": {
      "JS": "/**\n * @param {string[]} source\n * @return {string[]}\n */\nconst removeComments = function (source) {\n  const code = source.join('\\n')\n  const isBlockStart = (c, i) => c[i] === '/' && c[i + 1] === '*'\n  const isBlockEnd = (c, i) => c[i] === '*' && c[i + 1] === '/'\n  const isLineStart = (c, i) => c[i] === '/' && c[i + 1] === '/'\n  const isNewLine = (c, i) => c[i] === '\\n'\n  let i = 0,\n    output = ''\n\n  while (i < code.length) {\n    if (isBlockStart(code, i)) {\n      i += 2\n      while (!isBlockEnd(code, i) && i < code.length) i++\n      i += 2\n    } else if (isLineStart(code, i)) {\n      i += 2\n      while (!isNewLine(code, i) && i < code.length) i++\n    } else {\n      output += code[i++]\n    }\n  }\n\n  return output.split('\\n').filter((l) => l.length)\n}\n"
    }
  },
  {
    "name": "723-candy-crush",
    "code": {
      "JS": "/**\n * @param {number[][]} board\n * @return {number[][]}\n */\nconst candyCrush = function (board) {\n  while (true) {\n    let moreToCrush = false\n    for (let i = 0; i < board.length; i++) {\n      for (let j = 0; j < board[0].length; j++) {\n        if (board[i][j] > 0) {\n          moreToCrush =\n            flagForCrush(board, i, j, board[i][j], 0, true, false) ||\n            moreToCrush\n          moreToCrush =\n            flagForCrush(board, i, j, board[i][j], 0, false, true) ||\n            moreToCrush\n        }\n      }\n    }\n    if (!moreToCrush) break\n    crush(board)\n    inflictGravity(board)\n  }\n  return board\n}\nconst flagForCrush = function (board, i, j, target, count, right, down) {\n  if (\n    j === board[0].length ||\n    i === board.length ||\n    Math.abs(board[i][j]) !== Math.abs(target)\n  ) {\n    return count >= 3\n  }\n\n  let shouldFlagIndexRight = flagForCrush(\n    board,\n    i,\n    j + 1,\n    target,\n    right ? count + 1 : 1,\n    true,\n    false\n  )\n  let shouldFlagIndexDown = flagForCrush(\n    board,\n    i + 1,\n    j,\n    target,\n    down ? count + 1 : 1,\n    false,\n    true\n  )\n\n  if ((shouldFlagIndexRight && right) || (shouldFlagIndexDown && down)) {\n    board[i][j] = -Math.abs(board[i][j])\n    return true\n  }\n\n  return false\n}\nconst crush = function (board) {\n  for (let i = 0; i < board.length; i++) {\n    for (let j = 0; j < board[0].length; j++) {\n      if (board[i][j] < 0) board[i][j] = 0\n    }\n  }\n}\nconst inflictGravity = function (board) {\n  for (let j = 0; j < board[0].length; j++) {\n    let st = board.length - 1\n    let end = board.length - 2\n    while (end >= 0) {\n      if (board[st][j] === 0 && board[end][j] !== 0) {\n        let temp = board[st][j]\n        board[st][j] = board[end][j]\n        board[end][j] = temp\n        st--\n      } else if (board[st][j] !== 0) {\n        st--\n      }\n      end--\n    }\n  }\n}\n\n// another\n\n/**\n * @param {number[][]} board\n * @return {number[][]}\n */\nconst candyCrush = function (board) {\n  const N = board.length,\n    M = board[0].length\n  let found = true\n  while (found) {\n    found = false\n    for (let i = 0; i < N; i++) {\n      for (let j = 0; j < M; j++) {\n        const val = Math.abs(board[i][j])\n        if (val === 0) continue\n        if (\n          j < M - 2 &&\n          Math.abs(board[i][j + 1]) === val &&\n          Math.abs(board[i][j + 2]) === val\n        ) {\n          found = true\n          let ind = j\n          while (ind < Math.min(M, j + 3) && Math.abs(board[i][ind]) === val)\n            board[i][ind++] = -val\n        }\n        if (\n          i < N - 2 &&\n          Math.abs(board[i + 1][j]) === val &&\n          Math.abs(board[i + 2][j]) === val\n        ) {\n          found = true\n          let ind = i\n          while (ind < Math.min(N, i + 3) && Math.abs(board[ind][j]) === val)\n            board[ind++][j] = -val\n        }\n      }\n    }\n    if (found) {\n      // move positive values to the bottom, then set the rest to 0\n      for (let j = 0; j < M; j++) {\n        let storeInd = N - 1\n        for (let i = N - 1; i >= 0; i--) {\n          if (board[i][j] > 0) {\n            board[storeInd--][j] = board[i][j]\n          }\n        }\n        for (let k = storeInd; k >= 0; k--) board[k][j] = 0\n      }\n    }\n  }\n  return board\n}\n\n"
    }
  },
  {
    "name": "724-find-pivot-index",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst pivotIndex = function(nums) {\n    let sum = 0;\n    let leftSum = 0;\n    nums.forEach(num => {sum += num});\n    \n    for (let i = 0; i < nums.length; i++) {\n        if (leftSum === sum - leftSum - nums[i]) return i;\n        leftSum += nums[i];\n    }\n    return -1;\n};\n"
    }
  },
  {
    "name": "725-split-linked-list-in-parts",
    "code": {
      "JS": "/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} root\r\n * @param {number} k\r\n * @return {ListNode[]}\r\n */\r\nconst splitListToParts = function(root, k) {\r\n  let cur = root;\r\n  let N = 0;\r\n  while (cur != null) {\r\n    cur = cur.next;\r\n    N++;\r\n  }\r\n  let width = Math.floor(N / k),\r\n    rem = N % k;\r\n  let ans = [];\r\n  cur = root;\r\n  for (let i = 0; i < k; ++i) {\r\n    let head = cur;\r\n    for (let j = 0; j < width + (i < rem ? 1 : 0) - 1; ++j) {\r\n      if (cur != null) cur = cur.next;\r\n    }\r\n    if (cur != null) {\r\n      let prev = cur;\r\n      cur = cur.next;\r\n      prev.next = null;\r\n    }\r\n    ans[i] = head;\r\n  }\r\n  return ans;\r\n};\r\n"
    }
  },
  {
    "name": "726-number-of-atoms",
    "code": {
      "JS": "/**\n * @param {string} formula\n * @return {string}\n */\nfunction countOfAtoms(formula) {\n  let [dic, coeff, stack, elem, cnt, j, res] = [{}, 1, [], '', 0, 0, '']\n  for (let i = formula.length - 1; i >= 0; i--) {\n    if (!isNaN(formula[i] * 1)) {\n      ;(cnt += Number(formula[i]) * 10 ** j), (j += 1)\n    } else if (formula[i] == ')') {\n      stack.push(cnt), (coeff *= cnt), (j = cnt = 0)\n    } else if (formula[i] == '(') {\n      ;(coeff = Math.floor(coeff / stack.pop())), (j = cnt = 0)\n    } else if (formula[i] == formula[i].toUpperCase()) {\n      elem += formula[i]\n      elem = elem\n        .split('')\n        .reverse()\n        .join('')\n      dic[elem] = dic[elem] || 0\n      dic[elem] += (cnt || 1) * coeff\n      ;(elem = ''), (j = cnt = 0)\n    } else {\n      elem += formula[i]\n    }\n  }\n  Object.keys(dic)\n    .sort()\n    .forEach(function(c) {\n      res += dic[c] > 1 ? c + String(dic[c]) : c\n    })\n  return res\n}\n"
    }
  },
  {
    "name": "727-minimum-window-subsequence",
    "code": {
      "JS": "/**\n * @param {string} s1\n * @param {string} s2\n * @return {string}\n */\nconst minWindow = function (s1, s2) {\n  let n1 = s1.length,\n    n2 = s2.length,\n    s1Idx = 0,\n    s2Idx = 0,\n    start = -1,\n    len = n1 + 1\n  while (s1Idx < n1) {\n    if (s1[s1Idx] === s2[s2Idx]) {\n      if (s2Idx === n2 - 1) {\n        const end = s1Idx\n        while (s2Idx >= 0) {\n          while (s1[s1Idx] !== s2[s2Idx]) s1Idx--\n          s2Idx--\n          s1Idx--\n        }\n        const tmp = end - s1Idx\n        if (tmp < len) {\n          len = tmp\n          start = s1Idx + 1\n        }\n        s2Idx++\n        s1Idx += 2\n      } else {\n        s2Idx++\n        s1Idx++\n      }\n    } else s1Idx++\n  }\n  return start === -1 ? '' : s1.slice(start, start + len)\n}\n\n// another\n\n/**\n * @param {string} s1\n * @param {string} s2\n * @return {string}\n */\nconst minWindow = function(s1, s2) {\n  let res = '', n = s1.length, m = s2.length\n  if(s1 === '' || s2 === '') return res\n  let minLen = Infinity\n  let right = 0\n  while(right < n) {\n    let tIndex = 0\n    while(right < n) {\n      if(s1[right] === s2[tIndex]) tIndex++\n      if(tIndex === m) break\n      right++\n    }\n    if(right === n) break\n    let left = right\n    tIndex = m - 1\n    while(left >= 0) {\n      if(s1[left] === s2[tIndex]) {\n        tIndex--\n      }\n      if(tIndex < 0) break\n      left--\n    }\n    \n    if(right - left + 1 < minLen) {\n      minLen = right - left + 1\n      res = s1.slice(left, right + 1)\n    }\n    right = left + 1\n  }\n  \n  return res\n};\n\n// another\n\n/**\n * @param {string} S\n * @param {string} T\n * @return {string}\n */\nconst minWindow = function (S, T) {\n  if (S.length === 0 || T.length === 0) {\n    return ''\n  }\n  let right = 0\n  let minLen = Number.MAX_VALUE\n  let result = ''\n  while (right < S.length) {\n    let tIndex = 0\n    while (right < S.length) {\n      if (S.charAt(right) === T.charAt(tIndex)) {\n        tIndex++\n      }\n      if (tIndex === T.length) {\n        break\n      }\n      right++\n    }\n    if (right === S.length) {\n      break\n    }\n    let left = right\n    tIndex = T.length - 1\n    while (left >= 0) {\n      if (S.charAt(left) === T.charAt(tIndex)) {\n        tIndex--\n      }\n      if (tIndex < 0) {\n        break\n      }\n      left--\n    }\n    if (right - left + 1 < minLen) {\n      minLen = right - left + 1\n      result = S.slice(left, right + 1)\n    }\n    // we have to move right pointer to the next position of left pointer, NOT the next position\n    // of right pointer\n    right = left + 1\n  }\n  return result\n}\n"
    }
  },
  {
    "name": "729-my-calendar-i",
    "code": {
      "JS": "const MyCalendar = function () {\n  this.root = null\n}\n\nconst Node = function (start, end) {\n  this.start = start\n  this.end = end\n  this.left = null\n  this.right = null\n}\n\nNode.prototype.insert = function (node) {\n  if (node.start >= this.end) {\n    if (this.right === null) {\n      this.right = node\n      return true\n    }\n    return this.right.insert(node)\n  } else if (node.end <= this.start) {\n    if (this.left === null) {\n      this.left = node\n      return true\n    }\n    return this.left.insert(node)\n  } else {\n    return false\n  }\n}\n\n/**\n * @param {number} start\n * @param {number} end\n * @return {boolean}\n */\nMyCalendar.prototype.book = function (start, end) {\n  const newNode = new Node(start, end)\n  if (this.root === null) {\n    this.root = newNode\n    return true\n  } else {\n    return this.root.insert(newNode)\n  }\n}\n\n/**\n * Your MyCalendar object will be instantiated and called as such:\n * var obj = new MyCalendar()\n * var param_1 = obj.book(start,end)\n */\n\n// another\n\nconst MyCalendar = function() {\n  this.s = new Set()\n};\n\n/** \n * @param {number} start \n * @param {number} end\n * @return {boolean}\n */\nMyCalendar.prototype.book = function(start, end) {\n  for(let e of this.s) {\n    if(Math.max(start, e[0]) < Math.min(end, e[1])) return false\n  }\n  this.s.add([start, end])\n  return true\n};\n\n/** \n * Your MyCalendar object will be instantiated and called as such:\n * var obj = new MyCalendar()\n * var param_1 = obj.book(start,end)\n */\n"
    }
  },
  {
    "name": "73-set-matrix-zeroes",
    "code": {
      "JS": "/**\n * @param {number[][]} matrix\n * @return {void} Do not return anything, modify matrix in-place instead.\n */\nconst setZeroes = function(matrix) {\n    const rows = []\n    const cols = []\n    const rowNum = matrix.length\n    const colNum = matrix[0].length\n    for(let i = 0; i < rowNum; i++) {\n      for(let j = 0; j < colNum; j++) {\n        if(matrix[i][j] === 0) {\n           rows.push(i)\n           cols.push(j)\n        }\n      }\n    }\n    const mrows = rows.filter((el, idx, arr) => arr.indexOf(el) === idx)\n    const mcols = cols.filter((el, idx, arr) => arr.indexOf(el) === idx)\n    for(let i = 0; i < mrows.length; i++) {\n      matrix[mrows[i]] = new Array(colNum).fill(0)\n    }\n    for(let j = 0; j < mcols.length; j++) {\n      for(let k = 0; k < rowNum; k++) {\n        matrix[k][mcols[j]] = 0\n      }\n    }\n    return matrix\n};\n"
    }
  },
  {
    "name": "730-count-different-palindromic-subsequences",
    "code": {
      "JS": "/**\n * @param {string} S\n * @return {number}\n */\nconst countPalindromicSubsequences = function(S) {\n  const len = S.length\n  const dp = Array.from({ length: len }, () => new Array(len).fill(0))\n  const mod = 10 ** 9 + 7\n  for (let i = 0; i < len; i++) dp[i][i] = 1\n  for (let distance = 1; distance < len; distance++) {\n    for (let i = 0; i < len - distance; i++) {\n      let j = i + distance\n      if (S[i] === S[j]) {\n        let low = i + 1\n        let high = j - 1\n        while (low <= high && S[low] != S[j]) low++\n        while (low <= high && S[high] != S[j]) high--\n        if (low > high) {\n          dp[i][j] = dp[i + 1][j - 1] * 2 + 2\n        } else if (low == high) {\n          dp[i][j] = dp[i + 1][j - 1] * 2 + 1\n        } else {\n          dp[i][j] = dp[i + 1][j - 1] * 2 - dp[low + 1][high - 1]\n        }\n      } else {\n        dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]\n      }\n      dp[i][j] = dp[i][j] < 0 ? dp[i][j] + mod : dp[i][j] % mod\n    }\n  }\n  return dp[0][len - 1]\n}\n"
    }
  },
  {
    "name": "731-my-calendar-ii",
    "code": {
      "JS": "const MyCalendarTwo = function () {\n  this.calendar = []\n  this.overlaps = []\n}\n\n/**\n * @param {number} start\n * @param {number} end\n * @return {boolean}\n */\nMyCalendarTwo.prototype.book = function (start, end) {\n  for (let i = 0; i < this.overlaps.length; i++) {\n    if (start < this.overlaps[i].end && end > this.overlaps[i].start)\n      return false\n  }\n\n  for (let i = 0; i < this.calendar.length; i++) {\n    if (start < this.calendar[i].end && end > this.calendar[i].start)\n      this.overlaps.push({\n        start: Math.max(start, this.calendar[i].start),\n        end: Math.min(end, this.calendar[i].end),\n      })\n  }\n  this.calendar.push({ start: start, end: end })\n  return true\n}\n\n/**\n * Your MyCalendarTwo object will be instantiated and called as such:\n * var obj = new MyCalendarTwo()\n * var param_1 = obj.book(start,end)\n */\n"
    }
  },
  {
    "name": "732-my-calendar-iii",
    "code": {
      "JS": "const find = (cals, time, count) => {\n  let l = 0\n  let r = cals.length\n  let mid\n  while (l < r) {\n    mid = Math.trunc((l + r) / 2)\n    if (cals[mid][0] === time) {\n      cals[mid][1] += count\n      return\n    } else if (cals[mid][0] < time) {\n      l = mid + 1\n    } else {\n      r = mid\n    }\n  }\n  cals.splice(l, 0, [time, count])\n}\nconst MyCalendarThree = function() {\n  this.cals = []\n}\n\n/**\n * @param {number} start\n * @param {number} end\n * @return {number}\n */\nMyCalendarThree.prototype.book = function(start, end) {\n  let idx = find(this.cals, start, 1)\n  idx = find(this.cals, end, -1)\n  let count = 0\n  let max = 0\n  for (let cal of this.cals) {\n    count += cal[1]\n    max = Math.max(max, count)\n  }\n  return max\n}\n\n/**\n * Your MyCalendarThree object will be instantiated and called as such:\n * var obj = new MyCalendarThree()\n * var param_1 = obj.book(start,end)\n */\n"
    }
  },
  {
    "name": "733-flood-fill",
    "code": {
      "JS": "/**\n * @param {number[][]} image\n * @param {number} sr\n * @param {number} sc\n * @param {number} newColor\n * @return {number[][]}\n */\nconst floodFill = function(image, sr, sc, newColor, firstColor = image[sr][sc]) {\n  if (\n    sr < 0 ||\n    sc < 0 ||\n    sr >= image.length ||\n    sc >= image[sr].length ||\n    image[sr][sc] !== firstColor ||\n    image[sr][sc] === newColor\n  ) {\n    return image\n  }\n\n  image[sr][sc] = newColor\n\n  floodFill(image, sr + 1, sc, newColor, firstColor)\n  floodFill(image, sr - 1, sc, newColor, firstColor)\n  floodFill(image, sr, sc + 1, newColor, firstColor)\n  floodFill(image, sr, sc - 1, newColor, firstColor)\n\n  return image\n}\n\n// another\n\n/**\n * @param {number[][]} image\n * @param {number} sr\n * @param {number} sc\n * @param {number} newColor\n * @return {number[][]}\n */\nconst floodFill = function (\n  image,\n  sr,\n  sc,\n  newColor,\n  firstColor = image[sr][sc]\n) {\n  const dirs = [0, -1, 0, 1, 0]\n  const rows = image.length\n  const cols = image[0].length\n  const q = [[sr, sc]]\n  while (q.length) {\n    const len = q.length\n    for (let i = 0; i < len; i++) {\n      const cur = q.shift()\n      image[cur[0]][cur[1]] = newColor\n      for (let j = 0; j < 4; j++) {\n        const [nr, nc] = [cur[0] + dirs[j], cur[1] + dirs[j + 1]]\n        if (\n          nr >= 0 &&\n          nr < rows &&\n          nc >= 0 &&\n          nc < cols &&\n          image[nr][nc] === firstColor &&\n          image[nr][nc] !== newColor\n        ) {\n          q.push([nr, nc])\n        }\n      }\n    }\n  }\n  return image\n}\n\n"
    }
  },
  {
    "name": "734-sentence-similarity",
    "code": {
      "JS": "/**\n * @param {string[]} words1\n * @param {string[]} words2\n * @param {string[][]} pairs\n * @return {boolean}\n */\nconst areSentencesSimilar = function(words1, words2, pairs) {\n  if(pairs == null || pairs.length === 0) {\n    if(words1.length === words2.length) return true\n    return false\n  }\n  const m = new Map()\n  for(let p of pairs) {\n    if(!m.has(p[0])) m.set(p[0], new Set())\n    m.get(p[0]).add(p[1])\n    if(!m.has(p[1])) m.set(p[1], new Set())\n    m.get(p[1]).add(p[0])\n  }\n  for(let i = 0, len = Math.max(words1.length, words2.length); i < len; i++) {\n    const c1 = words1[i]\n    const c2 = words2[i]\n    if( c1 === c2 ) continue\n    if( !(m.has(c1) && m.get(c1).has(c2)) ) return false\n  }\n  return true\n};\n"
    }
  },
  {
    "name": "735-asteroid-collision",
    "code": {
      "JS": "/**\n * @param {number[]} asteroids\n * @return {number[]}\n */\nconst asteroidCollision = function(asteroids) {\n    const positive = []\n    const res = []\n    for(let i = 0; i < asteroids.length; i++) {\n        if (asteroids[i] > 0) {\n            positive.push(i)\n        } else {\n            const negVal = asteroids[i];\n\n            while(positive.length > 0 && asteroids[ positive[positive.length - 1] ] + negVal < 0 ) {\n                asteroids[ positive[positive.length - 1] ] = undefined\n                positive.pop()\n            }\n\n            if (positive.length > 0) {\n                if (asteroids[ positive[positive.length - 1] ] + negVal > 0) {\n                    asteroids[i] = undefined\n                } else if(asteroids[ positive[positive.length - 1] ] + negVal === 0) {\n                    asteroids[i] = undefined\n                    asteroids[ positive[positive.length - 1] ] = undefined\n                    positive.pop()\n                }\n            }\n        }\n    }\n    return asteroids.filter(el => el !== undefined)\n};\n"
    }
  },
  {
    "name": "736-parse-lisp-expression",
    "code": {
      "JS": "/**\n * @param {string} expression\n * @return {number}\n */\nconst evaluate = (x) =>\n  e(\n    JSON.parse(\n      x.replace(/[() ]|([a-z][a-z0-9]*)/g, (m) =>\n        m === '(' ? '[' : m === ')' ? ']' : m === ' ' ? ',' : `\"${m}\"`\n      )\n    )\n  )\nconst e = (x, v = []) =>\n  ({\n    string: () => v.find((y) => y[0] === x)[1],\n    number: () => x,\n    object: () =>\n      ({\n        add: () => e(x[1], v) + e(x[2], v),\n        mult: () => e(x[1], v) * e(x[2], v),\n        let: () =>\n          e(\n            x[x.length - 1],\n            x\n              .slice(1, -1)\n              .reduce(\n                ({ v, t }, z) =>\n                  t ? { v: [[t, e(z, v)], ...v] } : { v, t: z },\n                { v }\n              ).v\n          ),\n      }[x[0]]()),\n  }[typeof x]())\n\n// another\n\n/**\n * @param {string} expression\n * @return {number}\n */\nconst evaluate = function (expression) {\n  const tokens = tokenizer(expression)\n  let i = 0\n  function exec(scope) {\n    let value = null\n    const next = tokens[i++]\n    if (next === '(') {\n      scope = enter(scope)\n      switch (tokens[i++]) {\n        case 'add':\n          const a = exec(scope)\n          const b = exec(scope)\n          value = a + b\n          break\n        case 'mult':\n          const x = exec(scope)\n          const y = exec(scope)\n          value = x * y\n          break\n        case 'let':\n          while (tokens[i] !== '(' && tokens[i + 1] !== ')') {\n            scope.variables[tokens[i++]] = exec(scope)\n          }\n          value = exec(scope)\n          break\n      }\n      scope = exit(scope)\n      i++\n    } else if (isNumber(next)) {\n      value = Number(next)\n    } else {\n      // Find variable in current scope otherwise go to parent\n      let t = scope\n      while (t) {\n        if (next in t.variables) {\n          value = t.variables[next]\n          break\n        }\n        t = t.parent\n      }\n    }\n    return value\n  }\n  return exec(newScope())\n}\nfunction tokenizer(expression) {\n  const tokens = []\n  let token = ''\n  for (const c of expression) {\n    if (c === '(' || c === ')') {\n      if (token) tokens.push(token)\n      tokens.push(c)\n      token = ''\n    } else if (c === ' ') {\n      if (token) tokens.push(token)\n      token = ''\n    } else {\n      token += c\n    }\n  }\n  if (token) {\n    tokens.push(token)\n  }\n  return tokens\n}\nfunction isNumber(n) {\n  return !isNaN(n)\n}\nfunction newScope() {\n  return { parent: null, variables: {} }\n}\nfunction enter(scope) {\n  const next = newScope()\n  next.parent = scope\n  return next\n}\nfunction exit(scope) {\n  return scope.parent\n}\n"
    }
  },
  {
    "name": "737-sentence-similarity-ii",
    "code": {
      "JS": "/**\n * @param {string[]} words1\n * @param {string[]} words2\n * @param {string[][]} pairs\n * @return {boolean}\n */\nconst areSentencesSimilarTwo = function (words1, words2, pairs) {\n  if (words1.length !== words2.length) return false\n  const parent = {}\n\n  function getParent(word) {\n    if (parent[word] === undefined || parent[word] === word) return word\n    return getParent(parent[word])\n  }\n  for (let [w1, w2] of pairs) {\n    if (w1 > w2) [w1, w2] = [w2, w1]\n    parent[w1] = getParent(w1)\n    if (parent[w2] !== undefined) parent[getParent(w2)] = parent[w1]\n    parent[w2] = parent[w1]\n  }\n  for (let i = 0; i < words1.length; i++) {\n    let w1 = words1[i]\n    let w2 = words2[i]\n    if (getParent(w1) !== getParent(w2)) return false\n  }\n  return true\n}\n"
    }
  },
  {
    "name": "738-monotone-increasing-digits",
    "code": {
      "JS": "/**\n * @param {number} N\n * @return {number}\n */\nfunction monotoneIncreasingDigits(N) {\n  const arr = (''+N).split('').map(el => +el)\n  let mark = arr.length\n  for(let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) {\n      mark = i - 1\n      arr[i - 1]--\n    }\n  }\n  for(let i = mark + 1; i < arr.length; i++) {\n    arr[i] = 9\n  }\n\n  return arr.join('')\n}\n"
    }
  },
  {
    "name": "739-daily-temperatures",
    "code": {
      "JS": "/**\n * @param {number[]} T\n * @return {number[]}\n */\nconst dailyTemperatures = function(T) {\n  const n = T.length;\n  const sk = [];\n  const res = new Array(n).fill(0);\n  for (let i = 0; i < n; i++) {\n    let cur = T[i];\n    while (sk.length && T[sk[sk.length - 1]] < cur) {\n      let tail = sk.pop();\n      res[tail] = i - tail;\n    }\n    sk.push(i);\n  }\n  return res;\n};\n"
    }
  },
  {
    "name": "74-search-a-2d-matrix",
    "code": {
      "JS": "/**\n * @param {number[][]} matrix\n * @param {number} target\n * @return {boolean}\n */\nconst searchMatrix = function(matrix, target) {\n    const rows = matrix.length\n    const cols = (matrix[0] || []).length\n    const r = chkRow(matrix, rows, cols, target)\n    if(r === -1) return false\n    for(let i = 0; i < cols; i++) {\n      if(matrix[r][i] === target) return true\n    }\n    return false\n};\n\nfunction chkRow(matrix, rows, cols, target) {\n  if(cols <= 0) return -1\n  for(let i = 0; i < rows; i++) {\n    if(target <= matrix[i][cols - 1]) return i\n  }\n  return -1\n}\n"
    }
  },
  {
    "name": "740-delete-and-earn",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst deleteAndEarn = function (nums) {\n  const n = 10001\n  const values = new Array(n).fill(0)\n  for (let num of nums) values[num] += num\n\n  let take = 0,\n    skip = 0\n  for (let i = 0; i < n; i++) {\n    const takei = skip + values[i]\n    const skipi = Math.max(skip, take)\n    take = takei\n    skip = skipi\n  }\n  return Math.max(take, skip)\n}\n"
    }
  },
  {
    "name": "741-cherry-pickup",
    "code": {
      "JS": "/**\n\nIn a N x N grid representing a field of cherries, each cell is one of three possible integers.\n\n0 means the cell is empty, so you can pass through;\n1 means the cell contains a cherry, that you can pick up and pass through;\n-1 means the cell contains a thorn that blocks your way.\n \nYour task is to collect maximum number of cherries possible by following the rules below:\n\nStarting at the position (0, 0) and reaching (N-1, N-1) by moving right or down through valid\npath cells (cells with value 0 or 1);\nAfter reaching (N-1, N-1), returning to (0, 0) by moving left or up through valid path cells;\nWhen passing through a path cell containing a cherry, you pick it up and the cell becomes an empty cell (0);\nIf there is no valid path between (0, 0) and (N-1, N-1), then no cherries can be collected.\n\nExample 1:\n\nInput: grid =\n[[0, 1, -1],\n [1, 0, -1],\n [1, 1,  1]]\nOutput: 5\nExplanation: \nThe player started at (0, 0) and went down, down, right right to reach (2, 2).\n4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]].\nThen, the player went left, up, up, left to return home, picking up one more cherry.\nThe total number of cherries picked up is 5, and this is the maximum possible.\n\nNote:\n\ngrid is an N by N 2D array, with 1 <= N <= 50.\nEach grid[i][j] is an integer in the set {-1, 0, 1}.\nIt is guaranteed that grid[0][0] and grid[N-1][N-1] are not -1.\n\n*/\n\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nconst cherryPickup = grid => {\n  const n = grid.length\n  const dp = [...new Array(n)].map(() =>\n    [...new Array(n)].map(() => Array(n).fill(-Infinity))\n  )\n  dp[0][0][0] = grid[0][0]\n  const go = (x1, y1, x2) => {\n    const y2 = x1 + y1 - x2\n    if (x1 < 0 || y1 < 0 || x2 < 0 || y2 < 0) return -1\n    if (grid[y1][x1] === -1 || grid[y2][x2] === -1) return -1\n    if (dp[y1][x1][x2] !== -Infinity) return dp[y1][x1][x2]\n    dp[y1][x1][x2] = Math.max(\n      go(x1 - 1, y1, x2 - 1),\n      go(x1, y1 - 1, x2),\n      go(x1, y1 - 1, x2 - 1),\n      go(x1 - 1, y1, x2)\n    )\n    if (dp[y1][x1][x2] >= 0) {\n      dp[y1][x1][x2] += grid[y1][x1]\n      if (x1 !== x2) dp[y1][x1][x2] += grid[y2][x2]\n    }\n    return dp[y1][x1][x2]\n  }\n  return Math.max(0, go(n - 1, n - 1, n - 1))\n}\n"
    }
  },
  {
    "name": "742-closest-leaf-in-a-binary-tree",
    "code": {
      "JS": "/**\n\nGiven a binary tree where every node has a unique value, and a target key k,\nfind the value of the nearest leaf node to target k in the tree.\n\nHere, nearest to a leaf means the least number of edges travelled on the binary\ntree to reach any leaf of the tree. Also, a node is called a leaf if it has no children.\n\nIn the following examples, the input tree is represented in flattened form\nrow by row. The actual root tree given will be a TreeNode object.\n\nExample 1:\n\nInput:\nroot = [1, 3, 2], k = 1\nDiagram of binary tree:\n          1\n         / \\\n        3   2\n\nOutput: 2 (or 3)\n\nExplanation: Either 2 or 3 is the nearest leaf node to the target of 1.\nExample 2:\n\nInput:\nroot = [1], k = 1\nOutput: 1\n\nExplanation: The nearest leaf node is the root node itself.\nExample 3:\n\nInput:\nroot = [1,2,3,4,null,null,null,5,null,6], k = 2\nDiagram of binary tree:\n             1\n            / \\\n           2   3\n          /\n         4\n        /\n       5\n      /\n     6\n\nOutput: 3\nExplanation: The leaf node with value 3 (and not the leaf node with value 6)\nis nearest to the node with value 2.\n\nNote:\nroot represents a binary tree with at least 1 node and at most 1000 nodes.\nEvery node has a unique node.val in range [1, 1000].\nThere exists some node in the given binary tree for which node.val == k.\n\n*/\n\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} k\n * @return {number}\n */\nconst findClosestLeaf = function(root, k) {\n  if (root == null) return -1\n  const g = new Map()\n  dfs(root, null, g)\n  const q = []\n  for (let [key, value] of g) {\n    if (key.val === k) {\n      q.push(key, ...g.get(key))\n      break\n    }\n  }\n  const s = new Set()\n  while (q.length) {\n    const size = q.length\n    for (let i = 0; i < size; i++) {\n      const node = q.shift()\n      if (node.left === null && node.right === null) return node.val\n      if (!s.has(node)) q.push(...g.get(node))\n      s.add(node)\n    }\n  }\n}\n\nfunction dfs(node, parent, g) {\n  if (node == null) return\n  if (g.get(node) == null) g.set(node, new Set())\n  if (parent) {\n    g.get(node).add(parent)\n    if (g.get(parent) == null) g.set(parent, new Set())\n    g.get(parent).add(node)\n  }\n  dfs(node.left, node, g)\n  dfs(node.right, node, g)\n}\n"
    }
  },
  {
    "name": "743-network-delay-time",
    "code": {
      "JS": "/**\n * @param {number[][]} times\n * @param {number} N\n * @param {number} K\n * @return {number}\n */\nconst networkDelayTime = function (times, N, K) {\n  const mins = new Array(N).fill(Infinity)\n  mins[K - 1] = 0\n  for (let i = 0; i < N; i++) {\n    for (let [u, v, t] of times) {\n      if (mins[u - 1] === Infinity) continue\n      if (mins[v - 1] > mins[u - 1] + t) {\n        mins[v - 1] = mins[u - 1] + t\n      }\n    }\n  }\n  return mins.includes(Infinity) ? -1 : Math.max(...mins)\n}\n\n// another\n\n/**\n * @param {number[][]} times\n * @param {number} N\n * @param {number} K\n * @return {number}\n */\nconst networkDelayTime = function(times, N, K) {\n    const distances = new Array(N).fill(Infinity);\n    distances[K - 1] = 0;\n    \n    for(let i = 0 ; i < N -1 ; i++){\n        let counter = 0;\n        for(let j = 0 ; j < times.length ; j++){\n            const source = times[j][0];\n            const target = times[j][1];\n            const weight = times[j][2];\n            if(distances[source - 1] + weight < distances[target - 1]){\n                distances[target - 1] = distances[source - 1] + weight;\n                counter++\n            }\n        }\n        if(counter === 0) break\n    }\n    \n    const res = Math.max(...distances);\n    return res === Infinity ? -1 : res;\n};\n\n// another\n\n/**\n * @param {number[][]} times\n * @param {number} N\n * @param {number} K\n * @return {number}\n */\nconst networkDelayTime = function (times, N, K) {\n  const hash = {}\n  for(const [u, v, t] of times) {\n    if(hash[u] == null) hash[u] = {}\n    hash[u][v] = t\n  }\n  const pq = new PriorityQueue((a, b) => a[0] < b[0])\n  pq.push([0, K])\n  const visited = Array.from(N + 1)\n  let res = 0\n  while(!pq.isEmpty()) {\n    const [dist, cur] = pq.pop()\n    if(visited[cur]) continue\n    visited[cur] = true\n    res = dist\n    N--\n    if(hash[cur]) {\n      for(let next of Object.keys(hash[cur])) {\n        pq.push([dist + hash[cur][next], next])\n      }\n    }\n  }\n  return N === 0 ? res : -1\n}\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n"
    }
  },
  {
    "name": "744-find-smallest-letter-greater-than-target",
    "code": {
      "JS": "/**\n * @param {character[]} letters\n * @param {character} target\n * @return {character}\n */\nconst nextGreatestLetter = function (letters, target) {\n  const n = letters.length\n  if (target < letters[0] || target >= letters[n - 1]) return letters[0]\n  let left = 0\n  let right = n - 1\n  while (left < right) {\n    let mid = left + ((right - left) >> 1)\n    if (letters[mid] <= target) left = mid + 1\n    else right = mid\n  }\n  return letters[right]\n}\n"
    }
  },
  {
    "name": "745-prefix-and-suffix-search",
    "code": {
      "JS": "/**\n * @param {string[]} words\n */\nconst WordFilter = function (words) {\n  this.trie = new trie()\n  let val = 0\n  for (let word of words) {\n    /* suffix # prefix */\n    let temp = ''\n    this.trie.insert('#' + word, val)\n    this.trie.insert(word + '#', val)\n    for (let i = 0; i < word.length; i++) {\n      temp = word.substring(i)\n      temp += '#' + word\n      this.trie.insert(temp, val)\n    }\n    val++\n  }\n}\n/**\n * @param {string} prefix\n * @param {string} suffix\n * @return {number}\n */\nWordFilter.prototype.f = function (prefix, suffix) {\n  return this.trie.startsWith(suffix + '#' + prefix)\n}\n/**\n * Your WordFilter object will be instantiated and called as such:\n * var obj = new WordFilter(words)\n * var param_1 = obj.f(prefix,suffix)\n */\nconst trie = function () {\n  this.map = new Map()\n  this.isEnd = false\n  this.val = -1\n}\ntrie.prototype.insert = function (word, val) {\n  let temp = this\n  let i = 0\n  while (i < word.length && temp.map.has(word[i])) {\n    temp.val = Math.max(temp.val, val)\n    temp = temp.map.get(word[i++])\n  }\n  while (i < word.length) {\n    let t2 = new trie()\n    temp.map.set(word[i++], t2)\n    temp.val = Math.max(temp.val, val)\n    temp = t2\n  }\n  temp.isEnd = true\n  temp.val = Math.max(temp.val, val)\n  return true\n}\ntrie.prototype.startsWith = function (prefix) {\n  let temp = this\n  let i = 0\n  while (i < prefix.length && temp.map.has(prefix[i]))\n    temp = temp.map.get(prefix[i++])\n  return i >= prefix.length ? temp.val : -1\n}\n"
    }
  },
  {
    "name": "746-min-cost-climbing-stairs",
    "code": {
      "JS": "/**\r\n * @param {number[]} cost\r\n * @return {number}\r\n */\r\nconst minCostClimbingStairs = function(cost) {\r\n  let f1 = cost[0];\r\n  let f2 = cost[1];\r\n  for (let i = 2; i < cost.length; i++) {\r\n    let f_cur = cost[i] + Math.min(f1, f2);\r\n    f1 = f2;\r\n    f2 = f_cur;\r\n  }\r\n  return Math.min(f1, f2);\r\n};\r\n"
    }
  },
  {
    "name": "747-largest-number-at-least-twice-of-others",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst dominantIndex = function(nums) {\n  let max = -Infinity\n  let idx = -1\n  for(let i = 0, len = nums.length; i < len; i++) {\n    if(nums[i] > max) {\n      max = nums[i]\n      idx = i\n    }\n  }\n  for(let i = 0, len = nums.length; i < len; i++) {\n    if(nums[i] !== max && max < nums[i] * 2) return -1\n  }\n  return idx\n};\n"
    }
  },
  {
    "name": "748-shortest-completing-word",
    "code": {
      "JS": "/**\n * @param {string} licensePlate\n * @param {string[]} words\n * @return {string}\n */\nconst shortestCompletingWord = function(licensePlate, words) {\n  const letters = licensePlate\n    .replace(/\\d/g, '')\n    .replace(/ /g, '')\n    .toLowerCase()\n    .split('')\n  let matchingWords = words.filter(word => {\n    let completingWord = true\n    letters.forEach(letter => {\n      let letterIndex = word.indexOf(letter)\n      if (letterIndex > -1) {\n        let re = new RegExp(letter)\n        word = word.replace(re, '')\n      } else {\n        completingWord = false\n      }\n    })\n    return completingWord\n  })\n  const wordLengths = matchingWords.map(word => word.length)\n  return matchingWords[wordLengths.indexOf(Math.min.apply(Math, wordLengths))]\n}\n\n// another\n\n/**\n * @param {string} licensePlate\n * @param {string[]} words\n * @return {string}\n */\nconst shortestCompletingWord = function(licensePlate, words) {\n  licensePlate = licensePlate.toLowerCase()\n  const plateCount = Array(26).fill(0)\n  let plateLength = 0\n  for (let i = 0; i < licensePlate.length; i += 1) {\n    const code = licensePlate.charCodeAt(i)\n    if (code < 97 || code > 122) {\n      continue\n    }\n    plateCount[code - 97] += 1\n    plateLength += 1\n  }\n  const longerOrEqualWords = words.filter(word => word.length >= plateLength)\n  return longerOrEqualWords.reduce((shortest, word) => {\n    if (shortest && shortest.length <= word.length) {\n      return shortest\n    }\n    const wordCount = Array(26).fill(0)\n    for (let i = 0; i < word.length; i += 1) {\n      const code = word.charCodeAt(i)\n      wordCount[code - 97] += 1\n    }\n    for (let i = 0; i < 26; i += 1) {\n      if (wordCount[i] - plateCount[i] < 0) {\n        return shortest\n      }\n    }\n    return word\n  }, null)\n}\n"
    }
  },
  {
    "name": "749-contain-virus",
    "code": {
      "JS": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nconst containVirus = function (grid) {\n  let ans = 0\n  while (true) {\n    const walls = model(grid)\n    if (walls === 0) break\n    ans += walls\n  }\n  return ans\n  function model(grid) {\n    const m = grid.length,\n      n = grid[0].length\n    const virus = [],\n      toInfect = []\n    const visited = Array.from({ length: m }, () => Array(n).fill(0))\n    const walls = []\n    for (let i = 0; i < m; i++) {\n      for (let j = 0; j < n; j++) {\n        if (grid[i][j] === 1 && visited[i][j] === 0) {\n          virus.push(new Set())\n          toInfect.push(new Set())\n          walls.push([0])\n          dfs(\n            grid,\n            visited,\n            virus[virus.length - 1],\n            toInfect[toInfect.length - 1],\n            walls[walls.length - 1],\n            i,\n            j\n          )\n        }\n      }\n    }\n    let maxArea = 0,\n      idx = -1\n    for (let i = 0; i < toInfect.length; i++) {\n      if (toInfect[i].size > maxArea) {\n        maxArea = toInfect[i].size\n        idx = i\n      }\n    }\n    if (idx === -1) return 0\n    for (let i = 0; i < toInfect.length; i++) {\n      if (i !== idx) {\n        for (let key of toInfect[i]) grid[(key / n) >> 0][key % n] = 1\n      } else {\n        for (let key of virus[i]) grid[(key / n) >> 0][key % n] = -1\n      }\n    }\n    return walls[idx][0]\n  }\n  function dfs(grid, visited, virus, toInfect, wall, row, col) {\n    const m = grid.length,\n      n = grid[0].length\n    if (row < 0 || row >= m || col < 0 || col >= n || visited[row][col] === 1)\n      return\n    if (grid[row][col] === 1) {\n      visited[row][col] = 1\n      virus.add(row * n + col)\n      const dir = [0, -1, 0, 1, 0]\n      for (let i = 0; i < 4; i++)\n        dfs(\n          grid,\n          visited,\n          virus,\n          toInfect,\n          wall,\n          row + dir[i],\n          col + dir[i + 1]\n        )\n    } else if (grid[row][col] === 0) {\n      wall[0]++\n      toInfect.add(row * n + col)\n    }\n  }\n}\n\n// another\n\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nconst containVirus = (grid) => {\n  const m = grid.length;\n  const n = grid[0].length;\n  let ans = 0;\n  while (true) {\n    // list of regions can spread virus\n    const regions = [];\n    const visited = Array.from({ length: m }, () => Array(n).fill(false));\n    for (let i = 0; i < m; i++) {\n      for (let j = 0; j < n; j++) {\n        if (grid[i][j] === 1 && !visited[i][j]) {\n          const region = new Region();\n          dfs(grid, i, j, region, visited);\n          if (region.uninfected.size > 0) regions.push(region);\n        }\n      }\n    }\n\n    if (regions.length === 0) break;\n    regions.sort((a, b) => a.uninfected.size - b.uninfected.size);\n    let idx = -1, wall = -Infinity\n    for(let i = 0, len = regions.length; i < len; i++) {\n      if(regions[i].uninfected.size > wall) {\n        wall = regions[i].uninfected.size\n        idx = i\n      }\n    }\n    const mostToBeInfected = regions[idx]\n    ans += mostToBeInfected.wallNeeded\n    regions.splice(idx, 1)\n    for (let x of mostToBeInfected.infected) {\n      let i = (x / n) >> 0,\n        j = x % n;\n      grid[i][j] = 2;\n    }\n\n    for (let region of regions) {\n      for (let x of region.uninfected) {\n        let i = (x / n) >> 0,\n          j = x % n;\n        grid[i][j] = 1;\n      }\n    }\n  }\n\n  return ans;\n  function dfs(grid, i, j, region, visited) {\n    if (i < 0 || i == m || j < 0 || j == n) return;\n  \n    if (grid[i][j] === 1 && !visited[i][j]) {\n      visited[i][j] = true;\n      region.infected.add(i * n + j);\n      dfs(grid, i - 1, j, region, visited);\n      dfs(grid, i + 1, j, region, visited);\n      dfs(grid, i, j - 1, region, visited);\n      dfs(grid, i, j + 1, region, visited);\n    } else if (grid[i][j] === 0) {\n      region.wallNeeded += 1;\n      region.uninfected.add(i * n + j);\n    }\n  }\n};\nclass Region {\n  constructor() {\n    this.wallNeeded = 0;\n    this.infected = new Set();\n    this.uninfected = new Set();\n  }\n}\n\n// another\n\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nconst containVirus = function (grid) {\n  const infected = 1\n  const healthy = 0\n  const quarantined = 2\n  const directions = [\n    [1, 0],\n    [-1, 0],\n    [0, 1],\n    [0, -1],\n  ]\n  const mod = 100\n  const encode = (row, col) => row + col * mod\n  const decode = (num) => [num % mod, Math.floor(num / mod)]\n  const disjointSet = {}\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[row].length; col++) {\n      const coord = encode(row, col)\n      disjointSet[coord] = coord\n      if (grid[row][col] === 0) continue\n      if (grid[row][col - 1] === 1) union(coord, encode(row, col - 1))\n      if (row > 0 && grid[row - 1][col] === 1)\n        union(coord, encode(row - 1, col))\n    }\n  }\n  let numWalls = 0\n  while (true) {\n    const impact = quarantineAndContaminate()\n    if (impact === 0) return numWalls\n    numWalls += impact\n    spreadVirus()\n  }\n  function find(coord) {\n    return (disjointSet[coord] =\n      disjointSet[coord] === coord ? coord : find(disjointSet[coord]))\n  }\n  function union(coord, toCoord) {\n    return (disjointSet[find(coord)] = find(toCoord))\n  }\n  function quarantineAndContaminate() {\n    const impact = new Map()\n    for (let row = 0; row < grid.length; row++) {\n      for (let col = 0; col < grid[row].length; col++) {\n        if (grid[row][col] !== infected) continue\n        const root = find(encode(row, col))\n        if (!impact.has(root)) impact.set(root, new Set())\n        for (let [down, right] of directions) {\n          if (grid[row + down] && grid[row + down][col + right] === healthy) {\n            impact.get(root).add(encode(row + down, col + right))\n          }\n        }\n      }\n    }\n    let impactedCoords = new Set()\n    let root = null\n    for (let [node, coords] of impact) {\n      if (impactedCoords.size < coords.size) {\n        impactedCoords = coords\n        root = node\n      }\n    }\n    if (impactedCoords.size === 0) return 0\n    return quarantine(...decode(root))\n  }\n  function quarantine(row, col) {\n    if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length)\n      return 0\n    if (grid[row][col] === 2) return 0\n    if (grid[row][col] === 0) return 1\n    let totalWalls = 0\n    grid[row][col] = 2\n    for (let [down, right] of directions) {\n      totalWalls += quarantine(row + down, col + right)\n    }\n    return totalWalls\n  }\n  function spreadVirus() {\n    const infectedCoords = new Set()\n    for (let row = 0; row < grid.length; row++) {\n      for (let col = 0; col < grid[row].length; col++) {\n        if (grid[row][col] !== healthy) continue\n        for (let [down, right] of directions) {\n          if (grid[row + down] && grid[row + down][col + right] === infected) {\n            infectedCoords.add(encode(row, col))\n          }\n        }\n      }\n    }\n    for (let coord of infectedCoords) {\n      const [row, col] = decode(coord)\n      grid[row][col] = 1\n      for (let [down, right] of directions) {\n        if (grid[row + down] && grid[row + down][col + right] === 1) {\n          union(coord, encode(row + down, col + right))\n        }\n      }\n    }\n  }\n}\n"
    }
  },
  {
    "name": "75-sort-colors",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nconst sortColors = function(nums) {\n  let j = 0;\n  let k = nums.length - 1;\n  const swap = (a, b) => {\n    const t = nums[a];\n    nums[a] = nums[b];\n    nums[b] = t;\n  };\n  for (let i = 0; i <= k; i++) {\n    if (nums[i] === 2) {\n      swap(i--, k--);\n    } else if (nums[i] === 0) {\n      swap(i, j++);\n    }\n  }\n};\n"
    }
  },
  {
    "name": "750-number-of-corner-rectangles",
    "code": {
      "JS": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nconst countCornerRectangles = function (grid) {\n  let ans = 0\n  for (let i = 0; i < grid.length - 1; i++) {\n    for (let j = i + 1; j < grid.length; j++) {\n      let counter = 0\n      for (let k = 0; k < grid[0].length; k++) {\n        if (grid[i][k] === 1 && grid[j][k] === 1) counter++\n      }\n      ans += (counter * (counter - 1)) / 2\n    }\n  }\n  return ans\n}\n\n// another\n\n// optimized\n\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nconst countCornerRectangles = function (grid) {\n  let ans = 0\n  let largeLoopLen, smLoopLen, r\n  if(grid.length > grid[0].length) {\n    r = false\n    largeLoopLen = grid.length\n    smLoopLen = grid[0].length\n  } else {\n    r = true\n    largeLoopLen = grid[0].length\n    smLoopLen = grid.length\n  }\n  for (let i = 0; i < smLoopLen - 1; i++) {\n    for (let j = i + 1; j < smLoopLen; j++) {\n      let counter = 0\n      for (let k = 0; k < largeLoopLen; k++) {\n        if(r) {\n          if (grid[i][k] === 1 && grid[j][k] === 1) counter++\n        } else {\n          if (grid[k][i] === 1 && grid[k][j] === 1) counter++\n        }\n        \n      }\n      ans += (counter * (counter - 1)) / 2\n    }\n  }\n  return ans\n}\n"
    }
  },
  {
    "name": "751-ip-to-cidr",
    "code": {
      "JS": "/**\n * @param {string} ip\n * @param {number} n\n * @return {string[]}\n */\nconst ipToCIDR = function (ip, n) {\n  const ipToLong = (ip) =>\n    ip.split('.').reduce((acc, x) => 256 * acc + parseInt(x), 0)\n  const longToIp = (long) =>\n    [24, 16, 8, 0].map((i) => (long >>> i) % 256).join('.')\n  const bitLength = (num) => Math.floor(Math.log2(num)) + 1\n  const ans = []\n  let long = ipToLong(ip)\n  while (n) {\n    let mask = Math.max(33 - bitLength(long & -long), 33 - bitLength(n))\n    ans.push(longToIp(long) + '/' + mask)\n    long += 1 << (32 - mask)\n    n -= 1 << (32 - mask)\n  }\n  return ans\n}\n"
    }
  },
  {
    "name": "752-open-the-lock",
    "code": {
      "JS": "/**\r\n * @param {string[]} deadends\r\n * @param {string} target\r\n * @return {number}\r\n */\r\nconst openLock = function(deadends, target, count = 0) {\r\n  let deadSet = new Set(deadends);\r\n  let visited = new Set();\r\n  if (deadSet.has(\"0000\")) {\r\n    return -1;\r\n  }\r\n\r\n  let q = [];\r\n  q.push(\"0000\");\r\n  visited.add(\"0000\");\r\n\r\n  let steps = 0;\r\n  while (q.length > 0) {\r\n    let len = q.length;\r\n\r\n    for (let j = 0; j < len; j++) {\r\n      let cur = q.shift();\r\n\r\n      for (let i = 0; i < 4; i++) {\r\n        let slot = parseInt(cur[i]);\r\n        let before = cur.substr(0, i);\r\n        let after = cur.substr(i + 1);\r\n\r\n        let left = (10 + slot - 1) % 10;\r\n        let leftCode = before + left + after;\r\n        if (!visited.has(leftCode) && !deadSet.has(leftCode)) {\r\n          if (leftCode === target) {\r\n            return steps + 1;\r\n          }\r\n\r\n          visited.add(leftCode);\r\n          q.push(leftCode);\r\n        }\r\n\r\n        let right = (10 + slot + 1) % 10;\r\n        let rightCode = before + right + after;\r\n        if (!visited.has(rightCode) && !deadSet.has(rightCode)) {\r\n          if (rightCode === target) {\r\n            return steps + 1;\r\n          }\r\n\r\n          visited.add(rightCode);\r\n          q.push(rightCode);\r\n        }\r\n      }\r\n    }\r\n    steps++;\r\n  }\r\n\r\n  return -1;\r\n};\r\n"
    }
  },
  {
    "name": "754-reach-a-number",
    "code": {
      "JS": "/**\n * @param {number} target\n * @return {number}\n */\nconst reachNumber = function(target) {\n    const tar = Math.abs(target);\n    let step = 0;\n    let sum = 0;\n    while (sum < tar) {\n        step++;\n        sum += step;\n    }\n    while ((sum - tar) % 2 !== 0) {\n        step++;\n        sum += step;\n    }\n    return step;\n};\n"
    }
  },
  {
    "name": "755-pour-water",
    "code": {
      "JS": "/**\n * @param {number[]} heights\n * @param {number} V\n * @param {number} K\n * @return {number[]}\n */\nconst pourWater = function (heights, V, K) {\n  if (!V) return heights\n  let bottom = K\n  //iterate through from k to find thee lowest bottom\n  for (let i = K; i >= 0; i--) {\n    if (heights[i] > heights[bottom]) break\n    if (heights[i] < heights[bottom]) bottom = i\n  }\n  //if bottom is not k increase height of bottom\n  //and run again but decrease water droplet V by one\n  if (bottom !== K) {\n    heights[bottom]++\n    return pourWater(heights, V - 1, K)\n  }\n  for (let i = K + 1; i < heights.length; i++) {\n    if (heights[i] > heights[bottom]) break\n    if (heights[i] < heights[bottom]) bottom = i\n  }\n  heights[bottom]++\n  return pourWater(heights, V - 1, K)\n}\n\n// another\n\n/**\n * @param {number[]} heights\n * @param {number} V\n * @param {number} K\n * @return {number[]}\n */\nconst pourWater = function (heights, V, K) {\n  let cur = K\n  for (let i = 0; i < V; i++) {\n    // Move left\n    while (cur > 0 && heights[cur - 1] <= heights[cur]) {\n      cur--\n    }\n    // Move right\n    while (cur < heights.length - 1 && heights[cur + 1] <= heights[cur]) {\n      cur++\n    }\n    // Move left to K\n    while(cur > K && heights[cur - 1] === heights[cur]) {\n      cur--\n    }\n    heights[cur]++\n  }\n  return heights\n}\n\n"
    }
  },
  {
    "name": "756-pyramid-transition-matrix",
    "code": {
      "JS": "/**\n * @param {string} bottom\n * @param {string[]} allowed\n * @return {boolean}\n */\nconst pyramidTransition = function (bottom, allowed) {\n  const m = new Map()\n  for (let e of allowed) {\n    const p = e.slice(0, 2)\n    if (!m.has(p)) m.set(p, new Set())\n    m.get(p).add(e[2])\n  }\n  return dfs(bottom, '', m, 0)\n}\n\nfunction dfs(row, next, m, i) {\n  if (row.length === 1) return true\n  if (next.length + 1 === row.length) return dfs(next, '', m, 0)\n  for (let c of m.get(row.slice(i, i + 2)) || new Set())\n    if (dfs(row, next + c, m, i + 1)) return true\n  return false\n}\n\n"
    }
  },
  {
    "name": "757-set-intersection-size-at-least-two",
    "code": {
      "JS": "/**\n * @param {number[][]} intervals\n * @return {number}\n */\nconst intersectionSizeTwo = function(intervals) {\n  let highest = Number.NEGATIVE_INFINITY;\n  let secondHighest = Number.NEGATIVE_INFINITY;\n  return intervals\n      .sort((a, b) => a[1] - b[1])\n      .reduce((sum, interval) => {\n      if (interval[0] > secondHighest) {\n          secondHighest = interval[1];\n          highest = interval[1] - 1;\n          return sum + 2;\n      }\n      else if (interval[0] > highest) {\n          highest = secondHighest;\n          secondHighest = interval[1];\n          return sum + 1;\n      }\n      return sum;\n  }, 0);\n};\n\n// another\n\n/**\n * @param {number[][]} intervals\n * @return {number}\n */\nconst intersectionSizeTwo = function(intervals) {\n  intervals.sort((a, b) => a[1] - b[1]);\n\n  let n = intervals.length;\n  if (n === 0) return 0;\n\n  let count = 2;\n  let last = intervals[0][1];\n  let sec_last = intervals[0][1] - 1;\n\n  for (let i = 1; i < n; i++) {\n    if (intervals[i][0] <= sec_last) continue;\n    else if (intervals[i][0] <= last) {\n      sec_last = last;\n      last = intervals[i][1];\n      count++;\n    } else {\n      last = intervals[i][1];\n      sec_last = intervals[i][1] - 1;\n      count += 2;\n    }\n  }\n  return count;\n};\n\n// another\n\n/**\n * @param {number[][]} intervals\n * @return {number}\n */\nconst intersectionSizeTwo = function (intervals) {\n  if (intervals.length === 1) return 2\n  intervals.sort((a, b) => (a[1] !== b[1] ? a[1] - b[1] : b[0] - a[0]))\n  let right = intervals[0][1]\n  let left = right - 1\n  let result = 2\n  for (let i = 1, len = intervals.length; i < len; i++) {\n    const curr = intervals[i]\n    if (curr[0] <= right && curr[0] > left) {\n      result++\n      left = right\n      right = curr[1]\n    } else if (curr[0] > right) {\n      result += 2\n      left = curr[1] - 1\n      right = curr[1]\n    }\n  }\n\n  return result\n}\n\n"
    }
  },
  {
    "name": "758-bold-words-in-string",
    "code": {
      "JS": "/**\n * @param {string[]} words\n * @param {string} S\n * @return {string}\n */\nconst boldWords = function (words, S) {\n  const arr = new Array(S.length).fill(false)\n  for(let w of words) {\n    for(let i = 0, len = S.length - w.length; i <= len; i++) {\n      const tmp = S.slice(i)\n      if(tmp && tmp.startsWith(w)) {\n        for(let j = i; j < i + w.length; j++) {\n          arr[j] = true\n        }\n      }\n    }\n  }\n  let res = ''\n  for(let i = 0, len = S.length; i < len; i++) {\n    if(arr[i] && (i === 0 || !arr[i - 1])) {\n      res += '<b>'\n    }\n    res += S[i]\n    if(arr[i] && (i === len - 1 || !arr[i + 1])) {\n      res += '</b>'\n    }\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "759-employee-free-time",
    "code": {
      "JS": "/**\n\nWe are given a list schedule of employees, which represents the working time for each employee.\n\nEach employee has a list of non-overlapping Intervals, and these intervals are in sorted order.\n\nReturn the list of finite intervals representing common, positive-length free time for all employees,\nalso in sorted order.\n\n(Even though we are representing Intervals in the form [x, y], the objects inside are Intervals,\nnot lists or arrays. For example, schedule[0][0].start = 1, schedule[0][0].end = 2,\nand schedule[0][0][0] is not defined).  Also, we wouldn't include intervals like [5, 5] in our answer,\nas they have zero length.\n\nExample 1:\n\nInput: schedule = [[[1,2],[5,6]],[[1,3]],[[4,10]]]\nOutput: [[3,4]]\nExplanation: There are a total of three employees, and all common\nfree time intervals would be [-inf, 1], [3, 4], [10, inf].\nWe discard any intervals that contain inf as they aren't finite.\nExample 2:\n\nInput: schedule = [[[1,3],[6,7]],[[2,4]],[[2,5],[9,12]]]\nOutput: [[5,6],[7,9]]\n\nConstraints:\n\n1 <= schedule.length , schedule[i].length <= 50\n0 <= schedule[i].start < schedule[i].end <= 10^8\n\n*/\n\n\n/**\n * // Definition for an Interval.\n * function Interval(start, end) {\n *    this.start = start;\n *    this.end = end;\n * };\n */\n/**\n * // Definition for an Interval.\n * function Interval(start, end) {\n *    this.start = start;\n *    this.end = end;\n * };\n */\n\n/**\n * @param {Interval[][]} schedule\n * @return {Interval[]}\n */\nconst employeeFreeTime = function(schedule) {\n  const n = schedule.length\n  const time = mergeSort(schedule, 0, n - 1)\n  const free = []\n  let end = time[0].end\n  for(let i = 1; i < time.length; i++) {\n    if(time[i].start > end) {\n      free.push(new Interval(end, time[i].start))\n    }\n    end = Math.max(end, time[i].end)\n  }\n  return free\n}\n\nfunction mergeSort(schedule, l, r) {\n  if(l === r) return schedule[l]\n  const mid = l + ((r - l) >> 1)\n  const left = mergeSort(schedule, l, mid)\n  const right = mergeSort(schedule, mid + 1, r)\n  return merge(left, right)\n}\n\nfunction merge(A, B) {\n  const res = []\n  const m = A.length, n = B.length\n  let i = 0, j = 0\n  while(i < m || j < n) {\n    if(i === m) {\n      res.push(B[j++])\n    } else if(j === n) {\n      res.push(A[i++])\n    } else if(A[i].start < B[j].start) {\n      res.push(A[i++])\n    } else {\n      res.push(B[j++])\n    }\n  }\n  return res\n}\n\n\n// another\n\nconst employeeFreeTime = function(schedule) {\n  const intervals = []\n  schedule.forEach(s => s.forEach(t => intervals.push(t)))\n  intervals.sort((a, b) =>\n    a.start !== b.start ? a.start - b.start : a.end - b.end\n  )\n  let i1 = intervals[0]\n  const res = []\n  for (let interval of intervals.slice(1)) {\n    let i2 = interval\n    if (i1.end >= i2.start) {\n      i1.end = Math.max(i1.end, i2.end)\n    } else {\n      res.push(new Interval(i1.end, i2.start))\n      i1 = i2\n    }\n  }\n  return res\n}\n\n// another\n\n/**\n * // Definition for an Interval.\n * function Interval(start, end) {\n *    this.start = start;\n *    this.end = end;\n * };\n */\n\n/**\n * @param {Interval[][]} schedule\n * @return {Interval[]}\n */\nconst employeeFreeTime = function (schedule) {\n  const res = [], timeLine = []\n  schedule.forEach(e => timeLine.push(...e))\n  timeLine.sort((a, b) => a.start - b.start)\n  let tmp = timeLine[0]\n  for(let i = 1, n = timeLine.length; i < n; i++) {\n    const el = timeLine[i]\n    if(el.start > tmp.end) {\n      res.push(new Interval(tmp.end, el.start))\n      tmp = el\n    } else {\n      tmp = el.end > tmp.end ? el : tmp\n    }\n  }\n  return res\n}\n\n"
    }
  },
  {
    "name": "76-minimum-window-substring",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {string} t\n * @return {string}\n */\nconst minWindow = function(s, t) {\n  const map = {}\n  for (const c of t) {\n    map[c] = (map[c] || 0) + 1\n  }\n  let counter = t.length\n  let start = 0\n  let end = 0\n  let minLen = Infinity\n  let minStart = 0\n  while (end < s.length) {\n    const eChar = s[end]\n    if (map[eChar] > 0) {\n      counter--\n    }\n    map[eChar] = (map[eChar] || 0) - 1\n    end++\n    while (counter === 0) {\n      if (end - start < minLen) {\n        minStart = start\n        minLen = end - start\n      }\n      const sChar = s[start]\n      map[sChar] = (map[sChar] || 0) + 1\n      if (map[sChar] > 0) {\n        counter++\n      }\n      start++\n    }\n  }\n  if (minLen !== Infinity) {\n    return s.substring(minStart, minStart + minLen)\n  }\n  return ''\n}\n"
    }
  },
  {
    "name": "760-find-anagram-mappings",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @param {number[]} B\n * @return {number[]}\n */\nconst anagramMappings = function(A, B) {\n  const m = new Map()\n  for(let i = 0, len = B.length; i < len; i++) {\n    m.set(B[i], i)\n  }\n  const res = []\n  for(let i = 0, len = A.length; i < len; i++) {\n    res.push(m.get(A[i]))\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "761-special-binary-string",
    "code": {
      "JS": "/**\n * @param {string} S\n * @return {string}\n */\nconst makeLargestSpecial = function(S) {\n  let count = 0, i = 0\n  const res = []\n  for(let j = 0, len = S.length; i < len; j++) {\n    if(S.charAt(j) === '1') count++\n    else count--\n    if(count === 0) {\n      res.push('1' + makeLargestSpecial(S.substring(i + 1, j)) + '0')\n      i = j + 1\n    }\n  }\n  return res.sort().reverse().join('')\n};\n"
    }
  },
  {
    "name": "762-prime-number-of-set-bits-in-binary-representation",
    "code": {
      "JS": "/**\n * @param {number} L\n * @param {number} R\n * @return {number}\n */\nconst countPrimeSetBits = function(L, R) {\n  let res = 0;\n  for (let i = L; i <= R; i++) {\n    if (chkPrime(i)) {\n      res += 1;\n    }\n  }\n  return res;\n};\n\nfunction chkPrime(num) {\n  const str = bin(num);\n  const snum = setNum(str);\n  return isPrime(snum);\n}\n\nfunction setNum(str) {\n  let num = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str.charAt(i) === \"1\") {\n      num += 1;\n    }\n  }\n  return num;\n}\n\nfunction bin(num) {\n  return (num >>> 0).toString(2);\n}\nfunction isPrime(num) {\n  for (let i = 2; i < num; i++) {\n    if (num % i === 0) return false;\n  }\n  return num !== 1;\n}\n"
    }
  },
  {
    "name": "763-partition-labels",
    "code": {
      "JS": "/**\n * @param {string} S\n * @return {number[]}\n */\nconst partitionLabels = function (S) {\n  if (S == null || S.length === 0) {\n    return null\n  }\n  const list = []\n  // record the last index of the each char\n  const map = new Array(26).fill(0)\n  const a = 'a'.charCodeAt(0)\n  for (let i = 0, len = S.length; i < len; i++) {\n    map[S.charCodeAt(i) - a] = i\n  }\n  // record the end index of the current sub string\n  let last = 0\n  let start = 0\n  for (let i = 0, len = S.length; i < len; i++) {\n    last = Math.max(last, map[S.charCodeAt(i) - a])\n    if (last === i) {\n      list.push(last - start + 1)\n      start = last + 1\n    }\n  }\n  return list\n}\n"
    }
  },
  {
    "name": "764-largest-plus-sign",
    "code": {
      "JS": "/**\n * @param {number} N\n * @param {number[][]} mines\n * @return {number}\n */\nconst orderOfLargestPlusSign = function (N, mines) {\n  const dp = [...Array(N)].map((_) => Array(N).fill(N))\n  mines.map((m) => {\n    dp[m[0]][m[1]] = 0\n  })\n  for (let i = 0; i < N; i++) {\n    for (let j = 0, k = N - 1, l = (r = u = d = 0); j < N; j++, k--) {\n      dp[i][j] = Math.min(dp[i][j], (l = dp[i][j] == 0 ? 0 : l + 1))\n      dp[i][k] = Math.min(dp[i][k], (r = dp[i][k] == 0 ? 0 : r + 1))\n      dp[j][i] = Math.min(dp[j][i], (d = dp[j][i] == 0 ? 0 : d + 1))\n      dp[k][i] = Math.min(dp[k][i], (u = dp[k][i] == 0 ? 0 : u + 1))\n    }\n  }\n  let max = 0\n  for (let i = 0; i < N; i++) {\n    for (let j = 0; j < N; j++) {\n      max = Math.max(dp[i][j], max)\n    }\n  }\n  return max\n}\n"
    }
  },
  {
    "name": "765-couples-holding-hands",
    "code": {
      "JS": "/**\n * @param {number[]} row\n * @return {number}\n */\nconst minSwapsCouples = function (row) {\n  let res = 0,\n    N = row.length\n  const ptn = new Array(N).fill(0)\n  const pos = new Array(N).fill(0)\n  for (let i = 0; i < N; i++) {\n    ptn[i] = i % 2 === 0 ? i + 1 : i - 1\n    pos[row[i]] = i\n  }\n  for (let i = 0; i < N; i++) {\n    for (let j = ptn[pos[ptn[row[i]]]]; i !== j; j = ptn[pos[ptn[row[i]]]]) {\n      swap(row, i, j)\n      swap(pos, row[i], row[j])\n      res++\n    }\n  }\n  return res\n}\n\nfunction swap(arr, i, j) {\n  ;[arr[i], arr[j]] = [arr[j], arr[i]]\n}\n\n// another\n\n/**\n * @param {number[]} row\n * @return {number}\n */\nconst minSwapsCouples = function (row) {\n  const parents = Array.from({ length: row.length / 2 }, (_, i) => i)\n  const positions = new Map()\n  for (let i = 0; i < row.length / 2; i++) {\n    const left = Math.floor(row[i * 2] / 2)\n    const right = Math.floor(row[i * 2 + 1] / 2)\n    if (positions.has(left)) {\n      union(i, positions.get(left))\n    } else {\n      positions.set(left, i)\n    }\n    if (positions.has(right)) {\n      union(i, positions.get(right))\n    } else {\n      positions.set(right, i)\n    }\n  }\n\n  const uniqueRoots = new Set()\n  for (const parent of parents) {\n    uniqueRoots.add(find(parent))\n  }\n  return parents.length - uniqueRoots.size\n\n  function union(a, b) {\n    const aRoot = find(a)\n    const bRoot = find(b)\n    parents[aRoot] = bRoot\n  }\n  function root(x) {\n    while (x !== parents[x]) {\n      parents[x] = parents[parents[x]]\n      x = parents[x]\n    }\n    return x\n  }\n  function find(node) {\n    return root(node)\n  }\n}\n\n// another\n\n/**\n * @param {number[]} row\n * @return {number}\n */\nconst minSwapsCouples = function (row) {\n  let res = 0\n  const n = row.length\n  const ptn = Array(n).fill(0), pos = Array(n).fill(0)\n  \n  for(let i = 0; i < n; i++) {\n    ptn[i] = (i % 2 === 0 ? i + 1 : i - 1)\n    pos[row[i]] = i\n  }\n\n  for (let i  = 0; i < n ;i++) {\n    for (let j = ptn[pos[ptn[row[i]]]]; i != j; j = ptn[pos[ptn[row[i]]]]) {\n\t\t\tswap(row, i, j);\n\t\t\tswap(pos, row[i], row[j]);\n\t\t\tres++;\n\t\t}\n  }\n  \n  return res\n\n  function swap(arr, i, j) {\n    const val = arr[i]\n    arr[i] = arr[j]\n    arr[j] = val\n  }\n}\n"
    }
  },
  {
    "name": "766-toeplitz-matrix",
    "code": {
      "JS": "/**\r\n * @param {number[][]} matrix\r\n * @return {boolean}\r\n */\r\nconst isToeplitzMatrix = function(matrix) {\r\n  for (let r = 0; r < matrix.length; r++) {\r\n    for (let c = 0; c < matrix[0].length; c++) {\r\n      if (r > 0 && c > 0 && matrix[r - 1][c - 1] !== matrix[r][c]) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n  return true;\r\n};\r\n\r\nconsole.log(isToeplitzMatrix([[1, 2, 3, 4], [5, 1, 2, 3], [9, 5, 1, 2]]));\r\n\r\nconsole.log(isToeplitzMatrix([[1, 2], [2, 2]]));\r\n"
    }
  },
  {
    "name": "767-reorganize-string",
    "code": {
      "JS": "/**\n * @param {string} S\n * @return {string}\n */\nconst reorganizeString = function(S) {\n    if (!S || S.length <= 1) {\n        return S;\n    }\n    const freqs = Array(26).fill(0);\n    const acode = 'a'.charCodeAt(0);\n    for (let i = 0, n = S.length; i < n; i++) {\n        const index = S.charCodeAt(i) - acode;\n        freqs[index]++;\n        if (freqs[index] > Math.ceil(n / 2)) {\n            return '';\n        }\n    }\n    const list = [];\n    for (let i = 0, n = S.length; i < 26; i++) {\n        if (freqs[i] === 0) {\n            continue;\n        }\n        list.push({ch: String.fromCharCode(i + acode), freq: freqs[i]});\n    }\n    list.sort((l1, l2) => l2.freq - l1.freq);\n    const parts = [];\n    for (let i = 0, n = list[0].freq; i < n; i++) {\n        parts.push(list[0].ch);\n    }\n    let idx = 0;\n    for (let i = 1, n = list.length; i < n; i++) {\n        for (let j = 0, m = list[i].freq; j < m; j++) {\n            idx %= list[0].freq;\n            parts[idx++] += list[i].ch;\n        }\n    }\n    return parts.join('');\n};\n\n// another\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst reorganizeString = function(s) {\n  const arr = Array(26).fill(0), a = 'a'.charCodeAt(0)\n  for(let ch of s) arr[ch.charCodeAt(0) - a]++\n  let max = 0, idx = -1\n  for(let i = 0; i < 26; i++) {\n    if(arr[i] > max) {\n      max = arr[i]\n      idx = i\n    }\n  }\n  const n = s.length\n  const res = Array(n)\n  if(max > (n + 1) / 2) return ''\n\n  let i = 0\n  while(arr[idx] > 0) {\n    res[i] = String.fromCharCode(a + idx)\n    i += 2\n    arr[idx]--\n  }\n  \n  for(let j = 0; j < 26; j++) {\n    while(arr[j]) {\n      if(i >= n) i = 1\n      res[i] = String.fromCharCode(a + j)\n      i += 2\n      arr[j]--\n    }\n  }\n  return res.join('')\n};\n"
    }
  },
  {
    "name": "768-max-chunks-to-make-sorted-II",
    "code": {
      "JS": "/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nconst maxChunksToSorted = function(arr) {\r\n  const clonedArr = arr.slice(0);\r\n  let sum1 = 0;\r\n  let sum2 = 0;\r\n  let res = 0;\r\n  clonedArr.sort((a, b) => a - b);\r\n  for (let i = 0; i < arr.length; i++) {\r\n    sum1 += arr[i];\r\n    sum2 += clonedArr[i];\r\n    if (sum1 === sum2) res += 1;\r\n  }\r\n  return res;\r\n};\r\n"
    }
  },
  {
    "name": "769-max-chunks-to-make-sorted",
    "code": {
      "JS": "/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nconst maxChunksToSorted = function(arr) {\r\n  let res = 0;\r\n  let max = 0;\r\n  for (let i = 0; i < arr.length; i++) {\r\n    max = Math.max(max, arr[i]);\r\n    if (max === i) res += 1;\r\n  }\r\n  return res;\r\n};\r\n"
    }
  },
  {
    "name": "77-combinations",
    "code": {
      "JS": "/**\r\n * @param {number} n\r\n * @param {number} k\r\n * @return {number[][]}\r\n */\r\nconst combine = function(n, k) {\r\n  const res = [];\r\n  bt(res, [], 1, n, k);\r\n  return res;\r\n};\r\n\r\nfunction bt(res, tmp, start, n, k) {\r\n  if (k === 0) {\r\n    res.push(tmp.slice(0));\r\n    return;\r\n  }\r\n  for (let i = start; i <= n - k + 1; i++) {\r\n    tmp.push(i);\r\n    bt(res, tmp, i + 1, n, k - 1);\r\n    tmp.pop();\r\n  }\r\n}\r\n"
    }
  },
  {
    "name": "770-basic-calculator-iv",
    "code": {
      "JS": "/**\n * @param {string} expression\n * @param {string[]} evalvars\n * @param {number[]} evalints\n * @return {string[]}\n */\nconst basicCalculatorIV = function (expression, evalvars, evalints) {\n  // Tokenise and get list of unresolved variable names\n  let [variables, it] = (function () {\n    let variables = []\n    let evalMap = new Map(evalvars.map((name, i) => [name, evalints[i]]))\n    let tokens = expression.match(/\\w+|\\d+|\\S/g)\n    // Resolve occurrences of eval vars\n    for (let i = 0; i < tokens.length; i++) {\n      let token = tokens[i]\n      if (token[0] >= 'A') {\n        let num = evalMap.get(token)\n        if (num !== undefined) {\n          tokens[i] = num\n        } else {\n          variables.push(tokens[i])\n        }\n      }\n    }\n    return [[...new Set(variables)].sort(), tokens.values()] // array & iterator\n  })()\n  // Map each unknown variable to a sequential ID:\n  let variableMap = new Map(variables.map((name, i) => [name, i]))\n\n  // Parse tokens into Polynomial instance, and get output in required format\n  return (function parse(sign = 1) {\n    function parseTerm(sign = 1) {\n      let token = it.next().value\n      if (token === '(') return parse(sign)\n      let term = new Term(sign)\n      if (typeof token === 'string' && token >= 'A') {\n        term.setVar(variableMap.get(token))\n      } else {\n        term.setCoefficient(+token)\n      }\n      return new Polynomial([term])\n    }\n\n    let polynomial = new Polynomial()\n    let term = parseTerm(sign)\n    for (let token; (token = it.next().value) && token !== ')'; ) {\n      if (token === '*') {\n        term.mul(parseTerm(1))\n      } else {\n        polynomial.add(term)\n        term = parseTerm(token === '+' ? sign : -sign)\n      }\n    }\n    return polynomial.add(term)\n  })().output(variables)\n}\nclass Term {\n  constructor(coefficient, variables = [], degree = 0) {\n    this.variables = variables\n    this.coefficient = coefficient\n    this.degree = degree\n  }\n  setVar(id) {\n    while (this.variables.length <= id) this.variables.push(0)\n    this.variables[id]++\n    this.degree++\n  }\n  setCoefficient(coefficient) {\n    this.coefficient *= coefficient\n  }\n  clone() {\n    return new Term(this.coefficient, [...this.variables], this.degree)\n  }\n  mul(term) {\n    let n = term.variables.length\n    while (this.variables.length < n) this.variables.push(0)\n    for (let i = 0; i < n; i++) {\n      this.variables[i] += term.variables[i]\n    }\n    this.degree += term.degree\n    this.coefficient *= term.coefficient\n    return this\n  }\n  cmp(term) {\n    let diff = term.degree - this.degree\n    if (diff) return Math.sign(diff)\n    for (let i = 0; i < this.variables.length; i++) {\n      diff = term.variables[i] - this.variables[i]\n      if (diff) return Math.sign(diff)\n    }\n    return 0\n  }\n  format(variableNames) {\n    return !this.coefficient\n      ? ''\n      : this.coefficient +\n          this.variables.map((count, i) =>\n            ('*' + variableNames[i]).repeat(count)\n          ).join``\n  }\n}\n\nclass Polynomial {\n  constructor(terms = []) {\n    this.terms = terms\n  }\n  addTerm(term) {\n    let terms = this.terms\n    // binary search\n    let low = 0\n    let high = terms.length\n    while (low < high) {\n      let mid = (low + high) >> 1\n      let diff = terms[mid].cmp(term)\n      if (diff === 0) {\n        terms[mid].coefficient += term.coefficient\n        return this\n      } else if (diff < 0) {\n        low = mid + 1\n      } else {\n        high = mid\n      }\n    }\n    terms.splice(low, 0, term)\n    return this\n  }\n  add(polynomial) {\n    for (let term of polynomial.terms) {\n      this.addTerm(term)\n    }\n    return this\n  }\n  mul(polynomial) {\n    let orig = new Polynomial(this.terms)\n    this.terms = [] // clear\n    for (let term1 of polynomial.terms) {\n      for (let term2 of orig.terms) {\n        this.addTerm(term1.clone().mul(term2))\n      }\n    }\n    return this\n  }\n  output(variableNames) {\n    return this.terms.map((term) => term.format(variableNames)).filter(Boolean)\n  }\n}\n"
    }
  },
  {
    "name": "771-jewels-and-stones",
    "code": {
      "JS": "/**\n * @param {string} J\n * @param {string} S\n * @return {number}\n */\nconst numJewelsInStones = function(J, S) {\n  if(J == null || J === '' || S == null || S === '') return 0\n  const m = new Set(J)\n  let res = 0\n  for(let e of S) {\n    if(m.has(e)) res++\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "772-basic-calculator-iii",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst calculate = function (\n  s,\n  start = 0,\n  end = s.length,\n  parentheses = findParentheses(s)\n) {\n  const stack = []\n  let op = '+'\n  let num = 0\n  for (let i = start; i < end; i++) {\n    const c = s[i]\n    if (/[0-9]+/.test(c)) {\n      const n = parseInt(c)\n      num = 10 * num + n\n    } else if (isOperator(c)) {\n      compute(op, stack, num)\n      op = c\n      num = 0\n    } else if (c === '(') {\n      num = calculate(s, i + 1, parentheses[i], parentheses)\n      i = parentheses[i]\n    }\n  }\n  compute(op, stack, num)\n  return stack.reduce((acc, cur) => acc + cur, 0)\n}\n\nfunction findParentheses(s) {\n  const map = {}\n  const stack = []\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === '(') {\n      stack.push(i)\n    } else if (s[i] === ')') {\n      map[stack.pop()] = i\n    }\n  }\n  return map\n}\n\nfunction compute(op, stack, num) {\n  if (op === '-') {\n    stack.push(-num)\n  } else if (op === '+') {\n    stack.push(num)\n  } else if (op === '*') {\n    stack.push(stack.pop() * num)\n  } else if (op === '/') {\n    const pre = stack.pop()\n    const sign = pre / num >= 0 ? 1 : -1\n    const val = Math.floor(Math.abs(pre / num))\n    stack.push(Math.floor(sign * val))\n  }\n}\n\nfunction isOperator(c) {\n  return c === '+' || c === '-' || c === '*' || c === '/'\n}\n"
    }
  },
  {
    "name": "773-sliding-puzzle",
    "code": {
      "JS": "/**\r\n * @param {number[][]} board\r\n * @return {number}\r\n */\r\nconst slidingPuzzle = function(board) {\r\n  const target = \"123450\";\r\n  let start = \"\";\r\n  for (let i = 0; i < board.length; i++) {\r\n    for (let j = 0; j < board[0].length; j++) {\r\n      start += board[i][j];\r\n    }\r\n  }\r\n  const visited = {};\r\n  // all the positions 0 can be swapped to\r\n  const dirs = [[1, 3], [0, 2, 4], [1, 5], [0, 4], [1, 3, 5], [2, 4]];\r\n  const queue = [];\r\n  queue.push(start);\r\n  visited[start] = true;\r\n  let res = 0;\r\n  while (queue.length !== 0) {\r\n    // level count, has to use size control here, otherwise not needed\r\n    let size = queue.length;\r\n    for (let i = 0; i < size; i++) {\r\n      let cur = queue.shift();\r\n      if (cur === target) {\r\n        return res;\r\n      }\r\n      let zero = cur.indexOf(\"0\");\r\n      // swap if possible\r\n      for (let dir of dirs[zero]) {\r\n        let next = swap(cur, zero, dir);\r\n        if (visited.hasOwnProperty(next)) {\r\n          continue;\r\n        }\r\n        visited[next] = true;\r\n        queue.push(next);\r\n      }\r\n    }\r\n    res++;\r\n  }\r\n  return -1;\r\n};\r\n\r\nfunction swap(str, i, j) {\r\n  const arr = str.split(\"\");\r\n  const ic = str[i];\r\n  const jc = str[j];\r\n  arr.splice(i, 1, jc);\r\n  arr.splice(j, 1, ic);\r\n  return arr.join(\"\");\r\n}\r\n"
    }
  },
  {
    "name": "774-minimize-max-distance-to-gas-station",
    "code": {
      "JS": "/**\n * @param {number[]} stations\n * @param {number} K\n * @return {number}\n */\nconst minmaxGasDist = function (stations, K) {\n  const dis = []\n  let min = 0\n  let max = 1e8\n  for (let i = 0; i < stations.length - 1; i++) {\n    dis.push(stations[i + 1] - stations[i])\n  }\n  while (max - min > 1e-6) {\n    const mid = min + (max - min) / 2\n    if (possible(dis, mid, K)) {\n      max = mid\n    } else {\n      min = mid\n    }\n  }\n  return min\n}\n\nconst possible = (dis, res, K) => {\n  let need = 0\n  for (let i = 0; i < dis.length; i++) {\n    need += Math.floor(dis[i] / res)\n  }\n  return need <= K\n}\n"
    }
  },
  {
    "name": "775-global-and-local-inversions",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @return {boolean}\n */\nconst isIdealPermutation = function(A) {\n  if(A.length === 1 || A.length === 2) return true\n  let max = A[0]\n  for(let i = 0, len = A.length; i < len - 2; i++) {\n    max = Math.max(max, A[i])\n    if(max > A[i + 2]) return false\n  }\n  return true;\n};\n\n// another\n\n/**\n * @param {number[]} A\n * @return {boolean}\n */\nconst isIdealPermutation = function(A) {\n  if(A.length === 1 || A.length === 2) return true\n  for(let i = 0, len = A.length; i < len; i++) {\n    if(Math.abs(A[i] - i) > 1) return false\n  }\n  return true;\n};\n"
    }
  },
  {
    "name": "776-split-bst",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} V\n * @return {TreeNode[]}\n */\nconst splitBST = function(root, V) {\n  if(root == null) return [null, null]\n  if(root.val > V) {\n    const [left, right] = splitBST(root.left, V)\n    root.left = right\n    return [left, root]\n  } else {\n    const [left, right] =  splitBST(root.right, V)\n    root.right = left\n    return [root, right]\n  }\n};\n"
    }
  },
  {
    "name": "777-swap-adjacent-in-lr-string",
    "code": {
      "JS": "/**\n * @param {string} start\n * @param {string} end\n * @return {boolean}\n */\nconst canTransform = function(start, end) {\n    let r = 0, l = 0;\n    for (let i = 0; i < start.length; i++){\n        if (start.charAt(i) === 'R'){ r++; l = 0;}\n        if (end.charAt(i) === 'R') { r--; l = 0;}\n        if (end.charAt(i) === 'L') { l++; r = 0;}\n        if (start.charAt(i) === 'L') { l--; r = 0;}\n        if (l < 0 || r < 0) return false;\n    }\n\n    if (l != 0 || r != 0) return false;\n    return true; \n};\n"
    }
  },
  {
    "name": "778-swim-in-rising-water",
    "code": {
      "JS": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nconst swimInWater = function(grid) {\n  let n = grid.length;\n  let low = grid[0][0],\n    hi = n * n - 1;\n  while (low < hi) {\n    let mid = low + Math.floor((hi - low) / 2);\n    if (valid(grid, mid)) hi = mid;\n    else low = mid + 1;\n  }\n  return low;\n};\n\nfunction valid(grid, waterHeight) {\n  let n = grid.length;\n  const visited = Array.from(new Array(n), el => new Array(n).fill(0));\n  const dir = [-1, 0, 1, 0, -1];\n  return dfs(grid, visited, dir, waterHeight, 0, 0, n);\n}\nfunction dfs(grid, visited, dir, waterHeight, row, col, n) {\n  visited[row][col] = 1;\n  for (let i = 0; i < 4; ++i) {\n    let r = row + dir[i],\n      c = col + dir[i + 1];\n    if (\n      r >= 0 &&\n      r < n &&\n      c >= 0 &&\n      c < n &&\n      visited[r][c] == 0 &&\n      grid[r][c] <= waterHeight\n    ) {\n      if (r == n - 1 && c == n - 1) return true;\n      if (dfs(grid, visited, dir, waterHeight, r, c, n)) return true;\n    }\n  }\n  return false;\n}\n\n// another\n\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nconst dirs = [[-1, 0], [1, 0], [0, 1], [0, -1]];\nconst swimInWater = grid => {\n  let time = 0;\n  let N = grid.length;\n  const visited = new Set();\n  while (!visited.has(N * N - 1)) {\n    visited.clear();\n    dfs(grid, 0, 0, time, visited);\n    time++;\n  }\n  return time - 1;\n};\n\nfunction dfs(grid, i, j, time, visited) {\n  if (\n    i < 0 ||\n    i > grid.length - 1 ||\n    j < 0 ||\n    j > grid[0].length - 1 ||\n    grid[i][j] > time ||\n    visited.has(i * grid.length + j)\n  )\n    return;\n  visited.add(i * grid.length + j);\n  for (let dir of dirs) {\n    dfs(grid, i + dir[0], j + dir[1], time, visited);\n  }\n}\n\n\n// another\n\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nclass UnionFind {\n  constructor(N) {\n    this.id = [];\n    for (let i = 0; i < N; i++) {\n      this.id[i] = i;\n    }\n  }\n\n  root(i) {\n    while (i != this.id[i]) {\n      this.id[i] = this.id[this.id[i]];\n      i = this.id[i];\n    }\n    return i;\n  }\n  isConnected(p, q) {\n    return this.root(p) === this.root(q);\n  }\n  union(p, q) {\n    if (this.isConnected(p, q)) return;\n    this.id[this.root(p)] = this.root(q);\n  }\n}\nconst swimInWater = grid => {\n  const N = grid.length;\n  const uf = new UnionFind(N * N);\n  let time = 0;\n  while (!uf.isConnected(0, N * N - 1)) {\n    for (let i = 0; i < N; i++) {\n      for (let j = 0; j < N; j++) {\n        if (grid[i][j] > time) continue;\n        if (i < N - 1 && grid[i + 1][j] <= time)\n          uf.union(i * N + j, i * N + j + N);\n        if (j < N - 1 && grid[i][j + 1] <= time)\n          uf.union(i * N + j, i * N + j + 1);\n      }\n    }\n    time++;\n  }\n  return time - 1;\n};\n"
    }
  },
  {
    "name": "779-k-th-symbol-in-grammar",
    "code": {
      "JS": "/**\n * @param {number} N\n * @param {number} K\n * @return {number}\n */\nconst kthGrammar = function(N, K) {\n\tif (N === 1) return 0;\n\tif (K % 2 === 0) return (kthGrammar(N - 1, K / 2) === 0) ? 1 : 0;\n\telse return (kthGrammar(N - 1, (K + 1) / 2) === 0) ? 0 : 1;\n};\n\n/**\n\n// think of the problem like this\n/*        0\n      /       \\\n     0          1\n   /   \\      /    \\\n   0     1    1      0\n / \\     / \\   / \\   / \\\n 0  1   1   0  1  0  0  1\n*/\n\n*/\n"
    }
  },
  {
    "name": "78-subsets",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n * @return {number[][]}\r\n */\r\n\r\nfunction subsets(nums) {\r\n  const list = [];\r\n  const len = nums.length;\r\n  const subsetNum = Math.pow(2, len);\r\n  for (let n = 0; n < subsetNum; n++) {\r\n    list[n] = [];\r\n  }\r\n  for (let i = 0; i < len; i++) {\r\n    for (let j = 0; j < subsetNum; j++) {\r\n      if ((j >> i) & 1) {\r\n        list[j].push(nums[i]);\r\n      }\r\n    }\r\n  }\r\n  return list;\r\n}\r\n\r\nconsole.log(subsets([1, 2, 3]));\r\n\r\n// another\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @return {number[][]}\r\n */\r\n\r\nfunction subsets(nums) {\r\n  const subs = [[]]\r\n  for (let num of nums) {\r\n    const n = subs.length\r\n    for (let i = 0; i < n; i++) {\r\n      subs.push(subs[i].slice(0))\r\n      subs[subs.length - 1].push(num)\r\n    }\r\n  }\r\n  return subs\r\n}\r\n"
    }
  },
  {
    "name": "780-reaching-points",
    "code": {
      "JS": "/**\n * @param {number} sx\n * @param {number} sy\n * @param {number} tx\n * @param {number} ty\n * @return {boolean}\n */\nconst reachingPoints = function(sx, sy, tx, ty) {\n  while (tx >= sx && ty >= sy) {\n    if (tx === ty) break;\n    if (tx > ty) {\n       if (ty > sy) tx %= ty;\n       else return (tx - sx) % ty === 0;\n    } else {\n      if (tx > sx) ty %= tx;\n      else return (ty - sy) % tx === 0;\n    }\n  }\n  return tx === sx && ty === sy;\n};\n\n"
    }
  },
  {
    "name": "782-transform-to-chessboard",
    "code": {
      "JS": "/**\n * @param {number[][]} b\n * @return {number}\n */\nconst movesToChessboard = function (b) {\n  let N = b.length,\n    rowSum = 0,\n    colSum = 0,\n    rowSwap = 0,\n    colSwap = 0;\n  for (let i = 0; i < N; ++i)\n    for (let j = 0; j < N; ++j)\n      if ((b[0][0] ^ b[i][0] ^ b[0][j] ^ b[i][j]) === 1) return -1;\n  for (let i = 0; i < N; ++i) {\n    rowSum += b[0][i];\n    colSum += b[i][0];\n    if (b[i][0] === i % 2) rowSwap++;\n    if (b[0][i] === i % 2) colSwap++;\n  }\n  if (rowSum !== ((N / 2) >> 0) && rowSum !== ((N + 1) / 2)>>0 ) return -1;\n  if (colSum !== ((N / 2) >> 0) && colSum !== ((N + 1) / 2)>>0 ) return -1;\n  if (N % 2 === 1) {\n    if (colSwap % 2 === 1) colSwap = N - colSwap;\n    if (rowSwap % 2 === 1) rowSwap = N - rowSwap;\n  } else {\n    colSwap = Math.min(N - colSwap, colSwap);\n    rowSwap = Math.min(N - rowSwap, rowSwap);\n  }\n  return (colSwap + rowSwap) / 2;\n};\n"
    }
  },
  {
    "name": "783-minimum-distance-between-BST-nodes",
    "code": {
      "JS": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nconst minDiffInBST = function(root) {\r\n  if (root === null) return 0;\r\n  let min = Number.MAX_SAFE_INTEGER,\r\n    res = [];\r\n  const bst = (node, res) => {\r\n    if (!node) return;\r\n    bst(node.left, res);\r\n    res.push(node.val);\r\n    bst(node.right, res);\r\n  };\r\n  bst(root, res);\r\n  for (let i = 1; i < res.length; i++) {\r\n    min = Math.min(min, res[i] - res[i - 1]);\r\n  }\r\n  return min;\r\n};\r\n"
    }
  },
  {
    "name": "784-letter-case-permutation",
    "code": {
      "JS": "/**\n * @param {string} S\n * @return {string[]}\n */\nconst letterCasePermutation = function(S) {\n    let res = []\n    backtrack(res, \"\", 0, S)\n    return res\n};\n\nconst backtrack = (res, sol, depth, S) => {\n    if (depth == S.length) {\n        res.push(sol)\n        return\n    }\n    const c = S[depth]\n    if (\"1234567890\".indexOf(c) != - 1) {\n        backtrack(res, sol+c, depth + 1, S)\n    } else {\n        backtrack(res, sol+c.toLowerCase(), depth + 1, S)\n        backtrack(res, sol+c.toUpperCase(), depth + 1, S)\n    }\n}\n\nconsole.log(letterCasePermutation(\"a1b2\")) \nconsole.log(letterCasePermutation(\"3z4\")) \nconsole.log(letterCasePermutation(\"12345\")) "
    }
  },
  {
    "name": "785-is-graph-bipartite",
    "code": {
      "JS": "/**\n * @param {number[][]} graph\n * @return {boolean}\n */\nconst isBipartite = function (graph) {\n  const visited = Array(graph.length).fill(0);\n  for (let i = 0; i < graph.length; i++) {\n    if (visited[i] !== 0) {\n      continue;\n    }\n    const queue = [];\n    queue.push(i);\n    visited[i] = 1;\n    while (queue.length > 0) {\n      const index = queue.shift();\n      for (let j = 0; j < graph[index].length; j++) {\n        const temp = graph[index][j];\n        if (visited[temp] === 0) {\n          visited[temp] = visited[index] * -1;\n          queue.push(temp);\n        } else {\n          if (visited[temp] === visited[index]) return false;\n        }\n      }\n    }\n  }\n  return true;\n};\n"
    }
  },
  {
    "name": "786-k-th-smallest-prime-fraction",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @param {number} K\n * @return {number[]}\n */\nconst kthSmallestPrimeFraction = function(A, K) {\n  let ans = []\n  let left = 0.0\n  let right = 1.0\n  while (right - left > 1e-9) {\n    const mid = left + (right - left) / 2\n    const { count, p, q } = maxUnder(mid, A)\n    if (count >= K) {\n      ans = [p, q]\n      right = mid\n    } else {\n      left = mid\n    }\n  }\n  return ans\n\n  function maxUnder(x, primes) {\n    let [p, q] = [0, 1]\n    let count = 0\n    let l = -1\n    for (let r = 1; r < primes.length; r++) {\n      while (primes[l + 1] < primes[r] * x) {\n        l += 1\n      }\n      count += l + 1\n      if (l >= 0 && p * primes[r] < q * primes[l]) {\n        ;[p, q] = [primes[l], primes[r]]\n      }\n    }\n    return { count, p, q }\n  }\n}\n"
    }
  },
  {
    "name": "787-cheapest-flights-within-k-stops",
    "code": {
      "JS": "/**\n * @param {number} n\n * @param {number[][]} flights\n * @param {number} src\n * @param {number} dst\n * @param {number} K\n * @return {number}\n */\n\nconst findCheapestPrice = function(n, flights, src, dst, K) {\n    let mn = new Array(n + 1).fill(Infinity);\n    mn[src] = 0;\n    for(let k = 0; k < K + 1; k++){\n      let newmn = [].concat(mn);\n      for(let i = 0; i < flights.length; i++){\n        let f = flights[i], a = f[0], b = f[1], c = f[2];\n        newmn[b] = Math.min(newmn[b], mn[a] + c);\n      }\n      mn = [].concat(newmn);\n    }\n    return mn[dst] != Infinity ? mn[dst] : -1\n}\n\n// another\nconst findCheapestPrice = function(n, flights, src, dst, K) {\n    const map = [];\n    flights.forEach(([s, d, p]) => {\n      map[s] = map[s] || [];\n      map[s][d] = p;\n    });\n    let min = Infinity;\n    const p = find(src, 0, 0);\n    return p === Infinity ? -1 : p;\n  \n    function find(s, p, c) {\n      if (s === dst) {\n        return p;\n      }\n      const l = map[s];\n      if (c > K || p > min || !l) {\n        return Infinity;\n      }\n      l.forEach((p1, d) => {\n        min = Math.min(min, find(d, p + p1, c + 1));\n      });\n      return min;\n    }\n};\n"
    }
  },
  {
    "name": "788-rotated-digits",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst rotatedDigits = function(n) {\n   const dp = new Array(n + 1).fill(0);\n    let count = 0;\n    for(let i = 0; i <= n; i++){\n      if(i < 10){\n        if(i == 0 || i == 1 || i == 8) dp[i] = 1;\n        else if(i == 2 || i == 5 || i == 6 || i == 9){\n          dp[i] = 2;\n          count++;\n        }\n      } else {\n        let a = dp[~~(i / 10)], b = dp[i % 10];\n        if(a == 1 && b == 1) dp[i] = 1;\n        else if(a >= 1 && b >= 1){\n          dp[i] = 2;\n          count++;\n        }\n      }\n    }\n    return count; \n};\n"
    }
  },
  {
    "name": "79-word-search",
    "code": {
      "JS": "/**\n * @param {character[][]} board\n * @param {string} word\n * @return {boolean}\n */\nconst exist = function(board, word) {\n  const dirs = [[0, 1], [0, -1], [-1, 0], [1, 0]];\n  for (let j = 0; j < board.length; j++) {\n    for (let i = 0; i < board[0].length; i++) {\n      let res = dfs(board, i, j, dirs, word, 0);\n      if (res) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\nfunction dfs(board, x, y, dirs, word, start) {\n  if (start >= word.length) return true;\n  if (x < 0 || y < 0 || x >= board[0].length || y >= board.length) return false;\n  if (word[start] !== board[y][x] || board[y][x] === \"#\") return false;\n\n  let res = false;\n  let c = board[y][x];\n  board[y][x] = \"#\";\n  for (let el of dirs) {\n    let posx = x + el[0];\n    let posy = y + el[1];\n    res = res || dfs(board, posx, posy, dirs, word, start + 1);\n    if (res) return true;\n  }\n  board[y][x] = c;\n\n  return false;\n}\n\n// time complexity: O(M * N * 3^L), where L is the length of word.\n// we have a visited array and we never go back, so 3 directions\n\n// another\n\n/**\n * @param {character[][]} board\n * @param {string} word\n * @return {boolean}\n */\nconst exist = function(board, word) {\n  if (!word || !board || board.length === 0) return false\n  const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n  for (let row = 0; row < board.length; row++) {\n    for (let col = 0; col < board[row].length; col++) {\n      if (searchWord(board, row, col, word, 0, dirs)) return true\n    }\n  }\n  return false\n}\n\nconst searchWord = (board, row, col, word, widx, dirs) => {\n  if (widx === word.length) return true\n  if (\n    row < 0 ||\n    col < 0 ||\n    row === board.length ||\n    col === board[0].length ||\n    board[row][col] === null ||\n    board[row][col] !== word[widx]\n  ) return false\n\n  const ch = board[row][col]\n  board[row][col] = null // mark visited\n\n  for (let dir of dirs) {\n    if (searchWord(board, row + dir[0], col + dir[1], word, widx + 1, dirs)) {\n      return true\n    }\n  }\n  board[row][col] = ch // recover\n}\n"
    }
  },
  {
    "name": "791-custom-sort-string",
    "code": {
      "JS": "/**\r\n * @param {string} S\r\n * @param {string} T\r\n * @return {string}\r\n */\r\nconst customSortString = function(S, T) {\r\n  const arr = [];\r\n  const remaining = [];\r\n  const hash = {};\r\n  for (let i = 0; i < S.length; i++) {\r\n    if (T.indexOf(S.charAt(i)) !== -1) {\r\n      arr.push(S.charAt(i));\r\n    }\r\n  }\r\n  let char;\r\n  for (let j = 0; j < T.length; j++) {\r\n    char = T.charAt(j);\r\n    if (arr.indexOf(char) === -1 && remaining.indexOf(char) === -1) {\r\n      remaining.push(char);\r\n    }\r\n    hash[char] = hash.hasOwnProperty(char) ? hash[char] + 1 : 1;\r\n  }\r\n  return `${genPart(arr, hash)}${genPart(remaining, hash)}`;\r\n};\r\n\r\nfunction constructStr(char, num) {\r\n  let str = \"\";\r\n  for (let i = 0; i < num; i++) {\r\n    str += char;\r\n  }\r\n  return str;\r\n}\r\n\r\nfunction genPart(arr, hash) {\r\n  return arr.reduce((ac, el) => {\r\n    return ac + constructStr(el, hash[el]);\r\n  }, \"\");\r\n}\r\n\r\nconsole.log(customSortString(\"kqep\", \"pekeq\"));\r\nconsole.log(\r\n  customSortString(\r\n    \"hucw\",\r\n    \"utzoampdgkalexslxoqfkdjoczajxtuhqyxvlfatmptqdsochtdzgypsfkgqwbgqbcamdqnqztaqhqanirikahtmalzqjjxtqfnh\"\r\n  )\r\n);\r\n"
    }
  },
  {
    "name": "792-number-of-matching-subsequences",
    "code": {
      "JS": "/**\n * @param {string} s\n * @param {string[]} words\n * @return {number}\n */\nconst numMatchingSubseq = function(s, words) {\n  const hash = {}\n  for(let w of words) {\n    if(hash[w[0]] == null) hash[w[0]] = []\n    const it = w[Symbol.iterator]()\n    hash[w[0]].push( it )\n    it.next()\n  }\n  let res = 0\n  for(let ch of s) {\n    const advance = hash[ch] || []\n    hash[ch] = []\n    for(let it of advance) {\n      const obj = it.next()\n      if(obj.done === false) {\n        if(hash[obj.value] == null) hash[obj.value] = []\n        hash[obj.value].push(it)\n      } else {\n        res++\n      }\n    }\n  }\n\n  return res\n};\n\n// another\n\n/**\n * @param {string} S\n * @param {string[]} words\n * @return {number}\n */\nconst numMatchingSubseq = function(S, words) {\n    let res=0;\n    for(let i=0;i<words.length;i++){\n      let lastIdx=-1,isSub=true\n      for(let j=0;j<words[i].length;j++){\n        const curAlp=words[i][j]\n        const curIdx=S.indexOf(curAlp,lastIdx+1)\n        if(curIdx===-1){\n          isSub=false;\n          break;\n        }\n        lastIdx=curIdx\n      }\n      if(isSub)res++\n    }\n    return res\n  };\n\n"
    }
  },
  {
    "name": "793-preimage-size-of-factorial-zeroes-function",
    "code": {
      "JS": "/**\n * @param {number} K\n * @return {number}\n */\nconst preimageSizeFZF = function(K) {\n  let last = 1\n  while (last < K) last = last * 5 + 1\n  while (last > 1) {\n    K %= last\n    if (last - 1 == K) return 0\n    last = ((last - 1) / 5) >> 0\n  }\n  return 5\n}\n"
    }
  },
  {
    "name": "794-valid-tic-tac-toe-state",
    "code": {
      "JS": "/**\n * @param {string[]} board\n * @return {boolean}\n */\nconst validTicTacToe = function(board) {\n  if (board.length == 0) return false\n  // turns = 0 represents 'X' will move, otherwise, 'O' will move\n  let turns = 0\n  // check whether 'X' wins or 'O' wins, or no players win\n  let xWin = isGameOver(board, 'X')\n  let oWin = isGameOver(board, 'O')\n\n  for (let i = 0; i < board.length; i++) {\n    for (let j = 0; j < board[0].length; j++) {\n      if (board[i].charAt(j) == 'X') turns++\n      else if (board[i].charAt(j) == 'O') turns--\n    }\n  }\n\n  /**\n   * Four conditions will be the invalid tic tac toe board:\n   * 1. there are more 'O' than 'X'\n   * 2. the board has 2 more 'X' than 'O'\n   * 3. number of 'X' is equal to number of 'O', but 'X' wins, it is impossible because if 'X' wins, the game is\n   * over, 'O' cannot play again, then number of 'O' MUST less than 'X'\n   * 4. number of 'X' is more than number of 'O', but 'O' wins, it is impossible because if 'O' wins, the game is\n   * over, 'X' cannot play again, then number of 'X' CANNOT greater than 'O'\n   * */\n  if (turns < 0 || turns > 1 || (turns == 0 && xWin) || (turns == 1 && oWin))\n    return false\n  return true\n}\n\nfunction isGameOver(board, player) {\n  // check horizontal\n  for (let i = 0; i < 3; i++) {\n    if (\n      board[i].charAt(0) === player &&\n      board[i].charAt(0) === board[i].charAt(1) &&\n      board[i].charAt(1) === board[i].charAt(2)\n    ) {\n      return true\n    }\n  }\n\n  // check vertical\n  for (let j = 0; j < 3; j++) {\n    if (\n      board[0].charAt(j) == player &&\n      board[0].charAt(j) == board[1].charAt(j) &&\n      board[1].charAt(j) == board[2].charAt(j)\n    ) {\n      return true\n    }\n  }\n\n  // check diagonal\n  if (\n    board[1].charAt(1) == player &&\n    ((board[0].charAt(0) == board[1].charAt(1) &&\n      board[1].charAt(1) == board[2].charAt(2)) ||\n      (board[0].charAt(2) == board[1].charAt(1) &&\n        board[1].charAt(1) == board[2].charAt(0)))\n  ) {\n    return true\n  }\n  return false\n}\n"
    }
  },
  {
    "name": "795-number-of-subarrays-with-bounded-maximum",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @param {number} L\n * @param {number} R\n * @return {number}\n */\nconst numSubarrayBoundedMax = function(A, L, R) {\n    let res = 0;\n    let j = 0;\n    let count = 0;\n    for(let i = 0; i < A.length; i++) {\n        if(A[i] >= L && A[i] <= R) {\n            res += i - j + 1\n            count = i - j + 1\n        } else if(A[i] < L) {\n            res += count\n        } else {\n            j = i + 1\n            count = 0\n        }\n    }\n    return res\n};\n\n// another\n\n/**\n * @param {number[]} nums\n * @param {number} left\n * @param {number} right\n * @return {number}\n */\nconst numSubarrayBoundedMax = function(nums, left, right) {\n  let prev = -1, dp = 0, res = 0\n  for(let i = 0, n = nums.length; i < n; i++) {\n    const cur = nums[i]\n    if(cur < left) res += dp\n    else if(cur > right) {\n      dp = 0\n      prev = i\n    } else {\n      dp = i - prev\n      res += dp\n    }\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "796-rotate-string",
    "code": {
      "JS": "/**\r\n * @param {string} A\r\n * @param {string} B\r\n * @return {boolean}\r\n */\r\nconst rotateString = function(A, B) {\r\n  if (A.length != B.length) return false;\r\n  return A.concat(A).includes(B);\r\n};\r\n"
    }
  },
  {
    "name": "797-all-paths-from-source-to-target",
    "code": {
      "JS": "/**\n * @param {number[][]} graph\n * @return {number[][]}\n */\nconst allPathsSourceTarget = function(graph) {\n  const res = []\n  const path = []\n  bt(graph, res, path, 0)\n  return res\n};\n\nfunction bt(g, res, path, cur) {\n  path.push(cur)\n  if(cur === g.length - 1) res.push(path.slice())\n  else {\n    for(let i of g[cur]) bt(g, res, path, i)\n  }\n  path.pop()\n}\n"
    }
  },
  {
    "name": "798-smallest-rotation-with-highest-score",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @return {number}\n */\nconst bestRotation = function(A) {\n  const N = A.length\n  const bad = new Array(N).fill(0)\n  for (let i = 0; i < N; ++i) {\n    let left = (i - A[i] + 1 + N) % N\n    let right = (i + 1) % N\n    bad[left]--\n    bad[right]++\n    if (left > right) bad[0]--\n  }\n\n  let best = -N\n  let ans = 0,\n    cur = 0\n  for (let i = 0; i < N; ++i) {\n    cur += bad[i]\n    if (cur > best) {\n      best = cur\n      ans = i\n    }\n  }\n  return ans\n}\n\n// another\n\nconst bestRotation = function(A) {\n    let n = A.length;\n    let c = new Array(n).fill(0);\n    for(let i = 0; i < n; i++) {\n        c[(i - A[i] + 1 + n) % n] -= 1;\n    }\n    let max = 0;\n    for(let i = 1; i < n; i++) {\n        c[i] += c[i-1] + 1;\n        max = c[i] > c[max] ? i : max;\n    }\n    return max;\n}\n"
    }
  },
  {
    "name": "8-string-to-integer-(atoi)",
    "code": {
      "JS": "/**\r\n * @param {string} str\r\n * @return {number}\r\n */\r\nconst myAtoi = function(str) {\r\n  return Math.max(Math.min(parseInt(str) || 0, 2147483647), -2147483648);\r\n};\r\n\r\n// anotther\r\n\r\n/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nconst myAtoi = function(s) {\r\n    let n = s.length, i = 0, j = 0, sign = 1;\r\n    if(n === 0) {\r\n        return 0;\r\n    } \r\n    while(i < n && s[i] === ' ') {\r\n        i++;\r\n    }\r\n    if(i < n && (s[i] === '-' || s[i] === '+')) {\r\n        sign = (s[i] === '-') ? -1 : 1;\r\n        i++;\r\n    }\r\n    j = i\r\n    while(i < n) {\r\n        if(Number.isInteger(parseInt(s[i]))) i++;\r\n        else break;\r\n    }\r\n    let result = parseInt(s.slice(j, i))\r\n    if(isNaN(result)) return 0\r\n    if(sign * result < -(2**31)) return -(2**31);\r\n    else if(sign * result > (2**31-1)) return 2**31-1;\r\n    else return sign * result;  \r\n};\r\n"
    }
  },
  {
    "name": "80-remove-duplicates-from-sorted-array-ii",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst removeDuplicates = function(nums) {\n    for(let i = 0; i < nums.length;) {\n      if(i >= 0 && i - 1 >= 0 && i- 2 >= 0 && nums[i] === nums[i - 1] && nums[i] === nums[i - 2]) {\n         nums.splice(i, 1)\n      } else {\n        i++\n      }\n    }\n};\n"
    }
  },
  {
    "name": "800-similar-rgb-color",
    "code": {
      "JS": "/**\n * @param {string} color\n * @return {string}\n */\nconst similarRGB = function(color) {\n  const candidates = ['00', '11', '22', '33', '44', '55', '66', '77', '88', '99', 'aa', 'bb', 'cc', 'dd', 'ee', 'ff']\n  const r = color.slice(1, 3), g = color.slice(3, 5), b = color.slice(5, 7)\n  \n  return `#${min(r)}${min(g)}${min(b)}`\n  \n  function min(str) {\n    let res = '', max = Infinity\n    for(let s of candidates) {\n      const tmp = Math.abs(parseInt(s, 16) - parseInt(str, 16))\n      if(tmp < max) {\n        max = tmp\n        res = s\n      }\n    }\n    return res\n  }\n};\n"
    }
  },
  {
    "name": "801-minimum-swaps-to-make-sequences-increasing",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @param {number[]} B\n * @return {number}\n */\nconst minSwap = function(A, B) {\n    let swapRecord = 1, fixRecord = 0;\n    for (let i = 1; i < A.length; i++) {\n        if (A[i - 1] >= B[i] || B[i - 1] >= A[i]) {\n            // In this case, the ith manipulation should be same as the i-1th manipulation\n            // fixRecord = fixRecord;\n            swapRecord++;\n        } else if (A[i - 1] >= A[i] || B[i - 1] >= B[i]) {\n            // In this case, the ith manipulation should be the opposite of the i-1th manipulation\n            let temp = swapRecord;\n            swapRecord = fixRecord + 1;\n            fixRecord = temp;\n        } else {\n            // Either swap or fix is OK. Let's keep the minimum one\n            let min = Math.min(swapRecord, fixRecord);\n            swapRecord = min + 1;\n            fixRecord = min;\n        }\n    }\n    return Math.min(swapRecord, fixRecord);\n};\n"
    }
  },
  {
    "name": "802-find-eventual-safe-states",
    "code": {
      "JS": "/**\n * @param {number[][]} graph\n * @return {number[]}\n */\nconst eventualSafeNodes = function(graph) {\n  const n = graph.length, memo = {}, visited = new Set(), res = []\n  for(let i = 0; i < n; i++) {\n    if(!dfs(graph, i, memo, visited)) res.push(i)\n  }\n  return res\n};\n\nfunction dfs(graph, node, memo, visited) {\n  if(memo[node] != null) return memo[node]\n  let hasCycle = false\n  visited.add(node)\n  for(let e of graph[node]) {\n    if(visited.has(e) || dfs(graph, e, memo, visited)) {\n      hasCycle = true\n      break\n    }\n  }\n  visited.delete(node)\n  memo[node] = hasCycle\n  return hasCycle\n}\n\n// another\n\n/**\n * @param {number[][]} graph\n * @return {number[]}\n */\nconst eventualSafeNodes = function(graph) {\n  const res = []\n  if(graph == null || graph.length === 0) return res\n  const n = graph.length\n  const color = Array(n).fill(0)\n  for(let i = 0; i < n; i++) {\n    if(bt(graph, i, color)) res.push(i)\n  }\n  return res\n\n  function bt(graph, start, color) {\n    if(color[start] !== 0) return color[start] === 1\n    color[start] = 2\n    for(let next of graph[start]) {\n      if(!bt(graph, next, color)) return false\n    }\n    color[start] = 1\n    return true\n  }\n};\n"
    }
  },
  {
    "name": "803-bricks-falling-when-hit",
    "code": {
      "JS": "/**\n * @param {number[][]} grid\n * @param {number[][]} hits\n * @return {number[]}\n */\nconst hitBricks = function (grid, hits) {\n  const n = grid[0].length\n  const m = hits.length\n  const res = new Array(m).fill(0)\n  for (const [r, c] of hits) {\n    if (grid[r][c] == 1) grid[r][c] = 0\n    else grid[r][c] = -1\n  }\n  for (let j = 0; j < n; j++) {\n    getConnectedCount(grid, 0, j)\n  }\n  for (let i = m - 1; i >= 0; i--) {\n    const [r, c] = hits[i]\n    if (grid[r][c] == -1) continue\n    grid[r][c] = 1\n    if (isConnectedToTop(grid, r, c)) {\n      res[i] = getConnectedCount(grid, r, c) - 1\n    }\n  }\n  return res\n}\nconst isConnectedToTop = (grid, i, j) => {\n  if (i == 0) return true\n  const dircs = [\n    [-1, 0],\n    [1, 0],\n    [0, -1],\n    [0, 1],\n  ]\n  for (const [dx, dy] of dircs) {\n    const nx = i + dx\n    const ny = j + dy\n    if (\n      0 <= nx &&\n      nx < grid.length &&\n      0 <= ny &&\n      ny < grid[0].length &&\n      grid[nx][ny] == 2\n    ) {\n      return true\n    }\n  }\n  return false\n}\n\nconst getConnectedCount = (grid, i, j) => {\n  if (\n    i < 0 ||\n    i >= grid.length ||\n    j < 0 ||\n    j >= grid[0].length ||\n    grid[i][j] != 1\n  )\n    return 0\n  let count = 1\n  grid[i][j] = 2\n  count +=\n    getConnectedCount(grid, i + 1, j) +\n    getConnectedCount(grid, i - 1, j) +\n    getConnectedCount(grid, i, j + 1) +\n    getConnectedCount(grid, i, j - 1)\n  return count\n}\n\n// another\n\n/**\n * @param {number[][]} grid\n * @param {number[][]} hits\n * @return {number[]}\n */\nconst hitBricks = function (grid, hits) {\n  const SPACE = 0\n  const BRICK = 1\n  const WILL_HIT = 2\n  const DIRECTIONS = [\n    [0, 1],\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n  ]\n  const rows = grid.length\n  const cols = grid[0].length\n  const ds = new DisjointSet(rows * cols + 1)\n\n  for (const [hitR, hitC] of hits) {\n    if (grid[hitR][hitC] === BRICK) {\n      grid[hitR][hitC] = WILL_HIT\n    }\n  }\n\n  function hash(r, c) {\n    return r * cols + c + 1\n  }\n\n  function unionAround(r, c) {\n    const hashed = hash(r, c)\n    for (const [rDiff, cDiff] of DIRECTIONS) {\n      const rNext = r + rDiff\n      const cNext = c + cDiff\n      if (grid[rNext] !== undefined && grid[rNext][cNext] === BRICK) {\n        ds.union(hashed, hash(rNext, cNext))\n      }\n    }\n    if (r === 0) ds.union(0, hashed)\n  }\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === BRICK) unionAround(i, j)\n    }\n  }\n  let numBricksLeft = ds.size[ds.find(0)]\n  const numBricksDropped = new Array(hits.length)\n  // backwards\n  for (let i = hits.length - 1; i >= 0; i--) {\n    const [hitR, hitC] = hits[i]\n    if (grid[hitR][hitC] === WILL_HIT) {\n      grid[hitR][hitC] = BRICK\n      unionAround(hitR, hitC)\n      const newNumBricksLeft = ds.size[ds.find(0)]\n      numBricksDropped[i] = Math.max(newNumBricksLeft - numBricksLeft - 1, 0)\n      numBricksLeft = newNumBricksLeft\n    } else {\n      numBricksDropped[i] = 0\n    }\n  }\n  return numBricksDropped\n}\n\nclass DisjointSet {\n  constructor(n) {\n    this.size = new Array(n).fill(1)\n    this.parent = new Array(n)\n    for (let i = 0; i < n; i++) {\n      this.parent[i] = i\n    }\n  }\n  find(x) {\n    if (x === this.parent[x]) return x\n    this.parent[x] = this.find(this.parent[x])\n\n    return this.parent[x]\n  }\n  union(x, y) {\n    const rootX = this.find(x)\n    const rootY = this.find(y)\n    if (rootX !== rootY) {\n      // attach X onto Y\n      this.parent[rootX] = rootY\n      this.size[rootY] += this.size[rootX]\n    }\n  }\n}\n\n// another\n\n/**\n * @param {number[][]} grid\n * @param {number[][]} hits\n * @return {number[]}\n */\nconst hitBricks = function(grid, hits) {\n  const res = Array(hits.length).fill(0), dirs = [-1, 0, 1, 0, -1]\n  for(let [r, c] of hits) {\n    grid[r][c] -= 1\n  }\n  for(let i = 0; i < grid[0].length; i++) {\n    dfs(0, i, grid)\n  }\n  for(let i = hits.length - 1; i >= 0; i--) {\n    const [r, c] = hits[i]\n    grid[r][c] += 1\n    if(grid[r][c] === 1 && isConnected(r, c, grid, dirs)) {\n      res[i] = dfs(r, c, grid) - 1\n    }\n  }\n  return res\n}\nfunction dfs(i, j, grid) {\n  if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] !== 1) return 0\n  grid[i][j] = 2\n  return 1 + dfs(i + 1, j, grid) + dfs(i - 1, j, grid) + dfs(i, j + 1, grid) + dfs(i, j - 1, grid)\n}\nfunction isConnected(i, j, grid, dirs) {\n  if(i === 0) return true\n  for(let k = 1; k < dirs.length; k++) {\n    const r = i + dirs[k - 1], c = j + dirs[k]\n    if(r >= 0 && r < grid.length && c >= 0 && c < grid[0].length && grid[r][c] === 2) {\n      return true\n    }\n  }\n  return false\n}\n\n// another\n\n/**\n * @param {number[][]} grid\n * @param {number[][]} hits\n * @return {number[]}\n */\nconst hitBricks = function (grid, hits) {\n  const m = grid.length,\n    n = grid[0].length,\n    res = Array(hits.length).fill(0),\n    dirs = [\n      [-1, 0],\n      [1, 0],\n      [0, 1],\n      [0, -1],\n    ];\n  for (let [r, c] of hits) grid[r][c] -= 1;\n\n  for (let i = 0; i < n; i++) dfs(grid, 0, i, m, n, dirs);\n\n  for (let i = hits.length - 1; i >= 0; i--) {\n    const [r, c] = hits[i];\n    grid[r][c] += 1;\n    if (grid[r][c] === 1 && connected(grid, r, c, m, n, dirs)) {\n      res[i] = dfs(grid, r, c, m, n, dirs) - 1;\n    }\n  }\n\n  return res;\n};\n\nfunction dfs(grid, i, j, m, n, dirs) {\n  if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] !== 1) return 0;\n  grid[i][j] = 2;\n  let res = 1;\n  for (let [dr, dc] of dirs) {\n    res += dfs(grid, i + dr, j + dc, m, n, dirs);\n  }\n  return res;\n}\n\nfunction connected(grid, i, j, m, n, dirs) {\n  if (i === 0) return true;\n  for (let [dr, dc] of dirs) {\n    const nr = i + dr,\n      nc = j + dc;\n    if (nr >= 0 && nr < m && nc >= 0 && nc < n && grid[nr][nc] === 2)\n      return true;\n  }\n\n  return false;\n}\n\n"
    }
  },
  {
    "name": "805-split-array-with-same-average",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @return {boolean}\n */\nconst splitArraySameAverage = function(A) {\n  const totalSum = A.reduce((ac, el) => ac + el, 0)\n  const len = A.length\n  const mid = Math.floor(len / 2)\n  A.sort((a, b) => b - a)\n  for (let i = 1; i <= mid; i++) {\n    if ((totalSum * i) % len === 0 && combinationSum(A, 0, i, (totalSum * i) / len)) return true\n  }\n  return false\n}\n\nfunction combinationSum(nums, idx, k, target) {\n  if (target > k * nums[idx]) return false\n  if (k === 0) return target === 0\n  for (let i = idx; i < nums.length - k; i++) {\n    if (nums[i] <= target && combinationSum(nums, i + 1, k - 1, target - nums[i])) return true\n  }\n  return false\n}\n"
    }
  },
  {
    "name": "81-search-in-rotated-sorted-array-ii",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {boolean}\n */\nconst search = function(nums, target) {\n    const len = nums.length\n    if(len === 0) return false\n    if(nums[0] === target) return true\n    if(target > nums[0]) {\n       for(let i = 1; i < len; i++) {\n           if(nums[i] === target) {\n              return true\n            } else {\n                if(nums[i] < nums[i - 1]) return false\n            }\n       }\n    } else {\n      for(let i = len - 1; i >= 0; i--) {\n           if(nums[i] === target) {\n              return true\n            } else {\n                if(nums[i] < nums[i - 1]) return false\n            }\n       }\n    }\n    return false\n};\n"
    }
  },
  {
    "name": "810-chalkboard-xor-game",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nconst xorGame = function(nums) {\n  const xor = nums.reduce((xor,ele) => xor^ele, 0)\n  return xor === 0 || (nums.length & 1) === 0\n};\n"
    }
  },
  {
    "name": "812-largest-triangle-area",
    "code": {
      "JS": "/**\n * @param {number[][]} points\n * @return {number}\n */\nconst largestTriangleArea = function(points) {\n    const N = points.length\n    let ans = 0\n    for(let i = 0; i < N; i++) {\n        for(let j = i + 1; j < N; j++) {\n            for(let k = j + 1; k < N; k++) {\n                ans = Math.max(ans, area(points[i], points[j], points[k]))\n            }\n        }\n    }\n    return ans\n};\n\nfunction area(P,Q,R) {\n    return 0.5 * Math.abs(P[0]*Q[1] + Q[0]*R[1] + R[0]*P[1] -P[1]*Q[0] - Q[1]*R[0] - R[1]*P[0])\n}\n"
    }
  },
  {
    "name": "813-largest-sum-of-averages",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @param {number} K\n * @return {number}\n */\nconst largestSumOfAverages = function(A, K) {\n    const len = A.length\n    const P = [0]\n    for(let i = 0; i < len; i++) {\n        P[i+1] = (P[i] || 0) + A[i]\n    }\n    const dp = []\n    for(let j = 0; j < len; j++) {\n        dp[j] = (P[len] - P[j]) / (len - j)\n    }\n    for(let m = 0; m < K - 1; m++) {\n        for(let n = 0; n < len; n++) {\n            for(let k = n + 1; k < len; k++) {\n                dp[n] = Math.max(dp[n], (P[k] - P[n]) / (k - n) + dp[k])\n            }\n        }\n    }\n    return dp[0]\n}\n"
    }
  },
  {
    "name": "815-bus-routes",
    "code": {
      "JS": "/**\n * @param {number[][]} routes\n * @param {number} S\n * @param {number} T\n * @return {number}\n */\nconst numBusesToDestination = function (routes, S, T) {\n  if (S === T) return 0\n  const map = {}\n  const visited = new Array(routes.length).fill(false),\n    queue = [S]\n  let rides = 0\n  for (let i = 0; i < routes.length; i++) {\n    for (const stop of routes[i]) {\n      if (map[stop] === undefined) {\n        map[stop] = []\n      }\n      map[stop].push(i)\n    }\n  }\n  while (queue.length > 0) {\n    let size = queue.length\n    rides += 1\n    while (size > 0) {\n      const currStop = queue.shift()\n      size -= 1\n      for (const bus of map[currStop]) {\n        if (visited[bus]) continue\n        visited[bus] = true\n        for (const stop of routes[bus]) {\n          if (stop === T) return rides\n          queue.push(stop)\n        }\n      }\n    }\n  }\n  return -1\n}\n"
    }
  },
  {
    "name": "818-race-car",
    "code": {
      "JS": "/**\n * @param {number} target\n * @return {number}\n */\nconst racecar = function (target) {\n  const dp = new Array(target + 1).fill(0)\n  for (let i = 1; i <= target; i++) {\n    dp[i] = Number.MAX_VALUE\n    let m = 1,\n      j = 1\n    for (; j < i; j = (1 << ++m) - 1) {\n      for (let q = 0, p = 0; p < j; p = (1 << ++q) - 1) {\n        dp[i] = Math.min(dp[i], m + 1 + q + 1 + dp[i - (j - p)])\n      }\n    }\n    dp[i] = Math.min(dp[i], m + (i == j ? 0 : 1 + dp[j - i]))\n  }\n  return dp[target]\n}\n"
    }
  },
  {
    "name": "819-most-common-word",
    "code": {
      "JS": "/**\n * @param {string} paragraph\n * @param {string[]} banned\n * @return {string}\n */\nconst mostCommonWord = function(paragraph, banned) {\n    const str = paragraph.toLowerCase()\n    const arr = str.replace(/\\W+/g, ' ').trim().split(' ')\n    const hash = {}\n    for(let el of arr) {\n        if(banned.indexOf(el) !== -1) {\n\n        } else {\n           if(hash.hasOwnProperty(el)) {\n              hash[el] += 1\n           } else {\n               hash[el] = 1\n           }\n        }\n    }\n    const res = Object.entries(hash).sort((a, b) => b[1] - a[1])\n    return res[0][0]\n};\n"
    }
  },
  {
    "name": "82-remove-duplicates-from-sorted-list-ii",
    "code": {
      "JS": "\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nconst deleteDuplicates = function(head) {\n    let dummy = new ListNode(undefined);\n    dummy.next = head;\n    let prev = dummy;\n    let curr = head;\n    \n    while(curr) {\n      while(curr.next && curr.next.val === curr.val) {\n        curr = curr.next;\n      }\n      if(prev.next === curr) { // detect if it has deleted some elements\n        prev = prev.next;\n        curr = curr.next;\n      } else {\n        prev.next = curr.next;\n        curr = curr.next;\n      }\n    }\n    \n    return dummy.next;\n  };\n"
    }
  },
  {
    "name": "821-shortest-distance-to-a-character",
    "code": {
      "JS": "/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nconst shortestToChar = function(S, C) {\r\n  const res = [];\r\n  const idxArr = [];\r\n  for (let i = 0; i < S.length; i++) {\r\n    S.charAt(i) === C ? idxArr.push(i) : null;\r\n  }\r\n  let coordIdx = 0;\r\n  let nextCoordIdx = 1;\r\n  let val;\r\n  for (let idx = 0; idx < S.length; idx++) {\r\n    if (S.charAt(idx) === C) {\r\n      val = 0;\r\n      nextCoordIdx = idxArr[coordIdx + 1] == null ? coordIdx : coordIdx + 1;\r\n      if (\r\n        Math.abs(idxArr[coordIdx] - idx) >= Math.abs(idxArr[nextCoordIdx] - idx)\r\n      ) {\r\n        coordIdx = idxArr[coordIdx + 1] == null ? coordIdx : coordIdx + 1;\r\n      }\r\n    } else {\r\n      nextCoordIdx = idxArr[coordIdx + 1] == null ? coordIdx : coordIdx + 1;\r\n      if (\r\n        Math.abs(idxArr[coordIdx] - idx) < Math.abs(idxArr[nextCoordIdx] - idx)\r\n      ) {\r\n        val = Math.abs(idxArr[coordIdx] - idx);\r\n      } else {\r\n        val = Math.abs(idxArr[nextCoordIdx] - idx);\r\n        coordIdx = idxArr[coordIdx + 1] == null ? coordIdx : coordIdx + 1;\r\n      }\r\n    }\r\n    res[idx] = val;\r\n  }\r\n  return res;\r\n};\r\n\r\nconsole.log(shortestToChar(\"aaab\", \"b\"));\r\nconsole.log(shortestToChar(\"bbba\", \"b\"));\r\n"
    }
  },
  {
    "name": "823-binary-trees-with-factors",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @return {number}\n */\nconst numFactoredBinaryTrees = function(A) {\n    const mod = 10 ** 9 + 7\n    let res = 0\n    A.sort((a, b) => a - b)\n    const dp = {}\n    for(let i = 0; i < A.length; i++) {\n        dp[A[i]] = 1\n        for(let j = 0; j < i; j++) {\n            if(A[i] % A[j] === 0 && dp.hasOwnProperty(Math.floor( A[i] / A[j]))) {\n                dp[A[i]] = (dp[A[i]] + dp[A[j]] * dp[Math.floor(A[i] / A[j])]) % mod\n            }\n        }\n    }\n    for(let el of Object.values(dp)) res = (res + el) % mod\n    return res\n};\n"
    }
  },
  {
    "name": "824-goat-latin",
    "code": {
      "JS": "/**\n * @param {string} sentence\n * @return {string}\n */\nconst toGoatLatin = function(sentence) {\n  const arr = sentence.split(' ')\n  const vowel = new Set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'])\n  for(let i = 0, n = arr.length; i < n; i++) {\n    const first = arr[i][0]\n    const ma = vowel.has(first) ? 'ma' : ''\n    const tmp = !vowel.has(first) ? `${arr[i].slice(1)}${first}ma` : arr[i]\n    const suffix = 'a'.repeat(i + 1)\n    arr[i] = `${tmp}${ma}${suffix}`\n  }\n  return arr.join(' ')\n};\n"
    }
  },
  {
    "name": "827-making-a-large-island",
    "code": {
      "JS": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nfunction largestIsland(grid) {\n  const map = new Map() //Key: color, Val: size of island painted of that color\n  map.set(0, 0) //We won't paint island 0, hence make its size 0, we will use this value later\n  let n = grid.length\n  let colorIndex = 2 //0 and 1 is already used in grid, hence we start colorIndex from 2\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (grid[i][j] == 1) {\n        let size = paint(grid, i, j, colorIndex)\n        map.set(colorIndex, size)\n        colorIndex++\n      }\n    }\n  }\n\n  //If there is no island 0 from grid, res should be the size of islands of first color\n  //If there is no island 1 from grid, res should be 0\n  let res = map.get(2) || 0\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (grid[i][j] === 0) {\n        //We use a set to avoid repeatly adding islands with the same color\n        const set = new Set()\n        //If current island is at the boundary, we add 0 to the set, whose value is 0 in the map\n        set.add(i > 0 ? grid[i - 1][j] : 0)\n        set.add(i < n - 1 ? grid[i + 1][j] : 0)\n        set.add(j > 0 ? grid[i][j - 1] : 0)\n        set.add(j < n - 1 ? grid[i][j + 1] : 0)\n\n        let newSize = 1 //We need to count current island as well, hence we init newSize with 1\n        for (let color of set) newSize += map.get(color)\n        res = Math.max(res, newSize)\n      }\n    }\n  }\n  return res\n}\n\n//Helper method to paint current island and all its connected neighbors\n//Return the size of all painted islands at the end\nfunction paint(grid, i, j, color) {\n  if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] != 1) return 0\n  grid[i][j] = color\n  return (\n    1 +\n    paint(grid, i + 1, j, color) +\n    paint(grid, i - 1, j, color) +\n    paint(grid, i, j + 1, color) +\n    paint(grid, i, j - 1, color)\n  )\n}\n"
    }
  },
  {
    "name": "828-unique-letter-string",
    "code": {
      "JS": "/**\n * @param {string} S\n * @return {number}\n */\nconst uniqueLetterString = function(S) {\n  const s = S.split('')\n  let res = 0\n  for (let n = S.length, i = 0, l = 0, r = 0; i < n; i++) {\n    for (l = i - 1; l >= 0 && s[l] != s[i]; l--);\n    for (r = i + 1; r < n && s[r] != s[i]; r++);\n    res += (r - i) * (i - l)\n  }\n  return res % (10 ** 9 + 7)\n}\n\n// another\n\n/**\n * @param {string} S\n * @return {number}\n */\nconst uniqueLetterString = function(S) {\n  const len = S.length\n  if (len === 0) return 0\n  if (len === 1) return 1\n  let count = 0\n  let lastP = new Array(26).fill(0)\n  let lastLastP = new Array(26).fill(0)\n  let pre = 0\n  for (let i = 0; i < len; i++) {\n    let idx = S.charCodeAt(i) - 'A'.charCodeAt(0)\n    pre += i - lastP[idx] + 1\n    pre -= lastP[idx] - lastLastP[idx]\n    count += pre\n    lastLastP[idx] = lastP[idx]\n    lastP[idx] = i + 1\n  }\n  return count % 1000000007\n}\n"
    }
  },
  {
    "name": "829-consecutive-numbers-sum",
    "code": {
      "JS": "/**\n * @param {number} N\n * @return {number}\n */\nconst consecutiveNumbersSum = function (N) {\n  let count = 1\n  for (let k = 2; k < Math.sqrt(2 * N); k++) {\n    if ((N - (k * (k - 1)) / 2) % k === 0) count++\n  }\n  return count\n}\n\n// another\n\n/**\n * @param {number} N\n * @return {number}\n */\nconst consecutiveNumbersSum = function(N) {\n  let res = 0\n  for(let i = 1; i <= N; i++) {\n    const diff = i * (i - 1) / 2\n    const nd = N - diff\n    if(nd <= 0) break\n    if(nd % i === 0) res++\n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "83-remove-duplicates-from-sorted-list",
    "code": {
      "JS": "/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nconst deleteDuplicates = function(head) {\r\n  let current = head;\r\n  while (current !== null && current.next !== null) {\r\n    if (current.val === current.next.val) {\r\n      current.next = current.next.next;\r\n    } else {\r\n      current = current.next;\r\n    }\r\n  }\r\n  return head;\r\n};\r\n\r\n// another\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nconst deleteDuplicates = function(head) {\r\n  let prev = null, cur = head\r\n  while(cur) {\r\n    if(prev && prev.val === cur.val) {\r\n      prev.next = cur.next\r\n      cur = cur.next\r\n    } else {\r\n      prev = cur\r\n      cur = cur.next      \r\n    }\r\n  }\r\n  return head\r\n};\r\n\r\n"
    }
  },
  {
    "name": "830-positions-of-large-groups",
    "code": {
      "JS": "/**\r\n * @param {string} S\r\n * @return {number[][]}\r\n */\r\nconst largeGroupPositions = function(S) {\r\n  if (S.length === 0) return [];\r\n  let prevChar = S[0];\r\n  let curChar = S[0];\r\n  let curStartIdx = 0;\r\n  let curCount = 1;\r\n  const res = [];\r\n  let tmpChar;\r\n  for (let i = 1; i < S.length; i++) {\r\n    tmpChar = S[i];\r\n    if (tmpChar === prevChar) {\r\n      curCount += 1;\r\n    } else {\r\n      if (curCount >= 3) {\r\n        res.push([curStartIdx, curStartIdx + curCount - 1]);\r\n      }\r\n\r\n      prevChar = S[i];\r\n      curStartIdx = i;\r\n      curCount = 1;\r\n    }\r\n  }\r\n\r\n  if (curCount >= 3) {\r\n    res.push([curStartIdx, curStartIdx + curCount - 1]);\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\nconsole.log(largeGroupPositions(\"aaa\"));\r\nconsole.log(largeGroupPositions(\"abbxxxxzzy\"));\r\nconsole.log(largeGroupPositions(\"abcdddeeeeaabbbcd\"));\r\n"
    }
  },
  {
    "name": "834-sum-of-distances-in-tree",
    "code": {
      "JS": "/**\n * @param {number} N\n * @param {number[][]} edges\n * @return {number[]}\n */\nconst sumOfDistancesInTree = function (N, edges) {\n  const graph = createGraph(N, edges)\n  const counts = new Array(N).fill(0)\n  const dists = new Array(N).fill(0)\n  dists[0] = getCount(graph, 0, -1, counts).sum\n  return transferDist(N, graph, 0, -1, counts, dists)\n}\n\nfunction transferDist(N, graph, u, pre, counts, dists) {\n  if (pre >= 0) {\n    const nRight = counts[u]\n    const nLeft = N - nRight\n    dists[u] = dists[pre] - nRight + nLeft\n  }\n  for (const v of graph[u]) {\n    if (v !== pre) {\n      transferDist(N, graph, v, u, counts, dists)\n    }\n  }\n  return dists\n}\n\nfunction getCount(graph, u, pre, counts) {\n  const output = { nNodes: 0, sum: 0 }\n  for (const v of graph[u]) {\n    if (v !== pre) {\n      const result = getCount(graph, v, u, counts)\n      output.nNodes += result.nNodes\n      output.sum += result.nNodes + result.sum\n    }\n  }\n  output.nNodes += 1\n  counts[u] = output.nNodes\n  return output\n}\n\nfunction createGraph(N, edges) {\n  const graph = new Array(N).fill(null).map(() => [])\n  for (const [u, v] of edges) {\n    graph[u].push(v)\n    graph[v].push(u)\n  }\n  return graph\n}\n"
    }
  },
  {
    "name": "835-image-overlap",
    "code": {
      "JS": "/**\n * @param {number[][]} A\n * @param {number[][]} B\n * @return {number}\n */\nconst largestOverlap = function(A, B) {\n    const N = A.length\n    const count = constructMatrix(2*N, 2*N, 0)\n    for (let i = 0; i < N; i++) {\n      for (let j = 0; j < N; j++) {\n        if (A[i][j] === 1) {\n          for(let ii = 0; ii < N; ii++) {\n            for(let jj = 0; jj < N; jj++) {\n              if(B[ii][jj] === 1) {\n                count[i-ii+N][j-jj+N] += 1\n              }\n            }\n          }\n        }\n      }\n    }\n    let ans = 0\n\n    for(let row of count) {\n      for(let v of row) {\n        ans = Math.max(ans, v)\n      }\n    }\n    return ans\n};\n\nfunction constructMatrix(row, col, init = 0) {\n  const matrix = []\n  for(let i = 0; i < row; i++) {\n    matrix[i] = []\n    for(let j = 0; j < col; j++) {\n      matrix[i][j] = init\n    }\n  }\n  return matrix\n}\n\nconsole.log(largestOverlap([[1,1,0],\n    [0,1,0],\n    [0,1,0]],[[0,0,0],\n    [0,1,1],\n    [0,0,1]]))"
    }
  },
  {
    "name": "836-rectangle-overlap",
    "code": {
      "JS": "/**\n * @param {number[]} rec1\n * @param {number[]} rec2\n * @return {boolean}\n */\nconst isRectangleOverlap = function(rec1, rec2) {\n  return !(\n    chkOverlap(rec1, rec2) === false || chkOverlap(rec2, rec1) === false\n  );\n};\nfunction chkOverlap(r1, r2) {\n  if (r1[2] <= r2[0] || r1[3] <= r2[1]) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nconsole.log(isRectangleOverlap([0, 0, 2, 2], [1, 1, 3, 3]));\nconsole.log(isRectangleOverlap([0, 0, 1, 1], [1, 0, 2, 1]));\n"
    }
  },
  {
    "name": "837-new-21-game",
    "code": {
      "JS": "/**\n * @param {number} N\n * @param {number} K\n * @param {number} W\n * @return {number}\n */\nconst new21Game = function(N, K, W) {\n  if (K === 0 || N >= K + W) {\n    return 1;\n  }\n  const dp = [];\n  let Wsum = 1;\n  let res = 0;\n  dp[0] = 1;\n  for (let i = 1; i <= N; i++) {\n    dp[i] = Wsum / W;\n    if (i < K) {\n      Wsum += dp[i];\n    } else {\n      res += dp[i];\n    }\n    if (i - W >= 0) {\n      Wsum -= dp[i - W];\n    }\n  }\n  return res;\n};\n\nconsole.log(new21Game(6, 1, 10));\nconsole.log(new21Game(10, 1, 10));\nconsole.log(new21Game(21, 17, 10));\n"
    }
  },
  {
    "name": "839-similar-string-groups",
    "code": {
      "JS": "/**\n * @param {string[]} A\n * @return {number}\n */\nconst numSimilarGroups = function (A) {\n  const all = new Set(A)\n  const isSimilar = function (w1, w2) {\n    if (w1 === w2) return true\n    let misMatch = 0\n    for (let i = 0; i < w1.length; i++) {\n      if (w1[i] !== w2[i]) misMatch++\n      if (misMatch > 2) return false\n    }\n    return true\n  }\n  const recur = function (s) {\n    all.delete(s)\n    for (let n of all) {\n      if (isSimilar(s, n)) {\n        recur(n)\n      }\n    }\n  }\n  let ans = 0\n  while (all.size) {\n    const current = all.values().next().value\n    recur(current)\n    ans++\n  }\n  return ans\n}\n"
    }
  },
  {
    "name": "84-largest-rectangle-in-histogram",
    "code": {
      "JS": "/**\n * @param {number[]} heights\n * @return {number}\n */\nconst largestRectangleArea = function(heights) {\n  let height = heights;\n  if (height == null || height.length == 0) {\n    return 0;\n  }\n  const lessFromLeft = new Array(height.length).fill(0);\n  const lessFromRight = new Array(height.length).fill(0);\n  lessFromRight[height.length - 1] = height.length;\n  lessFromLeft[0] = -1;\n  for (let i = 1; i < height.length; i++) {\n    let p = i - 1;\n    while (p >= 0 && height[p] >= height[i]) {\n      p = lessFromLeft[p];\n    }\n    lessFromLeft[i] = p;\n  }\n  for (let i = height.length - 2; i >= 0; i--) {\n    let p = i + 1;\n    while (p < height.length && height[p] >= height[i]) {\n      p = lessFromRight[p];\n    }\n    lessFromRight[i] = p;\n  }\n  let maxArea = 0;\n  for (let i = 0; i < height.length; i++) {\n    maxArea = Math.max(\n      maxArea,\n      height[i] * (lessFromRight[i] - lessFromLeft[i] - 1)\n    );\n  }\n  return maxArea;\n};\n\n\n// another\n\n/**\n * @param {number[]} heights\n * @return {number}\n */\nconst largestRectangleArea = function(heights) {\n  if (!heights.length) return 0;\n  let stack = [];\n  let max = 0;\n  for (let i = 0, cur, len = heights.length; i <= len; i++) {\n    cur = i === len ? -1 : heights[i];\n    while (stack.length && cur < heights[stack[stack.length - 1]]) {\n      let index = stack.pop();\n      let h = heights[index];\n      let w = !stack.length ? i : i - stack[stack.length - 1] - 1;\n      max = Math.max(max, h * w);\n    }\n    stack.push(i);\n  }\n  return max;\n};\n\n// another\n\n/**\n * @param {number[]} heights\n * @return {number}\n */\nconst largestRectangleArea = function(heights) {\n  heights.push(0)\n  const st = [], n = heights.length\n  let res = 0\n  for(let i = 0; i <= n; i++) {\n    while(st.length && heights[st[st.length - 1]] >= heights[i]) {\n      const top = st.pop()\n      const pre = st.length ? st[st.length - 1] : -1\n      res = Math.max(res, heights[top] * (i - pre - 1))\n    }\n    st.push(i)\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "841-keys-and-rooms",
    "code": {
      "JS": "/**\r\n * @param {number[][]} rooms\r\n * @return {boolean}\r\n */\r\nconst canVisitAllRooms = function(rooms) {\r\n  const stack = [];\r\n  const seen = [];\r\n  for (let i = 0; i < rooms.length; i++) {\r\n    seen[i] = false;\r\n  }\r\n  seen[0] = true;\r\n  stack.push(0);\r\n  while (stack.length) {\r\n    let node = stack.pop();\r\n    for (let el of rooms[node]) {\r\n      if (!seen[el]) {\r\n        seen[el] = true;\r\n        stack.push(el);\r\n      }\r\n    }\r\n  }\r\n  for (let el of seen) {\r\n    if (!el) return false;\r\n  }\r\n  return true;\r\n};\r\n"
    }
  },
  {
    "name": "843-guess-the-word",
    "code": {
      "JS": "/**\n * // This is the master's API interface.\n * // You should not implement it, or speculate about its implementation\n * function Master() {\n *\n *     @param {string[]} wordlist\n *     @param {Master} master\n *     @return {integer}\n *     this.guess = function(word) {\n *         ...\n *     };\n * };\n */\n/**\n * @param {string[]} wordlist\n * @param {Master} master\n * @return {void}\n */\nconst findSecretWord = function (wordlist, master) {\n  let group = wordlist\n  for (let i = 0; i < 10; i++) {\n    let currentGuess = findTheTypical(group)\n    let res = master.guess(currentGuess)\n    if (res === 6) return\n    let tmp = []\n    for (let j = 0; j < group.length; j++) {\n      if (diff(group[j], currentGuess) === 6 - res) tmp.push(group[j])\n    }\n    group = tmp\n  }\n}\nfunction findTheTypical(wordlist) {\n  const count = Array.from({ length: 6 }, (x) => new Object())\n  for (let i = 0; i < wordlist.length; i++) {\n    for (let j = 0; j < 6; j++) {\n      const cur = wordlist[i][j]\n      if (count[j][cur] === undefined) count[j][cur] = 1\n      else count[j][cur]++\n    }\n  }\n  let maxPos = 0,\n    maxCount = 0,\n    maxAlp = ''\n  for (let i = 0; i < 6; i++) {\n    for (let k of Object.keys(count[i])) {\n      if (count[i][k] > maxCount) {\n        maxCount = count[i][k]\n        maxPos = i\n        maxAlp = k\n      }\n    }\n  }\n  for (let i = 0; i < wordlist.length; i++) {\n    if (wordlist[i][maxPos] === maxAlp) return wordlist[i]\n  }\n}\nfunction diff(a, b) {\n  let count = 0\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) count++\n  }\n  return count\n}\n"
    }
  },
  {
    "name": "844-backspace-string-compare",
    "code": {
      "JS": "/**\n * @param {string} S\n * @param {string} T\n * @return {boolean}\n */\nconst backspaceCompare = function(S, T) {\n  return chk(S) === chk(T)\n};\n\nfunction chk(str) {\n  const s = []\n  for(let i = 0, len = str.length; i < len; i++) {\n    if(str[i] === '#') s.pop()\n    else s.push(str[i])\n  }\n  return s.join('')\n}\n"
    }
  },
  {
    "name": "845-longest-mountain-in-array",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @return {number}\n */\nconst longestMountain = function(A) {\n        const N = A.length;\n        let ans = 0, base = 0;\n        while (base < N) {\n            let end = base;\n            // if base is a left-boundary\n            if (end + 1 < N && A[end] < A[end + 1]) {\n                // set end to the peak of this potential mountain\n                while (end + 1 < N && A[end] < A[end + 1]) end++;\n\n                // if end is really a peak..\n                if (end + 1 < N && A[end] > A[end + 1]) {\n                    // set end to the right-boundary of mountain\n                    while (end + 1 < N && A[end] > A[end + 1]) end++;\n                    // record candidate answer\n                    ans = Math.max(ans, end - base + 1);\n                }\n            }\n\n            base = Math.max(end, base + 1);\n        }\n\n        return ans;\n};\n"
    }
  },
  {
    "name": "847-shortest-path-visiting-all-nodes",
    "code": {
      "JS": "/**\n * @param {number[][]} graph\n * @return {number}\n */\nconst shortestPathLength = function(graph) {\n  const N = graph.length\n  const dist = Array.from({ length: 1 << N }, () => new Array(N).fill(N * N))\n  for (let x = 0; x < N; x++) dist[1 << x][x] = 0\n  for (let cover = 0; cover < 1 << N; cover++) {\n    let repeat = true\n    while (repeat) {\n      repeat = false\n      for (let head = 0; head < N; head++) {\n        let d = dist[cover][head]\n        for (let next of graph[head]) {\n          let cover2 = cover | (1 << next)\n          if (d + 1 < dist[cover2][next]) {\n            dist[cover2][next] = d + 1\n            if (cover == cover2) repeat = true\n          }\n        }\n      }\n    }\n  }\n  let ans = N * N\n  for (let cand of dist[(1 << N) - 1]) ans = Math.min(cand, ans)\n  return ans\n}\n"
    }
  },
  {
    "name": "848-shifting-letters",
    "code": {
      "JS": "/**\n * @param {string} S\n * @param {number[]} shifts\n * @return {string}\n */\nconst shiftingLetters = function(S, shifts) {\n  let suffixSum = 0,\n    result = \"\";\n  for (let i = S.length - 1; i >= 0; i--) {\n    suffixSum += shifts[i];\n    let ascii = S[i].charCodeAt() - 97;\n    result = String.fromCharCode(97 + ((ascii + suffixSum) % 26)) + result;\n  }\n  return result;\n};\n"
    }
  },
  {
    "name": "849-maximize-distance-to-closest-person",
    "code": {
      "JS": "/**\n * @param {number[]} seats\n * @return {number}\n */\nconst maxDistToClosest = function(seats) {\n    let left, right, res = 0, n = seats.length;\n    for (left = right = 0; right < n; ++right)\n        if (seats[right] === 1) {\n            if (left === 0) res = Math.max(res, right - left);\n            else res = Math.max(res, Math.floor((right - left + 1) / 2));\n            left = right + 1;\n        }\n    res = Math.max(res, n - left);\n    return res;\n};\n"
    }
  },
  {
    "name": "85-maximal-rectangle",
    "code": {
      "JS": "/**\n * @param {character[][]} matrix\n * @return {number}\n */\nconst maximalRectangle = function(matrix) {\n    if(matrix.length === 0) return 0;\n    const m = matrix.length; // rows\n    const n = matrix[0].length; // cols\n    const left = new Array(n).fill(0)\n    const right = new Array(n).fill(n)\n    const height = new Array(n).fill(0);\n    let maxA = 0;\n    for(let i = 0; i < m; i++) {\n        let cur_left = 0, cur_right = n;\n        // compute height (can do this from either side)\n        for(let j = 0; j < n; j++) {\n            if(matrix[i][j] === '1') height[j]++; \n            else height[j] = 0;\n        }\n        // compute left (from left to right)\n        for(let j = 0; j < n; j++) {\n            if(matrix[i][j] ==='1') left[j] = Math.max(left[j], cur_left);\n            else {left[j] = 0; cur_left = j + 1;}\n        }\n        // compute right (from right to left)\n        for(let j = n - 1; j >= 0; j--) {\n            if(matrix[i][j] === '1') right[j] = Math.min(right[j], cur_right);\n            else {right[j] = n; cur_right = j;}    \n        }\n        // compute the area of rectangle (can do this from either side)\n        for(let j = 0; j < n; j++) {\n          maxA = Math.max(maxA, (right[j] - left[j]) * height[j]); \n        }\n    }\n    return maxA; \n};\n\n// another\n\n/**\n * @param {character[][]} matrix\n * @return {number}\n */\nconst maximalRectangle = function(matrix) {\n    if (matrix == null || matrix.length === 0 || matrix[0] == null || matrix[0].length === 0) return 0;\n    let m = matrix.length, n = matrix[0].length, maxArea = 0;\n\n    const left = new Array(n).fill(0)\n    const right = new Array(n).fill(n - 1)\n    const height = new Array(n).fill(0)\n    for (let i = 0; i < m; i++) {\n        let rB = n - 1;\n        for (let j = n - 1; j >= 0; j--) {\n            if (matrix[i][j] === '1') {\n                right[j] = Math.min(right[j], rB);\n            } else {\n                right[j] = n - 1;\n                rB = j - 1;\n            }\n        }\n        let lB = 0;\n        for (let j = 0; j < n; j++) {\n            if (matrix[i][j] === '1') {\n                left[j] = Math.max(left[j], lB);\n                height[j]++;\n                maxArea = Math.max(maxArea, height[j] * (right[j] - left[j] + 1));\n            } else {\n                height[j] = 0;\n                left[j] = 0;\n                lB = j + 1;\n            }\n        }\n    }\n    return maxArea;\n};\n"
    }
  },
  {
    "name": "850-rectangle-area-ii",
    "code": {
      "JS": "/**\n * @param {number[][]} rectangles\n * @return {number}\n */\nconst rectangleArea = function(rectangles) {\n  let xnodes = rectangles.reduce((arr, rect) => {\n    arr.push(rect[0], rect[2])\n    return arr\n  }, [])\n  xnodes = [...new Set(xnodes)].sort((a, b) => a - b)\n  let res = 0n\n  let overlay\n  let ynodes\n  let ysum\n  for (let i = 1; i < xnodes.length; i++) {\n    overlay = []\n    rectangles.forEach(rect => {\n      if (rect[0] <= xnodes[i - 1] && rect[2] >= xnodes[i]) overlay.push(rect)\n    })\n    ynodes = overlay.reduce((set, rect) => {\n      set.add(rect[1])\n      set.add(rect[3])\n      return set\n    }, new Set())\n    ynodes = [...ynodes].sort((a, b) => a - b)\n    ysum = 0n\n    for (let i = 1; i < ynodes.length; i++) {\n      for (let j = 0; j < overlay.length; j++) {\n        if (overlay[j][1] <= ynodes[i - 1] && overlay[j][3] >= ynodes[i]) {\n          ysum += BigInt(ynodes[i] - ynodes[i - 1])\n          break\n        }\n      }\n    }\n    res += ysum * BigInt(xnodes[i] - xnodes[i - 1])\n  }\n  return Number(res % BigInt(Math.pow(10, 9) + 7))\n}\n"
    }
  },
  {
    "name": "854-k-similar-strings",
    "code": {
      "JS": "/**\n * @param {string} A\n * @param {string} B\n * @return {number}\n */\nconst kSimilarity = function(A, B) {\n  if (A === B) return 0\n  let arr = [[B, 0]]\n  while (arr.length > 0) {\n    let len = arr.length\n    for (let i = 0; i < len; i++) {\n      let [cur, step] = arr.shift()\n      for (let i = 0; i < cur.length; i++) {\n        if (cur[i] === A[i]) continue\n        for (let j = i + 1; j < cur.length; j++) {\n          if (cur[j] !== A[i]) continue\n          let newStr =\n            cur.substring(0, i) +\n            cur[j] +\n            cur.substring(i + 1, j) +\n            cur[i] +\n            cur.substring(j + 1)\n          if (newStr === A) return step + 1\n          if (cur[i] === A[j]) arr.unshift([newStr, step + 1])\n          else arr.push([newStr, step + 1])\n        }\n        break\n      }\n    }\n  }\n}\n"
    }
  },
  {
    "name": "856-score-of-parentheses",
    "code": {
      "JS": "/**\n * @param {string} S\n * @return {number}\n */\nconst scoreOfParentheses = function(S) {\n  let res = 0,\n    bal = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S.charAt(i) === \"(\") {\n      bal += 1;\n    } else {\n      bal -= 1;\n      if (S.charAt(i - 1) === \"(\") {\n        res += 1 << bal;\n      }\n    }\n  }\n  return res;\n};\n"
    }
  },
  {
    "name": "857-minimum-cost-to-hire-k-workers",
    "code": {
      "JS": "/**\n * @param {number[]} quality\n * @param {number[]} wage\n * @param {number} K\n * @return {number}\n */\nconst mincostToHireWorkers = function(quality, wage, K) {\n    const workers = [], n = quality.length;\n    for (let i = 0; i < n; i++) {\n        workers[i] = { ratio: wage[i] / quality[i], quality: quality[i] }\n    }\n    workers.sort((a, b) => a.ratio - b.ratio);\n    const heap = new MaxPriorityQueue({ priority: x => x.quality });\n    let totalQuality = 0, res = Infinity;\n    while (workers.length) {\n        const curWorker = workers.shift();\n        totalQuality += curWorker.quality;\n        heap.enqueue(curWorker);\n        \n        if (heap.size() > K) {\n            totalQuality -= heap.dequeue().element.quality;\n        }\n        if (heap.size() === K) {\n            res = Math.min(res, curWorker.ratio * totalQuality)\n        }\n    }\n    return res;\n};\n\n\n\n// another\n\n/**\n * @param {number[]} quality\n * @param {number[]} wage\n * @param {number} K\n * @return {number}\n */\nconst mincostToHireWorkers = function(quality, wage, K) {\n  const workers = Array.from({length: quality.length}, () => new Array(2));\n  for (let i = 0; i < quality.length; ++i) workers[i] = [wage[i] / quality[i], quality[i]];\n  workers.sort((a, b) => a[0] - b[0])\n  let res = Number.MAX_VALUE, qsum = 0;\n  const queue = []\n  for (let worker of workers) {\n    qsum += worker[1];\n    insert(queue, -worker[1])\n    if (queue.length > K) qsum += queue.shift();\n    if (queue.length === K) res = Math.min(res, qsum * worker[0]);\n  }\n  return res;\n};\n\nfunction insert(arr, el) {\n  for(let i = 0; i < arr.length; i++) {\n    if(arr[i] > el) {\n      arr.splice(i, 0, el)\n      return\n    }\n  }\n  arr.push(el)\n}\n"
    }
  },
  {
    "name": "858-mirror-reflection",
    "code": {
      "JS": "/**\r\n * @param {number} p\r\n * @param {number} q\r\n * @return {number}\r\n */\r\nconst mirrorReflection = function(p, q) {\r\n  while (p % 2 === 0 && q % 2 === 0) {\r\n    p /= 2;\r\n    q /= 2;\r\n  }\r\n\r\n  if (p % 2 === 0) {\r\n    return 2;\r\n  } else if (q % 2 === 0) {\r\n    return 0;\r\n  } else {\r\n    return 1;\r\n  }\r\n};\r\n"
    }
  },
  {
    "name": "859-buddy-strings",
    "code": {
      "JS": "/**\n * @param {string} A\n * @param {string} B\n * @return {boolean}\n */\nconst buddyStrings = function(A, B) {\n    if(A.length !== B.length) return false\n    const aCode = ('a').charCodeAt(0)\n    if(A === B) {\n       const count = new Array(26).fill(0)\n       for(let i = 0; i < A.length; i++) {\n         count[A.charCodeAt(i) - aCode]++\n       }\n       for(let el of count) {\n         if(el > 1) return true\n       }\n       return false\n    } else {\n      const arr = []\n      for(let i = 0; i < A.length; i++) {\n        if(A[i] !== B[i]) {\n           arr.push(i)\n           if(arr.length > 2) return false\n        }\n      }\n      if(arr.length !== 2) return false\n      return A[arr[0]] === B[arr[1]] && A[arr[1]] === B[arr[0]]\n    }\n};\n"
    }
  },
  {
    "name": "86-partition-list",
    "code": {
      "JS": "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} x\n * @return {ListNode}\n */\nconst partition = function(head, x) {\n    const leftHead = new ListNode(); \n    const rightHead = new ListNode(); \n    let left = leftHead;\n    let right = rightHead;\n  \n    // split list into two sides, left if val < x, else right\n    for (let node = head; node !== null; node = node.next) {\n      if (node.val < x) {\n        left.next = node;\n        left = node;\n      } else {\n        right.next = node;\n        right = node;\n      }\n    }\n  \n    // combine the two sides\n    left.next = rightHead.next;\n    right.next = null;\n  \n    return leftHead.next;\n};\n\n// another\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} x\n * @return {ListNode}\n */\nconst partition = function(head, x) {\n    const left = []\n    const right = []\n    let containX = false\n    let cur = head\n    while(cur !== null) {\n        if (containX === true) {\n            if (cur.val < x) {\n                left.push(cur)\n            } else {\n                right.push(cur)\n            }\n        } else {\n            if (cur.val >= x) {\n                containX = true\n                right.push(cur)\n            } else {\n                left.push(cur)\n            }\n        }\n        cur = cur.next\n    }\n    const arr = left.concat(right)\n    \n    for(let i = 0; i < arr.length; i++) {\n        if (i === arr.length - 1) {\n            arr[i].next = null\n        } else {\n            arr[i].next = arr[i+1]\n        }\n    }\n    return arr[0] == null ? null : arr[0]\n};\n"
    }
  },
  {
    "name": "860-lemonade-change",
    "code": {
      "JS": "/**\r\n * @param {number[]} bills\r\n * @return {boolean}\r\n */\r\nconst lemonadeChange = function(bills) {\r\n  let five = 0;\r\n  let ten = 0;\r\n  for (let el of bills) {\r\n    if (el === 5) {\r\n      five += 1;\r\n    } else if (el === 10) {\r\n      if (five < 1) return false;\r\n      five -= 1;\r\n      ten += 1;\r\n    } else {\r\n      if (five > 0 && ten > 0) {\r\n        five -= 1;\r\n        ten -= 1;\r\n      } else if (five >= 3) {\r\n        five -= 3;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n"
    }
  },
  {
    "name": "862-shortest-subarray-with-sum-at-least-k",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @param {number} K\n * @return {number}\n */\nconst shortestSubarray = function(A, K) {\n    const N = A.length\n    const P = new Array(N+1).fill(0)\n    \n    for(let i = 0; i < N; i++) {\n        P[i+1] = P[i] + A[i]\n    }\n\n    let ans = N + 1\n    const monoq = []\n    for(let y = 0; y < P.length; y++) {\n        while(monoq.length > 0 && P[y] <= P[monoq[monoq.length - 1]] ) {\n            monoq.pop()\n        }\n        while(monoq.length > 0 && P[y] >= P[monoq[0]] + K ) {\n            ans = Math.min(ans, y - monoq.shift())\n        }\n        monoq.push(y)\n    }\n\n    return ans < N + 1 ? ans : -1\n};\n"
    }
  },
  {
    "name": "863-all-nodes-distance-k-in-binary-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} target\n * @param {number} K\n * @return {number[]}\n */\nconst distanceK = function(root, target, K) {\n  const map = new Map();\n  const res = [];\n  if (target == null || K < 0 || root == null) return res;\n  buildGraph(root, null);\n  const visited = new Set();\n  const q = [];\n  visited.add(target);\n  q.push(target);\n  while (q.length) {\n    const len = q.length;\n    if (K === 0) {\n      for (let i = 0; i < len; i++) res.push(q.shift().val);\n      return res;\n    }\n    for (let i = 0; i < len; i++) {\n      const el = q.shift();\n      for (let e of map.get(el)) {\n        if (visited.has(e)) continue;\n        visited.add(e);\n        q.push(e);\n      }\n    }\n    K--;\n  }\n  return res;\n\n  function buildGraph(node, parent) {\n    if (node === null) return;\n    if (!map.has(node)) {\n      map.set(node, []);\n      if (parent !== null) {\n        map.get(node).push(parent);\n        if (!map.has(parent)) map.set(parent, []);\n        map.get(parent).push(node);\n      }\n      buildGraph(node.left, node);\n      buildGraph(node.right, node);\n    }\n  }\n};\n\n// another\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} target\n * @param {number} K\n * @return {number[]}\n */\nconst distanceK = function(root, target, K) {\n  let res = []\n  dfs(root, target, K, res)\n  return res\n}\n\nfunction dfs(node, target, k, res) {\n  if (node === null) return -1\n  if (node === target) {\n    getRes(node, 0, k, res)\n    return 1\n  }\n  let left = dfs(node.left, target, k, res)\n  let right = dfs(node.right, target, k, res)\n  if (left !== -1) {\n    if (left === k) res.push(node.val)\n    getRes(node.right, left + 1, k, res)\n    return left + 1\n  }\n  if (right !== -1) {\n    if (right === k) res.push(node.val)\n    getRes(node.left, right + 1, k, res)\n    return right + 1\n  }\n  return -1\n}\n\nfunction getRes(node, dist, k, res) {\n  if (node === null) return\n  if (dist === k) return res.push(node.val)\n  getRes(node.left, dist + 1, k, res)\n  getRes(node.right, dist + 1, k, res)\n}\n"
    }
  },
  {
    "name": "864-shortest-path-to-get-all-keys",
    "code": {
      "python": "NA",
      "JS": "/**\n * @param {string[]} grid\n * @return {number}\n */\nconst shortestPathAllKeys = function(grid) {\n  let r = grid.length,\n    c = grid[0].length\n  let moves = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n  let finalState = 0,\n    startPoint = null\n  for (let i = 0; i < r; i++) {\n    for (let j = 0; j < c; j++) {\n      let code = grid[i].charCodeAt(j) - 97\n      if (code >= 0 && code <= 5) {\n        finalState = finalState | (1 << code)\n      } else if (grid[i][j] === '@') {\n        startPoint = [i, j]\n      }\n    }\n  }\n  let visited = Array(finalState + 1)\n    .fill()\n    .map(() =>\n      Array(r)\n        .fill()\n        .map(() => Array(c).fill(false))\n    )\n  let step = 0\n  let arr = [[startPoint[0], startPoint[1], 0]]\n  while (arr.length > 0) {\n    let len = arr.length\n    for (let i = 0; i < len; i++) {\n      let [x, y, keysState] = arr.shift()\n      for (let [dx, dy] of moves) {\n        let newx = x + dx,\n          newy = y + dy\n        if (newx < 0 || newy < 0 || newx >= r || newy >= c) continue\n        let curstr = grid[newx][newy]\n        if (curstr === '#') continue\n        let code = grid[newx].charCodeAt(newy)\n        if (visited[keysState][newx][newy]) continue\n        visited[keysState][newx][newy] = true\n        if (code >= 65 && code <= 72 && ((1 << (code - 65)) & keysState) === 0)\n          continue\n        let newState = keysState\n        if (\n          code >= 97 &&\n          code <= 102 &&\n          ((1 << (code - 97)) & keysState) === 0\n        ) {\n          newState = newState | (1 << (code - 97))\n          if (newState === finalState) return step + 1\n        }\n        arr.push([newx, newy, newState])\n      }\n    }\n    step++\n  }\n  return -1\n}\n"
    }
  },
  {
    "name": "865-smallest-subtree-with-all-the-deepest-nodes",
    "code": {
      "python": "NA",
      "JS": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {TreeNode}\r\n */\r\nconst subtreeWithAllDeepest = function(root) {\r\n  return dfs(root).node;\r\n};\r\n\r\nfunction dfs(node) {\r\n  if (node == null) return new result(null, 0);\r\n  const l = dfs(node.left);\r\n  const r = dfs(node.right);\r\n  if (l.dist > r.dist) return new result(l.node, l.dist + 1);\r\n  if (l.dist < r.dist) return new result(r.node, r.dist + 1);\r\n  return new result(node, l.dist + 1);\r\n}\r\n\r\nfunction result(node, dist) {\r\n  this.node = node;\r\n  this.dist = dist;\r\n}\r\n"
    }
  },
  {
    "name": "866-prime-palindrome",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst primePalindrome = function(n) {\n  if(n >= 8 && n <= 11) return 11\n  const rev = str => str.split('').reverse().join('')\n  for (let i = 1; i < 1e5; i++) {\n    let left = `${i}`, right = rev(left).slice(1)\n    let num = +(left + right)\n    if (num >= n && isPrime(num)) return num\n  }\n  return -1\n\n  function isPrime(num) {\n    if(num < 2 || num % 2 === 0) return num === 2\n    for(let i = 3; i * i <= num; i += 2) {\n      if(num % i === 0) return false\n    }\n    return true\n  }\n};\n\n// another\n\n/**\n * @param {number} N\n * @return {number}\n */\nconst primePalindrome = function(N) {\n  if(N >= 8 && N <= 11) return 11\n  for(let x = 1; x < 100000; x++) {\n    let s = '' + x, r = s.split('').reverse().join('')\n    let y = +(s + r.slice(1))\n    if(y >= N && isPrime(y)) return y\n  }\n  return -1\n};\n\nfunction isPrime(x) {\n  if(x < 2 || x % 2 === 0) return x === 2\n  for(let i = 3; i * i <= x; i += 2) {\n    if(x % i === 0) return false\n  }\n  return true\n}\n\n// another\n\n\n/**\n * @param {number} n\n * @return {number}\n */\nconst primePalindrome = function(n) {\n  if(n >= 8 && n <= 11) return 11\n\n  const rev = num => `${num}`.split('').reverse().join('')\n  for(let i = 1; i < 1e5; i++) {\n    let left = i, right = rev(left).slice(1)\n    const tmp = +(left + right)\n    if(tmp >= n && isPrime(tmp)) return tmp\n  }\n\n  function isPrime(num) {\n    if(num <= 2) return num === 2\n    if(num % 2 === 0) return false\n    for(let i = 3; i ** 2 <= num; i += 2) {\n      if(num % i === 0) return false\n    }\n    return true\n  }\n};\n"
    }
  },
  {
    "name": "868-binary-gap",
    "code": {
      "JS": "/**\r\n * @param {number} N\r\n * @return {number}\r\n */\r\nconst binaryGap = function(N) {\r\n  const bin = (N >>> 0).toString(2);\r\n  const idxArr = [];\r\n  for (let i = 0; i < bin.length; i++) {\r\n    const num = bin.charAt(i);\r\n    if (num === \"1\") {\r\n      idxArr.push(i);\r\n    }\r\n  }\r\n  let maxConLen = 0;\r\n  for (let idx = 0; idx < idxArr.length - 1; idx++) {\r\n    if (idxArr[idx + 1] - idxArr[idx] > maxConLen) {\r\n      maxConLen = idxArr[idx + 1] - idxArr[idx];\r\n    }\r\n  }\r\n\r\n  return maxConLen;\r\n};\r\n"
    }
  },
  {
    "name": "869-reordered-power-of-2",
    "code": {
      "JS": "/**\r\n * @param {number} N\r\n * @return {boolean}\r\n */\r\nconst reorderedPowerOf2 = function(N) {\r\n  const A = count(N);\r\n  for (let i = 0; i < 31; i++) {\r\n    if (arrayEqual(A, count(1 << i))) return true;\r\n  }\r\n  return false;\r\n};\r\n\r\nfunction count(num) {\r\n  const res = [];\r\n  while (num > 0) {\r\n    addOne(res, num % 10);\r\n    num = parseInt(num / 10);\r\n  }\r\n  return res;\r\n}\r\nfunction addOne(arr, idx) {\r\n  if (arr[idx]) {\r\n    arr[idx] += 1;\r\n    return;\r\n  }\r\n  arr[idx] = 1;\r\n}\r\nfunction arrayEqual(a1, a2) {\r\n  return JSON.stringify(a1) === JSON.stringify(a2);\r\n}\r\n\r\nconsole.log(reorderedPowerOf2(1));\r\nconsole.log(reorderedPowerOf2(10));\r\nconsole.log(reorderedPowerOf2(16));\r\nconsole.log(reorderedPowerOf2(24));\r\nconsole.log(reorderedPowerOf2(46));\r\n"
    }
  },
  {
    "name": "87-scramble-string",
    "code": {
      "JS": "/**\n * @param {string} s1\n * @param {string} s2\n * @return {boolean}\n */\nconst isScramble = function(s1, s2) {\n  if (s1 === s2) return true\n  const letters = new Array(128).fill(0)\n  const a = 'a'.charCodeAt(0)\n  for (let i = 0; i < s1.length; i++) {\n    letters[s1.charCodeAt(i) - a]++\n    letters[s2.charCodeAt(i) - a]--\n  }\n  for (let i = 0; i < 128; i++) if (letters[i] !== 0) return false\n  for (let i = 1; i < s1.length; i++) {\n    if (\n      isScramble(s1.substring(0, i), s2.substring(0, i)) &&\n      isScramble(s1.substring(i), s2.substring(i))\n    )\n      return true\n    if (\n      isScramble(s1.substring(0, i), s2.substring(s2.length - i)) &&\n      isScramble(s1.substring(i), s2.substring(0, s2.length - i))\n    )\n      return true\n  }\n  return false\n}\n"
    }
  },
  {
    "name": "870-advantage-shuffle",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @param {number[]} B\n * @return {number[]}\n */\nfunction advantageCount(aArr, B) {\n    const A = aArr.sort((a, b) => a - b)\n    const n = A.length\n    const res = []\n    let pq = []\n    for(let i = 0; i < n; i++) {\n        pq.push([B[i], i])\n    }\n    pq.sort((a, b) => b[0] - a[0])\n    let lo = 0\n    let hi = n - 1\n    while(pq.length > 0) {\n        let cur = pq.shift()\n        let idx = cur[1]\n        let val = cur[0]\n        if (A[hi] > val) {\n            res[idx] = A[hi--]\n        } else {\n            res[idx] = A[lo++]\n        }\n    }\n    return res\n}\n"
    }
  },
  {
    "name": "871-minimum-number-of-refueling-stops",
    "code": {
      "JS": "/**\n * @param {number} target\n * @param {number} startFuel\n * @param {number[][]} stations\n * @return {number}\n */\nconst minRefuelStops = function (target, startFuel, stations) {\n  const dp = Array(stations.length + 1).fill(0)\n  dp[0] = startFuel\n  for (let i = 0; i < stations.length; ++i) {\n    for (let t = i; t >= 0 && dp[t] >= stations[i][0]; --t) {\n      dp[t + 1] = Math.max(dp[t + 1], dp[t] + stations[i][1])\n    }\n  }\n  for (let t = 0; t <= stations.length; ++t) {\n    if (dp[t] >= target) return t\n  }\n  return -1\n}\n"
    }
  },
  {
    "name": "873-length-of-longest-fibonacci-subsequence",
    "code": {
      "JS": "/**\r\n * @param {number[]} A\r\n * @return {number}\r\n */\r\nconst lenLongestFibSubseq = function(A) {\r\n  const n = A.length;\r\n  let max = 0;\r\n  const dp = Array(n).map(el => Array(n).fill(0));\r\n  for (let i = 1; i < n; i++) {\r\n    let l = 0,\r\n      r = i - 1;\r\n    while (l < r) {\r\n      let sum = A[l] + A[r];\r\n      if (sum > A[i]) {\r\n        r--;\r\n      } else if (sum < A[i]) {\r\n        l++;\r\n      } else {\r\n        dp[r][i] = dp[l][r] + 1;\r\n        max = Math.max(max, dp[r][i]);\r\n        r--;\r\n        l++;\r\n      }\r\n    }\r\n  }\r\n  return max == 0 ? 0 : max + 2;\r\n};\r\n"
    }
  },
  {
    "name": "874-walking-robot-simulation",
    "code": {
      "JS": "/**\n * @param {number[]} commands\n * @param {number[][]} obstacles\n * @return {number}\n */\nconst robotSim = function(commands, obstacles) {\n  const dirs = [[1, 0], [0, -1], [-1, 0], [0, 1]] // east, south, west, north\n  const set = new Set()\n  obstacles.forEach(([x, y]) => set.add(`${x},${y}`))\n  let idx = 3, x = 0, y = 0, res = 0\n  for(let e of commands) {\n    if(e === -2) idx = (3 + idx) % 4\n    else if(e === -1) idx = (1 + idx) % 4\n    else {\n      const [dx, dy] = dirs[idx]\n      let dis = 0\n      while(dis < e) {\n        const nx = x + dx, ny = y + dy\n        const k = `${nx},${ny}`\n        if(set.has(k)) break\n        x = nx\n        y = ny\n        dis++\n        res = Math.max(res, x * x + y * y)\n      }\n    }\n  }\n  \n  return res\n};\n"
    }
  },
  {
    "name": "876-middle-of-the-linked-list",
    "code": {
      "JS": "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nconst middleNode = function (head) {\n  if (head == null) return null\n  let count = 1\n  let iter = head\n  while (iter.next) {\n    iter = iter.next\n    count++\n  }\n  count = (count / 2) >> 0\n  while (count) {\n    head = head.next\n    count--\n  }\n  return head\n}\n"
    }
  },
  {
    "name": "878-nth-magical-number",
    "code": {
      "JS": "/**\n * @param {number} N\n * @param {number} A\n * @param {number} B\n * @return {number}\n */\nconst gcd = (x, y) => {\n  while (y > 0) [x, y] = [y, x % y]\n  return x\n}\nconst lcm = (x, y) => (x * y) / gcd(x, y)\nconst nthMagicalNumber = function(N, A, B) {\n  let l = lcm(A, B)\n  const seq = {}\n  for (let i = 1; i < Math.floor(l / A) + 1; i++) seq[i * A] = 1\n  for (let i = 1; i < Math.floor(l / B) + 1; i++) seq[i * B] = 1\n  const arr = Object.keys(seq)\n    .sort((a, b) => a - b)\n    .map(el => +el)\n  let idx = N % arr.length === 0 ? arr.length - 1 : (N % arr.length) - 1\n  let res = Math.floor((N - 1) / arr.length) * arr[arr.length - 1] + arr[idx]\n  return res % (1e9 + 7)\n}\n\n// another\n\nconst nthMagicalNumber = function(N, A, B) {\n  const gcd = (x, y) => {\n    if (x == 0) return y\n    return gcd(y % x, x)\n  }\n  const MOD = 1e9 + 7\n  const L = (A / gcd(A, B)) * B\n  let lo = 0\n  let hi = 1e15\n  while (lo < hi) {\n    let mi = lo + Math.trunc((hi - lo) / 2)\n    if (Math.trunc(mi / A) + Math.trunc(mi / B) - Math.trunc(mi / L) < N) lo = mi + 1\n    else hi = mi\n  }\n  return lo % MOD\n}\n"
    }
  },
  {
    "name": "879-profitable-schemes",
    "code": {
      "JS": "/**\n * @param {number} G\n * @param {number} P\n * @param {number[]} group\n * @param {number[]} profit\n * @return {number}\n */\nconst profitableSchemes = function(G, P, group, profit) {\n  const dp = Array.from({ length: P + 1 }, () => new Array(G + 1).fill(0))\n  dp[0][0] = 1\n  let res = 0,\n    mod = 10 ** 9 + 7\n  for (let k = 0; k < group.length; k++) {\n    let g = group[k],\n      p = profit[k]\n    for (let i = P; i >= 0; i--)\n      for (let j = G - g; j >= 0; j--)\n        dp[Math.min(i + p, P)][j + g] =\n          (dp[Math.min(i + p, P)][j + g] + dp[i][j]) % mod\n  }\n  for (let x of dp[P]) res = (res + x) % mod\n  return res\n}\n"
    }
  },
  {
    "name": "88-merge-sorted-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums1\n * @param {number} m\n * @param {number[]} nums2\n * @param {number} n\n * @return {void} Do not return anything, modify nums1 in-place instead.\n */\nconst merge = function(nums1, m, nums2, n) {\n  if (nums2.length === 0) return nums1;\n  let fi = 0;\n  let si = 0;\n  for (let i = si; i < n; i++) {\n    let se = nums2[i];\n    while (se >= nums1[fi] && fi < m + n && fi < m + i) {\n      fi++;\n    }\n    nums1.splice(fi, 0, se);\n    fi++;\n  }\n  while (nums1.length > m + n) {\n    nums1.pop();\n  }\n};\n"
    }
  },
  {
    "name": "880-decoded-string-at-index",
    "code": {
      "JS": "/**\n * @param {string} S\n * @param {number} K\n * @return {string}\n */\n\nconst decodeAtIndex = function(S, K) {\n  let n = S.length;\n  let dp = Array(n + 1).fill(0);\n  for (let i = 0; i < n; i++) {\n    if (S[i] >= \"2\" && S[i] <= \"9\") {\n      dp[i + 1] = dp[i] * (S[i] - \"0\");\n    } else {\n      dp[i + 1] = dp[i] + 1;\n    }\n  }\n  K--;\n  for (let i = n - 1; i >= 0; i--) {\n    K %= dp[i + 1];\n    if (K + 1 == dp[i + 1] && !(S[i] >= \"2\" && S[i] <= \"9\")) {\n      return \"\" + S[i];\n    }\n  }\n  return null;\n};\n"
    }
  },
  {
    "name": "881-boats-to-save-people",
    "code": {
      "JS": "/**\n * @param {number[]} people\n * @param {number} limit\n * @return {number}\n */\nconst numRescueBoats = function(people, limit) {\n    if(people.length === 0) return 0\n    const arr = people.sort((a, b) => a - b)\n    let count = 0\n    let i = 0\n    let j = arr.length - 1\n    while(i <= j) {\n        count++\n        if(arr[i] + arr[j] <= limit) {\n            i++\n        }\n        j--\n    }\n\n    return count\n};\n"
    }
  },
  {
    "name": "882-reachable-nodes-in-subdivided-graph",
    "code": {
      "JS": "/**\n * @param {number[][]} edges\n * @param {number} maxMoves\n * @param {number} n\n * @return {number}\n */\nconst reachableNodes = function(edges, maxMoves, n) {\n    let res = 0,\n    heap = new Heap(),\n    state = new Array(n).fill(0),\n    graph = Array.from(new Array(n), () => []),\n    distance = new Array(n).fill(Number.MAX_SAFE_INTEGER);\n  for (let [u, v, d] of edges) {\n    graph[u].push([v, d]);\n    graph[v].push([u, d]);\n  }\n  distance[0] = 0;\n  heap.insert([0, distance[0]]);\n  while (heap.length != 0) {\n    let t = heap.remove();\n    if (state[t[0]] === 1) continue;\n    if (distance[t[0]] <= maxMoves) res++;\n    state[t[0]] = 1;\n    for (let i of graph[t[0]]) {\n      if (distance[i[0]] > distance[t[0]] + i[1] + 1) {\n        distance[i[0]] = distance[t[0]] + i[1] + 1;\n        heap.insert([i[0], distance[i[0]]]);\n      }\n    }\n  }\n  for (let [u, v, d] of edges) {\n    let a = maxMoves - distance[u] >= 0 ? maxMoves - distance[u] : 0,\n      b = maxMoves - distance[v] >= 0 ? maxMoves - distance[v] : 0;\n    res += Math.min(d, a + b);\n  }\n  return res;\n};\n\nclass Heap {\n  constructor() {\n    this.heap = [];\n  }\n\n  get length() {\n    return this.heap.length;\n  }\n\n  compare(i, j) {\n    if (!this.heap[j]) return false;\n    return this.heap[i][1] > this.heap[j][1];\n  }\n\n  swap(i, j) {\n    const temp = this.heap[i];\n    this.heap[i] = this.heap[j];\n    this.heap[j] = temp;\n  }\n\n  insert(num) {\n    this.heap.push(num);\n    let idx = this.length - 1;\n    let parent = (idx - 1) >> 1;\n    while (idx !== 0 && this.compare(parent, idx)) {\n      this.swap(parent, idx);\n      idx = parent;\n      parent = (idx - 1) >> 1;\n    }\n  }\n\n  remove() {\n    if (this.length === 1) return this.heap.pop();\n    let res = this.heap[0],\n      idx = 0,\n      left = 1 | (idx << 1),\n      right = (1 + idx) << 1;\n    this.heap[0] = this.heap.pop();\n    while (this.compare(idx, left) || this.compare(idx, right)) {\n      if (this.compare(left, right)) {\n        this.swap(idx, right);\n        idx = right;\n      } else {\n        this.swap(idx, left);\n        idx = left;\n      }\n      left = 1 | (idx << 1);\n      right = (1 + idx) << 1;\n    }\n    return res;\n  }\n}\n\n// another\n\n/**\n * @param {number[][]} edges\n * @param {number} M\n * @param {number} N\n * @return {number}\n */\nconst reachableNodes = function (edges, M, N) {\n  const graph = Array.from({ length: N }, () => Array(N).fill(-1))\n  for (let edge of edges) {\n    graph[edge[0]][edge[1]] = edge[2]\n    graph[edge[1]][edge[0]] = edge[2]\n  }\n  let result = 0\n  const pq = new PriorityQueue((a, b) => a[1] > b[1])\n  const visited = new Array(N).fill(false)\n  pq.push([0, M])\n  while (!pq.isEmpty()) {\n    const cur = pq.pop()\n    const start = cur[0]\n    const move = cur[1]\n    if (visited[start]) {\n      continue\n    }\n    visited[start] = true\n    result++\n    for (let i = 0; i < N; i++) {\n      if (graph[start][i] > -1) {\n        if (move > graph[start][i] && !visited[i]) {\n          pq.push([i, move - graph[start][i] - 1])\n        }\n        graph[i][start] -= Math.min(move, graph[start][i])\n        result += Math.min(move, graph[start][i])\n      }\n    }\n  }\n  return result\n}\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n\n// another\n\n// time complexity: \n// Dijkstra + Heap is O(E log E)\n// worst case: O(N ^ 2 * log (N ^ 2))\n/**\n * @param {number[][]} edges\n * @param {number} M\n * @param {number} N\n * @return {number}\n */\nconst reachableNodes = function(edges, M, N) {\n  const graph = {}\n  for(const [u,v,c] of edges) {\n    if(graph[u] == null) graph[u] = {}\n    if(graph[v] == null) graph[v] = {}\n    graph[u][v] = c\n    graph[v][u] = c\n  }\n  const pq = new PriorityQueue((a, b) => a[0] > b[0])\n  pq.push([M, 0])\n  const visited = {}\n  while(!pq.isEmpty()) {\n    const [moves, i] = pq.pop()\n    if(visited[i] == null) {\n      visited[i] = moves\n      for(const k of Object.keys(graph[i] || {})) {\n        const remain = moves - graph[i][k] - 1\n        if(visited[k] == null && remain >= 0) {\n          pq.push([remain, k])\n        }\n      }\n    }\n  }\n  let res = 0\n  res += Object.keys(visited).length\n  for(const [u, v, c] of edges) {\n    const a = visited[u] || 0, b = visited[v] || 0\n    res += Math.min(a + b, c)\n  }\n\n  return res\n};\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n"
    }
  },
  {
    "name": "883-projection-area-of-3d-shapes",
    "code": {
      "JS": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nconst projectionArea = function(grid) {\n  let xy = 0, xz = 0, yz = 0\n  const m = grid.length, n = grid[0].length\n  for (let i = 0; i < m; i++) {\n    for(let j = 0; j < n; j++) {\n      if(grid[i][j]) xy++\n    }\n  }\n  \n  for (let i = 0; i < m; i++) {\n    let tmp = 0\n    for(let j = 0; j < n; j++) {\n      tmp = Math.max(tmp, grid[i][j])\n    }\n    xz += tmp\n  }\n  for (let j = 0; j < n; j++) {\n    let tmp = 0\n    for(let i = 0; i < m; i++) {\n      tmp = Math.max(tmp, grid[i][j])  \n    }\n    yz += tmp\n  }\n  \n  return xy + yz + xz\n};\n"
    }
  },
  {
    "name": "884-uncommon-words-from-two-sentences",
    "code": {
      "JS": "/**\n * @param {string} s1\n * @param {string} s2\n * @return {string[]}\n */\nconst uncommonFromSentences = function(s1, s2) {\n  const hash = {}\n  const a1 = s1.split(' '), a2 = s2.split(' ')\n  for(let e of a1) {\n    if(hash[e] == null) hash[e] = 0\n    hash[e]++\n  }\n  const res = []\n  for(let e of a2) {\n    if(hash[e] == null) hash[e] = 0\n    hash[e]++\n  }\n  Object.keys(hash).forEach(k => {\n    if(hash[k] === 1) res.push(k)\n  })\n  \n  return res\n};\n"
    }
  },
  {
    "name": "886-possible-bipartition",
    "code": {
      "JS": "/**\n * @param {number} N\n * @param {number[][]} dislikes\n * @return {boolean}\n */\nconst possibleBipartition = function (N, dislikes) {\n  const graph = []\n  for (let i = 0; i <= N; i++) {\n    graph[i] = []\n  }\n  for (let el of dislikes) {\n    graph[el[0]].push(el[1])\n    graph[el[1]].push(el[0])\n  }\n  const color = new Array(N + 1).fill(0)\n  for (let i = 1; i <= N; i++) {\n    if (color[i] == 0) {\n      color[i] = 1\n      const q = []\n      q.push(i)\n      while (q.length > 0) {\n        let cur = q.shift()\n        for (let j of graph[cur]) {\n          if (color[j] == 0) {\n            color[j] = color[cur] == 1 ? 2 : 1\n            q.push(j)\n          } else {\n            if (color[j] == color[cur]) return false\n          }\n        }\n      }\n    }\n  }\n  return true\n}\n\n// another\n\n/**\n * @param {number} N\n * @param {number[][]} dislikes\n * @return {boolean}\n */\nconst possibleBipartition = function (N, dislikes) {\n  const graph = new Array(N + 1)\n  for (const [a, b] of dislikes) {\n    if (!graph[a]) graph[a] = []\n    graph[a].push(b)\n    if (!graph[b]) graph[b] = []\n    graph[b].push(a)\n  }\n\n  const colors = new Array(N + 1)\n  const dfs = (node, color = 0) => {\n    colors[node] = color\n    const nextColor = color ^ 1\n    const children = graph[node] || []\n    for (const child of children) {\n      if (colors[child] !== undefined) {\n        if (colors[child] !== nextColor) return false\n      } else {\n        if (!dfs(child, nextColor)) return false\n      }\n    }\n    return true\n  }\n  for (let i = 1; i <= N; i++) {\n    if (colors[i] === undefined && !dfs(i)) return false\n  }\n  return true\n}\n"
    }
  },
  {
    "name": "887-super-egg-drop",
    "code": {
      "JS": "/**\n * @param {number} K\n * @param {number} N\n * @return {number}\n */\n\nconst superEggDrop = function(K, N) {\n  let lo = 1,\n    hi = N,\n    mi\n  while (lo < hi) {\n    mi = ((lo + hi) / 2) >> 0\n    if (f(mi, K, N) < N) lo = mi + 1\n    else hi = mi\n  }\n  return lo\n}\n\nfunction f(x, K, N) {\n  let ans = 0,\n    r = 1,\n    i = 1\n  for (let i = 1; i <= K; ++i) {\n    r = ((r * (x - i + 1)) / i) >> 0\n    ans += r\n    if (ans >= N) break\n  }\n  return ans\n}\n\n// another\n\nconst superEggDrop = function(K, N) {\n  const dp = Array.from({ length: K + 1 }, () => new Array(N + 1).fill(0))\n  return helper(K, N, dp)\n}\nfunction helper(K, N, memo) {\n  if (N <= 1) {\n    return N\n  }\n  if (K === 1) {\n    return N\n  }\n  if (memo[K][N] > 0) {\n    return memo[K][N]\n  }\n\n  let low = 1,\n    high = N,\n    result = N\n  while (low < high) {\n    let mid = Math.floor(low + (high - low) / 2)\n    let left = helper(K - 1, mid - 1, memo)\n    let right = helper(K, N - mid, memo)\n    result = Math.min(result, Math.max(left, right) + 1)\n    if (left === right) {\n      break\n    } else if (left < right) {\n      low = mid + 1\n    } else {\n      high = mid\n    }\n  }\n  memo[K][N] = result\n  return result\n}\n"
    }
  },
  {
    "name": "888-fair-candy-swap",
    "code": {
      "JS": "/**\n * @param {number[]} aliceSizes\n * @param {number[]} bobSizes\n * @return {number[]}\n */\nconst fairCandySwap = function(aliceSizes, bobSizes) {\n  let sum = 0\n  for(let e of aliceSizes) sum += e\n  for(let e of bobSizes) sum -= e\n  // sum > 0, alice > bob\n  // sum < 0, alice < bob\n  sum /= 2\n  const set = new Set()\n  for(let e of aliceSizes) set.add(e)\n  for(let e of bobSizes) {\n    if(set.has(e + sum)) return [e + sum, e]\n  }\n  return [0]\n};\n"
    }
  },
  {
    "name": "889-construct-binary-tree-from-preorder-and-postorder-traversal",
    "code": {
      "JS": "/**\n\nReturn any binary tree that matches the given preorder and postorder traversals.\nValues in the traversals pre and post are distinct positive integers.\n\nExample 1:\n\nInput: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]\nOutput: [1,2,3,4,5,6,7]\n \nNote:\n\n1 <= pre.length == post.length <= 30\npre[] and post[] are both permutations of 1, 2, ..., pre.length.\nIt is guaranteed an answer exists.\nIf there exists multiple answers, you can return any of them.\n\n*/\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {number[]} pre\n * @param {number[]} post\n * @return {TreeNode}\n */\nconst constructFromPrePost = function(pre, post) {\n  let i = 0,\n    j = 0\n  return (function dfs() {\n    let val = pre[i++]\n    let node = new TreeNode(val)\n    if (val !== post[j]) node.left = dfs()\n    if (val !== post[j]) node.right = dfs()\n    j++\n    return node\n  })()\n}\n"
    }
  },
  {
    "name": "89-gray-code",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number[]}\n */\nconst grayCode = function(n) {\n  if (n === 0) {\n    return [0]\n  }\n  const temp = grayCode(n - 1)\n  const nums = [].concat(temp)\n  const addNum = 1 << (n - 1)\n  for (let i = temp.length - 1; i >= 0; i--) {\n    nums.push(addNum + temp[i])\n  }\n  return nums\n}\n\n// another\n\n/**\n * @param {number} n\n * @return {number[]}\n */\nconst grayCode = function(n) {\n  const arr = []\n  arr.push(0)\n  for (let i = 0; i < n; i++) {\n    let inc = 1 << i\n    for (let j = arr.length - 1; j >= 0; j--) {\n      arr.push(arr[j] + inc)\n    }\n  }\n  return arr\n}\n\n// another\n\n/**\n * @param {number} n\n * @return {number[]}\n */\nconst grayCode = function(n) {\n  return n\n    ? (x => [...x, ...x.map((v, i) => x[x.length - 1 - i] + x.length)])(\n        grayCode(n - 1)\n      )\n    : [0]\n}\n"
    }
  },
  {
    "name": "890-find-and-replace-pattern",
    "code": {
      "JS": "/**\n * @param {string[]} words\n * @param {string} pattern\n * @return {string[]}\n */\nconst findAndReplacePattern = (words, pattern) => {\n  return words.reduce((acc, item, index) => {\n    if (compose(words[index], pattern)) acc.push(words[index]);\n    return acc;\n  }, []);\n\n  function compose(element, pattern) {\n    const s = new Set();\n    const m = new Map();\n    for (let i = 0; i < element.length; i++) {\n      const e = element[i];\n      const p = pattern[i];\n      s.add(e);\n      if (m.get(p) === undefined) {\n        m.set(p, e);\n      } else if (m.get(p) !== e) {\n        return false;\n      }\n    }\n    return m.size === s.size;\n  }\n};\n\n// anoother\n\n/**\n * @param {string[]} words\n * @param {string} pattern\n * @return {string[]}\n */\nconst findAndReplacePattern = function(words, pattern) {\n  const p = helper(pattern);\n  const res = [];\n  for (let w of words) {\n    if (arrEqual(helper(w), p)) res.push(w);\n  }\n  return res;\n};\n\nfunction arrEqual(a, b) {\n  if (a.length !== b.length) return false;\n  for (let i = 0, len = a.length; i < len; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n\nfunction helper(w) {\n  const m = new Map();\n  const n = w.length;\n  const res = new Array(n).fill(0);\n  for (let i = 0; i < n; i++) {\n    if (!m.has(w[i])) m.set(w[i], m.size);\n    res[i] = m.get(w[i]);\n  }\n  return res;\n}\n"
    }
  },
  {
    "name": "891-sum-of-subsequence-widths",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @return {number}\n */\nconst sumSubseqWidths = function(A) {\n  A.sort((a, b) => a - b)\n  let c = 1, res = 0, mod = 10 ** 9 + 7\n  for (let i = 0, n = A.length; i < n; i++, c = c * 2 % mod) {\n    res = (res + A[i] * c - A[n - i - 1] * c) % mod;\n  }\n  return (res + mod) % mod;\n};\n"
    }
  },
  {
    "name": "892-surface-area-of-3d-shapes",
    "code": {
      "JS": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nconst surfaceArea = function(grid) {\n  if(grid == null || grid.length === 0) return 0\n  const m = grid.length, n = grid[0].length\n  let res = 0, adj = 0\n  for(let i = 0; i < m; i++) {\n    for(let j = 0; j < n; j++) {\n      const h = grid[i][j]\n      if(h) res += h * 4 + 2\n      if(j > 0) {\n        if(grid[i][j - 1]) adj += Math.min(h, grid[i][j - 1])\n      }\n      if(i > 0) {\n        if(grid[i - 1][j]) adj += Math.min(h, grid[i - 1][j])\n      }\n      // console.log(adj)\n    }\n  }\n  \n  return res - adj * 2\n};\n\n// 2 * 4 + 2\n// 6 + 10 + 14 + 18 - (1 + 2 + 3 + 1) * 2\n"
    }
  },
  {
    "name": "893-groups-of-special-equivalent-strings",
    "code": {
      "JS": "/**\n * @param {string[]} A\n * @return {number}\n */\nconst numSpecialEquivGroups = function(A) {\n  return new Set(\n    A.map(word =>\n      [...word]\n        .reduce((counter, c, i) => {\n          counter[c.charCodeAt(0) - \"a\".charCodeAt(0) + 26 * (i % 2)]++;\n          return counter;\n        }, new Array(52).fill(0))\n        .join(\"-\")\n    )\n  ).size;\n};\n\n// another\n\n/**\n * @param {string[]} A\n * @return {number}\n */\nconst numSpecialEquivGroups = function(A) {\n  const result = new Set();\n  for (let i of A) {\n    let arr = i.split(\"\");\n    let res = [[], []];\n    for (let j = 0; j < arr.length; j++) {\n      res[j & 1].push(arr[j]);\n    }\n    result.add(res[0].sort().join(\"\") + res[1].sort().join(\"\"));\n  }\n  return result.size;\n};\n"
    }
  },
  {
    "name": "894-all-possible-full-binary-trees",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {number} N\n * @return {TreeNode[]}\n */\nconst allPossibleFBT = function(N) {\n  if (N <= 0) return []\n  const dp = Array.from({ length: N + 1 }, () => [])\n  dp[1].push(new TreeNode(0))\n\n  for (let numNode = 1; numNode <= N; numNode += 2) {\n    for (let leftNode = 1; leftNode < numNode; leftNode += 2) {\n      for (let left of dp[leftNode]) {\n        for (let right of dp[numNode - 1 - leftNode]) {\n          let root = new TreeNode(0)\n          root.left = left\n          root.right = right\n          dp[numNode].push(root)\n        }\n      }\n    }\n  }\n  return dp[N]\n};\n"
    }
  },
  {
    "name": "895-maximum-frequency-stack",
    "code": {
      "JS": "\nconst FreqStack = function() {\n  this.stack = Array.from({length: 10001}, () => [])\n  this.maxf = 0\n  this.freq = {}\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nFreqStack.prototype.push = function(x) {\n  if(!this.freq[x]) this.freq[x] = 0\n  this.freq[x]++\n  if(this.freq[x] > this.maxf) this.maxf = this.freq[x]\n  this.stack[this.freq[x]].push(x)\n};\n\n/**\n * @return {number}\n */\nFreqStack.prototype.pop = function() {\n  let res = this.stack[this.maxf].pop()\n  if(this.stack[this.maxf].length === 0) this.maxf--\n  this.freq[res]--\n  return res\n};\n\n/** \n * Your FreqStack object will be instantiated and called as such:\n * var obj = Object.create(FreqStack).createNew()\n * obj.push(x)\n * var param_2 = obj.pop()\n */\n"
    }
  },
  {
    "name": "896-monotonic-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nconst isMonotonic = function(nums) {\n  return inc(nums) || dec(nums)\n};\n\nfunction inc(nums) {\n  if(nums == null || nums.length <= 1) return true\n  for(let i = 1, n = nums.length; i < n; i++) {\n    if(nums[i] < nums[i - 1]) return false\n  }\n  return true \n}\nfunction dec(nums) {\n  if(nums == null || nums.length <= 1) return true\n  for(let i = 1, n = nums.length; i < n; i++) {\n    if(nums[i] > nums[i - 1]) return false\n  }\n  return true \n}\n\n// another\n\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\nconst isMonotonic = function(nums) {\n  let inc = true, dec =  true\n  for(let i = 1, n = nums.length; i < n; i++) {\n    inc &= nums[i] >= nums[i - 1]\n    dec &= nums[i] <= nums[i - 1]\n  }\n  return inc ||  dec\n};\n"
    }
  },
  {
    "name": "897-increasing-order-search-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nconst increasingBST = function(root) {\n  return helper(root, null)\n};\n\nfunction helper(node, tail) {\n  if(node == null) return tail\n  const res = helper(node.left, node)\n  node.left = null\n  node.right = helper(node.right, tail)\n  return res\n}\n"
    }
  },
  {
    "name": "898-bitwise-ors-of-subarrays",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @return {number}\n */\nconst subarrayBitwiseORs = function(A) {\n    let cur = new Set()\n    const ans = new Set()\n  \n    for (let i = 0; i < A.length; i++) {\n      const item = A[i]\n      const x = new Set()\n      for (let e of cur.values()) {\n        x.add(e | item)\n      }\n      x.add(item)\n      cur = x\n      for (let sub of cur.values()) {\n        ans.add(sub)\n      }\n    }\n    return ans.size\n};\n"
    }
  },
  {
    "name": "899-orderly-queue",
    "code": {
      "JS": "/**\n * @param {string} S\n * @param {number} K\n * @return {string}\n */\nconst orderlyQueue = function (S, K) {\n  if (K === 0) return S\n  else if (K > 1) return S.split('').sort().join('')\n  let result = 0,\n    L = S.length\n  for (let i = 1; i < L; i++) {\n    for (let j = 0; j < L; j++) {\n      let d = S.charCodeAt((result + j) % L) - S.charCodeAt((i + j) % L)\n      if (d !== 0) {\n        if (d > 0) result = i\n        break\n      }\n    }\n  }\n  return S.slice(result) + S.slice(0, result)\n}\n"
    }
  },
  {
    "name": "9-palindrome-number",
    "code": {
      "JS": "/**\r\n * @param {number} x\r\n * @return {boolean}\r\n */\r\nconst isPalindrome = function(x) {\r\n  if (x < 0) return false;\r\n  const rev = reverseNum(x);\r\n  return x === rev;\r\n};\r\n\r\nfunction reverseNum(num) {\r\n  let n = num;\r\n  let rev = 0;\r\n  let dig;\r\n  while (num > 0) {\r\n    dig = num % 10;\r\n    rev = rev * 10 + dig;\r\n    num = Math.floor(num / 10);\r\n  }\r\n  return rev;\r\n}\r\n"
    }
  },
  {
    "name": "90-subsets-II",
    "code": {
      "JS": "/**\r\n * @param {number[]} nums\r\n * @return {number[][]}\r\n */\r\nconst subsetsWithDup = function(nums) {\r\n  nums.sort((a, b) => a - b);\r\n  const res = [];\r\n  bt(res, nums, [], 0);\r\n  return res;\r\n};\r\n\r\nfunction bt(res, nums, arr, start) {\r\n  res.push(arr.slice(0));\r\n  for (let i = start; i < nums.length; i++) {\r\n    if (i === start || nums[i] !== nums[i - 1]) {\r\n      arr.push(nums[i]);\r\n      bt(res, nums, arr, i + 1);\r\n      arr.pop();\r\n    }\r\n  }\r\n}\r\n"
    }
  },
  {
    "name": "901-online-stock-span",
    "code": {
      "JS": "const StockSpanner = function() {\n  this.values = []\n}\n\n/**\n * @param {number} price\n * @return {number}\n */\nStockSpanner.prototype.next = function(price) {\n  let count = 1\n  while (\n    this.values.length > 0 &&\n    this.values[this.values.length - 1][0] <= price\n  ) {\n    count += this.values.pop()[1]\n  }\n  this.values.push([price, count])\n  return count\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * var obj = new StockSpanner()\n * var param_1 = obj.next(price)\n */\n"
    }
  },
  {
    "name": "902-numbers-at-most-n-given-digit-set",
    "code": {
      "JS": "/**\n * @param {string[]} D\n * @param {number} N\n * @return {number}\n */\nconst atMostNGivenDigitSet = function (D, N) {\n  const NS = '' + N\n  const digit = NS.length,\n    dsize = D.length\n  let rtn = 0\n  for (let i = 1; i < digit; ++i) rtn += Math.pow(dsize, i)\n  for (let i = 0; i < digit; ++i) {\n    let hasSameNum = false\n    for (let d of D) {\n      if (d < NS[i]) rtn += Math.pow(dsize, digit - i - 1)\n      else if (d == NS[i]) hasSameNum = true\n    }\n    if (!hasSameNum) return rtn\n  }\n  return rtn + 1\n}\n"
    }
  },
  {
    "name": "903-valid-permutations-for-di-sequence",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst numPermsDISequence = function(s) {\n  const n = s.length, mod = 1e9 + 7\n  const dp = Array.from({ length: n + 1}, () => Array(n + 1).fill(0))\n  dp[0][0] = 1\n  for(let i = 1; i <= n; i++) {\n    for(let j = 0; j <= i; j++) {\n      if(s[i - 1] === 'D') {\n        for(let k = j; k <= i - 1; k++) {\n          dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod\n        }\n      } else {\n        for(let k = 0; k < j; k++) {\n          dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod\n        }\n      }\n    }\n  }\n  let res = 0\n  for(let i = 0; i <= n; i++) {\n    res = (res + dp[n][i]) % mod\n  }\n  \n  return res\n};\n\n// another\n\n/**\n * @param {string} S\n * @return {number}\n */\nconst numPermsDISequence = function(S) {\n  let n = S.length,\n    mod = 10 ** 9 + 7\n  const dp = Array.from({ length: n + 1 }, () => new Array(n + 1).fill(0))\n  for (let j = 0; j <= n; j++) dp[0][j] = 1\n  for (let i = 0; i < n; i++)\n    if (S.charAt(i) === 'I')\n      for (let j = 0, cur = 0; j < n - i; j++)\n        dp[i + 1][j] = cur = (cur + dp[i][j]) % mod\n    else\n      for (let j = n - i - 1, cur = 0; j >= 0; j--)\n        dp[i + 1][j] = cur = (cur + dp[i][j + 1]) % mod\n  return dp[n][0]\n}\n"
    }
  },
  {
    "name": "905-sort-array-by-parity",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @return {number[]}\n */\nconst sortArrayByParity = function(A) {\n    for(let i = 0, len = A.length; i < len;) {\n      if(A[i] % 2 !== 0) {\n        A.push(A[i])\n        A.splice(i, 1)\n        len--\n      } else {\n        i++\n      }\n    }\n    return A\n}; \n"
    }
  },
  {
    "name": "906-super-palindromes",
    "code": {
      "JS": "/**\n * @param {string} L\n * @param {string} R\n * @return {number}\n */\nconst superpalindromesInRange = function (L, R) {\n  // My idea was to take the root of L and R and then generate all palindromes between those numbers,\n  // and then put those palindromes to power 2 and check if those are palindrome as well.\n\n  // The generation of palindromes is done like this:\n  // Lets say i want all palindromes of length 4, then i take all numbers of length 2.\n  // I reverse the length 2 numbers and concatenate them with themselves.\n  // So \"19\" becomes \"19\" + \"91\". For odd length I do the same,\n  //\tbut put a for loop around them that puts nrs 0 - 9 inside them.\n  // So \"19\" + \"0\" + \"91\", then \"19\" + \"1\" + \"91\", etc.\n\n  // Next I loop through the generated palindromes and just check whether they are\n  // inside sqrt(L) and sqrt(R). (sqrt(L) < palin < sqrt(R))\n  // For every palin within sqrt(L) and sqrt(R), i put the palin to power 2\n  // (with BigInt!) and then check if that is a palindrome. If so, then count++;\n\n  const sqL = Math.sqrt(L)\n  const sqR = Math.sqrt(R)\n  const sqR_Length = parseInt(sqR).toString(10).length\n  // counting the valid super-palindromes\n  let palins = 0\n  // L is a superpalindrome\n  if (\n    isPalindrome(L) &&\n    sqL === parseInt(sqL) &&\n    isPalindrome(sqL.toString(10))\n  )\n    palins++\n  // R is a superpalindrome\n  if (\n    isPalindrome(R) &&\n    sqR === parseInt(sqR) &&\n    isPalindrome(sqR.toString(10))\n  )\n    palins++\n\n  let end\n  if (sqR === parseInt(sqR)) {\n    // or else the loop will possibly add R as well\n    end = parseInt(sqR) - 1\n  } else {\n    end = parseInt(Math.floor(sqR))\n  }\n\n  let begin\n  if (sqL === parseInt(sqL)) {\n    // or else the loop will possibly add R as well\n    begin = parseInt(sqL) + 1\n  } else {\n    begin = parseInt(Math.ceil(sqL))\n  }\n\n  // account for superpalins with for single digit 'sub-palins'\n  if (begin <= 1 && end >= 1) palins++ // 1\n  if (begin <= 2 && end >= 2) palins++ // 4\n  if (begin <= 3 && end >= 3) palins++ // 9\n  const length = sqR_Length\n  const even = length % 2 === 0\n  const half = Math.floor(length / 2)\n  const pow10Half = Math.pow(10, half) // 10 or 100 or 1000, etc\n  const pow10HalfMinOne = Math.pow(10, half - 1)\n  let pal = '' // init\n  let palinStr = '' // init\n  let palin = -1 // init\n  for (let i = 1, leni = pow10Half; i < leni; i++) {\n    pal = i.toString(10)\n    pal.padStart(half - pal.length, '0')\n    palReverse = reverseStr(pal)\n    // generate even length palindrome\n    palinStr = pal + palReverse\n    palin = parseInt(palinStr)\n    if (palin >= begin && palin <= end) {\n      if (isPalindromeInt(BigInt(palin) * BigInt(palin))) {\n        palins++\n      }\n    }\n    // If I generate all palindromes up until some even length,\n    // lets say 4, then last step is to do length 2 + length 2 (19 + 91),\n    // and not the 19 + 0 + 91 step that generates odd length palindromes.\n    if (even && i >= pow10HalfMinOne) {\n      continue\n    }\n    for (let j = 0, lenj = 10; j < lenj; j++) {\n      // generate odd length palindrome\n      palinStr = pal + j + palReverse\n      palin = parseInt(palinStr)\n      if (palin >= begin && palin <= end) {\n        if (isPalindromeInt(BigInt(palin) * BigInt(palin))) {\n          palins++\n        }\n      }\n    }\n  }\n  return palins\n}\n\nconst reverseStr = function (str) {\n  return str.split('').reverse().join('')\n}\n\nconst isPalindromeInt = function (nr) {\n  nr = nr.toString(10)\n  return nr === nr.split('').reverse().join('')\n}\nconst isPalindrome = function (nr) {\n  return nr === nr.split('').reverse().join('')\n}\n\n// another\n\n/**\n * @param {string} left\n * @param {string} right\n * @return {number}\n */\n const superpalindromesInRange = function(left, right) {\n  const palindromes = []\n  let res = 0\n  for(let i = 1; i < 10; i++) {\n    palindromes.push(`${i}`)\n  }\n  for(let i = 1; i < 1e4; i++) {\n    let l = `${i}`, r = l.split('').reverse().join('')\n    palindromes.push(`${l}${r}`)\n    for(let j = 0; j < 10; j++) {\n      palindromes.push(`${l}${j}${r}`)\n    }\n  }\n\n  for(let p of palindromes) {\n    const square = BigInt(p) * BigInt(p)\n    if(!isPalindrome(`${square}`)) continue\n    if(BigInt(left) <= square && square <= BigInt(right)) res++ \n  }\n\n  return res\n\n  function isPalindrome(str) {\n    let i = 0;\n    let j = str.length - 1;\n    while (i < j) {\n      if (str.charAt(i) !== str.charAt(j)) {\n        return false;\n      }\n      i++;\n      j--;\n    }\n    return true;\n  }\n};\n\n// another\n\n/**\n * @param {string} left\n * @param {string} right\n * @return {number}\n */\nconst superpalindromesInRange = function (left, right) {\n  let ans = 9 >= left && 9 <= right ? 1 : 0\n\n  const isPal = (str) => {\n    for (let i = 0, j = str.length - 1; i < j; i++, j--)\n      if (str.charAt(i) !== str.charAt(j)) return false\n    return true\n  }\n\n  for (let dig = 1; dig < 10; dig++) {\n    let isOdd = dig % 2 && dig !== 1,\n      innerLen = (dig >> 1) - 1,\n      innerLim = Math.max(1, 2 ** innerLen),\n      midPos = dig >> 1,\n      midLim = isOdd ? 3 : 1\n    for (let edge = 1; edge < 3; edge++) {\n      let pal = new Uint8Array(dig)\n      ;(pal[0] = edge), (pal[dig - 1] = edge)\n      if (edge === 2) (innerLim = 1), (midLim = Math.min(midLim, 2))\n      for (let inner = 0; inner < innerLim; inner++) {\n        if (inner > 0) {\n          let innerStr = inner.toString(2).padStart(innerLen, '0')\n          for (let i = 0; i < innerLen; i++)\n            (pal[1 + i] = innerStr[i]), (pal[dig - 2 - i] = innerStr[i])\n        }\n        for (let mid = 0; mid < midLim; mid++) {\n          if (isOdd) pal[midPos] = mid\n          let palin = ~~pal.join(''),\n            square = BigInt(palin) * BigInt(palin)\n          if (square > right) return ans\n          if (square >= left && isPal(square.toString())) ans++\n        }\n      }\n    }\n  }\n  return ans\n}\n"
    }
  },
  {
    "name": "907-sum-of-subarray-minimums",
    "code": {
      "JS": "/**\n * @param {number[]} arr\n * @return {number}\n */\nconst sumSubarrayMins = function (arr) {\n  const n = arr.length,\n    s1 = [],\n    s2 = [],\n    left = Array(n),\n    right = Array(n)\n  for (let i = 0; i < n; i++) {\n    let cnt = 1\n    while (s1.length && s1[s1.length - 1][0] > arr[i]) {\n      cnt += s1.pop()[1]\n    }\n    left[i] = cnt\n    s1.push([arr[i], cnt])\n  }\n\n  for (let i = n - 1; i >= 0; i--) {\n    let cnt = 1\n    while (s2.length && s2[s2.length - 1][0] >= arr[i]) {\n      cnt += s2.pop()[1]\n    }\n    right[i] = cnt\n    s2.push([arr[i], cnt])\n  }\n  let res = 0\n  const mod = 1e9 + 7\n  for (let i = 0; i < n; i++) {\n    // left[i] number of starting positions\n    // right[i] number of ending positions\n    res = (res + arr[i] * left[i] * right[i]) % mod\n  }\n\n  return res\n}\n"
    }
  },
  {
    "name": "908-smallest-range-i",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nconst smallestRangeI = function(nums, k) {\n  let min = Infinity, max = -Infinity\n  for(let e of nums) {\n    min = Math.min(min, e)\n    max = Math.max(max, e)\n  }\n  return max - k >= min + k ? max - k - (min + k) : 0\n};\n"
    }
  },
  {
    "name": "91-decode-ways",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst numDecodings = function(s) {\n  if(s == null || s.length === 0) return 1\n  if(s[0] === '0') return 0\n  const set = new Set()\n  const n = s.length\n  for(let i = 1; i <= 26; i++) {\n    set.add(`${i}`)\n  }\n  const dp = Array(n + 1).fill(0)\n  dp[0] = dp[1] = 1\n  for(let i = 2; i <= n; i++) {\n    if(set.has(s[i - 2] + s[i - 1])) dp[i] += dp[i - 2]\n    if(set.has(s[i - 1])) dp[i] += dp[i - 1]\n  }\n  return dp[n]\n};\n\n\n// another\n\n/**\n * @param {string} s\n * @return {number}\n */\nconst numDecodings = function(s) {\n  if (s.length === 0) return 0\n  const N = s.length\n  const dp = Array(N + 1).fill(0)\n  dp[0] = 1\n  dp[1] = s[0] === \"0\" ? 0 : 1\n  for (let i = 2; i <= N; i++) {\n    if (s[i - 1] !== \"0\") {\n      dp[i] += dp[i - 1]\n    }\n    if (s[i - 2] === \"1\" || (s[i - 2] === \"2\" && s[i - 1] <= \"6\")) {\n      dp[i] += dp[i - 2]\n    }\n  }\n  return dp[N]\n}\n"
    }
  },
  {
    "name": "912-sort-an-array",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nfunction swap(items, l, r) {\n  const temp = items[l];\n  items[l] = items[r];\n  items[r] = temp;\n}\nfunction partition(items, start, end) {\n  let pivot = items[end], s = start\n  for(let i = start; i < end; i++) {\n    if(items[i] <= pivot) {\n      swap(items, s, i)\n      s++\n    }\n  }\n  swap(items, s, end)\n  return s\n}\n\nfunction quickSort(items, left, right) {\n  if(left < right) {\n    const pIdx = partition(items, left, right)\n    quickSort(items, left, pIdx - 1)\n    quickSort(items, pIdx + 1, right)\n  }\n  return items;\n}\nconst sortArray = function(nums) {\n  return quickSort(nums, 0, nums.length - 1);\n};\n"
    }
  },
  {
    "name": "913-cat-and-mouse",
    "code": {
      "JS": "/**\n * @param {number[][]} graph\n * @return {number}\n */\nconst catMouseGame = function (g) {\n  const n = g.length\n  const win = Array(2)\n    .fill(0)\n    .map(() => Array(n * n).fill(0))\n  for (let i = 0; i < n; i++) {\n    win[0][i] = 1\n    win[1][i] = 1\n  }\n  for (let i = 1; i < n; i++) {\n    win[0][i * n + i] = 2\n    win[1][i * n + i] = 2\n  }\n\n  while (true) {\n    let anew = false\n    for (let m = 0; m < n; m++) {\n      inner: for (let c = 1; c < n; c++) {\n        if (win[0][m * n + c] == 0) {\n          let und = false\n          for (let e of g[m]) {\n            if (win[1][e * n + c] == 1) {\n              win[0][m * n + c] = 1\n              anew = true\n              continue inner\n            }\n            if (win[1][e * n + c] == 0) {\n              und = true\n            }\n          }\n          if (!und) {\n            win[0][m * n + c] = 2\n            anew = true\n          }\n        }\n      }\n    }\n    for (let c = 1; c < n; c++) {\n      inner: for (let m = 0; m < n; m++) {\n        if (win[1][m * n + c] == 0) {\n          let und = false\n          for (e of g[c]) {\n            if (e == 0) continue\n            if (win[0][m * n + e] == 2) {\n              win[1][m * n + c] = 2\n              anew = true\n              continue inner\n            }\n            if (win[0][m * n + e] == 0) {\n              und = true\n            }\n          }\n          if (!und) {\n            win[1][m * n + c] = 1\n            anew = true\n          }\n        }\n      }\n    }\n    if (!anew) break\n  }\n\n  return win[0][1 * n + 2]\n}\n"
    }
  },
  {
    "name": "914-x-of-a-kind-in-a-deck-of-cards",
    "code": {
      "JS": "/**\n * @param {number[]} deck\n * @return {boolean}\n */\nconst hasGroupsSizeX = function(deck) {\n  if(deck == null || deck.length <= 1) return false\n  const hash = {}\n  for(let e of deck) {\n    if(hash[e] == null) hash[e] = 0\n    hash[e]++\n  }\n  let res = 0\n  for(let k in hash) res = gcd(hash[k], res)\n  return res > 1\n};\n\nfunction gcd(a, b) {\n  return b ? gcd(b, a % b) : a\n}\n"
    }
  },
  {
    "name": "915-partition-array-into-disjoint-intervals",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @return {number}\n */\nconst partitionDisjoint = function(A) {\n    let n = A.length;\n    let maxLeft = A[0];\n    let minRight = new Int32Array(n);\n    let min = Infinity;\n    for (let i = n - 1; i >= 1; i--) {\n        min = Math.min(min, A[i]);\n        minRight[i] = min;\n   }\n   \n   for(let i = 1; i < n; i++){\n       if (maxLeft <= minRight[i]){\n           return i;\n       }\n\n       maxLeft = Math.max(maxLeft, A[i]);               \n   }\n};\n"
    }
  },
  {
    "name": "916-word-subsets",
    "code": {
      "JS": "/**\r\n * @param {string[]} A\r\n * @param {string[]} B\r\n * @return {string[]}\r\n */\r\nconst wordSubsets = function(A, B) {\r\n  function counter(s) {\r\n    let count = Array(26).fill(0);\r\n    for (let i = 0; i < s.length; i++) count[s.charCodeAt(i) - 97]++;\r\n    return count;\r\n  }\r\n  let aux = Array(26).fill(0);\r\n  let result = [];\r\n  for (let i = 0; i < B.length; i++) {\r\n    let count = counter(B[i]);\r\n    for (let i = 0; i < 26; i++) {\r\n      aux[i] = Math.max(aux[i], count[i]);\r\n    }\r\n  }\r\n  for (let i = 0; i < A.length; i++) {\r\n    let count = counter(A[i]);\r\n    let flag = true;\r\n    for (let j = 0; j < 26; j++) {\r\n      if (aux[j] > 0 && count[j] - aux[j] < 0) {\r\n        flag = false;\r\n        break;\r\n      }\r\n    }\r\n    if (flag) result.push(A[i]);\r\n  }\r\n  return result;\r\n};\r\n"
    }
  },
  {
    "name": "917-reverse-only-letters",
    "code": {
      "JS": "/**\n * @param {string} S\n * @return {string}\n */\nconst reverseOnlyLetters = function(S) {\n  let start = 0\n  let end = S.length - 1\n  const arr = S.split(\"\")\n  while (start < end) {\n    while (start < end && !chk(S.charCodeAt(start))) {\n      start++\n    }\n    while (start < end && !chk(S.charCodeAt(end))) {\n      end--\n    }\n\n    let tmp = S[end]\n    arr[end] = S[start]\n    arr[start] = tmp\n    start++\n    end--\n  }\n  return arr.join(\"\")\n}\n\nfunction chk(num) {\n  const aCode = \"a\".charCodeAt(0)\n  const zCode = \"z\".charCodeAt(0)\n  const ACode = \"A\".charCodeAt(0)\n  const ZCode = \"Z\".charCodeAt(0)\n\n  if ((num >= aCode && num <= zCode) || (num >= ACode && num <= ZCode)) {\n    return true\n  } else {\n    return false\n  }\n}\n"
    }
  },
  {
    "name": "918-maximum-sum-circular-subarray",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @return {number}\n */\nconst maxSubarraySumCircular = function(A) {\n  let minSum = Infinity, sum = 0, maxSum = -Infinity, curMax = 0, curMin = 0\n  for(let a of A) {\n    sum += a\n    curMax = Math.max(curMax + a, a);\n    maxSum = Math.max(maxSum, curMax);\n    curMin = Math.min(curMin + a, a);\n    minSum = Math.min(minSum, curMin);\n  }\n  return  maxSum > 0 ? Math.max(maxSum, sum - minSum) : maxSum;\n};\n"
    }
  },
  {
    "name": "92-reverse-linked-list-ii",
    "code": {
      "JS": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} left\n * @param {number} right\n * @return {ListNode}\n */\nconst reverseBetween = function(head, left, right) {\n  if(head == null) return head\n  const dummy = new ListNode(null, head)\n  let num = 0, cur = head\n  while (cur) {\n    num++\n    cur = cur.next\n  }\n  let idx = 0, pre = null\n  cur = dummy\n  while (idx < right && idx <= num) {\n    if (idx === left - 1) pre = cur\n    if (idx >= left) {\n      const tmp = pre.next\n      pre.next = cur.next\n      cur.next = cur.next.next\n      pre.next.next = tmp\n    }\n\n    if (idx < left) cur = cur.next\n    idx++\n  }\n  return dummy.next\n};\n\n// another\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} m\n * @param {number} n\n * @return {ListNode}\n */\nconst reverseBetween = function(head, m, n) {\n    // Empty list\n    if (head == null) {\n        return null;\n    }\n\n    // Move the two pointers until they reach the proper starting point\n    // in the list.\n    let cur = head, prev = null;\n    while (m > 1) {\n        prev = cur;\n        cur = cur.next;\n        m--;\n        n--;\n    }\n\n    // The two pointers that will fix the final connections.\n    let con = prev, tail = cur;\n\n    // Iteratively reverse the nodes until n becomes 0.\n    let third = null;\n    while (n > 0) {\n        third = cur.next;\n        cur.next = prev;\n        prev = cur;\n        cur = third;\n        n--;\n    }\n\n    // Adjust the final connections as explained in the algorithm\n    if (con != null) {\n        con.next = prev;\n    } else {\n        head = prev;\n    }\n\n    tail.next = cur;\n    return head;\n};\n\n// another\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} m\n * @param {number} n\n * @return {ListNode}\n */\nconst reverseBetween = function(head, m, n) {\n    if (!head) return null;\n    const dummy = new ListNode(0);\n    dummy.next = head;\n    let pre = dummy;\n    for (let i = 0; i < m-1; i++) pre = pre.next\n    let start = pre.next;\n    let then = start.next;\n    \n    for (let i = 0; i < n-m; i++) {\n        start.next = then.next\n        then.next = pre.next\n        pre.next = then;\n        then = start.next;\n    }\n    return dummy.next;\n};\n\n// another\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} left\n * @param {number} right\n * @return {ListNode}\n */\nconst reverseBetween = function(head, left, right) {\n  if(head == null || left === right) return head\n  const dummy = new ListNode()\n  dummy.next = head\n  let tail = null, p = dummy\n  for(let i = 1; i < left; i++) {\n    p = p.next\n  } \n  tail = p.next\n  let tmp\n  for(let i = 0; i < right - left; i++) {\n    tmp = p.next\n    p.next = tail.next\n    tail.next = tail.next.next\n    p.next.next = tmp\n  }\n\n  return dummy.next\n};\n\n// another\n\n/**\n * @param {ListNode} head\n * @param {number} left\n * @param {number} right\n * @return {ListNode}\n */\nconst reverseBetween = function(head, left, right) {\n  if(head == null) return head\n  if(left === right) return head\n  let cur = head, prev = null\n  let step = 1\n  while(step !== left) {\n    prev = cur\n    cur = cur.next\n    step++\n  }\n  let l = cur\n  while(step !== right) {\n    cur = cur.next\n    step++\n  }\n  let r = cur, next = cur.next\n  // reverse\n  \n  let start = l, p = null\n  while(start !== r) {\n    let n = start.next\n    start.next = p\n    p = start\n    start = n\n  }\n\n  r.next = p\n  l.next = next\n  if(prev) prev.next = r\n\n  return prev ? head : r\n};\n\n// another\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} left\n * @param {number} right\n * @return {ListNode}\n */\nconst reverseBetween = function(head, left, right) {\n  if(head == null) return head\n  const dummy = new ListNode()\n  dummy.next = head\n\n  let p = dummy\n  for(let i = 0; i < left - 1; i++) {\n    p = p.next\n  }\n  let tail = p.next, tmp = null\n  for(let i = 0; i < right - left; i++) {\n    tmp = p.next\n    p.next = tail.next\n    tail.next = tail.next.next\n    p.next.next = tmp\n  }\n  \n  return dummy.next\n};\n"
    }
  },
  {
    "name": "920-number-of-music-playlists",
    "code": {
      "JS": "/**\n * @param {number} N\n * @param {number} L\n * @param {number} K\n * @return {number}\n */\nconst numMusicPlaylists = function (N, L, K) {\n  const mod = 10 ** 9 + 7\n  const dp = Array.from({ length: L + 1 }, () => Array(N + 1).fill(0))\n  dp[0][0] = 1\n  for (let i = 1; i <= L; i++) {\n    for (let j = 1; j <= N; j++) {\n      dp[i][j] = (dp[i - 1][j - 1] * (N - (j - 1))) % mod\n      if (j > K) {\n        dp[i][j] = (dp[i][j] + ((dp[i - 1][j] * (j - K)) % mod)) % mod\n      }\n    }\n  }\n  return dp[L][N]\n}\n"
    }
  },
  {
    "name": "921-minimum-add-to-make-parentheses-valid",
    "code": {
      "JS": "/**\n * @param {string} S\n * @return {number}\n */\nconst minAddToMakeValid = function(S) {\n  if(S === '' || S == null) return 0\n  const len = S.length\n  const h = {\n    o: 0,\n    c: 0\n  }\n  for(let i = 0; i < len; i++) {\n    if(S[i] === '(') {\n      h.o++\n    } else {\n      if(h.o > 0) {\n        h.o--\n      } else {\n        h.c++\n      }\n    }\n  }\n  \n  return h.o + h.c\n};\n"
    }
  },
  {
    "name": "922-sort-array-by-parity-ii",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @return {number[]}\n */\nconst sortArrayByParityII = function(A) {\n  const res = []\n  const odd = []\n  const even = []\n  for(let i = 0, len = A.length; i < len; i++) {\n    if(A[i] % 2 === 0) even.push(A[i])\n    else odd.push(A[i])\n  }\n  for(let i = 0, len = odd.length; i < len; i++) {\n    res.push(even[i], odd[i])\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "923-3sum-with-multiplicity",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @param {number} target\n * @return {number}\n */\nconst threeSumMulti = function(A, target) {\n  const d = {};\n  let res = 0;\n  const mod = Math.pow(10, 9) + 7;\n  for (let i = 0; i < A.length; i++) {\n    res += d[target - A[i]] >= 0 ? d[target - A[i]] : 0;\n    res %= mod;\n    for (let j = 0; j < i; j++) {\n      d[A[i] + A[j]] = (d[A[i] + A[j]] || 0) + 1;\n    }\n  }\n  return res % mod;\n};\n"
    }
  },
  {
    "name": "924-minimize-malware-spread",
    "code": {
      "JS": "/**\n * @param {number[][]} graph\n * @param {number[]} initial\n * @return {number}\n */\nconst minMalwareSpread = function (graph, initial) {\n  const l = graph.length\n  const p = []\n  const children = []\n  for (let i = 0; i < l; i++) {\n    p[i] = i\n    children[i] = [i]\n  }\n\n  for (let i = 0; i < l; i++) {\n    for (let j = i + 1; j < l; j++) {\n      if (graph[i][j] === 1) {\n        const pi = find(i)\n        const pj = find(j)\n        if (pi !== pj) {\n          union(pi, pj)\n        }\n      }\n    }\n  }\n\n  initial.sort((a, b) => (a > b ? 1 : -1))\n\n  const count = {}\n\n  let index = initial[0]\n  let max = 0\n  // find the index that not unioned with other indexes and with the most number of children\n  initial.forEach((e) => {\n    const pe = find(e)\n    if (!count[pe]) count[pe] = 0\n    count[pe] += 1\n  })\n  initial.forEach((e, i) => {\n    const pe = find(e)\n    if (count[pe] === 1 && children[pe].length > max) {\n      max = children[pe].length\n      index = e\n    }\n  })\n\n  return index\n\n  function find(x) {\n    while (p[x] !== x) {\n      p[x] = p[p[x]]\n      x = p[x]\n    }\n    return x\n  }\n\n  function union(pi, pj) {\n    p[pj] = pi\n    //also move the children to the new parent\n    children[pi] = children[pi].concat(children[pj])\n    children[pj] = []\n  }\n}\n"
    }
  },
  {
    "name": "925-long-pressed-name",
    "code": {
      "JS": "/**\n * @param {string} name\n * @param {string} typed\n * @return {boolean}\n */\nconst isLongPressedName = function(name, typed) {\n  let i = 0, m = name.length, n = typed.length\n  for(let j = 0; j < n; j++) {\n    if(i < m && name[i] === typed[j]) i++\n    else if(j === 0 || typed[j] !== typed[j - 1]) return false\n  }\n  return i === m\n};\n"
    }
  },
  {
    "name": "927-three-equal-parts",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @return {number[]}\n */\nconst threeEqualParts = function (A) {\n  let countNumberOfOnes = 0\n  for (let c of A) if (c === 1) countNumberOfOnes++\n  if (countNumberOfOnes === 0) return [0, A.length - 1]\n  if (countNumberOfOnes % 3 != 0) return [-1, -1]\n  const k = countNumberOfOnes / 3\n  let i\n  // find the first 1 in the array\n  for (i = 0; i < A.length; i++) if (A[i] == 1) break\n  let start = i\n  // find (k+1)th 1 in the array\n  let count1 = 0\n  for (i = 0; i < A.length; i++) {\n    if (A[i] == 1) count1++\n    if (count1 == k + 1) break\n  }\n  let mid = i\n  //find (2*k +1)th 1 in the array\n  count1 = 0\n  for (i = 0; i < A.length; i++) {\n    if (A[i] === 1) count1++\n    if (count1 === 2 * k + 1) break\n  }\n  let end = i\n  // Match all values till the end of the array\n  while (end < A.length && A[start] === A[mid] && A[mid] === A[end]) {\n    start++\n    mid++\n    end++\n  }\n  // Return appropriate values if all the values have matched till the end\n  if (end == A.length) return [start - 1, mid]\n  // otherwise, no such indices found\n  return [-1, -1]\n}\n"
    }
  },
  {
    "name": "928-minimize-malware-spread-ii",
    "code": {
      "JS": "/**\n * @param {number[][]} graph\n * @param {number[]} initial\n * @return {number}\n */\nvar minMalwareSpread = function (graph, initial) {\n  const map = new Map() // node -> initial nodes infect this node\n  for (let i of initial) {\n    const visited = new Set(initial)\n    const q = []\n    q.push(i)\n    while (q.length) {\n      let cur = q.shift()\n      for (let j = 0; j < graph[cur].length; j++) {\n        if (graph[cur][j] == 1) {\n          if (!visited.has(j)) {\n            visited.add(j)\n            q.push(j)\n\n            if (map.get(j) == null) map.set(j, [])\n            map.get(j).push(i)\n          }\n        }\n      }\n    }\n  }\n\n  const res = Array(graph.length).fill(0) // node -> safe nodes it infects\n  for (let node of map.keys()) {\n    if (map.get(node).length == 1) {\n      let i = map.get(node)[0]\n      res[i]++\n    }\n  }\n  let max = 0\n  let removed = -1\n  for (let i = 0; i < res.length; i++) {\n    if (res[i] > max) {\n      max = res[i]\n      removed = i\n    }\n  }\n  initial.sort((a, b) => a - b)\n  return removed == -1 ? initial[0] : removed\n}\n\n// another\n\n/**\n * @param {number[][]} graph\n * @param {number[]} initial\n * @return {number}\n */\nconst minMalwareSpread = function (graph, initial) {\n  const map = new Map(), n = graph.length\n  for(let init of initial) {\n    const visited = new Set(initial)\n    const q = [init]\n    while(q.length) {\n      const cur = q.pop()\n      for(let i = 0; i < n; i++) {\n        if(graph[cur][i] === 1 && !visited.has(i)) {\n          visited.add(i)\n          q.push(i)\n          if(map.get(i) == null) map.set(i, [])\n          map.get(i).push(init)\n        }\n      }      \n    }\n  }\n  \n  let res = 0, max = -1\n  const arr = Array(n)\n  for(let [k,v] of map) {\n    if(v.length === 1) {\n      if(arr[v[0]] == null) arr[v[0]] = 0\n      arr[v[0]]++\n    }\n  }\n  \n  for(let k = 0; k < n; k++) {\n    const v = arr[k]\n    if(v > max) {\n      max = v\n      res = +k\n    }\n  }\n  \n  let min = Infinity\n  for(let e of initial) {\n    if(e < min) min = e\n  }\n  return max === -1 ? min: res\n  \n}\n\n"
    }
  },
  {
    "name": "929-unique-email-addresses",
    "code": {
      "JS": "/**\n * @param {string[]} emails\n * @return {number}\n */\nconst numUniqueEmails = function(emails) {\n  const res = new Set()\n  emails.forEach(el => helper(el, res))\n  return res.size\n};\n\nfunction helper(str, s) {\n  const arr = str.split('@')\n  const p = arr[0]\n  const d = arr[1]\n  let res = ''\n  for(let i = 0, len = p.length; i < len; i++) {\n    if(p[i] === '.') {\n      continue\n    } else if(p[i] === '+') {\n      break\n    } else {\n      res += p[i]\n    }\n  }\n  s.add(`${res}@${d}`)\n}\n"
    }
  },
  {
    "name": "93-restore-ip-addresses",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {string[]}\n */\nconst restoreIpAddresses = function(s) {\n  if (s.length < 4 || s.length > 12) return [];\n  const res = [];\n  let ans = \"\";\n  for (let a = 1; a <= 3; a++) {\n    for (let b = 1; b <= 3; b++) {\n      for (let c = 1; c <= 3; c++) {\n        for (let d = 1; d <= 3; d++) {\n          if (a + b + c + d === s.length) {\n            let A = +s.substr(0, a);\n            let B = +s.substr(a, b);\n            let C = +s.substr(a + b, c);\n            let D = +s.substr(a + b + c, d);\n            if (A <= 255 && B <= 255 && C <= 255 && D <= 255) {\n              if (\n                ((ans = A + \".\" + B + \".\" + C + \".\" + D).length === s.length + 3)\n              ) {\n                res.push(ans);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return res;\n};\n\n// another method\n\n/**\n * @param {string} s\n * @return {string[]}\n */\nconst restoreIpAddresses = function(s) {\n  const ans = [];\n  const stack = [];\n  let ipstr;\n  const len = s.length;\n  function restoreIp(start) {\n    if (stack.length > 4) return;\n    if (stack.length === 4 && start > len - 1) {\n      ans.push(stack.slice().join(\".\"));\n      return;\n    }\n    for (let i = start; i < start + 3; i++) {\n      if (i > len - 1) return;\n      ipstr = s.substring(start, i + 1);\n      if ((ipstr[0] === \"0\" && ipstr.length !== 1) || ipstr > 255) return;\n      stack.push(ipstr);\n      restoreIp(i + 1);\n      stack.pop();\n    }\n  }\n  restoreIp(0);\n  return ans;\n};\n"
    }
  },
  {
    "name": "930-binary-subarrays-with-sum",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @param {number} S\n * @return {number}\n */\nconst numSubarraysWithSum = function(A, S) {\n    if(A === null || A.length == 0) return 0;\n    const freq = new Array(A.length + 1).fill(0)\n    let ans = 0;\n    let sum = 0;\n    for(let i = 0; i < A.length; i++) {\n        sum += A[i];\n        let index = sum - S;\n        if(index >= 0) ans += freq[index];\n        if(sum == S) ans++;\n        freq[sum]++;\n    }\n    return ans;\n};\n"
    }
  },
  {
    "name": "931-minimum-falling-path-sum",
    "code": {
      "JS": "/**\n * @param {number[][]} A\n * @return {number}\n */\nconst minFallingPathSum = function(A) {\n  for (let i = 1, rows = A.length; i < rows; i++) {\n    for (let j = 0, cols = A[0].length; j < cols; j++) {\n      A[i][j] += Math.min(\n        getValueOrMax(A, i - 1, j - 1),\n        getValueOrMax(A, i - 1, j),\n        getValueOrMax(A, i - 1, j + 1)\n      );\n    }\n  }\n  return Math.min(...A[A.length - 1]);\n};\n\nfunction getValueOrMax(A, i, j) {\n  return A[i][j] !== undefined ? A[i][j] : Number.MAX_VALUE;\n}\n\n// another\n\n/**\n * @param {number[][]} A\n * @return {number}\n */\nconst minFallingPathSum = function(A) {\n    for (let i = A.length - 2; i >= 0; i -= 1) {\n      for (let j = 0; j < A[i].length; j += 1) {\n        A[i][j] += Math.min(\n          getValueOrMax(A, i + 1, j - 1),\n          getValueOrMax(A, i + 1, j),\n          getValueOrMax(A, i + 1, j + 1)\n        )\n      }\n    }\n    return Math.min(...A[0])\n  }\n  \n  function getValueOrMax(A, i, j) {\n    return A[i][j] !== undefined ? A[i][j] : Number.MAX_VALUE\n  }\n  \n"
    }
  },
  {
    "name": "932-beautiful-array",
    "code": {
      "JS": "/**\n * @param {number} N\n * @return {number[]}\n */\nconst beautifulArray = function(N) {\n  let res = [];\n  res.push(1);\n  while (res.length < N) {\n    const tmp = [];\n    for (let i of res) if (i * 2 - 1 <= N) tmp.push(i * 2 - 1);\n    for (let i of res) if (i * 2 <= N) tmp.push(i * 2);\n    res = tmp;\n  }\n  return res;\n};\n"
    }
  },
  {
    "name": "933-number-of-recent-calls",
    "code": {
      "JS": "const RecentCounter = function() {\n    this.pings = [];\n};\n\n/** \n * @param {number} t\n * @return {number}\n */\nRecentCounter.prototype.ping = function(t) {\n    if (t === null) return null;\n    if (t > 3000) {\n        let delta = t - 3000;\n       while (this.pings.length > 0 && this.pings[0] < delta) {\n            this.pings.shift();\n        } \n    }\n        \n    this.pings.push(t);\n    return this.pings.length;\n};\n\n/** \n * Your RecentCounter object will be instantiated and called as such:\n * var obj = new RecentCounter()\n * var param_1 = obj.ping(t)\n */\n"
    }
  },
  {
    "name": "934-shortest-bridge",
    "code": {
      "JS": "/**\n * @param {number[][]} A\n * @return {number}\n */\nconst shortestBridge = function(A) {\n    let r = A.length;\n    let c = A[0].length;\n    let found = false;\n    let queue = [];\n    for (let i = 0; i < r; i++) {\n        for (let j = 0; j < c; j++) {\n            if (A[i][j]) {\n                dfs(A, i, j, queue);\n                found = true;\n                break;\n            }\n        }\n        if (found) break;\n    }\n    \n    let replace = [];\n    let count = 0;\n    let cells = [[1, 0], [-1, 0], [0, 1], [0, -1]];\n    while (queue.length) {\n        let pos = queue.shift();\n        \n        for (let i = 0; i < cells.length; i++) {\n            let x = pos[0] + cells[i][0]; \n            let y = pos[1] + cells[i][1];\n            \n            if (0 <= x && x < r && 0 <= y && y < c && A[x][y] != 2) {\n                if (A[x][y] == 1) return count;\n                A[x][y] = 2;\n                replace.push([x, y]);\n            }\n        }\n        \n        if (!queue.length) {\n            queue = replace;\n            replace = [];\n            count++;\n        }\n    }\n};\n\nfunction dfs(A, x, y, queue) {\n    if (x < 0 || x >= A.length || y < 0 || y >= A[0].length || A[x][y] == 0 || A[x][y] == 2) return;\n    \n    A[x][y] = 2;\n    queue.push([x, y]);\n    dfs(A, x-1, y, queue);\n    dfs(A, x+1, y, queue);\n    dfs(A, x, y-1, queue);\n    dfs(A, x, y+1, queue);\n}\n"
    }
  },
  {
    "name": "936-stamping-the-sequence",
    "code": {
      "JS": "/**\n * @param {string} stamp\n * @param {string} target\n * @return {number[]}\n */\nconst movesToStamp = function (stamp, target) {\n  const S = stamp.split('')\n  const T = target.split('')\n  const res = []\n  const visited = Array(T.length).fill(false)\n  let stars = 0\n\n  while (stars < T.length) {\n    let doneReplace = false\n    for (let i = 0; i <= T.length - S.length; i++) {\n      if (!visited[i] && canReplace(T, i, S)) {\n        stars = doReplace(T, i, S.length, stars)\n        doneReplace = true\n        visited[i] = true\n        res.unshift(i)\n        if (stars === T.length) {\n          break\n        }\n      }\n    }\n\n    if (!doneReplace) {\n      return []\n    }\n  }\n\n  return res\n  function canReplace(T, p, S) {\n    for (let i = 0; i < S.length; i++) {\n      if (T[i + p] !== '*' && T[i + p] !== S[i]) {\n        return false\n      }\n    }\n    return true\n  }\n\n  function doReplace(T, p, len, count) {\n    for (let i = 0; i < len; i++) {\n      if (T[i + p] !== '*') {\n        T[i + p] = '*'\n        count++\n      }\n    }\n    return count\n  }\n}\n"
    }
  },
  {
    "name": "937-reorder-data-in-log-files",
    "code": {
      "JS": "/**\n * @param {string[]} logs\n * @return {string[]}\n */\nconst reorderLogFiles = function(logs) {\n  const letterLog = [],\n    digitLog = []\n  for (let log of logs) {\n    if (isNaN(log.split(' ')[1])) {\n      letterLog.push(log)\n    } else {\n      digitLog.push(log)\n    }\n  }\n  letterLog.sort((log1, log2) => {\n    let body1 = log1.slice(log1.indexOf(' '))\n    let body2 = log2.slice(log2.indexOf(' '))\n    if (body1 === body2) {\n      return log1.split(' ')[0] > log2.split(' ')[0] ? 1 : -1\n    } else {\n      return body1 > body2 ? 1 : -1\n    }\n  })\n  return [...letterLog, ...digitLog]\n}\n\n// another\n\n/**\n * @param {string[]} logs\n * @return {string[]}\n */\nconst reorderLogFiles = function(logs) {\n  if(logs == null || logs.length === 0) return []\n  const ll = []\n  const dl = []\n  const zero = '0'.charCodeAt(0)\n  const nine = '9'.charCodeAt(0)\n  for(let e of logs) {\n    const arr = e.split(' ')\n    if(arr[1].charCodeAt(0) >= zero && arr[1].charCodeAt(0) <= nine) {\n      dl.push(arr)\n    } else {\n      ll.push(arr)\n    }\n  }\n  const rll = ll.map(el => {\n    const r = el.slice(1).join(' ')\n    return [el[0], r]\n  }).sort((a, b) => {\n    if(a[1] < b[1]) return -1\n    else if(a[1] > b[1]) return 1\n    else {\n      if(`${a[0]} ${a[1]}` > `${b[0]} ${b[1]}`) return 1\n      else if(`${a[0]} ${a[1]}` < `${b[0]} ${b[1]}`) return -1\n      else return 0\n    }\n  }).map(el => el.join(' '))\n  \n  const rdl = dl.map(el => el.join(' '))\n  return rll.concat(rdl)\n};\n"
    }
  },
  {
    "name": "938-range-sum-of-bst",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} L\n * @param {number} R\n * @return {number}\n */\nconst rangeSumBST = function(root, L, R) {\n  const payload = {sum: 0}  \n  traverse(root, payload, L, R)\n  return payload.sum\n};\n\nfunction traverse(node, obj, L, R) {\n  if(node == null) return\n  if(node.val >= L && node.val <= R) obj.sum += node.val\n  traverse(node.left, obj, L, R)\n  traverse(node.right, obj, L, R)\n}\n"
    }
  },
  {
    "name": "939-minimum-area-rectangle",
    "code": {
      "JS": "/**\n * @param {number[][]} points\n * @return {number}\n */\nconst minAreaRect = function(points) {\n  const xmap = {}, ymap = {}\n  points.forEach(e => {\n    const [x, y] = e\n    if(!xmap.hasOwnProperty(x)) xmap[x] = new Set()\n    if(!ymap.hasOwnProperty(y)) ymap[y] = new Set()\n    xmap[x].add(y)\n    ymap[y].add(x)\n  })\n  let res = Infinity\n  for(let i = 0, len = points.length; i < len - 1; i++) {\n    const [x, y] = points[i]\n    for(let j = i + 1; j < len; j++) {\n      const [x1, y1] = points[j]\n      if(x === x1 || y === y1) continue\n      let area = Infinity\n      if(xmap[x].has(y1) && ymap[y].has(x1)) area = Math.abs(x - x1) * Math.abs(y - y1)\n      else continue\n      res = Math.min(res, area)\n    }\n  }\n  return res === Infinity ? 0 : res\n};\n\n// another\n\n/**\n * @param {number[][]} points\n * @return {number}\n */\nconst minAreaRect = function (points) {\n  let ans = Infinity\n  const isPoint = {}\n  points.forEach(([x, y]) => (isPoint[x * 40000 + y] = true))\n  for (let idx1 = 0; idx1 < points.length - 1; idx1++) {\n    const [x1, y1] = points[idx1]\n    for (let idx2 = idx1 + 1; idx2 < points.length; idx2++) {\n      const [x2, y2] = points[idx2]\n      const area = Math.abs((x1 - x2) * (y1 - y2))\n      if (area === 0 || area >= ans) continue\n      if (isPoint[x1 * 40000 + y2] && isPoint[x2 * 40000 + y1]) ans = area\n    }\n  }\n  return ans !== Infinity ? ans : 0\n}\n\n"
    }
  },
  {
    "name": "94-binary-tree-inorder-traversal",
    "code": {
      "JS": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number[]}\r\n */\r\nconst inorderTraversal = function(root) {\r\n  const res = [];\r\n  if (root == null) return res;\r\n  traversal(root, res);\r\n  return res;\r\n};\r\n\r\nfunction traversal(node, res) {\r\n  if (node.left) {\r\n    traversal(node.left, res);\r\n  }\r\n  res.push(node.val);\r\n  if (node.right) {\r\n    traversal(node.right, res);\r\n  }\r\n}\r\n"
    }
  },
  {
    "name": "940-distinct-subsequences-ii",
    "code": {
      "JS": "/**\n * @param {string} s\n * @return {number}\n */\nconst distinctSubseqII = function(s) {\n  const n = s.length,\n    dp = Array(26).fill(0),\n    a = 'a'.charCodeAt(0),\n    mod = 1e9 + 7\n  let res = 0\n  for(let ch of s) {\n    const idx = ch.charCodeAt(0) - a\n    let tmp = 0\n    for(let i = 0; i < 26; i++) tmp = (tmp + dp[i]) % mod\n    tmp = (tmp + 1) % mod\n    dp[idx] = tmp\n  }\n  return dp.reduce((ac, e) => (ac + e) % mod, 0)\n};\n\n// another\n\n/**\n * @param {string} S\n * @return {number}\n */\nconst distinctSubseqII = function(S) {\n  // let end = new Array(26).fill(0), res = 0, added = 0, mod = 10 ** 9 + 7;\n  // const aCode = ('a').charCodeAt(0)\n  // for (let c of S) {\n  //     added = (res + 1 - end[c.charCodeAt(0) - aCode]) % mod;\n  //     res = (res + added) % mod;\n  //     end[c.charCodeAt(0) - aCode] = (end[c.charCodeAt(0) - aCode] + added) % mod;\n  // }\n  // return (res + mod) % mod;\n  const m = new Map(),\n    dp = [1],\n    M = 1000000007\n  for (let i = 0; i < S.length; i++) {\n    const c = S.charAt(i)\n    let prev = 0\n    if (m.has(c)) {\n      prev = dp[m.get(c)]\n    }\n    m.set(c, i)\n    dp.push((((dp[i] * 2) % M) - prev) % M)\n    if (dp[i + 1] < 0) {\n      dp[i + 1] += M\n    }\n  }\n  return dp[S.length] - 1\n}\n"
    }
  },
  {
    "name": "941-valid-mountain-array",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @return {boolean}\n */\nconst validMountainArray = function(A) {\n  if (A.length < 3) return false;\n  let start = 0;\n  let end = A.length - 1;\n  while (start < end) {\n    while (A[end - 1] > A[end]) {\n      end--;\n    }\n    while (A[start] < A[start + 1]) {\n      start++;\n    }\n    if (start !== end || start === 0 || end === A.length - 1) return false;\n  }\n  return true;\n};\n"
    }
  },
  {
    "name": "942-di-string-match",
    "code": {
      "JS": "/**\n * @param {string} S\n * @return {number[]}\n */\nconst diStringMatch = function(S) {\n  const N = S.length\n  const arr = []\n  for(let i = 0; i <= N; i++) {\n    arr[i] = i\n  }\n  const res = []\n  for(let i = 0; i < N; i++) {\n    if(S[i] === 'I') {\n      res.push(arr.shift())\n    } else if(S[i] === 'D') {\n      res.push(arr.pop())\n    }\n  }\n  res.push(arr.pop())\n  return res\n};\n"
    }
  },
  {
    "name": "943-find-the-shortest-superstring",
    "code": {
      "JS": "/**\n * @param {string[]} A\n * @return {string}\n */\nconst shortestSuperstring = function(arr) {\n  while (arr.length > 1) {\n    let maxCommonLength = 0\n    let maxCommonString = arr[0] + arr[1]\n    let maxCommonWords = [arr[0], arr[1]]\n    for (let i = 0; i < arr.length - 1; i++) {\n      for (let j = i + 1; j < arr.length; j++) {\n        const { commonLength, commonString } = checkCommonPair(arr[i], arr[j])\n        if (commonString && commonLength >= maxCommonLength) {\n          maxCommonLength = commonLength\n          maxCommonString = commonString\n          maxCommonWords = [arr[i], arr[j]]\n        }\n      }\n    }\n    arr = arr.filter(\n      word => word !== maxCommonWords[0] && word !== maxCommonWords[1]\n    )\n    arr.unshift(maxCommonString)\n  }\n  return arr[0]\n}\n\nconst checkCommonPair = function(s1, s2) {\n  let maxCommonLength = 0\n  let commonString = ''\n  if (s1.length > s2.length) s1, (s2 = s2), s1\n  for (let stringLength = 1; stringLength < s1.length; stringLength++) {\n    const s1Suffix = s1.substring(s1.length - stringLength)\n    const s2Prefix = s2.substring(0, stringLength)\n    if (s1Suffix === s2Prefix && stringLength > maxCommonLength) {\n      maxCommonLength = stringLength\n      commonString = s1 + s2.substring(stringLength)\n    }\n  }\n  for (let stringLength = 1; stringLength < s1.length; stringLength++) {\n    const s1Prefix = s1.substring(0, stringLength)\n    const s2Suffix = s2.substring(s2.length - stringLength)\n    if (s1Prefix === s2Suffix && stringLength > maxCommonLength) {\n      if (stringLength > maxCommonLength) {\n        maxCommonLength = stringLength\n        commonString = s2 + s1.substring(stringLength)\n      }\n    }\n  }\n\n  return {\n    commonLength: maxCommonLength,\n    commonString\n  }\n}\n"
    }
  },
  {
    "name": "944-delete-columns-to-make-sorted",
    "code": {
      "JS": "/**\n * @param {string[]} A\n * @return {number}\n */\nconst minDeletionSize = function(A) {\n  // increment this if we find a\n  // column that is out of order\n  let numColumnsToDelete = 0;\n\n  // all strings in the array\n  // are the same length\n  const strLength = A[0].length;\n\n  // outer loop checks entire string\n  for (let i = 0; i < strLength; i++) {\n    // inner loop checks the colunns\n    for (let j = 0; j < A.length - 1; j++) {\n       const top = A[j][i];\n       const bottom = A[j + 1][i];\n\n       if (top > bottom) {\n          numColumnsToDelete++;\n          break;\n        }\n      }\n    }\n    return numColumnsToDelete;\n};\n"
    }
  },
  {
    "name": "946-validate-stack-sequences",
    "code": {
      "JS": "/**\n * @param {number[]} pushed\n * @param {number[]} popped\n * @return {boolean}\n */\nconst validateStackSequences = function(pushed, popped) {\n  const arr = []\n  for (let i = 0, len = pushed.length; i < len; i++) {\n    if (!helper(arr, pushed, popped)) return false\n  }\n  return true\n}\n\nfunction helper(arr, pu, po) {\n  let target = po[0]\n\n  while (arr.length || pu.length) {\n    let curP = pu[0]\n    if (curP === target) {\n      po.shift()\n      pu.shift()\n      return true\n    } else if (arr.length && arr[arr.length - 1] === target) {\n      arr.pop()\n      po.shift()\n      return true\n    } else {\n      if (curP == null) {\n        return false\n      } else {\n        arr.push(curP)\n        pu.shift()\n      }\n    }\n  }\n  return false\n}\n"
    }
  },
  {
    "name": "947-most-stones-removed-with-same-row-or-column",
    "code": {
      "JS": "/**\n * @param {number[][]} stones\n * @return {number}\n */\nconst removeStones = function(stones) {\n  const f = new Map()\n  let islands = 0\n  for (let i = 0; i < stones.length; i++) {\n    union(stones[i][0], ~stones[i][1]) // row, col\n  }\n  return stones.length - islands\n\n  function find(x) {\n    if (!f.has(x)) {\n      islands++\n      f.set(x, x)\n    }\n    if (x != f.get(x)) {\n      f.set(x, find(f.get(x)))\n    }\n    return f.get(x)\n  }\n\n  function union(x, y) {\n    x = find(x)\n    y = find(y)\n    if (x !== y) {\n      f.set(x, y)\n      islands--\n    }\n  }\n}\n"
    }
  },
  {
    "name": "948-bag-of-tokens",
    "code": {
      "JS": "/**\n * @param {number[]} tokens\n * @param {number} P\n * @return {number}\n */\nconst bagOfTokensScore = function (tokens, P) {\n  tokens.sort((a, b) => a - b)\n  let res = 0,\n    score = 0,\n    i = 0,\n    j = tokens.length - 1\n  while (i <= j) {\n    if (P >= tokens[i]) {\n      P -= tokens[i++]\n      res = Math.max(res, ++score)\n    } else if (score > 0) {\n      score--\n      P += tokens[j--]\n    } else break\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "949-largest-time-for-given-digits",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @return {string}\n */\n\nconst largestTimeFromDigits = function(A) {\n    let ans = \"\";\n    for (let i = 0; i < 4; ++i) {\n        for (let j = 0; j < 4; ++j) {\n            for (let k = 0; k < 4; ++k) {\n                // avoid duplicate among i, j & k.\n                if (i == j || i == k || j == k) continue; \n                // hour, minutes, & time.\n                let h = \"\" + A[i] + A[j], m = \"\" + A[k] + A[6 - i - j - k], t = h + \":\" + m; \n                // hour < 24; minute < 60; update result.\n                if (h < \"24\" && m < \"60\" && ans < t) ans = t; \n            }\n        }\n    }\n    return ans;\n};\n"
    }
  },
  {
    "name": "95-unique-binary-search-trees-ii",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {number} n\n * @return {TreeNode[]}\n */\nconst generateTrees = function(n) {\n  if (n === 0) return []\n  return genTreeList(1, n)\n}\n\nfunction genTreeList(start, end) {\n  const list = []\n  if (start > end) list.push(null)\n  for (let idx = start; idx <= end; idx++) {\n    const leftList = genTreeList(start, idx - 1)\n    const rightList = genTreeList(idx + 1, end)\n    for (let left of leftList) {\n      for (let right of rightList) {\n        const root = new TreeNode(idx)\n        root.left = left\n        root.right = right\n        list.push(root)\n      }\n    }\n  }\n  return list\n}\n"
    }
  },
  {
    "name": "950-reveal-cards-in-increasing-order",
    "code": {
      "JS": "/**\n * @param {number[]} deck\n * @return {number[]}\n */\nconst deckRevealedIncreasing = function(deck) {\n  const n= deck.length;\n\n  deck.sort((a, b) => a - b)\n  const q = [];\n  for (let i=0; i<n; i++) q.push(i);\n  const res = new Array(n).fill(0);\n  for (let i=0; i<n; i++){\n    res[q.shift()]=deck[i];\n    q.push(q.shift());\n  }\n  return res;\n};\n"
    }
  },
  {
    "name": "951-flip-equivalent-binary-trees",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root1\n * @param {TreeNode} root2\n * @return {boolean}\n */\nconst flipEquiv = function(root1, root2) {\n  if(root1 == null || root2 == null) return root1 === root2\n  return root1.val === root2.val &&\n    (\n      (flipEquiv(root1.left, root2.left) && flipEquiv(root1.right, root2.right)) ||\n      (flipEquiv(root1.left, root2.right) && flipEquiv(root1.right, root2.left))\n    )\n};\n"
    }
  },
  {
    "name": "952-largest-component-size-by-common-factor",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @return {number}\n */\nclass UF {\n  constructor(N) {\n    this.parent = []\n    this.size = []\n    this.max = 1\n    for (let i = 0; i < N; i++) {\n      this.parent[i] = i\n      this.size[i] = 1\n    }\n  }\n  find(x) {\n    if (x === this.parent[x]) {\n      return x\n    }\n    return (this.parent[x] = this.find(this.parent[x]))\n  }\n  union(x, y) {\n    let rootX = this.find(x)\n    let rootY = this.find(y)\n    if (rootX != rootY) {\n      this.parent[rootX] = rootY\n      this.size[rootY] += this.size[rootX]\n      this.max = Math.max(this.max, this.size[rootY])\n    }\n  }\n}\nconst largestComponentSize = A => {\n  let N = A.length\n  const map = {} // key is the factor, val is the node index\n  const uf = new UF(N)\n  for (let i = 0; i < N; i++) {\n    let a = A[i]\n    for (let j = 2; j * j <= a; j++) {\n      if (a % j == 0) {\n        if (!map.hasOwnProperty(j)) {\n          //this means that no index has claimed the factor yet\n          map[j] = i\n        } else {\n          //this means that one index already claimed, so union that one with current\n          uf.union(i, map[j])\n        }\n        if (!map.hasOwnProperty(a / j)) {\n          map[a / j] = i\n        } else {\n          uf.union(i, map[a / j])\n        }\n      }\n    }\n    if (!map.hasOwnProperty(a)) {\n      //a could be factor too. Don't miss this\n      map[a] = i\n    } else {\n      uf.union(i, map[a])\n    }\n  }\n  return uf.max\n}\n"
    }
  },
  {
    "name": "953-verifying-an-alien-dictionary",
    "code": {
      "JS": "/**\n * @param {string[]} words\n * @param {string} order\n * @return {boolean}\n */\nconst isAlienSorted = function(words, order) {\n  const mapping = Array(26).fill(0), a = 'a'.charCodeAt(0)\n  for(let i = 0, len = order.length; i < len; i++) {\n    mapping[order.charCodeAt(i) - a] = i\n  }\n\n  for(let i = 1, n = words.length; i < n; i++) {\n    if(bigger(words[i - 1], words[i])) return false\n  }\n  \n  return true\n  \n  function bigger(s1, s2) {\n    const n = s1.length, m = s2.length;\n    for (let i = 0; i < n && i < m; ++i) {\n      if (s1.charAt(i) != s2.charAt(i)) return mapping[s1.charCodeAt(i) - a] > mapping[s2.charCodeAt(i) - a];          \n    }\n\n    return n > m;\n  }\n\n};\n"
    }
  },
  {
    "name": "954-array-of-doubled-pairs",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @return {boolean}\n */\nconst canReorderDoubled = function(A) {\n    const cnt = {}\n    for(let val of A) {\n        val = Math.abs(val)\n        cnt[val] ? cnt[val]++ : cnt[val] = 1\n    }\n    for(let val in cnt) {\n        let sibling = val * 2\n        if(val == '0') {\n            if(cnt[val] % 2) return false\n            cnt[val] = 0 \n        } else if(cnt[val] && cnt[sibling]) {\n            cnt[sibling] -= cnt[val]\n            cnt[val] = 0\n        }\n    }\n    for(let val in cnt)\n        if(cnt[val]) return false\n    return true\n};\n"
    }
  },
  {
    "name": "955-delete-columns-to-make-sorted-ii",
    "code": {
      "JS": "/**\n * @param {string[]} A\n * @return {number}\n */\nconst minDeletionSize = function (A) {\n  let res = 0,\n    i,\n    j //n: 有多少个字符串，对应i.  m:每个字符串的长度,对应j\n  const n = A.length,\n    m = A[0].length,\n    sorted = new Array(n - 1).fill(false)\n  for (j = 0; j < m; ++j) {\n    //从第一个字符到最后一个字符\n    for (i = 0; i < n - 1; ++i) {\n      //i从第一个字到最后一个字\n      if (!sorted[i] && A[i].charAt(j) > A[i + 1].charAt(j)) {\n        res++\n        break\n      }\n    }\n    if (i < n - 1) continue\n\n    //假设输入是[\"xgag\",\"xfba\",\"yfac\"]\n    //那么第一轮j=0,比较第一列: x=x<y，合理，所以此时res=0，然后运行了下面的循环， 可以使得sorted[xfb] = true;\n    //然后第二轮j=1,第二列g>f,进入if条件语句，所以res = 1, break\n    //然后第三轮j=2,a<b>a,这里b虽然>a，但是由于sorted[xfb] = true，所以不会进入到上面的循环体，然后sorted[xga] = true\n    //然后第四轮j=3,这一轮已经不再重要，因为通过前面几轮 sorted[0] = true， sorted[1] = true, 这意味着已经实现了排序，所以res最终结果就是1\n\n    for (\n      i = 0;\n      i < n - 1;\n      ++i //这一段代码结合最外面的循环可以用作比较string大小的通用代码\n    )\n      if (A[i].charAt(j) < A[i + 1].charAt(j)) sorted[i] = true\n  }\n  return res\n}\n\n// another\n\n/**\n * @param {string[]} A\n * @return {number}\n */\nconst minDeletionSize = function (A) {\n  const set = new Set()\n  const m = A.length\n  let res = 0\n  if(m === 0) return 0\n  const n = A[0].length\n  for(j = 0; j < n; j++) {\n    if(set.size === m - 1) return res\n    for(i = 0; i < m - 1; i++) {\n      if(!set.has(i) && A[i][j] > A[i + 1][j]) {\n        res++\n        break\n      }\n    }\n    if(i < m - 1) continue\n    for(i = 0; i < m - 1; i++) {\n      if(A[i][j] < A[i + 1][j]) set.add(i)\n    }\n  }\n  \n  return res\n}\n\n"
    }
  },
  {
    "name": "956-tallest-billboard",
    "code": {
      "JS": "/**\n * @param {number[]} rods\n * @return {number}\n */\nconst tallestBillboard = function(rods) {\n  const dp = {0 : 0}\n  for(let el of rods) {\n    for(let [diff, y] of Object.entries(dp)) {\n      diff = +diff\n      dp[diff + el] = Math.max(dp[diff + el] || 0, y)\n      if(diff >= el) dp[diff - el] = Math.max(dp[diff - el] || 0, y + el)\n      else dp[el - diff] = Math.max(dp[el - diff] || 0, y + diff)\n    }\n  }\n  return dp['0']\n};\n"
    }
  },
  {
    "name": "957-prison-cells-after-n-days",
    "code": {
      "JS": "/**\n * @param {number[]} cells\n * @param {number} N\n * @return {number[]}\n */\nconst prisonAfterNDays = function (cells, N) {\n  const temp = [...cells]\n  const maxIter = 2 * cells.length - 2\n  N = N % maxIter === 0 ? maxIter : N % maxIter\n  while (N > 0) {\n    for (let i = 0; i < cells.length; i++) {\n      temp[i] = cells[i - 1] === cells[i + 1] ? 1 : 0\n    }\n    cells = [...temp]\n    N--\n  }\n  return cells\n}\n"
    }
  },
  {
    "name": "959-regions-cut-by-slashes",
    "code": {
      "JS": "/**\n * @param {string[]} grid\n * @return {number}\n */\nconst regionsBySlashes = function(grid) {\n  const len = grid.length\n  let regionsNum = 0\n  const dirs = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n  const matrix = Array.from({ length: 3 * len }, () => new Array(3 * len).fill(0))\n\n  // 把每个格子切成3 * 3个小格子，再标记出现线段的位置\n  for (let i = 0; i < len; i++) {\n    for (let j = 0; j < len; j++) {\n      if (grid[i][j] === '/') matrix[i * 3][j * 3 + 2] = matrix[i * 3 + 1][j * 3 + 1] = matrix[i * 3 + 2][j * 3] = 1\n      if (grid[i][j] === '\\\\') matrix[i * 3][j * 3] = matrix[i * 3 + 1][j * 3 + 1] = matrix[i * 3 + 2][j * 3 + 2] = 1\n    }\n  }\n\n  for (let i = 0; i < matrix.length; i++) {\n    for (let j = 0; j < matrix.length; j++) {\n      if (matrix[i][j] === 0) {\n        dfs(matrix, i, j, dirs)\n        regionsNum++\n      }\n    }\n  }\n  return regionsNum\n}\nfunction dfs(m, i, j, dirs) {\n  if (i >= 0 && j >= 0 && i < m.length && j < m.length && m[i][j] === 0) {\n    m[i][j] = 1\n    for (let dir of dirs) dfs(m, i + dir[0], j + dir[1], dirs)\n  }\n}\n"
    }
  },
  {
    "name": "96-unique-binary-search-trees",
    "code": {
      "JS": "/**\n * @param {number} n\n * @return {number}\n */\nconst numTrees = function(n) {\n  const arr = new Array(n + 1).fill(0)\n  arr[0] = arr[1] = 1\n  for (let i = 2; i <= n; i++) {\n    for (let j = 1; j <= i; j++) {\n      arr[i] += arr[j - 1] * arr[i - j]\n    }\n  }\n  return arr[n]\n}\n\n// another\n\n/**\n * @param {number} n\n * @return {number}\n */\nconst numTrees = function(n) {\n  const hash = {\n    0: 1,\n    1: 1\n  }\n  return doNumTrees(n, hash)\n}\n\nfunction doNumTrees(n, hash) {\n  if (hash[n]) return hash[n]\n  let sum = 0\n  for (let i = 1; i <= n; i++) {\n    const left = doNumTrees(i - 1, hash)\n    const right = doNumTrees(n - i, hash)\n    sum += left * right\n  }\n  hash[n] = sum\n  return sum\n}\n"
    }
  },
  {
    "name": "960-delete-columns-to-make-sorted-iii",
    "code": {
      "JS": "/**\n * @param {string[]} A\n * @return {number}\n */\nconst minDeletionSize = function(A) {\n  const dp = new Array(A[0].length).fill(1)\n  for (let i = 0; i < A[0].length; i++) {\n    for (let j = 0; j < i; j++) {\n      for (let k = 0; k <= A.length; k++) {\n        if (k === A.length) dp[i] = Math.max(dp[i], dp[j] + 1)\n        else if (A[k][j] > A[k][i]) break\n      }\n    }\n  }\n  return A[0].length - Math.max(...dp)\n}\n\n// another\n\nconst minDeletionSize = function(A) {\n  const rows = A.length\n  const cols = A[0].length\n  let res = cols - 1\n  let k\n  const dp = new Array(cols).fill(1)\n  for (let i = 0; i < cols; i++) {\n    for (let j = 0; j < i; j++) {\n      for (k = 0; k < rows; k++) {\n        if (A[k][j] > A[k][i]) break\n      }\n      if (k === rows && dp[j] + 1 > dp[i]) dp[i] = dp[j] + 1\n    }\n    res = Math.min(res, cols - dp[i])\n  }\n  return res\n}\n"
    }
  },
  {
    "name": "961-n-repeated-element-in-size-2n-array",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @return {number}\n */\nconst repeatedNTimes = function(A) {\n    const checkerSet = new Set();\n    for (let num of A){\n        if (!checkerSet.has(num)){\n            checkerSet.add(num);\n        } else{\n            return num;\n        }\n    }\n};\n"
    }
  },
  {
    "name": "964-least-operators-to-express-number",
    "code": {
      "JS": "/**\n * @param {number} x\n * @param {number} target\n * @return {number}\n */\n\nconst leastOpsExpressTarget = function(x, target) {\n  let pows = [1]\n  while (pows[pows.length - 1] < target) {\n    pows.push(pows[pows.length - 1] * x)\n  }\n  let dp = {}\n  for (let i = 0; i < pows.length; i++) {\n    dp[pows[i]] = Math.abs(i - 1) + 1\n  }\n  let dpFunc = (t, unit) => {\n    if (t <= 0) return 0\n    if (dp[t]) return dp[t]\n    let cur = t % (unit * x)\n    let count = dp[unit]\n    let pos = dpFunc(t - cur, unit * x) + (cur / unit) * count\n    let neg = dpFunc(t + x * unit - cur, unit * x) + (x - cur / unit) * count\n    dp[t] = Math.min(pos, neg)\n    return dp[t]\n  }\n  return dpFunc(target, 1) - 1\n}\n\n\n// another\n\nconst leastOpsExpressTarget = function(x, y) {\n  let pos = 0,\n    neg = 0,\n    k = 0,\n    pos2,\n    neg2,\n    cur\n  while (y > 0) {\n    cur = y % x\n    y = (y / x) >> 0\n    if (k > 0) {\n      pos2 = Math.min(cur * k + pos, (cur + 1) * k + neg)\n      neg2 = Math.min((x - cur) * k + pos, (x - cur - 1) * k + neg)\n      pos = pos2\n      neg = neg2\n    } else {\n      pos = cur * 2\n      neg = (x - cur) * 2\n    }\n    k++\n  }\n  return Math.min(pos, k + neg) - 1\n}\n"
    }
  },
  {
    "name": "965-univalued-binary-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nconst isUnivalTree = function(root) {\n  const arr = []\n  dfs(root, arr)\n  for(let i = 1; i < arr.length; i++) {\n    if(arr[i] !== arr[i- 1]) return false\n  }\n  return true\n};\n\nfunction dfs(node, arr) {\n  if(node === null) return\n  arr.push(node.val)\n  dfs(node.left, arr)\n  dfs(node.right, arr)\n}\n"
    }
  },
  {
    "name": "968-binary-tree-cameras",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nconst minCameraCover = function(root) {\n  if (root === null) return 0;\n  let max = 0;\n  return (helper(root) < 1 ? 1 : 0) + max;\n  function helper(root) {\n    if (root === null) return 2;\n    if (root.left === null && root.right === null) return 0;\n    let left = helper(root.left);\n    let right = helper(root.right);\n    if (left === 0 || right === 0) {\n      max++;\n      return 1;\n    }\n    return left === 1 || right === 1 ? 2 : 0;\n  }\n};\n\n // another\n\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nconst minCameraCover = function(root) {\n  let ans = 0\n  const covered = new Set([null])\n  dfs(root, null)\n  return ans\n  function dfs(node, parent) {\n    if (node) {\n      dfs(node.left, node)\n      dfs(node.right, node)\n      if (\n        !(\n          (parent || covered.has(node)) &&\n          covered.has(node.left) &&\n          covered.has(node.right)\n        )\n      ) {\n        ans += 1\n        covered\n          .add(node)\n          .add(parent)\n          .add(node.left)\n          .add(node.right)\n      }\n    }\n  }\n};\n"
    }
  },
  {
    "name": "97-interleaving-string",
    "code": {
      "JS": "/**\n * @param {string} s1\n * @param {string} s2\n * @param {string} s3\n * @return {boolean}\n */\nconst isInterleave = function(s1, s2, s3) {\n  const len3 = s3.length\n  const len1 = s1.length\n  const len2 = s2.length\n  if(len1 + len2 !== len3) return false\n  \n  const dp = Array.from({length: len1 + 1}, () => new Array(len2 + 1).fill(false))\n  for(let i = 0; i <= len1; i++) {\n    for(let j = 0; j <= len2; j++) {\n      if(i === 0 && j === 0) {\n        dp[i][j] = true\n      } else if(i === 0) {\n        dp[i][j] = dp[i][j - 1] && s2[j - 1] === s3[i + j - 1]   \n      } else if(j === 0) {\n        dp[i][j] = dp[i - 1][j] && s1[i - 1] === s3[i + j - 1]      \n      } else {\n        dp[i][j] = (dp[i - 1][j] && s1[i - 1] === s3[i + j - 1]) || (dp[i][j - 1] && s2[j - 1] === s3[i + j - 1])\n      }\n    }\n  }\n  \n  return dp[len1][len2]\n};\n"
    }
  },
  {
    "name": "972-equal-rational-numbers",
    "code": {
      "JS": "/**\n * @param {string} S\n * @param {string} T\n * @return {boolean}\n */\nconst isRationalEqual = function (S, T) {\n  return f(S) === f(T)\n}\n\nfunction f(S) {\n  let i = S.indexOf('(')\n  if (i > 0) {\n    let base = S.slice(0, i)\n    let rep = S.slice(i + 1, S.length - 1)\n    for (let j = 0; j < 20; ++j) base += rep\n    return +base\n  }\n  return +S\n}\n"
    }
  },
  {
    "name": "973-k-closest-points-to-origin",
    "code": {
      "JS": "/**\n * @param {number[][]} points\n * @param {number} K\n * @return {number[][]}\n */\nconst kClosest = (points, K) => {\n  let len = points.length,\n    l = 0,\n    r = len - 1\n  while (l <= r) {\n    let mid = helper(points, l, r)\n    if (mid === K) break\n    if (mid < K) {\n      l = mid + 1\n    } else {\n      r = mid - 1\n    }\n  }\n  return points.slice(0, K)\n}\n\nfunction helper(A, l, r) {\n  let pivot = A[l]\n  let ll = l\n  while (l < r) {\n    while (l < r && compare(A[r], pivot) >= 0) r--\n    while (l < r && compare(A[l], pivot) <= 0) l++\n    swap(A, l, r)\n  }\n  swap(A, ll, l)\n  return l\n}\nfunction swap(arr, i, j) {\n  let tmp = arr[i]\n  arr[i] = arr[j]\n  arr[j] = tmp\n}\n\nfunction compare(p1, p2) {\n  return p1[0] * p1[0] + p1[1] * p1[1] - p2[0] * p2[0] - p2[1] * p2[1]\n}\n\n\n// another\n\n/**\n * @param {number[][]} points\n * @param {number} K\n * @return {number[][]}\n */\nconst kClosest = (points, K) => {\n  const pq = new PriorityQueue(\n    (p1, p2) => p1[0] * p1[0] + p1[1] * p1[1] > p2[0] * p2[0] + p2[1] * p2[1]\n  )\n  for (let p of points) {\n    pq.push(p)\n    if (pq.size() > K) {\n      pq.pop()\n    }\n  }\n  const res = new Array(K)\n  while (K > 0) {\n    res[--K] = pq.pop()\n  }\n  return res\n}\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this.heap = []\n    this.top = 0\n    this.comparator = comparator\n  }\n  size() {\n    return this.heap.length\n  }\n  isEmpty() {\n    return this.size() === 0\n  }\n  peek() {\n    return this.heap[this.top]\n  }\n  push(...values) {\n    values.forEach((value) => {\n      this.heap.push(value)\n      this.siftUp()\n    })\n    return this.size()\n  }\n  pop() {\n    const poppedValue = this.peek()\n    const bottom = this.size() - 1\n    if (bottom > this.top) {\n      this.swap(this.top, bottom)\n    }\n    this.heap.pop()\n    this.siftDown()\n    return poppedValue\n  }\n  replace(value) {\n    const replacedValue = this.peek()\n    this.heap[this.top] = value\n    this.siftDown()\n    return replacedValue\n  }\n\n  parent = (i) => ((i + 1) >>> 1) - 1\n  left = (i) => (i << 1) + 1\n  right = (i) => (i + 1) << 1\n  greater = (i, j) => this.comparator(this.heap[i], this.heap[j])\n  swap = (i, j) => ([this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]])\n  siftUp = () => {\n    let node = this.size() - 1\n    while (node > this.top && this.greater(node, this.parent(node))) {\n      this.swap(node, this.parent(node))\n      node = this.parent(node)\n    }\n  }\n  siftDown = () => {\n    let node = this.top\n    while (\n      (this.left(node) < this.size() && this.greater(this.left(node), node)) ||\n      (this.right(node) < this.size() && this.greater(this.right(node), node))\n    ) {\n      let maxChild =\n        this.right(node) < this.size() &&\n        this.greater(this.right(node), this.left(node))\n          ? this.right(node)\n          : this.left(node)\n      this.swap(node, maxChild)\n      node = maxChild\n    }\n  }\n}\n\n// another\n\n/**\n * @param {number[][]} points\n * @param {number} k\n * @return {number[][]}\n */\nconst kClosest = function(points, k) {\n  let len = points.length, l = 0, r = len - 1\n  while (l <= r) {\n    let mid = helper(points, l, r)\n    if (mid === k) break\n    if (mid  < k) l = mid + 1\n    else r = mid - 1\n  }\n  return points.slice(0, k)\n\n  function helper(arr, l, r) {\n    const pivot = arr[l]\n    while(l < r) {\n      while(l < r && cmp(arr[r], pivot) >= 0) r--\n      arr[l] = arr[r]\n      while(l < r && cmp(arr[l], pivot) <= 0) l++\n      arr[r] = arr[l]\n    }\n    arr[l] = pivot\n    return l\n  }\n  \n  function cmp(a, b) {\n    return a[0] * a[0] + a[1] * a[1] - b[0] * b[0] - b[1] * b[1]\n  }\n};\n"
    }
  },
  {
    "name": "975-odd-even-jump",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @return {number}\n */\nconst oddEvenJumps = function (A) {\n  // Creates an array with ONLY the indices of the sorted array\n  let sorted = A.map((el, idx) => idx).sort((a, b) => A[a] - A[b] || a - b)\n  // Create an array of '-1's of the same array length for odd and even jumps\n  let oddJumps = new Array(A.length).fill(-1)\n  let evenJumps = new Array(A.length).fill(-1)\n  // Create an empty stack\n  let stack = []\n  // Loop the the sorted array of the indices\n  for (let i of sorted) {\n    // Loops as long the stack is full OR if the index is greater than the the last index of the stack\n    while (stack.length && i > stack[stack.length - 1]) {\n      // Pops the index from the stack and place and add the 'i' index in sortedJumps\n      oddJumps[stack.pop()] = i\n    }\n    // Pushes the index onto the stack\n    stack.push(i)\n  }\n  // Empty the stack\n  stack = []\n  // Reverses the sorted index array\n  let reverseSorted = sorted.sort((a, b) => A[b] - A[a] || a - b)\n  // Does the exact thing but for even jumps\n  for (let i of reverseSorted) {\n    while (stack.length && i > stack[stack.length - 1]) {\n      evenJumps[stack.pop()] = i\n    }\n    stack.push(i)\n  }\n  // Starts the count at 0\n  let count = 1\n  // Creates a boolean array of false elements for even and odd ends\n  let oddEnd = new Array(A.length).fill(false)\n  let evenEnd = new Array(A.length).fill(false)\n  // Switches the end of each array to true\n  oddEnd[A.length - 1] = true\n  evenEnd[A.length - 1] = true\n  // Loops through the array, starting from the 2nd from the right (since we do not need to worry about       the last index)\n  for (let i = A.length - 2; i >= 0; --i) {\n    // If even jumps does\n    if (evenJumps[i] !== -1 && oddEnd[evenJumps[i]]) evenEnd[i] = true\n    if (oddJumps[i] !== -1 && evenEnd[oddJumps[i]]) {\n      oddEnd[i] = true\n      count++\n    }\n  }\n  return count\n}\n"
    }
  },
  {
    "name": "976-largest-perimeter-triangle",
    "code": {
      "JS": "/**\n * @param {number[]} nums\n * @return {number}\n */\nconst largestPerimeter = function(nums) {\n  nums.sort((a, b) => a - b)\n  for(let i = nums.length - 1; i > 1; i--) {\n    if(nums[i] < nums[i - 1] + nums[i - 2]) return nums[i - 2] + nums[i - 1] + nums[i]\n  }\n  return 0\n};\n"
    }
  },
  {
    "name": "977-squares-of-a-sorted-array",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @return {number[]}\n */\nconst sortedSquares = function(A) {\n  const result = [];\n  let i = A.length - 1;\n  let left = 0;\n  let right = A.length -1;\n  while (left <= right) {\n    if (Math.abs(A[left]) < A[right]) {\n      result.unshift(A[right] * A[right])\n      right--;\n    } else {\n      result.unshift(A[left] * A[left])\n      left++\n    }\n  }\n  return result;\n};\n"
    }
  },
  {
    "name": "98-validate-binary-search-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nconst isValidBST = function(root) {\n  return helper(root, -Infinity, Infinity)\n}\nfunction helper(root, minValue, maxValue) {\n  if (!root) return true\n  if (root.val <= minValue || root.val >= maxValue) {\n    return false\n  }\n  let leftSide = helper(root.left, minValue, root.val)\n  let rightSide = helper(root.right, root.val, maxValue)\n  return leftSide && rightSide\n}\n"
    }
  },
  {
    "name": "980-unique-paths-iii",
    "code": {
      "JS": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nconst uniquePathsIII = function(grid) {\n  const obj = {\n    eNum: 1,\n    res: 0,\n    rows: grid.length,\n    dirs: [[-1, 0], [1, 0], [0, -1], [0, 1]],\n    sr: 0,\n    sc: 0,\n    er: 0,\n    ec: 0\n  }\n  if (obj.rows === 0) return 0\n  obj.cols = grid[0].length\n  for (let i = 0; i < obj.rows; i++) {\n    for (let j = 0; j < obj.cols; j++) {\n      if (grid[i][j] === 0) obj.eNum++\n      else if (grid[i][j] === 1) (obj.sr = i), (obj.sc = j)\n      else if (grid[i][j] === 2) (obj.er = i), (obj.ec = j)\n    }\n  }\n  bt(grid, obj.sr, obj.sc, obj)\n  return obj.res\n}\n\nfunction bt(grid, x, y, obj) {\n  if (x < 0 || x >= obj.rows || y < 0 || y >= obj.cols || grid[x][y] < 0) return\n  if (x === obj.er && y === obj.ec) {\n    if (obj.eNum === 0) obj.res++\n    return\n  }\n  grid[x][y] = -2\n  obj.eNum--\n  for (let dir of obj.dirs) {\n    bt(grid, x + dir[0], y + dir[1], obj)\n  }\n  obj.eNum++\n  grid[x][y] = 0\n}\n"
    }
  },
  {
    "name": "981-time-based-key-value-store",
    "code": {
      "JS": "/**\n * Initialize your data structure here.\n */\nconst TimeMap = function() {\n   this.hash = {}\n};\n\n/** \n * @param {string} key \n * @param {string} value \n * @param {number} timestamp\n * @return {void}\n */\nTimeMap.prototype.set = function(key, value, timestamp) {\n  if(this.hash[key] == null) this.hash[key] = []\n  this.hash[key].push([value, timestamp])\n};\n\n/** \n * @param {string} key \n * @param {number} timestamp\n * @return {string}\n */\nTimeMap.prototype.get = function(key, timestamp) {\n  if(this.hash[key] == null) return ''\n  const arr = this.hash[key]\n\n  let l = 0, r = arr.length - 1;\n  while(l <= r) {\n    const pick = Math.floor((l + r) / 2);\n    if (arr[pick][1] < timestamp) {\n        l = pick + 1;\n    } else if (arr[pick][1] > timestamp) {\n        r = pick - 1\n    } else {\n        return arr[pick][0];\n    }\n  }\n  return arr[r]?.[0] || ''\n};\n\n/** \n * Your TimeMap object will be instantiated and called as such:\n * var obj = new TimeMap()\n * obj.set(key,value,timestamp)\n * var param_2 = obj.get(key,timestamp)\n */\n\n// another\n\n/**\n * Initialize your data structure here.\n */\nconst TimeMap = function() {\n   this.hash = {}\n};\n\n/** \n * @param {string} key \n * @param {string} value \n * @param {number} timestamp\n * @return {void}\n */\nTimeMap.prototype.set = function(key, value, timestamp) {\n  if(this.hash[key] == null) this.hash[key] = []\n  this.hash[key].push([value, timestamp])\n};\n\n/** \n * @param {string} key \n * @param {number} timestamp\n * @return {string}\n */\nTimeMap.prototype.get = function(key, timestamp) {\n  if(this.hash[key] == null) return ''\n  const arr = this.hash[key]\n\n  let l = 0, r = arr.length\n  while(l < r) {\n    const mid = l + ((r - l) >> 1)\n    if(arr[mid][1] <= timestamp) {\n      l = mid + 1\n    } else {\n      r = mid\n    }\n  }\n\n  if(r === 0) return ''\n  return arr[r - 1][0]\n};\n\n/** \n * Your TimeMap object will be instantiated and called as such:\n * var obj = new TimeMap()\n * obj.set(key,value,timestamp)\n * var param_2 = obj.get(key,timestamp)\n */\n"
    }
  },
  {
    "name": "982-triples-with-bitwise-and-equal-to-zero",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @return {number}\n */\nconst countTriplets = function (A) {\n  const N = 1 << 16,\n    M = 3\n  const dp = Array.from({ length: M + 1 }, () => Array(N).fill(0))\n  dp[0][N - 1] = 1\n  for (let i = 0; i < M; i++) {\n    for (let k = 0; k < N; k++) {\n      for (let a of A) {\n        dp[i + 1][k & a] += dp[i][k]\n      }\n    }\n  }\n  return dp[M][0]\n}\n"
    }
  },
  {
    "name": "983-minimum-cost-for-tickets",
    "code": {
      "JS": "/**\n * @param {number[]} days\n * @param {number[]} costs\n * @return {number}\n */\nconst mincostTickets = function(days, costs) {\n  const last7 = [], last30 = []\n  let res = 0\n  for(let d of days) {\n    while(last7.length && last7[0][0] + 7 <= d) last7.shift()\n    while(last30.length && last30[0][0] + 30 <= d) last30.shift()\n    last7.push([d, res + costs[1]])\n    last30.push([d, res + costs[2]])\n    res = Math.min(res + costs[0], last7[0][1], last30[0][1])\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "984-string-without-aaa-or-bbb",
    "code": {
      "JS": "/**\n * @param {number} a\n * @param {number} b\n * @return {string}\n */\nconst strWithout3a3b = function(a, b) {\n  let m = a, n = b, ch1 = 'a', ch2 = 'b'\n  if(b > a) {\n    m = b, n = a, ch1 = 'b', ch2 = 'a'\n  }\n  let res = ''\n  while(m-- > 0) {\n    res += ch1\n    if(m > n) {\n      res += ch1\n      m--\n    }\n    if(n > 0) {\n      res += ch2\n      n--\n    }\n  }\n  return res\n};\n"
    }
  },
  {
    "name": "985-sum-of-even-numbers-after-queries",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @param {number[][]} queries\n * @return {number[]}\n */\nconst sumEvenAfterQueries = function(A, queries) {\n  const res = []\n  for(let i = 0; i < queries.length; i++) {\n    A[queries[i][1]] += queries[i][0]\n    res.push(sum(A))\n  }\n  return res\n};\n\nfunction sum(arr) {\n  return arr.reduce((ac, el) => ac + (el % 2 === 0 ? el : 0), 0)\n}\n\n// another, better\n\nconst sumEvenAfterQueries = function(A, queries) {\n    let sum = A.reduce((acc, cur) => cur%2 == 0 ? acc + cur : acc, 0);\n    return queries.map((q) => {\n        let i = q[1];\n        let s = A[i] + q[0];\n        if(s%2 === 0) {\n            sum += q[0];\n            if(A[i]%2 !== 0) sum += A[i];\n        } else if(A[i]%2 === 0) sum -= A[i];\n        A[i] = s;\n        return sum;\n    });\n};\n"
    }
  },
  {
    "name": "986-interval-list-intersections",
    "code": {
      "JS": "/**\n * Definition for an interval.\n * function Interval(start, end) {\n *     this.start = start;\n *     this.end = end;\n * }\n */\n/**\n * @param {Interval[]} A\n * @param {Interval[]} B\n * @return {Interval[]}\n */\nconst intervalIntersection = function (A, B) {\n  const intersection = []\n  let i = (j = 0)\n  while (i < A.length && j < B.length) {\n    const min = Math.max(A[i][0], B[j][0])\n    const max = Math.min(A[i][1], B[j][1])\n    if (min <= max) intersection.push([min, max])\n    A[i][1] > B[j][1] ? j++ : i++\n  }\n  return intersection\n}\n"
    }
  },
  {
    "name": "987-vertical-order-traversal-of-a-binary-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nconst verticalTraversal = function(root) {\n  const arr = []\n  helper(root, 0, 0, arr)\n  arr.sort((a, b) => a[0] - b[0] || b[1] - a[1] || a[2] - b[2])\n  const res = new Map()\n\n  for(let [x, y, val] of arr) {\n    if(!res.has(x)) res.set(x, [])\n    res.get(x).push(val)\n  }\n  return [...res.values()]\n};\n\nfunction helper(node, x, y, arr) {\n  if(node) {\n    helper(node.left, x - 1, y - 1, arr)\n    arr.push([x, y, node.val])\n    helper(node.right, x  + 1, y - 1, arr)\n  }\n}\n"
    }
  },
  {
    "name": "988-smallest-string-starting-from-leaf",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {string}\n */\nconst smallestFromLeaf = function(root) {\n    const res = []\n    chk(root, [], res)\n    res.sort()\n    return res[0]\n};\n\nfunction chk(node, path, res) {\n  if(node == null) return\n  path.push(node.val)\n  if(node.left == null && node.right == null) {\n    res.push(arrToStr( path.slice(0).reverse() ))\n    return\n  }\n  chk(node.left, path.slice(0), res)\n  chk(node.right, path.slice(0), res)\n}\n\nfunction numToChar(num) {\n  const str = 'abcdefghijklmnopqrstuvwxyz'\n  return str[num]\n}\n\nfunction arrToStr(arr) {\n  let res = ''\n  for(let i = 0; i < arr.length; i++) {\n    res += numToChar(arr[i])\n  }\n  return res\n}\n\n// another\n\nconst smallestFromLeaf = function(root) {\n    if (!root) return ''\n    const char = String.fromCharCode(97 + root.val)\n    let left = smallestFromLeaf(root.left)\n    let right = smallestFromLeaf(root.right)\n    if (!left) return right + char\n    if (!right) return left + char\n    return (left < right ? left : right) + char\n};\n"
    }
  },
  {
    "name": "989-add-to-array-form-of-integer",
    "code": {
      "JS": "/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nconst addToArrayForm = function(num, k) {\n  const res = []\n  for(let i = num.length - 1; i >= 0; i--) {\n    const tmp = num[i] + k\n    res.push(tmp % 10)\n    k = ~~(tmp / 10)\n  }\n\n  while(k > 0) {\n    res.push(k % 10)\n    k  = ~~(k / 10)\n  }\n  res.reverse()\n  return res\n};\n"
    }
  },
  {
    "name": "99-recover-binary-search-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {void} Do not return anything, modify root in-place instead.\n */\nconst recoverTree = function(root) {\n  let node1, node2;\n  let prev = new TreeNode(-Infinity);\n  traverse(root);\n  swap(node1, node2)\n    \n  function traverse(node) {\n    if (!node) return;\n    traverse(node.left);\n    if (node.val < prev.val) {\n      node2 = node;\n      if (!node1) node1 = prev;\n    }\n    prev = node;\n    traverse(node.right);\n  }\n\n  function swap(node1, node2) {\n    let temp = node1.val\n    node1.val = node2.val\n    node2.val = temp\n  }\n}\n\n// another\n\nconst recoverTree = function(root) {\n  const eNodes = [];\n  if (root == null) return;\n  let current = root;\n  let pre;\n  let previous = null;\n  while (current != null) {\n    if (current.left == null) {\n      if (previous != null && previous.val > current.val) {\n        eNodes.push(previous);\n        eNodes.push(current);\n      }\n      previous = current;\n      current = current.right;\n    } else {\n      pre = current.left;\n      while (pre.right != null && pre.right.val != current.val) {\n        pre = pre.right;\n      }\n\n      if (pre.right == null) {\n        pre.right = current;\n        current = current.left;\n      } else {\n        if (previous != null && previous.val > current.val) {\n          eNodes.push(previous);\n          eNodes.push(current);\n        }\n        pre.right = null;\n        previous = current;\n        current = current.right;\n      }\n    }\n  }\n  if (eNodes.length == 2) {\n    pre = eNodes[0];\n    current = eNodes[1];\n  } else {\n    pre = eNodes[0];\n    current = eNodes[3];\n  }\n  let temp = pre.val;\n  pre.val = current.val;\n  current.val = temp;\n};\n"
    }
  },
  {
    "name": "990-satisfiability-of-equality-equations",
    "code": {
      "JS": "/**\n * @param {string[]} equations\n * @return {boolean}\n */\nconst equationsPossible = function(equations) {\n    const uf = new Array(26).fill(0);\n    const aCode = ('a').charCodeAt(0)\n\n    for (let i = 0; i < 26; ++i) uf[i] = i;\n    for (let e of equations)\n        if (e.charAt(1) === '=')\n            uf[find(e.charCodeAt(0) - aCode)] = find(e.charCodeAt(3) - aCode);\n    for (let e of equations)\n        if (e.charAt(1) === '!' && find(e.charCodeAt(0) - aCode) === find(e.charCodeAt(3) - aCode))\n            return false;\n    return true;\n\n\n    function find(x) {\n        if (x != uf[x]) uf[x] = find(uf[x]);\n        return uf[x];\n    }\n};\n\n\n// another\n\n/**\n * @param {string[]} equations\n * @return {boolean}\n */\nconst equationsPossible = function(equations) {\n  const num = 26\n  const visited = new Array(num).fill(false)\n  const color = new Array(num).fill(-1)\n  const adj = Array.from(new Array(num), el => [])\n  const aCode = ('a').charCodeAt(0)\n  for(let el of equations) {\n    if(el[1] === '=') {\n      adj[el[0].charCodeAt(0) - aCode].push(el[3].charCodeAt(0) - aCode)\n      adj[el[3].charCodeAt(0) - aCode].push(el[0].charCodeAt(0) - aCode)\n    }\n  }\n  let c = 0\n  for(let i = 0; i < num; i++) {\n    !visited[i] && dfs(i, c)\n    c++\n  }\n  for(let el of equations) {\n    if(el[1] === '!' && color[el[0].charCodeAt(0) - aCode] === color[el[3].charCodeAt(0) - aCode]) {\n      return false\n    }\n  }\n  return true\n  \n  function dfs(idx, val) {\n    visited[idx] = true\n    color[idx] = val\n    for(let el of adj[idx]) {\n      !visited[el] && dfs(el, val)\n    }\n  }\n};\n"
    }
  },
  {
    "name": "992-subarrays-with-k-different-integers",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @param {number} K\n * @return {number}\n */\nconst subarraysWithKDistinct = function(A, K) {\n  let res = 0\n  let prefix = 0\n  const m = new Array(A.length + 1).fill(0)\n  for (let i = 0, j = 0, cnt = 0, len = A.length; i < len; i++) {\n    if (m[A[i]]++ === 0) cnt++\n    if (cnt > K) {\n      m[A[j++]]--\n      cnt--\n      prefix = 0\n    }\n    while (m[A[j]] > 1) {\n      prefix++\n      m[A[j++]]--\n    }\n    if (cnt === K) res += prefix + 1\n  }\n  return res\n}\n\n// another\n\n/**\n * @param {number[]} A\n * @param {number} K\n * @return {number}\n */\nconst subarraysWithKDistinct = function (A, K) {\n  return mostK(K) - mostK(K - 1)\n  function mostK(num) {\n    const m = {}, len = A.length\n    let i = 0, j = 0, res = 0\n    for(j = 0; j < len; j++) {\n      if(!m[A[j]]) m[A[j]] = 0, num--\n      m[A[j]]++\n      while(num < 0) {\n        m[A[i]]--\n        if(!m[A[i]]) num++\n        i++\n      }\n      res += j - i + 1\n    }\n    return res\n  }\n}\n\n"
    }
  },
  {
    "name": "993-cousins-in-binary-tree",
    "code": {
      "JS": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nconst isCousins = (root, x, y, depth = 1, P = {}, D = {}) => {\n  let q = [root]\n  while (q.length) {\n    let K = q.length\n    while (K--) {\n      let p = q.shift()\n      if (p.left) {\n        if (p.left.val === x) (P.x = p.val), (D.x = depth)\n        if (p.left.val === y) (P.y = p.val), (D.y = depth)\n        q.push(p.left)\n      }\n      if (p.right) {\n        if (p.right.val === x) (P.x = p.val), (D.x = depth)\n        if (p.right.val === y) (P.y = p.val), (D.y = depth)\n        q.push(p.right)\n      }\n    }\n    ++depth\n  }\n  return P.x !== P.y && D.x === D.y\n}\n\n\n// another\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nconst isCousins = function(root, x, y) {\n    if(root == null) return false\n    const res = []\n    chk(root, x, [], res)\n    chk(root, y, [], res)\n    if(res.length < 2) return false\n    return chkRes(res, x, y)\n};\nfunction chkRes(arr, x, y) {\n  let ci = 0, xi = -1, yi = -1\n  let len = Math.max(arr[0].length, arr[1].length)\n  for(let i = 0; i < len; i++) {\n    if(arr[0][i] === arr[1][i]) ci = i\n    if(arr[0][i] === x || arr[1][i] === x) xi = i\n    if(arr[0][i] === y || arr[1][i] === y) yi = i\n  }\n  if(xi - yi === 0 && xi - ci > 1) {\n     return true\n  } else {\n    return false\n  }\n}\n\nfunction chk(node, val, path, res) {\n  if(node == null) return\n  path.push(node.val)\n  if(node.val === val) {\n    res.push(path.slice(0))\n    return\n  }\n  chk(node.left, val, path.slice(0), res)\n  chk(node.right, val, path.slice(0), res)\n}\n"
    }
  },
  {
    "name": "994-rotting-oranges",
    "code": {
      "JS": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nconst orangesRotting = function(grid) {\n  const m = grid.length, n = grid[0].length\n  const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n  const visited = new Set()\n  let q = []\n  let num = 0\n  for(let i = 0; i < m; i++) {\n    for(let j = 0; j < n; j++) {\n      if(grid[i][j] === 2) q.push([i, j]), visited.add(`${i},${j}`)\n      if(grid[i][j] !== 0) num++\n    }\n  }\n  let res = 0\n  while(q.length) {\n    const size = q.length\n    const tmp = []\n    for(let i = 0; i < size; i++) {\n      const [x, y] = q[i]\n      for(let [dx, dy] of dirs) {\n        const nx = x + dx, ny = y + dy\n        if(nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] === 1 && !visited.has(`${nx},${ny}`)) {\n          tmp.push([nx, ny])\n          visited.add(`${nx},${ny}`)\n        }\n      }\n    }\n    q = tmp\n    if(q.length) res++\n  }\n  return visited.size === num ? res : -1\n};\n\n// another\n\n\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nconst orangesRotting = function(grid) {\n    let count = 0\n    const p = {s: 2}\n    const rows = grid.length\n    const cols = grid[0].length\n    while(!chk(grid, rows, cols)) {\n      loop(grid, rows, cols, p)\n      count++\n      if(count> rows * cols) return -1\n    }\n    \n    return count\n};\n\nfunction loop(grid, rows, cols, p) {\n  let cur = p.s\n  let next = cur + 1\n  for(let i = 0; i < rows; i++) {\n    for(let j = 0; j < cols; j++) {\n      if(grid[i][j] === cur) rotten(i, j, grid, next)\n    }\n  }\n  p.s += 1\n}\n\nfunction rotten(row, col, grid, p) { \n  if(grid[row] && col > 0 && grid[row][col - 1] === 1) grid[row][col - 1] = p\n  if(grid[row] && col < (grid[0] || []).length - 1 && grid[row][col + 1] === 1) grid[row][col + 1] = p\n  if(grid[row] && row > 0 && grid[row - 1][col] === 1) grid[row - 1][col] = p\n  if(grid[row] && row < grid.length - 1 && grid[row + 1][col] === 1) grid[row + 1][col] = p\n}\n\nfunction chk(grid, rows, cols) {\n  for(let i = 0; i < rows; i++) {\n    for(let j = 0; j < cols; j++) {\n      if(grid[i][j] === 1) return false\n    }\n  }\n  return true\n}\n"
    }
  },
  {
    "name": "995-minimum-number-of-k-consecutive-bit-flips",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @param {number} K\n * @return {number}\n */\nconst minKBitFlips = function(A, K) {\n    let cur = 0, res = 0;\n    for (let i = 0; i < A.length; ++i) {\n        if (i >= K) cur -= (A[i - K] / 2) >> 0;\n        if ((cur & 1 ^ A[i]) === 0) {\n            if (i + K > A.length) return -1;\n            A[i] += 2;\n            cur++;\n            res++;\n        }\n    }\n    return res;\n};\n\n// another\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nconst minKBitFlips = function(nums, k) {\n  const n = nums.length, q = []\n  let res = 0\n  for(let i = 0; i < n; i++) {\n    if(nums[i] === 0) {\n      if(q.length === 0 || q.length % 2 === 0) {\n        res++\n        q.push(i + k - 1)\n      }\n    } else {\n      if(q.length % 2 === 1) {\n        res++\n        q.push(i + k - 1)\n      }\n    }\n    if(q.length && i >= q[0]) q.shift()\n  }\n  return q.length ? -1 : res\n};\n\n"
    }
  },
  {
    "name": "996-number-of-squareful-arrays",
    "code": {
      "JS": "/**\n * @param {number[]} A\n * @return {number}\n */\n\nconst numSquarefulPerms = function (A) {\n  const cntMap = {}\n  const squareMap = {}\n  let cnt = 0\n  for (let num of A) {\n    if (!cntMap.hasOwnProperty(num)) {\n      cntMap[num] = 1\n      squareMap[num] = new Set()\n    } else {\n      cntMap[num] = cntMap[num] + 1\n    }\n  }\n\n  for (let num1 of Object.keys(cntMap)) {\n    for (let num2 of Object.keys(cntMap)) {\n      let c = Math.sqrt(+num1 + +num2)\n      if (c === Math.floor(c)) {\n        squareMap[num1].add(+num2)\n        squareMap[num2].add(+num1)\n      }\n    }\n  }\n  for (let num of Object.keys(cntMap)) {\n    countPerm(num, A.length - 1)\n  }\n  return cnt\n  function countPerm(num, left) {\n    cntMap[num] = cntMap[num] - 1\n    if (left === 0) {\n      cnt++\n    } else {\n      for (let next of squareMap[num]) {\n        if (cntMap[next] !== 0) {\n          countPerm(next, left - 1)\n        }\n      }\n    }\n    cntMap[num] = cntMap[num] + 1\n  }\n}\n"
    }
  },
  {
    "name": "997-find-the-town-judge",
    "code": {
      "JS": "/**\n * @param {number} N\n * @param {number[][]} trust\n * @return {number}\n */\nconst findJudge = function(N, trust) {\n  const arr = new Array(N + 1).fill(0)\n  for(let [t, ted] of trust) {\n    arr[t]--\n    arr[ted]++\n  }\n  for(let i = 1; i <= N; i++) {\n    if(arr[i] === N - 1) return i\n  }\n  return -1\n};\n\n// another\n\n/**\n * @param {number} N\n * @param {number[][]} trust\n * @return {number}\n */\nconst findJudge = function(N, trust) {\n  const m = new Map()\n  for(let i = 1; i<= N; i++) {\n    const e = new Map()\n    e.set('t', new Set())\n    e.set('ted', new Set())\n    m.set(i, e)\n  }\n  for(let [t, ted] of trust) {\n    m.get(t).get('t').add(ted)\n    m.get(ted).get('ted').add(t)\n  }\n  for(let [k,v] of m) {\n    if(v.get('t').size === 0 && v.get('ted').size === N - 1) return k\n  }\n  return -1\n};\n"
    }
  },
  {
    "name": "999-available-captures-for-rook",
    "code": {
      "JS": "/**\n * @param {character[][]} board\n * @return {number}\n */\nconst numRookCaptures = function(board) {\n  for (let i = 0; i < board.length; ++i)\n    for (let j = 0; j < board[i].length; ++j)\n      if (board[i][j] == 'R') return cap(board,i,j,0,1)+cap(board,i,j,0,-1)+cap(board,i,j,1,0)+cap(board,i,j,-1,0);\n  return 0;  \n};\n\nfunction cap(b, x, y, dx, dy) {\n  while (x >= 0 && x < b.length && y >= 0 && y < b[x].length && b[x][y] != 'B') {\n    if (b[x][y] == 'p') return 1;\n    x += dx; y += dy;\n  }\n  return 0;\n}\n"
    }
  },
  {
    "name": "TBD-leftmost-column-with-at-least-a-one",
    "code": {
      "JS": "/**\n * // This is the BinaryMatrix's API interface.\n * // You should not implement it, or speculate about its implementation\n * function BinaryMatrix() {\n *     @param {integer} x, y\n *     @return {integer}\n *     this.get = function(x, y) {\n *         ...\n *     };\n *\n *     @return {[integer, integer]}\n *     this.dimensions = function() {\n *         ...\n *     };\n * };\n */\n\n/**\n * @param {BinaryMatrix} binaryMatrix\n * @return {number}\n */\nconst leftMostColumnWithOne = function (binaryMatrix) {\n  const [rows, cols] = binaryMatrix.dimensions()\n  let candidate = -1\n  for (let r = 0, c = cols - 1; r < rows && c >= 0; ) {\n    if (binaryMatrix.get(r, c) === 1) {\n      candidate = c\n      c--\n    } else {\n      r++\n    }\n  }\n  return candidate\n}\n"
    }
  }
]
